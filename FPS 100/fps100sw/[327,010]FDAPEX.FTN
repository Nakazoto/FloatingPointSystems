C****** FDAPEX = HOST DEPENDENT APEX (PDP-11 RT11) = REL B.1  , NOV 79 ********
C
C               THIS FILE IS:
C                  FPS100>PDP11>OPSYS>APX100.01>FDAPEX.RT11
C
C               FOR PDP11  RT11  3B
C
C            CHANGED             12-NOV-79    BY  J. RAMUS
C
C          LIST OF ROUTINES   (ARRANGED IN THIS ORDER)
C
C    APRUN    START AN AP PROGRAM
C    APOVIN   PLACE THE OVERLAY HANDLER IN PS
C    APLMLD   AP LOAD MODULE LOADER
C    FSLMLD   LOAD MODULE LOADER
C    APLLI    INITIALIZE THE LOAD MODULE LOADER
C    APSEIN   PLACE SIGN EXTEND CODE IN PS
C    APGSEI   GET SIGN-EXTENDED INTEGER FROM 'MD'
C    APEXC    EXECUTE CHANNEL PROGRAM
C    APMODE   SWITCH CPAPEX MODES
C    APGMOD   GET THE CPAPEX MODE
C    APSTOP   PAUSE ON AP FATAL ERROR
C
C****** APRUN = START AN AP PROGRAM = REL B.1  , NOV 79 ***********************
C
        SUBROUTINE APRUN (PSADDR,LOCADR,OPTION,OVFLG,BRKLOC)
C
        INTEGER PSADDR,LOCADR,OPTION,OVFLG,SLIST(16),IOPT,BRKLOC
C
C       THIS ROUTINE IS CALLED BY THE HASI OUTPUT BY APLOAD TO START
C       A SUBROUTINE RUNNING IN THE AP.
C
C       CALL:
C
C       PSADDR = THE PS ADDRESS OF THE SUBROUTINES ENTRY POINT
C       LOCADR = THE MD ADDRESS OF THE SUBROUTINE'S LOCAL DATA BLOCK
C                (USED ONLY WITH OPTION=1)
C       OPTION = SPECIFIES THE TYPE OF CALL:
C                1 = ADC CALL
C                2 = UDC CALL WITHOUT COMMON DATA PROCESSING
C                3 = UDC CALL WITH COMMON
C       OVFLG  = 1 IF OVERLAYS ARE BEING USED, ELSE 0.
C       BRKLOC = A PS BREAK POINT
C
C       IF OPTION = 1 THE SUBROUTINE PARAMETER ADDRESSES (IF ANY) ARE
C       PASSED TO THE LOCAL DATA BLOCK.  IF OPTION = 2 OR 3 THE ADDRESSES
C       ARE PASSED INTO S-PAD.  AT THIS POINT IF NO OVERLAYS NEED TO BE
C       LOADED (IOVS(2)=0) CONTROL IS PASSED TO THE SUBROUTINE'S ENTRY
C       POINT.  IF OVERLAYS ARE TO BE LOADED THEIR ID NUMBERS ARE PLACED
C       IN THE OVERLAY HANDLER'S DATA AREA AND CONTROL IS GIVEN TO
C       APOVLD IN THE AP.
C
C       HOST DEPENDENCIES:  IN THE CALLS TO RUNDMA-
C            FOR 16 BIT MACHINES, USE CTL = 195
C            FOR 32 BIT MACHINES, USE CTL = 193
C
C       VARIABLES:
C
C       IPAV   = THE PARAMETER ADDRESS VECTOR.  IPAV(1) CONTAINS THE NUMBER
C                OF PARAMETERS AND THE REST OF THE ARRAY CONTAINS THOSE
C                ADDRESSES.
C       IOVS   = THE OVERLAY ID ARRAY.
C                IOVS(1) = PS ADDRESS OF SUBROUTINE TO RUN.
C                IOVS(2) CONTAINS THE NUMBER OF
C                OVERLAYS THAT MUST BE LOADED BEFORE RUNNING THE REQUESTED
C                SUBROUTINE.  THE REST OF THE ARRAY CONTAINS THOSE
C                OVERLAY'S ID NUMBERS.
C       OVDATA = THE MD ADDRESS OF THE OVERLAY HANDLER'S DATA AREA.
C       OVENT1 = THE PS ADDRESS OF APOVLD'S ENTRY POINT.  THE ONE FOR
C                ADC CALLS.
C       OVENT2 = THE APOVLD ENTRY POINT FOR UDC CALLS.
C       ENTRY  = THE ACTUAL AP ENTRY POINT THAT WILL BE CALLED.
C
C       FOR  ADC  AND  UDC  CALLS:
C         IF NO SUPERVISOR IN THE FPS-100,
C            ENTRY IS SET TO 16 OR 19 TO RUN THE OVERLAY MANAGER.
C         IF SUPERVISOR IS USED,
C            ENTRY IS SET TO  START-1  TO RUN THE OVERLAY MANAGER.
C            START IS SET BY  MTSGO  OR  RTSGO.
C            START-1  IS  PSSIZE-17  JUST BELOW BOOTSTRAP IN HIGH PS.
C
        INTEGER HADDR,STOPN
        COMMON /ERRORS/ HADDR,STOPN
        INTEGER SUPER, START, BOOTST
        COMMON /SYSTEM/ SUPER, START, BOOTST
        COMMON /APLDCM/ IPAV(33),NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS(33),
     *                  LMT(10,3),LMTE
        INTEGER IPAV,NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS,LMT,LMTE
C
        INTEGER OVDATA,OVENT1,OVENT2,ENTRY,I,CODE(4),ID
C
        DATA OVDATA,OVENT1,OVENT2 /10,16,19/
C
C       JUMP IF USING OVERLAYS
C
        ENTRY=PSADDR
        IOPT=OPTION
        IF (OVFLG .EQ. 0 .OR. IOVS(2) .EQ. 0) GOTO (1200,800,800),IOPT
C
C       PLACE OVERLAY ID NUMBERS  INTO THE AP AND ADD THE PS ENTRY TO
C       THE END OF THE LIST.
C
        IOVS(1)=ENTRY
        IF (SUPER .NE. 0) OVDATA = 0
C            FOR 32 BIT HOST,  CHANGE 195 TO 193
        CALL RUNDMA (IOVS(1),OVDATA,IOVS(2)+2,195)
        GOTO (1000,700,700),IOPT
C
C       PROCESS UDC TYPE CALL.
C
700     ENTRY=OVENT2
        IF (SUPER .NE. 0) ENTRY = START-1
        CALL APWD
800     CALL SPLDGO (IPAV(2),IPAV(1),ENTRY,BRKLOC)
        IF (OPTION .EQ. 3) CALL APWR
        IOVS(2)=0
        RETURN
C
C       PROCESS ADC TYPE CALL
C
C       PLACE THE PARAMETER ADDRESSES IN THE SUBROUTINES LOCAL DATA BLOCK.
C       PLACE THE LOCAL BLOCK ADDRESS AND NUMBER OF PARAMETERS INTO
C       S-PAD 0 AND 1.
C
1000    ENTRY=OVENT1
        IF (SUPER .NE. 0) ENTRY = START-1
1200    J=IPAV(1)+2
        IF (J .EQ. 2) GOTO 1300
C            FOR 32 BIT HOST,  CHANGE 195 TO 193
        CALL RUNDMA (IPAV(2),LOCADR,IPAV(1),195)
C
C         TEST FOR  PARAM PASSING AREA  ( PPA ) OVERFLOW
C
C       IPAV(J) IS ADDRESS OF FIRST UNUSED PPA ENTRY FOR THIS CALL
C       IPPAND  IS ADDRESS OF MD WORD IMMEDIATELY FOLLOWING PPA
C           ( IPPAND IS SET BY  APFILL  USING LOAD MODULE INFO )
C       IPPAAD  IS STARTING ADDRESS OF PPA
C           ( IPPAAD IS SET BY  APFILL  USING LOAD MODULE INFO )
C
C       ON 16 BIT MACHINES,  ADDRESSES > 32K LOOK LIKE NEG NUMBERS
C             AND IPAV(J) MAY WRAP AROUND 64K.
C
C       ERROR IF  IPAV(J)  EXCEEDS  IPPAND  (PASSED THE END)
C       ERROR IF  IPAV(J)  LESS THAN  IPPAAD  (WRAPPED AROUND)
C
        IF ( ICMP16 (IPAV(J), IPPAND) .GT. 0) GO TO 90000
        IF ( ICMP16 (IPAV(J), IPPAAD) .LT. 0) GO TO 90000
1300    CALL APWD
        SLIST(1)=LOCADR
        SLIST(2)=IPAV(1)
        CALL SPLDGO (SLIST,2,ENTRY,BRKLOC)
1500    CALL APWR
        IOVS(2)=0
C
C       EXAMINE PSA.  IF PSA=14 (THE HALT IN THE BOOTSTRAP) THEN JUST
C       RETURN.  OTHERWISE WE ASSUME AN AP FORTRAN STOP STATEMENT
C       HAS BEEN EXECUTED.  THIS TAKES THE FORM OF:
C
C                               HALT; DB=<STOP NUMBER>
C
C       SO, GET THE NUMBER, AND TELL THE USER THE AP STOPPED.
C    IGNORE THE WHOLE THING WITH MTS100 AND RTS100 SUPERVISOR.
C
        IF (SUPER .NE. 0) RETURN
        CALL APOUT (1024,2)
        CALL APIN (I,3)
        IF (I .EQ. 14) RETURN
        CALL APEXAM (CODE,9,I-1)
        HADDR = I
        STOPN = CODE(4)
        CALL APSTOP (12)
C
C       CONTINUE EXECUTION IN THE AP WHERE WE LEFT OFF
C
        CALL RUNAP (ID,1,0,16383)
        GOTO 1500
C
C       ERROR - PPA OVERFLOW
C
90000   CALL APSTOP (11)
        GO TO 1300
        END
C****** APOVIN = PLACE THE OVERLAY HANDLER IN PS = REL B.1  , NOV 79 **********
C
       SUBROUTINE APOVIN
C
       INTEGER OV(297)
C
C       THIS ROUTINE PLACES THE OVERLAY HANDLER - CONTAINED IN THE FOLLOWING
C       DATA STATEMENTS - INTO PS AT ADDRESS 16.
C
C         ----  THIS VERSION OF APOVIN IS FOR 16 BIT HOSTS  ----
C
      DATA OV(  1),OV(  2),OV(  3),OV(  4) /  4616,     0,     0,     3/
      DATA OV(  5),OV(  6),OV(  7),OV(  8) /  4616,     0,     0,    29/
      DATA OV(  9),OV( 10),OV( 11),OV( 12) /  4616,     0,     0,    35/
      DATA OV( 13),OV( 14),OV( 15),OV( 16) /     3,-31744,  1024,    15/
      DATA OV( 17),OV( 18),OV( 19),OV( 20) /     0,     0,     0,     0/
      DATA OV( 21),OV( 22),OV( 23),OV( 24) / 17404,     0,  3072,   208/
      DATA OV( 25),OV( 26),OV( 27),OV( 28) /   956,    82,  1024,    15/
      DATA OV( 29),OV( 30),OV( 31),OV( 32) /   952,   402,  3072,   208/
      DATA OV( 33),OV( 34),OV( 35),OV( 36) /   703,-32177,  3072,     0/
      DATA OV( 37),OV( 38),OV( 39),OV( 40) /     3,-31744,  1024,    11/
      DATA OV( 41),OV( 42),OV( 43),OV( 44) /   932,     0,  1024,    12/
      DATA OV( 45),OV( 46),OV( 47),OV( 48) /     3,-31744,  1024,    12/
      DATA OV( 49),OV( 50),OV( 51),OV( 52) /   936,     0,  2560,     0/
      DATA OV( 53),OV( 54),OV( 55),OV( 56) /   616,     0,     0,     0/
      DATA OV( 57),OV( 58),OV( 59),OV( 60) /   680,     0,     0,     0/
      DATA OV( 61),OV( 62),OV( 63),OV( 64) /   928,   404,  2560,     0/
      DATA OV( 65),OV( 66),OV( 67),OV( 68) /  4620,     0,     0,    21/
      DATA OV( 69),OV( 70),OV( 71),OV( 72) /   612,     0,  3072,    48/
      DATA OV( 73),OV( 74),OV( 75),OV( 76) /     0,    76,     0,     0/
      DATA OV( 77),OV( 78),OV( 79),OV( 80) /     3,-31744,  1024,    10/
      DATA OV( 81),OV( 82),OV( 83),OV( 84) /  4876,     0,     0,     2/
      DATA OV( 85),OV( 86),OV( 87),OV( 88) /     0,   224,     0,     0/
      DATA OV( 89),OV( 90),OV( 91),OV( 92) /     3,-31232,  2560,     0/
      DATA OV( 93),OV( 94),OV( 95),OV( 96) /     3,-31744,  1024,    16/
      DATA OV( 97),OV( 98),OV( 99),OV(100) /   896,     0,  1024,    16/
      DATA OV(101),OV(102),OV(103),OV(104) /   643,-32256,  3072,    16/
      DATA OV(105),OV(106),OV(107),OV(108) /   896,   495,  2560,     0/
      DATA OV(109),OV(110),OV(111),OV(112) /   896,     0,  2560,     0/
      DATA OV(113),OV(114),OV(115),OV(116) /  4628,     0,     0,     0/
      DATA OV(117),OV(118),OV(119),OV(120) /  4608,     0,     0,    13/
      DATA OV(121),OV(122),OV(123),OV(124) /     3,-31744,  1024,    10/
      DATA OV(125),OV(126),OV(127),OV(128) /     0,     0,     0,     0/
      DATA OV(129),OV(130),OV(131),OV(132) /     0,     0,     0,     0/
      DATA OV(133),OV(134),OV(135),OV(136) /     3,-31744,  2560,     0/
      DATA OV(137),OV(138),OV(139),OV(140) /     0,     0,     0,     0/
      DATA OV(141),OV(142),OV(143),OV(144) /     0,     0,     0,     0/
      DATA OV(145),OV(146),OV(147),OV(148) /   928,     0,  2560,     0/
      DATA OV(149),OV(150),OV(151),OV(152) /     3,-31744,  1024,     1/
      DATA OV(153),OV(154),OV(155),OV(156) /   948,     0,  1024,     4/
      DATA OV(157),OV(158),OV(159),OV(160) /   952,     0,     0,    16/
      DATA OV(161),OV(162),OV(163),OV(164) /   940,     0,  2560,     0/
      DATA OV(165),OV(166),OV(167),OV(168) /   623,-29184,  1024,    26/
      DATA OV(169),OV(170),OV(171),OV(172) /   947,-31744,  2560,     0/
      DATA OV(173),OV(174),OV(175),OV(176) / 13216,    32,     0,     0/
      DATA OV(177),OV(178),OV(179),OV(180) /   684,   404,     0,     0/
      DATA OV(181),OV(182),OV(183),OV(184) /   952,   402, 18949,     0/
      DATA OV(185),OV(186),OV(187),OV(188) /  9072,    77,     0,    48/
      DATA OV(189),OV(190),OV(191),OV(192) /     3, -4096,  1024,    -2/
      DATA OV(193),OV(194),OV(195),OV(196) /   923,-14336,   512,     0/
      DATA OV(197),OV(198),OV(199),OV(200) /     3,-16384,     0,     0/
      DATA OV(201),OV(202),OV(203),OV(204) /     3,-29184,  1024,    24/
C
C       THE ZERO IN OV(208) IS A TM ROM ADDRESS FOR THE VALUE 1.0
C       EARLIER VERSIONS OF THIS ROUTINE HAD THE ADDRESS OF !ONE
C       WHICH IS 2049 FOR 2.5K TM ROM OR 4097 FOR 4.5K TM ROM
C
C       THE ZERO ADDRESS IS GOOD FOR BOTH SIZES OF TM ROM
C
      DATA OV(205),OV(206),OV(207),OV(208) /     3,-31232,  1024,  0000/
      DATA OV(209),OV(210),OV(211),OV(212) /   927,-14336,   512,    32/
      DATA OV(213),OV(214),OV(215),OV(216) /   956,     0,  1024,    27/
      DATA OV(217),OV(218),OV(219),OV(220) /     0,     0,  7680,-32736/
      DATA OV(221),OV(222),OV(223),OV(224) /   952,     0,  2560,     0/
      DATA OV(225),OV(226),OV(227),OV(228) / 17336,     0, 19460,    32/
      DATA OV(229),OV(230),OV(231),OV(232) /     3,-31232,  2560,     0/
      DATA OV(233),OV(234),OV(235),OV(236) / 17405, -9216,   256,     0/
      DATA OV(237),OV(238),OV(239),OV(240) /  1017,"100000, 1856,     0/
      DATA OV(241),OV(242),OV(243),OV(244) / 17339,-16384,  3072,     0/
      DATA OV(245),OV(246),OV(247),OV(248) /     3,-31744,-30204,     0/
      DATA OV(249),OV(250),OV(251),OV(252) /     0,     0,     0,     0/
      DATA OV(253),OV(254),OV(255),OV(256) /     0,-19456,   288,    16/
      DATA OV(257),OV(258),OV(259),OV(260) /  4849,"100000, 2560,     0/
      DATA OV(261),OV(262),OV(263),OV(264) /     0,     0,-32764,    16/
      DATA OV(265),OV(266),OV(267),OV(268) /  4852,   275,  2560,     1/
      DATA OV(269),OV(270),OV(271),OV(272) /     0,-19456,   288,    16/
      DATA OV(273),OV(274),OV(275),OV(276) /  4849,-32691,  2560,     0/
      DATA OV(277),OV(278),OV(279),OV(280) / 16863,-16384,  3072,     0/
      DATA OV(281),OV(282),OV(283),OV(284) /     3,-29184,  1024,    26/
      DATA OV(285),OV(286),OV(287),OV(288) / 16795,-16160,  3072,     0/
      DATA OV(289),OV(290),OV(291),OV(292) /     0,   224,     0,     0/
      DATA OV(293),OV(294),OV(295),OV(296) /     0,   224,     0,     0/
C
       CALL LOADPS (OV,16,(298-2)/4)
        CALL APWD
       RETURN
       END
C****** APLMLD = AP LOAD MODULE LOADER = REL B.1  , NOV 79 ********************
C
        SUBROUTINE APLMLD (LMID,CODE,CODSIZ)
C
        INTEGER LMID,CODSIZ,CODE(CODSIZ)
C
C       CALL:
C
C       LMID   = THE ID NUMBER OF THE LOAD MODULE TO BE PLACED IN
C                THE AP.
C       CODE   = ARRAY WHICH HOLDS ALL OR PART OF A DISK RESIDENT
C                LOAD MODULE.
C       CODSIZ = SIZE OF ABOVE ARRAY.
C
        INTEGER I,LUNTMP,MODE
C
        COMMON /APLDCM/ IPAV(33),NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS(33),
     *                  LMT(10,3),LMTE
        INTEGER IPAV,NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS,LMT,LMTE
C
C
C
C       SEARCH FOR THE LM ID IN THE LMT()
C
        IF (LMTE .EQ. 0) GOTO 90000
        DO 500 I=1,LMTE
        IF (LMT(I,1) .EQ. LMID) GOTO 1000
500     CONTINUE
        GOTO 90000
C
C       GOT FILE UNIT, READ IN A BUFFERS WORTH AND CALL FSLMLD
C
C#      REWINDING A FILE HERE
1000    LUNTMP=LMT(I,3)+7
        REWIND LUNTMP
C
C
90      CONTINUE
        K=0
C
C         NEED COMMENTS HERE TO EXPLAIN THE LOGIC OF THE FOLLOWING
C         TESTS AND LOOP
C
100     CONTINUE
        I=K+1
        K=I+7
        READ(LUNTMP,END=90010)(CODE(J),J=I,K)
        IF(CODE(I).EQ.3)GO TO 200
        IF(CODE(I).NE.1) GO TO 140
        LL=CODE(I+1)
          DO 130 KK=1,LL
            I=K+1
            K=I+7
            READ(LUNTMP,END=90010)(CODE(J),J=I,K)
130         CONTINUE
          GO TO 100
140       CONTINUE
        IF(CODE(I).NE.0)GO TO 100
        IF(CODE(I+1).EQ.0)GO TO 100
        L=K+1
        K=K+CODE(I+1)
        DO 150 KK=L,K,8
          LL=MIN0(KK+7,K)
          READ(LUNTMP,END=90010)(CODE(J),J=KK,LL)
150       CONTINUE
        GO TO 100
200     CONTINUE
        CALL FSLMLD(LMID,CODE)
        IF(CODE(I+1).NE.1)GO TO 90
C
        CALL APWD
        RETURN
C
C       ERROR - LM ID NOT FOUND
C
90000   CALL APSTOP (9)
        RETURN
90010   CALL APSTOP(10)
        RETURN
        END
C****** FSLMLD = LOAD MODULE LOADER = REL B.1  , NOV 79 ***********************
C
        SUBROUTINE FSLMLD (LMID,LMBUF)
        INTEGER LMBUF(9999),LMID
C
C        THIS ROUTINE LOADS AN AP HOST RESIDENT LOAD MODULE CREATED BY
C        APLOAD INTO THE AP.
C
C       *************************************************************
C
C       I N S T A L L A T I O N   I N S T R U C T I O N S
C
C       SET FPPAK AND PAKFAC FOR THE HOST AS DESCRIBED UNDER VARIABLES
C       BELOW.
C
C       SET THE ABUF DIMENTION SIZE IN THE INTEGER STMT.
C       TO THE IBUF SIZE DIVIDED BY FPFAK.
C
C       **************************************************************
C
C       CALL:
C
C       LUN    = LOGICAL UNIT ASSIGNED TO THE LOAD MODULE FILE
C
C       VARIABLES:
C
C       PGCRNT = THE CURRENTLY SELECTED MD PAGE (0-16)
C       FPPAK  = THE NUMBER OF HOST WORDS PER HOST FLOATING PT. NUMBER
C       PAKFAC = THE NUMBER OF 16 BIT INTEGERS PER HOST WORD ( 1 OR 2 )
C       IBUF() = GENERAL INPUT BUFFER - THIS MUST BE AT LEAST AS
C                BIG AS THE BUFFER() IN APLOAD.
C       ABUF() = EQUIVALENCED TO IBUF() - FOR HOST F.P.N.'S
C       BUFSIZ = THE NUMBER OF WORDS IN IBUF()
C       LMBUF  = BUFFER FOR READING HEADER RECORDS
C       TYPE   = THE TYPE OF HEADER READ:  0=INTEGER VALUES (CODE OR
C                OVERLAY MAP), 1=DATA BLOCK VALUES, 2=N.I., 3=END RECORD.
C       ADDR   = THE AP DESTINATION ADDRESS OF AN ITEM OR THE START ADDRESS
C                OF A BLOCK OF ITEMS.  IT IS AN ARRAY BECAUSE OF CP APEX
C       PG     = THE MD PAGE DESTINATION OF A VALUE(S).  IT IS AN ARRAY
C                BECAUSE OF CP APEX
C       CNT    = THE NUMBER OF RECORDS IN A BLOCK OR THE HOST WORD SIZE OF
C                A BLOCK
C       DEST   = THE DESTINATION OF A CODE BLOCK: 0=PS, 1=MD
C       VALTYP = VALUE TYPE SPECIFIER: 1=INTEGER (16), 2=HOST F.P.N.
C       REPCNT = REPETITION COUNT (USED W/ DATA BLOCK VALUES)
C
C       ROUTINES-APEX:  APPUT, LOADPS, OAPME
C
        INTEGER I,TTYPE,ADDR(20),PG(16),CNT,K,VALTYP,DEST,PTPG
        INTEGER MXADDR,PTADDR
        INTEGER REPCNT,IBUF(200),PGCRNT,J,PAKFAC,FPPAK,BUFSIZ
        INTEGER IPTR,IVAL(2),L
C
        REAL ABUF(100),VAL
C
        EQUIVALENCE (ABUF(1),IBUF(1))
        EQUIVALENCE (IVAL(1),VAL)
C
        COMMON /APLDCM/ IPAV(33),NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS(33),
     *                  LMT(10,3),LMTE
        INTEGER IPAV,NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS,LMT,LMTE
C
C------- INITIALIZE
C
        DATA FPPAK,PAKFAC,BUFSIZ / 2 , 1 , 200 /
        DATA MXADDR,PTADDR/20,0/
        DATA PG(1),PG(2),PG(3),PG(4),PG(5),PG(6),PG(7),PG(8)/
     *           0,    1,    2,    3,    4,    5,    6,    7/
        DATA PG(9),PG(10),PG(11),PG(12),PG(13),PG(14),PG(15),PG(16)/
     *           8,     9,    10,    11,    12,    13,    14,    15/
C
C       SELECT MD PAGE ZERO
C
        CALL OAPME (0)
        PGCRNT=0
C
C------ INITIALIZE THE POINTER TO THE START OF THE MODULE.
C
         IPTR=1
C
C       GET A HEADER RECORD, GET THE TYPE, RECORD COUNT, LOAD ADDRESS,
C       AND PAGE DESTINATION.
C
100     CONTINUE
        TTYPE=LMBUF(IPTR)+1
        CNT=LMBUF(IPTR+1)
        PTADDR=PTADDR+1
        IF (PTADDR.LE.MXADDR) GO TO 110
        PTADDR=1
110     ADDR(PTADDR)=LMBUF(IPTR+2)
        PTPG=LMBUF(IPTR+3) + 1
        DEST=LMBUF(IPTR+4)
C
C       PROCESS:  INTEGER VALUES (CODE OR OV MAP), DATA BLOCK VALUES, N.I.,
C                 AND END BLOCK
C
        IF (TTYPE .LT. 0 .OR. TTYPE .GT. 4) GOTO 90000
        GOTO (1000,2000,600,500),TTYPE
C
C------- END RECORD FOUND - SET PAGE MASK BITS AND RETURN
C
500     CALL OMASK (15)
        RETURN
C
C------- INFO RECORD PROCESSING
C
C       MUST SET PPAAD, PPASZ AND LMID IN THE RUN TIME INFO COMMON
C       AREA (/APLDCM/)
C
600     IPPAAD=LMBUF(IPTR+1)
        IPPAND=LMBUF(IPTR+2)
        IDLM=LMBUF(IPTR+3)
        IF (LMBUF(IPTR+4) .EQ. 0) GOTO 650
        CALL APPUT (LMBUF(IPTR+4),1,2,1)
650     IPTR=IPTR+8
        GOTO 100
C
C------- INTEGER VALUE PROCESSING (CODE OR OVERLAY MAP VALUES)
C
C       IF DEST .NE. 0 WE MUST SELECT AN MD PG FOR THE MD TRANSFER.
C       IF PG=PGCRNT THEN DO NOTHING, ELSE SELECT PAGE PG.  IF
C       DEST=0 THEN TRANSFER IS TO PS.
C
1000    CONTINUE
        IF (CNT.NE.0) GO TO 1010
        IPTR=IPTR + 8
        GO TO 100
1010    CONTINUE
        IF (DEST.NE.0) GO TO 1400
C
C       MOVE VALUES (CODE) TO PS
C
        IPTR=IPTR+8
        CALL LOADPS (LMBUF(IPTR),ADDR(PTADDR),(CNT*PAKFAC)/4)
        GOTO 1440
C
C       MOVE VALUES (CODE OR OVERLAY MAP) TO MD;  32 BITS OF HOST
C       PER MD WORD.
C
1400    CONTINUE
        IF (PG(PTPG).EQ.PGCRNT) GO TO 1410
        CALL OAPME (PG(PTPG))
        PGCRNT=PG(PTPG)
1410    CONTINUE
        IPTR=IPTR+8
        CALL APPUT (LMBUF(IPTR),ADDR(PTADDR),(CNT*PAKFAC)/2,0)
C
C       UPDATE POINTER TO NEXT HEADER RECORD AND READ RECORD.
C
1440    IPTR=IPTR+CNT
        GO TO 100
C
C------- DATA BLOCK VALUE PROCESSING
C
C       SELECT THE REQUESTED MD PAGE (PG) IF ITS DIFFERENT FROM PGCRNT.
C
2000    IF (PG(PTPG) .EQ. PGCRNT) GOTO 2020
        CALL OAPME (PG(PTPG))
        PGCRNT=PG(PTPG)
C
C       GET DATA BLOCK VALUES (1 PER RECORD) AND PLACE THEM IN MD.
C       GET THE TYPE OF VALUE (0=16 BIT INTEGER, 1=F.P.), AND DESTINATION
C       ADDRESS.
C
2020    DO 3500 J=1,CNT
        IPTR=IPTR+8
        VALTYP=LMBUF(IPTR)
        PTADDR=PTADDR+1
        IF (PTADDR.LE.MXADDR) GO TO 2030
        PTADDR=1
2030    ADDR(PTADDR)=LMBUF(IPTR+2)
C
C       IF REPETITION COUNT (LMBUF(2)) .GT. 1 PROCESS SEPERATE
C
        IF (LMBUF(IPTR+1) .GT. 1) GOTO 2600
C
C       PROCESS VALUES:  INTEGER, REAL, COMPLEX, TRIPLE
C
        GOTO (2100,2150,2200,2300),VALTYP
C
C       INTEGER VALUE
C
2100    CALL APPUT (LMBUF(IPTR+4),ADDR(PTADDR),1,1)
        GOTO 3500
C
C       REAL VALUE
C
2150    CALL APPUT (LMBUF(IPTR+4),ADDR(PTADDR),1,2)
        GOTO 3500
C
C           COMPLEX VALUE
2200    CONTINUE
        GO TO 90000
C
C               TRIPLE DATA VALUE (32 BITS OF 38 BIT WORD)
2300    CONTINUE
        CALL APPUT (LMBUF(IPTR+5),ADDR(PTADDR),1,0)
        GO TO 3500
C
C       PROCESS VALUE WITH A REPETITION COUNT.  MAKE 'REPCNT' COPIES OF VALUE
C       IN THE IBUF(),  (EQUIVALENCED TO ABUF()).
C
C       PROCESS BY VALTYP:  INTEGER, REAL, COMPLEX, TRIPLE
C
2600    REPCNT=LMBUF(IPTR+1)
        GOTO (2700,2800,2900,3000),VALTYP
C
C       INTEGER VALUE WITH REPETITION COUNT
C
2700    K=MIN0 (BUFSIZ,REPCNT)
        L=LMBUF(IPTR+4)
        DO 2750 I=1,K
2750    IBUF(I)=L
        CALL APPUT(IBUF,ADDR(PTADDR),K,1)
        IF (K .EQ. REPCNT) GOTO 3470
        REPCNT=REPCNT-K
        PTADDR=PTADDR+1
        IF (PTADDR.LE.MXADDR) GO TO 2760
        PTADDR=1
        ADDR(1)=ADDR(MXADDR) + K
        GO TO 2700
2760    ADDR(PTADDR)=ADDR(PTADDR-1) + K
        GO TO 2700
C
C       REAL VALUE WITH REPETITION COUNT
C
2800    K=MIN0(BUFSIZ/FPPAK,REPCNT)
        IVAL(1)=LMBUF(IPTR+4)
        IVAL(2)=LMBUF(IPTR+5)
        DO 2850 I=1,K
2850    ABUF(I)=VAL
        CALL APPUT (ABUF,ADDR(PTADDR),K,2)
        IF (REPCNT .EQ. K) GOTO 3470
        REPCNT=REPCNT-K
        PTADDR=PTADDR+1
        IF (PTADDR.LE.MXADDR) GO TO 2860
        PTADDR=1
        ADDR(1)=ADDR(MXADDR)+K
        GO TO 2800
2860    ADDR(PTADDR)=ADDR(PTADDR-1) + K
        GO TO 2800
C
C               COMPLEX VALUE WITH REPETITION COUNT
2900    CONTINUE
        GO TO 90000
C
C               TRIPLE WITH REPETITION COUNT
3000    CONTINUE
        L=3-PAKFAC
        K=MIN0 (BUFSIZ/L,REPCNT)
        KK=K*L
        DO 3050 I=1,KK,L
        IBUF(I)=LMBUF(IPTR+5)
        IBUF(I+1)=LMBUF(IPTR+6)
3050    CONTINUE
        CALL APPUT(IBUF,ADDR(PTADDR),K,0)
        IF (K .EQ. REPCNT) GOTO 3470
        REPCNT=REPCNT-K
        PTADDR=PTADDR+1
        IF (PTADDR.LE.MXADDR) GO TO 3060
        PTADDR=1
        ADDR(1)=ADDR(MXADDR) + K
        GO TO 3000
3060    ADDR(PTADDR)=ADDR(PTADDR-1) + K
        GO TO 3000
C
C
C       BOTTOM OF THE DATA BLOCK RECORD LOOP
C
3470    CONTINUE
3500    CONTINUE
        IPTR=IPTR+8
        GOTO 100
C
C       ERROR - BAD LOAD MODULE
C
90000   CALL APSTOP (10)
        RETURN
        END
C****** APLLI = INITIALIZE THE LOAD MODULE LOADER = REL B.1  , NOV 79 *********
C
        SUBROUTINE APLLI (FILNAM,NAMLEN,LUN,OPTION,LMID,ARRAY,NU)
C
        INTEGER FILNAM(16),NAMLEN,OPTION,LUN,LMID,ARRAY(9999),NU
C
C       THIS ROUTINE IS CALLED TO SPECIFY WHERE A GIVEN LOAD MODULE
C       MAY BE FOUND AND HOW IT SHOULD BE TRANSFERED TO THE AP.
C
C       CALL:
C
C       FILNAM = THE FILE NAME WHERE THE LOAD MODULE MAY BE FOUND.
C       NAMLEN = THE LENGTH OF THE FILE NAME IN CHARACTERS.
C       LUN    = A LOGICAL UNIT THAT MAY BE USED FOR THE FILE ASSIGNMENT.
C       OPTION = 1 FOR DIRECT LOADING OF THE LM INTO THE AP.
C       LMID   = THE IDENTIFICATION NUMBER OF THE LOAD MODULE.  THIS
C                MUST BE THE SAME NUMBER THAT WAS SPECIFIED AT LOAD TIME.
C       ARRAY  = NOT USED NOW.
C       NU     = NOT USED NOW.
C
C       VARIABLES:
C
C       LUNIT  = THE LOCAL VARIABLE EQUAL TO LUN.
C       IDIOT  = DUMMY VARIABLE.
C       ERRLU  = ERROR TEST VARIABLE
C       LMTMAX = THE MAXIMUM NUMBER OF ENTRIES IN THE LMT ARRAY.
C       LMTE   = THE CURRENT NUMBER OF ENTRIES IN THE LMT ARRAY.
C       LMT    = AN ARRAY CONTAINING INFORMATION SPECIFIED DURING
C                PREVIOUS CALLS TO APLLI.
C                LMT(1)=THE LOAD MODULE ID.
C                LMT(2)=THE OPTION
C                LMT(3)=THE LOGICAL UNIT ASSIGNED TO THIS LM  , OR -1
C                IF NO LOGICAL UNIT IS CURRENTLY ASSIGNED.
C
        INTEGER I,LUNIT,IDIOT,INDX,LMTMAX,ERRLU
C
        COMMON /APLDCM/ IPAV(33),NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS(33),
     *                  LMT(10,3),LMTE
        INTEGER IPAV,NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS,LMT,LMTE
C#      DECLARATIONS FOR FILE I/O ROUTINES
C
        DATA LMTMAX /10/
C
C       INITIALIZE
C
C#      MAP LUN FOR CALLING FILE OPENING UTILITY
C
        LUNIT = LUN+7
        INDX=0
C
C       SEARCH LMT() AND IGNORE THIS CALL IF AN ENTRY EXISTS W/ THE SAVE
C       LM ID AND ALREADY HAS A LOGICAL UNIT ASSIGNED (LMT(#,3) .NE. -1)
C
        IF (LMTE .EQ. 0) GOTO 1000
        DO 500 I=1,LMTE
        IF (LMT(I,1) .EQ. LMID) RETURN
500     CONTINUE
C
C       SEARCH LMT() AND UNASSIGN ANY FILE ALREADY ASSIGNED TO LUNIT
C
        DO 520 I=1,LMTE
        IF (LMT(I,3) .EQ. LUN) GOTO 700
520     CONTINUE
        GOTO 1000
C#      CLOSE THE FILE
C
700     CONTINUE
        CALL CLOSE(LUNIT)
C
C       IF A CLOSE ERROR IS DETECTED:     CALL APSTOP (7)
C
        INDX=I
        GOTO 1100
C
C       CHECK FOR LMT() OVERFLOW
C
1000    INDX=LMTE+1
        IF (INDX .GT. LMTMAX) GOTO 90000
        LMTE=LMTE+1
C
C       MAKE THE NEW ENTRY
C
1100    LMT(INDX,1)=LMID
        LMT(INDX,2)=OPTION
        LMT(INDX,3)=LUN
C
C#      OPEN THE FILE
C      SHOULD USE INFILE AND OPEN FOR UNFORMATTED BINARY READ
C        FORTRAN OPEN HAS ERROR RETURN OPTION
C
        CALL ASSIGN (LUNIT,FILNAM,NAMLEN)
C
C       IF AN OPEN ERROR IS DETECTED:      CALL APSTOP (13)
C
        RETURN
C
C
C       LMT() OVERFLOW
C
90000   CALL APSTOP (8)
        RETURN
        END
C****** APSEIN = PLACE SIGN EXTEND CODE IN PS = REL B.1  , NOV 79 *************
C
        SUBROUTINE APSEIN
C
C     FOR 16 BIT MACHINES, THIS IS A NO-OP
C
        RETURN
        END
C****** APGSEI = GET SIGN-EXTENDED INTEGER FROM 'MD' = REL B.1  , NOV 79 ******
C
        SUBROUTINE APGSEI(HOST,AP,N)
        INTEGER HOST(1),AP,N
C
C  THE FUNCTION OF THIS ROUTINE IS TO GET 16 BIT INTEGERS FROM AP MD AND PUT
C  THEM INTO HOST MEMORY SIGN-EXTENDED TO THE FULL HOST WORD SIZE.  THE MANNER
C  IN WHICH THIS IS DONE IS HOST AND APEX DEPENDENT.  THE DEFAULT FOR 16 BIT
C  HOSTS IS TO DO A FMT=1 RUNDMA CALL.  FOR LARGER HOST WORDS, A FMT=0
C  TRANSFER AND SUBSEQUENT SIGN-EXTEND IS APPROPRIATE.  FOR CPAPEX, SOME OR
C  ALL OF THIS FUNCTION MAY BE AP RESIDENT.
C
C  PARAMETERS:
C    SAME AS APGET
C
C  ROUTINES USED:  NONE
C
C  NOT NEED BY 16 BIT HOSTS
C
        RETURN
        END
C
C****** APEXC = EXECUTE CHANNEL PROGRAM = REL B.1  , NOV 79 *******************
C
        SUBROUTINE APEXC
C
C       WILL EXECTUE THE CHANNEL PROGRAM CURRENTLY RESIDING IN THE
C       CHANNEL PROGRAM BUFFER.  WHEN CONTROL IS RETURNED TO THE
C       CALLER THE ENTIRE CHANNEL PROGRAM WILL BE COMPLETELY
C       EXECUTED AND ALL AP I/O WILL BE COMPLETE.
C
C       THIS ROUTINE WILL ONLY BE REQUIRED FOR CPAPEX'S.  CPAPEX IS
C       DESIGNED FOR CHANNEL MACHINES OR HOST'S THAT CAN EFFICIENTLY
C       EMMULATE A CHANNEL.  IF CPAPEX CANNOT BE IMPLEMENTED, THIS
C       ROUTINE WILL ACT AS A NO-OP.
C
        RETURN
        END
C
C****** APMODE = SWITCH CPAPEX MODES = REL B.1  , NOV 79 **********************
C
        SUBROUTINE APMODE(M)
        INTEGER M
C
C       PARAMETERS:
C
C           M  =  0, INDICATES A CHANGE TO CP MODE IS DESIRED
C           M  = NOT 0, INDICATES A CHANGE TO STEP MODE IS DESIRED
C
C       PURPOSE:  TO CHANGE THE CPAPEX MODE
C
C       NOTE:  IF THE SWITCH IS FROM CP MODE TO STEP MODE, APMODE
C       MUST CALL APEXC TO EMPTY THE CHANNEL PROGRAM BUFFER.
C       IF THE SWITCH IS FROM STEP MODE TO CP MODE, THE SWITCH
C       IS MADE IMMEDIATELY.  THIS ROUTINE IS FOR CPAPEX ONLY.
C       IF CPAPEX CANNOT BE IMPLEMENTED THIS ROUTINE WILL ACT A
C       A NO-OP.
C
        RETURN
        END
C
C****** APGMOD = GET THE CPAPEX MODE = REL B.1  , NOV 79 **********************
C
        SUBROUTINE APGMOD(M)
        INTEGER M
C
C       RETURN THE CURRENT CPAPEX MODE
C       IF CPAPEX CANNOT BE IMPLEMENTED RETURN A MODE OF 1
C
        M = 1
        RETURN
        END
C
C****** APSTOP = PAUSE ON AP FATAL ERROR = REL B.1  , NOV 79 ******************
        SUBROUTINE APSTOP(ERNUM)
        INTEGER ERNUM
C
C       COMMON TO PASS HALT ADDRESS AND STOP NUMBER FOR MESSAGE AP.12
C
        COMMON /ERRORS/ HADDR,STOPN
        INTEGER HADDR,STOPN
C
C       TINP  IS LOGICAL UNIT FOR TERMINAL INPUT
C       TOUT  IS LOGICAL UNIT FOR TERMINAL OUTPUT
        INTEGER TINP,TOUT
C
C            FOR   PDP11  RSX11M
        DATA TINP/5/
        DATA TOUT/5/
C
C       PURPOSE - IS TO INFORM THE USER THAT AN ERROR HAS OCCURRED
C                 BY ISSUING THE APPROPRIATE MESSAGE.  AFTER THE
C                 MESSAGE HAS BEEN ISSUED THE USER SHOULD BE GIVEN
C                 THE OPTION TO CONTINUE OR ABORT THE TASK.
C
C       ERROR MESSAGES - HOST INDEPENDENT ERROR MESSAGES ARE
C                        PREFIXED AP.1 THROUGH AP.99.
C                        HOST DEPENDENT ERROR MESSAGES ARE
C                        PREFIXED AP.100 AND UP.
C
C                        ERROR MESSAGES ARE TO BE RETURNED TO THE USER'S
C                        TERMINAL OR OUTPUT FILE.
C
C                        MESSAGES ARE 70 CHARACTERS OR LESS.
C
C       INDEPENDENT ERROR MESSAGES :
C
C       NUM           MESSAGE
C
C       1    AP.1 - P.S. MEMORY OVERFLOW
C       2    AP.2 - PARAMETER MISMATCH
C       3    AP.3 - AP DATA LATE ERROR
C       4    AP.4 - AP STACK OVERFLOW (SRAO) ERROR
C       5    AP.5 - PARITY ERROR ON MD READ/WRITE
C       6    AP.6 - ILLEGAL DMA FORMAT REQUESTED
C       7    AP.7 - SERVICE CALL ERROR (E.G. MONITOR REQUEST REJECTED)
C       8    AP.8 - TOO MANY LOAD MODULES
C       9    AP.9 - LOAD MODULE NOT INITIALIZED
C       10   AP.10 - BAD AP LOAD MODULE
C       11   AP.11 - MAIN DATA PARAMETER PASSING AREA OVERFLOW
C       12   AP.12- APFTN STOP STATEMENT EXECUTED
C       13   AP.13- ERROR ON LOAD MODULE OPEN
C
C       AP.14 - AP.63 ARE RESERVED FOR HOST INDEPENDENT MESSAGES
C
C       FPS-100 SUPERVISOR RELATED MESSAGES
C
C     64      AP.64 - UNEXPECTED SUPERVISOR HALT
C     65      AP.65 - HPUT.  ILLEGAL DEST VALUE
C     66      AP.66 - HPUT.  DATUM EXCEEDS 13 BITS
C     67      AP.67 - HGET. AP USED INDEX ZERO
C     68      AP.68 - HGET. ILLEGAL SORS NUMBER
C     69      AP.69 - INACCESIBLE AP REGISTER OR MEMORY
C     70      AP.70 - PSFUNC TRIED IN SUPERVISOR MODE
C     71      AP.71 - APGSP  TRIED IN SUPERVISOR MODE
C     72      AP.72 - ILLEGAL APEXAM REQUEST
C     73      AP.73 - ILLEGAL APDEP REQUEST
C     74      AP.74 - NOT IN SUPERVISOR MODE
C     75      AP.75 - AP HARDWARE IS HALTED
C     76      AP.76 - AP FLOATING POINT EXCEPTION
C     77      AP.77 - REQUEST FOR NON-EXISTENT OVERLAY
C     78      AP.78 - SUPERVISOR CRASH ON SAVE
C     79      AP.79 - SUPERVISOR CRASH ON RESTORE
C     80      AP.80 - ILLEGAL USAGE PROG INTERRUPT
C     81      AP.81 - AP MESSAGE TIMEOUT
C
C         AP.82 TO AP.99 ARE RESERVED FOR HOST INDEPENDENT
C                        SUPERVISOR RELATED MESSAGES
C
C       DEPENDENT ERROR MESSAGES:
C
C       NUM         MESSAGE
C
C       101     AP.101 - INTERRUPT VECTOR CLOBBERED
C
C       ROUTINES USED: NONE
C
C
C
        IF (ERNUM .LE. 0) GO TO 9899
        IF (ERNUM .GT. 8) GOTO 10
        GO TO (100,200,300,400,500,600,700,800), ERNUM
C
 10     IF (ERNUM .GT. 63) GOTO 20
        JNUM = ERNUM-8
        GO TO (900,1000,1100,1200,1300), JNUM
C
20      IF (ERNUM .GT. 70) GO TO 30
        JNUM = ERNUM-63
        GOTO (6400,6500,6600,6700,6800,6900,7000), JNUM
C
30      IF (ERNUM .GT. 99) GO TO 40
        JNUM = ERNUM-70
        GO TO (7100,7200,7300,7400,7500,7600,7700,
     X    7800,7900,8000,8100), JNUM
C
40      IF (ERNUM .GT. 102) GO TO 9899
        JNUM = ERNUM -99
        GO TO (10001,10101,10201), JNUM
C
100     WRITE(TOUT, 102 )
        GO TO 9999
200     WRITE(TOUT, 202 )
        GO TO 9999
300     WRITE(TOUT, 302 )
        GO TO 9999
400     WRITE(TOUT, 402 )
        GO TO 9999
500     WRITE(TOUT, 502 )
        GO TO 9999
600     WRITE(TOUT, 602 )
        GO TO 9999
700     WRITE(TOUT, 702 )
        GO TO 9999
800     WRITE(TOUT, 802 )
        GO TO 9999
900     WRITE(TOUT, 902 )
        GO TO 9999
1000     WRITE(TOUT, 1002 )
        GO TO 9999
1100     WRITE(TOUT, 1102 )
        GO TO 9999
1200     WRITE(TOUT, 1202 ) HADDR, STOPN
        GO TO 9999
1300     WRITE(TOUT, 1302 )
        GO TO 9999
6400     WRITE(TOUT, 6402 )
        GO TO 9999
6500     WRITE(TOUT, 6502 )
        GO TO 9999
6600     WRITE(TOUT, 6602 )
        GO TO 9999
6700     WRITE(TOUT, 6702 )
        GO TO 9999
6800     WRITE(TOUT, 6802 )
        GO TO 9999
6900     WRITE(TOUT, 6902 )
        GO TO 9999
7000     WRITE(TOUT, 7002 )
        GO TO 9999
7100     WRITE(TOUT, 7102 )
        GO TO 9999
7200     WRITE(TOUT, 7202 )
        GO TO 9999
7300     WRITE(TOUT, 7302 )
        GO TO 9999
7400     WRITE(TOUT, 7402 )
        GO TO 9999
7500    WRITE (TOUT,7502)
        GO TO 9999
7600   WRITE (TOUT,7602)
       GO TO 9999
7700   WRITE (TOUT,7702)
       GO TO 9999
7800   WRITE (TOUT,7802)
       GO TO 9999
7900   WRITE (TOUT,7902)
       GO TO 9999
8000    WRITE (TOUT,8002)
        GO TO 9999
8100    WRITE (TOUT,8102)
        GO TO 9999
10001   GO TO 9899
10101     WRITE(TOUT, 10102 )
        GO TO 9999
10201   GO TO 9899
C
102     FORMAT(' AP.1 - P.S. MEMORY OVERFLOW')
202     FORMAT(' AP.2 - PARAMETER MISMATCH')
302     FORMAT(' AP.3 - AP DATA LATE ERROR')
402     FORMAT(' AP.4 - AP STACK OVERFLOW')
502     FORMAT(' AP.5 - PARITY ERROR ON MD READ/WRITE')
602     FORMAT(' AP.6 - ILLEGAL DMA FORMAT REQUESTED')
702     FORMAT(' AP.7 - SYSTEM SERVICE ERROR')
802     FORMAT(' AP.8 - TOO MANY LOAD MODULES OR OVERLAYS')
902     FORMAT(' AP.9 - LOAD MODULE NOT INITIALIZED')
1002    FORMAT(' AP.10 - BAD AP LOAD MODULE')
1102    FORMAT(' AP.11 - MAIN DATA PARAMETER PASSING AREA OVERFLOW')
1202    FORMAT(' AP.12 - AP HALTED AT ',I8,' STOP NUMBER = ',I8)
1302    FORMAT(' AP.13 - UNABLE TO OPEN LOAD MODULE FILE')
6402    FORMAT(' AP.64 - UNEXPECTED SUPERVISOR HALT')
6502    FORMAT(' AP.65 - HPUT. ILLEGAL DEST VALUE ')
6602    FORMAT(' AP.66 - HPUT. DATUM EXCEEDS 13 BITS ')
6702    FORMAT(' AP.67 - HGET. AP USED INDEX 0')
6802    FORMAT(' AP.68 - HGET. ILLEGAL SORS NUMBER')
6902    FORMAT(' AP.69 - INACCESSIBLE REGISTER OR MEMORY')
7002    FORMAT(' AP.70 - TRIED PSFUNC IN SUPERVISOR MODE')
7102    FORMAT(' AP.71 - TRIED APGSP IN SUPERVISOR MODE')
7202    FORMAT(' AP.72 - ILLEGAL APEXAM REQUEST')
7302    FORMAT(' AP.73 - ILLEGAL APDEP REQUEST ')
7402    FORMAT(' AP.74 - NOT IN SUPERVISOR MODE')
7502    FORMAT(' AP.75 - AP HARDWARE IS HALTED')
7602    FORMAT(' AP.76 - AP FLOATING POINT EXCEPTION')
7702    FORMAT(' AP.77 - REQUEST FOR NON-EXISTENT OVERLAY')
7802    FORMAT(' AP.78 - SUPERVISOR CRASH IN SAVE')
7902    FORMAT(' AP.79 - SUPERVISOR CRASH IN RESTORE')
8002    FORMAT(' AP.80 - ILLEGAL USAGE PROG INTERRUPT' )
8102    FORMAT(' AP.81 - AP MESSAGE TIMEOUT' )
10102   FORMAT(' AP.101 - INTERRUPT VECTOR CLOBBERED')
C
9899    WRITE (TOUT,9893) ERNUM
9893    FORMAT (' ILLEGAL APSTOP NUMBER',I8)
C
C  FORCE PROGRAM TO STOP
C
9999    CONTINUE
        WRITE (TOUT,9993)
9993     FORMAT(' DO YOU WISH TO CONTINUE? (1-YES, 0-NO)')
        READ (TINP,9994) JNUM
9994    FORMAT (I4)
        IF (JNUM .EQ. 1) RETURN
        CALL EXIT
C
C
        END
