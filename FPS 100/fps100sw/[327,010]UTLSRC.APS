$LIB
"****** UTLSRC = UTILITY LIBRARY /FAST/ = REL 3.5, DEC 80 *****
"
"======================================================================
"
"     ---HISTORY---
"REV 3.5 AND 2A.5: DEC 80
"       1. SAVESP FIXED WHEN FOR SAVE OF 1 OR 2 S-PADS.
"       2. FLUSH MODIFIED TO SAVE INSTEAD OF CLEAR APSTATUS.
"       3. (REV 2A.5 ONLY) SINCOS FIXED FOR ACCURACY PROBLEM WITH
"          ARGUMENTS OF VERY SMALL MAGNITUDE.
"
"REV 3.4 AND 2A.4: AUG 80
"       1. ENHANCES SAVESP AND SETSP TO ALLOW SAVING AND RESTORING UP
"          TO 16 SPADS IN PS (FORMERLY ONLY 12 WERE ALLOWED).  SAVESP,
"          SETSP, AND SET2SP NOW SCRATCH SOME DATA PADS INSTEAD OF SPADS.
"
"REV 3.3 AND 2A.3: MAR 80
"       1. FIXED BUGS IN THE FOLLOWING ROUTINES:
"              CTOR
"              RTOC
"       2. (REV 3.3 ONLY) $RADIX 8 STATEMENT ADDED TO ALL ROUTINES SO ROUTINES
"          WILL ASSEMBLE CORRECTLY EVEN WHEN ASSEMBLER DEFAULT IS BASE 10 OR 16.
"
"REV 3.2 AND 2A.2: SEP 79
"       1.  VFCL1 AND VFCL2 NOW PROPERLY EXIT WHEN ELEMENT COUNT IS ZERO.
"       2.  DIV SPEEDED FROM 23 TO 22 CYCLES.
"
"REV 3.1 AND 2.6:  AUG 79
"       1.  SETSP CHANGED TO ALLOW SELECTABLE STARTING SPAD
"
"
"REV 2.5:  MAY 79
"       1.  DELETES THE FOLLOWING ROUTINES:
"               SETC5
"               RDC5
"               DAREAD
"               DAWRIT
"               MDCOM
"          (THESE ROUTINES NOW LOACATED IN BABSRC).
"       2.  ADDS THE FOLLOWING ROUTINE:
"               APNOP
"               (LOCATED AT THE END OF THE LIBRARY)
"REV 3.0:  MAR 79
"       1. DELETES THE FOLLOWING ROUTINES WHICH ARE MOVED TO BABSRC
"              SETC5
"              RDC5
"              DAREAD
"              DAWRIT
"              MDCOM
"       2. MINOR MODS TO FOLLOWING ROUTINES FOR APAL3 COMPATIBILITY:
"             XCFFT
"             PCFFT
"             XREALT
"             REALTR
"      3. ADDS THE FOLLOWING ROUTINE
"             FLUSH  --  FLUSH PIPELINES, CLEAR STATUS
"REV 2.4:  FEB 79
"          1. ADDS THE FOLLOWING ROUTINE:
"                      FLUSH  --  FLUSH PIPELINES, CLEAR STATUS
"REV 2.3:  JAN 79
"          1. DELETES ROUTINE ZMD, NOW ONLY IN DGNSRC
"REV 2.2:  SEP 78
"       1. SPLITS BASIC LIBRARY INTO 3 PARTS:
"               BAASRC --  COMPLEX VECTOR OPERATIONS
"                          BASIC VECTOR OPERATIONS
"                          VECTOR-TO-SCALAR OPERATIONS
"
"               BABSRC --  VECTOR COMPARISON OPERATIONS
"                          DATA FORMATING OPERATIONS
"                          MATRIX ROUTINES
"                          FFT ROUTINES
"                          AUXILIARY ROUTINES
"
"               UTLSRC --  APAL-CALLABLE UTILITY ROUTINES
"
"       2. ADDS THE FOLLOWING NEW ROUTINES:
"               SPUFLT --  S-PAD UNSIGNED FLOAT
"       3. ADDS 2D FFT UTILITY ROUTINES, INCLUDING:
"               XRFFT  --  EXPANDED REAL FFT
"               XCFFT  --  EXPANDED COMPLEX FFT
"               XBITRE --  EXPANDED BIT REVERSE
"               PCFFT  --  PARTIAL COMPLEX FFT
"               XFFT4  --  EXPANDED RADIX 4 FFT PASS
"               XREALT --  EXPANDED REAL FFT FINAL PASS
"               CTOR   --  COMPLEX TO REAL FFT UNSCRAMBLE
"               RTOC   --  REAL TO COMPLEX FFT SCRAMBLE
"       4. FIXES BUGS IN THE FOLLOWING ROUTINES:
"               SPDIV
"               SIN
"               COS
"
"=============================================================================
"****** FLUSH = FLUSH PIPELINES, SAVE STATUS /COMMON/ = REL 2.5, DEC 80 ***
        $TITLE FLUSH
        $RADIX 8
        $ENTRY FLUSH
"
"      ---ABSTRACT---
"CLEANS OUT PIPELINES FOR ADDER AND MULTIPLIER, AND SAVES AP STATUS
"REGISTER.  ORIGINAL CODE WAS EXTRACTED FROM THE BOOTSTRAP.
"
"      ---HISTORY---
"ORIGINAL:  FEB 79  R.S. NORIN
"REV 2.5:   DEC 80  T.E. SKINNER  SAVES VS CLEARS AP STATUS (TAR UK0110)
"
"      ---STATISTICS---
"LANGUAGE:   APAL
"EQUIPMENT:  AP WITH EITHER SPEED MEMORY
"SIZE:       4 PS WORDS
"SPEED:      0.67 US
"
"      ---USAGE---
"APAL CALL:  JSR FLUSH
"SCRATCH:    DPX(0),FA,FM,SP(17)
"
FLUSH:  DPX<ZERO;                   "SET DPX(0)=0.0
         RAPS; LDSPNL 17            "SAVE AP STATUS REGISTER
        FMUL DPX,DPX; FADD DPX,DPX  "FLUSH ADDER AND MULT
        FMUL DPX,DPX; FADD DPX,DPX
        FMUL DPX,DPX;
         LDAPS; DB=SPFN; MOV 17,17; "RESTORE AP STATUS REGISTER
         RETURN                     "EXIT FLUSH
        $END
"****** XRFFT = EXPANDED REAL FFT /COMMON/ = REL 2.2, SEP 78 ***
"
        $TITLE XRFFT
        $RADIX 8
        $ENTRY XRFFT,4                          "USER-DIRECTED-CALL ENTRY
        $EXT XREALT,XCFFT
"
"
"                               --- ABSTRACT ---
"MAINLINE PROGRAM TO DO A REAL FFT
"
"
"                  --- STATISTICS ---
"EQUIPMENT:  AP-120B WITH EITHER MEMORY
"ORIGINAL:      DEC 77  G. J. THROOP
"       THE S-PADS CALLING FFT MUST BE MODIFIED
"               C = 0
"               N = 1
"               DI = 2
"               F = 3
"SIZE:  17 PS LOCATIONS
"SUBROUTINES USED: XCFFT,XREALT
"
"ARGUMENTS IN S-PAD
"0      C    BASE ADDRESS OF REAL DATA VECTOR
"2      DI      MEMORY SPACING BETWEEN PAIRS OF POINTS
"3      F    FLAG:  +1 FOR DIRECT, -1 FOR INVERSE TRANSFORM
"
"
"                               --- SCRATCH (OVERALL) ---
"SPAD:                          2-17
"DATA PAD X:                    -4 TO +3 (RELATIVE TO DPA)
"DATA PAD Y:                    -4 TO +3 (RELATIVE TO DPA)
"
"
"
"                  --- ALGORITHM ---
"DOES A REAL FFT:
"       DIRECT:    DOES FIRST AN N/2 POINT COMPLEX FFT, AND THEN
"                      AN N POINT REAL UNRAVEL PASS
"       INVERSE:   DOES AN N POINT INVERSE REAL TRANSFORM PASS,
"                      AND THEN AN N/2 POINT INVERSE COMPLEX FFT
"S/PAD NAMES:
        C $EQU 0
        N $EQU 1
        DI $EQU 2
        F $EQU 3
"       THE FOLLOWING IS TEMP STORAGE FOR C SINCE XREALT
"       CLOBBERS THE ADDRESS.
        CSAVE $EQU 7
XRFFT:  MOV F,F                         "SEE IF DIRECT OR INVERSE
        BGT DIRECT                      "BRANCH IF DIRECT
INVRSE: MOV C,CSAVE                     "SAVE C
        JSR XREALT                      "GO DO THE REAL PASS
        MOVR N,N                        "MAKE N THE # OF COMPLEX POINTS
        MOV CSAVE,C                     "RESTORE C
        JSR XCFFT                       "DO AN N/2 POINT COMPLEX FFT
        LDSPI F; DB=-1                  "RESTORE FORWARD INVERSE FLAG
        MOVL N,N;  BR DONE              "RESTORE N REAL AND RETURN
DIRECT: MOVR N,N                        "MAKE N # OF COMPLEX POINTS
        JSR XCFFT                       "DO AN N/2 POINT COMPLEX FFT
        LDSPI F; DB=1                   "SET 'F' FOR REALTR, ETC.
        MOVL N,N                        "RESTORE N TO BE # REAL POINTS
        MOV C,CSAVE                     "SAVE C
        JSR XREALT                      "DO THE REAL PASS
        MOV CSAVE,C                     "RESTORE C
DONE:   RETURN
        $END
"****** XCFFT = EXPANDED COMPLEX FFT /COMMON/ = REL 3.0, NOV 78 ****
"
        $TITLE XCFFT
        $RADIX 8
        $ENTRY XCFFT,4                          "USER-DIRECTED-CALL ENTRY
"
        $EXT FFT2,XFFT4,STSTAT,CLSTAT,ADV2,ADV4,XBITRE
"
"
"
"
"                               --- ABSTRACT ---
"DOES A COMPLEX FFT
"
"
"                               --- STATISTICS ---
"EQUIPMENT:                     AP-120B WITH EITHER MEMORY
"SIZE:  22 PS LOCATIONS
"
"         --- HISTORY ---
" ORIGINAL      SEPT 78, G. J. THROOP     FOR MEMORY INCREMENT A POWER OF 2
"  REVISED      NOV 78,  R.S. NORIN       LABEL !FFTX2 REPLACES TBLSZE*2
"                                           FOR APAL3 COMPATIBILITY
"
"
"
"                               --- USEAGE ---
"DOES A COMPLEX FFT
"
"S-PAD PARAMETERS:
"       NAME     NUMBER          PURPOSE
        C   $EQU 0              "BASE ADDRESS OF ARRAY
        N   $EQU 1              "# OF COMPLEX POINTS TO BE TRANSFORMED (>1)
        DI $EQU 2               "MEMORY INCREMENT
        F $EQU 3                "DIRECTIONS:  1 = FORWARD,  -1 = INVERSE
"
"
"                               --- SCRATCH (OVERALL) ---
"S-PAD:                         2-17
"DATA PAD X:                    -4 THROUGH +3 (RELATIVE TO DPA)
"DATA PAD Y:                    -4 THROUGH +3 (RELATIVE TO DPA)
"
"
"
"
"                               --- ALGORITHM ---
"
"PROCEDURE:
"
"       MEMORY INCREMENTS ARE ASSUMED TO BE A POWER OF 2.
"       FOR NORMAL CLOSE PACKED DATA WHICH IS IN SEQUENTIAL
"       ORDER RIRIRIRI, WHERE R IS THE REAL PART AND I IS
"       THE IMAGINARY PART OF A COMPLEX NUMBER, THE MEMORY
"       INCREMENT DI IS 2.  TO TAKE A FFT OF AN ARRAY
"       WHERE YOU WISH TO TAKE EVERY LTH COMPLEX PAIR OF
"       AN ARRAY, DI = 2*L.
"
"       SINCE N IS THE NUMBER OF POINTS TO BE CALCULATED
"
"
"1.      CALL 'STSTAT'      THIS TAKES 'N' AND 'F', AND SETS THE BIT-REVERSE
"                           AND FFT-MODE BITS IN THE STATUS REGISTER,  AND
"                           LEAVES 2**(N) IN SPAD(17)
"2.      PARAMETER INITIALIZE  SET THE FOUR 'PASS VARIABLES'
"                            WD = TBLSZE * 2
"                            MDEL = DI
"                            JCOUNT = 1
"                            ICOUNT = N/4  IF N A POWER OF 4
"                                   = N/2 IF N A POWER OF 2
"3.     DO THE FIRST PASS:   RADIX 2 (FFT2) IF N WAS A POWER OF 2
"                               AND ADVANCE (ADV2)
"                            RADIX 4 (XFFT4) IF N WAS A POWER OF 4
"                               AND ADVANCE (ADV4)
"4.     DO THE REST OF THE RADIX 4 PASSES.
"                            CALL XFFT4  (TO DO THE NEXT FFT PASS)
"                            CALL ADV4  (TO ADVANCE TO THE NEXT PASS)
"                            TEST ICOUNT (SPFN AFTER ADV4) FOR ZERO TO TEST
"                                 FOR DONE
"5.     WHEN DONE, CALL 'CLSTAT' TO CLEAR THE BIT-REVERSE AND FFT-MODE
"                             STATUS BITS
"
"
"OTHER S-PAD NAMES:
        I $EQU 13               "TOP OF ARRAY FOR BITREVERSE
        WD     $EQU 14          "W DELTA
        MDEL   $EQU 15          "MEMORY DELTA
        ICOUNT $EQU 16          "I-LOOP COUNT
        JCOUNT $EQU 17          "J-LOOP COUNT
"
"
        FP $EQU 16              "PARAMETER FOR STSTAT (F)
        NP $EQU 17              "FOR STSTAT (N)
        M  $EQU 17              "FROM STSTAT (M = LOG2(N) )
"
"
"
"SIZE OF INSTALLED FFT TABLE
        TBLSZE $EQU !FFTSZ
"
"
"
"SET UP FOR THE FFT
"
"INITIALIZE POINTERS:
"
"SET AP-STATUS FOR FORWARD OR INVERSE FFT
"SET AP-STATUS FOR BIT-REVERSE SIZE
"JCOUNT<1
"WD<!FFTSZ*2
"MDEL<DI
"ICOUNT<N/4  IF 1ST PASS RADIX 4
"ICOUNT<N/2  IF 1ST PASS RADIX 2
"
XCFFT:  MOVL N,I                "TOP OF ARRAY FOR BITREVERSE
        MOV F,15                "TO SAVE FLAG FOR STSTAT
        MOV N,NP                "TO SET APSTAT WITH ILOG2(N)
        MOV F,FP
        JSR STSTAT              "SET FFT STATUS BITS
        MOV M,7                 "PATCH BECAUSE BITREV CLOBBERS M
        JSR XBITRE              "BIT-REVERSE THE ARRAY
        LDSPI WD; DB=!FFTX2     "SET WD=!FFTSZ*2
        MOV DI,MDEL             "PUT DI INTO MDEL
        "FOLLOWING IS PATCH BECAUSE BITREV CLOBBERS M
        MOVR 7,7                        "WAS LOG2(N) ODD?????
        BNC R2                  "IF SO, DO A RADIX 2 PASS FIRST
"
"SET UP FOR FIRST RADIX 4 PASS
R4:     MOVRR N,ICOUNT          "SET ICOUNT=N/4
        LDSPI JCOUNT; DB=1;     "SET COUNT=1
          BR LOOP
"
"DO A RADIX 2 PASS FIRST
R2:     MOVR N,ICOUNT           "SET ICOUNT=N/2
        JSR FFT2
        LDSPI JCOUNT; DB=1      "SET JCOUNT=1
        JSR ADV2                "RADIX 2 ADVANCE
        BEQ DONE                "SEE IF DONE
"
"
"LOOP HERE TO DO ALL THE PASES
LOOP:   JSR XFFT4               "DO A RADIX 4 PASS
        JSR ADV4                "RADIX 4 PASS ADVANCE
"
"DONE IF 'ADV' HAS SHIFTED ICOUNT TO ZERO
        BNE LOOP                "IF NOT DONE, GO BACK FOR MORE
"
"
"WHEN DONE, CLEAR FFT MODE BITS
"
DONE:   JMP CLSTAT              "CLEAR STATUS REGISTER
                                "AND EXIT THRU CLSTAT
        $END
"****** XBITRE = EXPANDED BIT REVERSE /COMMON/ = REL 2.2, SEP 78**
"
        $TITLE XBITRE
        $RADIX 8
        $ENTRY XBITRE                          "USER-DIRECTED-CALL ENTRY
"
"               --- ABSTRACT ---
"TAKES A COMPLEX DATA ARRAY AND PUTS IT INTO BIT-REVERSED (RADIX 2) ORDER
"
"               --- STATISTICS ---
"LANGUAGE:      AP-120B ASSEMBLER
"EQUIPMENT:     AP-120B WITH STANDARD MEMORY
"SIZE:          57 LOCATIONS
"SPEED:         3.7 US./COMPLEX POINT
"
"               --- HISTORY ---
"ORIGINAL:      DEC 77, G. J. THROOP
"
"               --- USEAGE ---
"S-PAD PARAMETERS:              BASE ADDRESS OF ARRAY
"       0 BASE                  BASE ADDRESS OF ARRAY
"       1 N                     NUMBER OF COMPLEX PAIRS
"       2 DI                    BASE INCREMENT
"       13 I                    LENGTH OF ARRAY
"
"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
"ALSO EXPECTS THE STATUS REGISTER BIT REVERSE BITS SET PROPERLY TO
"       IAND(15-LOG2(N),7)
"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
"
"               --- SCRATCH ---
"S-PAD:         11-16 OCTAL
"DATA PAD:              X - 0   (RELATIVE TO DPA)
"
"               --- ALGORITHM ---
"       WE USE THE ADDRESS BIT-REVERSING BUILT INTO THE S-PAD, WHICH
"       BIT-REVERSES THE SUBSCRIPT TO A COMPLEX DATA ARRAY (ELEMENTS
"       OCCUPY PAIRS OF MEMORY LOCATIONS SO THE LSB OF THE SUBSCRIPT
"       IS TAKEN TO BE 0.
"       WE SPECIFY THE ARRAY ELNGTH (MUST BE A POWER OF 2) IN THE
"       STATUS REGISTER BITS 13-15:  15 - LOG2(N)
"       WE HAVE TWO SEPARATE LOOPS, DEPENDING UPON WHETHER N IS LESS THAN
"       256. IF N IS SMALL WE SET THE STATUS BITS TO 7 - LOG2(N), AND
"       THEN SHIFT THE SUBSCRIPT LEFT 8 PLACES BEFORE BIT-REVERSING,
"       WHICH TOGETHER GIVES THE PROPER BIT-REVERSED SUBSCRIPT.
"
"
"
"
"
"       S-PAD REGISTER MNEMONICS
        BASE $EQU 0             "ARRAY BASE ADDRESS
        N $EQU 1                "NUMBER OF COMPLEX POINTS
        DI $EQU 2               "INCREMENT BETWEEN COMPLEX LOCATIONS
        I $EQU 13               "UPPER ADDRESS OF ARRAY = N*DI
"
"       --- LOCAL VARIABLES ---
        CTI $EQU 10             "SHIFT LEFT COUNTER
        BASEP1 $EQU 11          "BASE + DI
        AT $EQU 12              "&I STORAGE
        TI $EQU 16              "I STORAGE
        T $EQU 14               "ARRAY SUBSCRIPT SHIFTED LEFT 8 (*256)
        DT $EQU 3               "DELTA FOR T (DI*256)
        MDEL $EQU 15
"
"
XBITRE:         MOV BASE,BASEP1
        LDSPI MDEL; DB=2                "
        MOV MDEL,DT             "INCREMENT FOR MEMORY FETCH
        LDSPI T; DB=256.                "FOR TESTING N
        SUB# T,N                        "SEE IF N .GE. 256
        BGE BIG                         "YES, A BIG ARRAY
        JMP SMALL                       "NO, A SMALL ARRAY
"ARRAY 256 ELEMENTS OR LARGER:
"BIT-REVERSE BITS OF STATUS REGISTER SET TO 15. - LOG2(N)
"
"NOTE:  THE LOOP WILL TERMINATE AS FOLLOWS, A(1) WILL BE SWAPPED,
"       BUT NOT A(0), SO 'I' REACHING ZERO WILL BE CAUGHT IN THE
"       'NOSWAP' BRANCH.
"
BIG:    SUB MDEL,I                      "START IN THE CHECKING LOOP
        BGT CKBIG
DONBIG: RETURN
"
"
"SUBSCRIPT CHECKING LOOP, COMPARE THE SUBSCRIPT AGAINST
"ITSELF BIT-REVERSED - SWAP COMPLEX ELEMENTS ONLY IF BIT-
"REVERSED VALUE IS LOWER.  I.E. SWAP THE PAIR THE SECOND TIME
"WE PASS IT ON OUR WAY DOWN FROM THE TOP OF THE ARRAY.
CKBIG:  SUB# &I,I                       "TEST BITREV(I) AGAINST I
        MOVR &I,AT;                     "ADDRESS FOR &I
        BGE BIG
"
"WE COME HERE IF HW HAVE TO SWAP ELEMENTS:
"NOTE THAT I HAS BEEN DECREMENTED ONE ELEMENT BELOW THE PAIR
"THAT MUST BE SWAPPED.
        JSR SWAP
        SUB MDEL,I;                     "TO GET NEXT ADDRESS
        BR BIG+1                        "GO DO NEXT ONE
SWAP:   MOVR DI,CTI                     "COUNTER FOR SHIFT
        MOVR I,TI                       "BECAUSE SHLFT ALWAYS SHIFTS
SHLFT:  MOVL TI,TI                      "DO I = I*(MDEL/2)
        MOVR CTI,CTI                    "DECREMENT SHIFT COUNTER
        MOVL AT,AT;                     "DO &I = &I*(MDEL/2)
        BGT SHLFT
        ADD# TI,BASEP1;                 "FETCH RE(I)
        SETMA
        NOP
        INCMA                           "FETCH IM(I)
        FADD ZERO,MD                    "TEMP STORE FOR RE(I)
        ADD# AT,BASEP1; SETMA           "FETCH RE(&I)
        FADD ZERO,MD                    "TEMP STORE FOR IM(I)
        INCMA;                          "FETCH IM(&I)
        DPX<FA                          "SAVE RE(I)
        FADD ZERO,MD                    "SAVE RE(&I)
        DECMA; MI<DPX;                  "STORE NEW RE(&I)
        DPX<FA;                         "SAVE IM(I)
        FADD
        INCMA; MI<DPX;                  "STORE NEW IM(&I)
        FADD ZERO,MD;                   "TEMP STORE FOR NEW IM(I)
        DPX<FA                          "SAVE RE(&I)
        ADD# TI,BASEP1; SETMA;          "STORE NEW RE(I)
        MI<DPX; FADD
        INCMA; MI<FA; RETURN            "STORE NEW IM(I)
"
"
"
"ARRAY SMALLER THAN 256 ELEMENTS:
"BIT-REVERSE FIELD OF STATUS REGISTER SET TO 7-LOG2(TN)
SMALL:  LDSPI DT; DB=512.
        MOVL I,T                        "SHIFT I LEFT 8 PLACES TO GET T
        ADDL T,T                        "!!!
        ADDL T,T                        "!!!
        ADDL T,T                        "!!!
        MOVL T,T                        "!!!
        SUB MDEL,I                      "DECREMENT I
CKSML:  SUB DT,T;                       "DECREMENT T
        BGT .+2
        JMP DONBIG
        SUB# &T,I                       "COMPARE BITREV(T) AND I
        MOVR &T,AT;                     "BECAUSE SHLFT ALWAYS SHIFTS
        BGE .+2                         "BRANCH IF DON'T SWAP THIS ONE
"SWAP ELEMENTS:
        JSR SWAP
        SUB MDEL,I;                     "DECREMENT I TO NEXT ELEMENT
        BR CKSML
        $END
"****** PCFFT = PARTIAL  COMPLEX FFT /COMMON/ = REL 3.0, NOV 78 ****
"
        $TITLE PCFFT
        $RADIX 8
        $ENTRY PCFFT,4                          "USER-DIRECTED-CALL ENTRY
"
        $EXT FFT2,XFFT4,ADV2,ADV4
"
"
"
"
"                               --- ABSTRACT ---
"DOES A COMPLEX FFT EXCEPT BIT REVERSE,SET STATUS,CLEAR STATUS
"
"
"                               --- STATISTICS ---
"EQUIPMENT:                     AP-120B WITH EITHER MEMORY
"SIZE:          15 PS LOCATIONS
"
"         --- HISTORY ---
"ORIGINAL:      DEC 77 G. J. THROOP
" REVISED:      NOV 78 R.S. NORIN     LABEL !FFTX2 REPLACES TBLSZE*2
"                                       FOR APAL3 COMPATIBILITY
"
"
"
"                               --- USEAGE ---
"DOES A PARTIAL COMPLEX FFT, I.E., THE RADIX 2 AND RADIX 4 PASSES.
"
"S-PAD PARAMETERS:
"       NAME     NUMBER          PURPOSE
        C   $EQU 0              "BASE ADDRESS OF ARRAY
        N   $EQU 1              "# OF COMPLEX POINTS TO BE TRANSFORMED (>1)
        DI $EQU 2               "MEMORY INCREMENT
        F $EQU 3                "DIRECTIONS:  1 = FORWARD,  -1 = INVERSE
"
"
"                               --- SCRATCH (OVERALL) ---
"S-PAD:                         2-17
"DATA PAD X:                    -4 THROUGH +3 (RELATIVE TO DPA)
"DATA PAD Y:                    -4 THROUGH +3 (RELATIVE TO DPA)
"
"
"
"
"                               --- ALGORITHM ---
"
"PROCEDURE:
"
"       MEMORY INCREMENTS ARE ASSUMED TO BE A POWER OF 2.
"       FOR NORMAL CLOSE PACKED DATA WHICH IS IN SEQUENTIAL
"       ORDER RIRIRIRI, WHERE R IS THE REAL PART AND I IS
"       THE IMAGINARY PART OF A COMPLEX NUMBER, THE MEMORY
"       INCREMENT DI IS 2.  TO TAKE A FFT OF AN ARRAY
"       WHERE YOU WISH TO TAKE EVERY LTH COMPLEX PAIR OF
"       AN ARRAY, DI = 2*L.
"
"1.      PARAMETER INITIALIZE  SET THE FOUR 'PASS VARIABLES'
"                            WD = TBLSZE * 2
"                            MDEL = DI
"                            JCOUNT = 1
"                            ICOUNT = N/4  IF N A POWER OF 4
"                                   = N/2 IF N A POWER OF 2
"2.     DO THE FIRST PASS:   RADIX 2 (FFT2) IF N WAS A POWER OF 2
"                               AND ADVANCE (ADV2)
"                            RADIX 4 (FFT4) IF N WAS A POWER OF 4
"                               AND ADVANCE (ADV4)
"3.     DO THE REST OF THE RADIX 4 PASSES.
"                            CALL FFT4  (TO DO THE NEXT FFT PASS)
"                            CALL ADV4  (TO ADVANCE TO THE NEXT PASS)
"                            TEST ICOUNT (SPFN AFTER ADV4) FOR ZERO TO TEST
"
"
"OTHER S-PAD NAMES:
        WD     $EQU 14          "W DELTA
        MDEL   $EQU 15          "MEMORY DELTA
        ICOUNT $EQU 16          "I-LOOP COUNT
        JCOUNT $EQU 17          "J-LOOP COUNT
"
"
        FP $EQU 16              "PARAMETER FOR STSTAT (F)
        NP $EQU 17              "FOR STSTAT (TN)
        M  $EQU 17              "FROM STSTAT (M = LOG2(TN) )
        TN $EQU 3               "EXPANDED N = N*(DI/2)**2
"
"
"
"SIZE OF INSTALLED FFT TABLE
        TBLSZE $EQU !FFTSZ
"
"
"
"SET UP FOR THE FFT
"
"INITIALIZE POINTERS:
"
"JCOUNT<1
"WD<!FFTSZ*2
"MDEL<DI
"ICOUNT<N/4  IF 1ST PASS RADIX 4
"ICOUNT<N/2  IF 1ST PASS RADIX 2
"
PCFFT:  LDSPI WD; DB=!FFTX2     "SET WD=!FFTSZ*2   (11/78)
        MOV DI,MDEL             "PUT DI INTO MDEL
        "FOLLOWING IS PATCH BECAUSE BITREV CLOBBERS M
        MOVR 7,7                        "WAS LOG2(N) ODD?????
        BNC R2                  "IF SO, DO A RADIX 2 PASS FIRST
"
"SET UP FOR FIRST RADIX 4 PASS
R4:     MOVRR N,ICOUNT          "SET ICOUNT=N/4
        LDSPI JCOUNT; DB=1;     "SET COUNT=1
          BR LOOP
"
"DO A RADIX 2 PASS FIRST
R2:     MOVR N,ICOUNT           "SET ICOUNT=N/2
        JSR FFT2
        LDSPI JCOUNT; DB=1      "SET JCOUNT=1
        JSR ADV2                "RADIX 2 ADVANCE
        BEQ DONE                "SEE IF DONE
"
"
"LOOP HERE TO DO ALL THE PASES
LOOP:   JSR XFFT4               "DO A RADIX 4 PASS
        JSR ADV4                "RADIX 4 PASS ADVANCE
"
"DONE IF 'ADV' HAS SHIFTED ICOUNT TO ZERO
        BNE LOOP                "IF NOT DONE, GO BACK FOR MORE
"
DONE:   RETURN
        $END
"****** XFFT4 = EXPANDED RADIX FFT PASS /FAST/ = REL 2.2, SEP 78 ********
"
        $TITLE XFFT4
        $RADIX 8
        $ENTRY XFFT4                          "USER-DIRECTED-CALL ENTRY
"
"
"
"                               --- ABSTRACT ---
"DOES ONE RADIX 4 COMPLEX FFT PASS
"
"
"                               --- STATISTICS ---
"LANGUAGE:                      APAL
"EQUIPMENT:                     AP-120B WITH FAST (1 CYCLE) MEMORY
"PROGRAM SIZE:                  79 LOCATIONS
"AUTHOR:                        A.E. CHARLESWORTH
"DATE:                          JUNE 76
"REL 2.2                        CHANGES MINC FROM SP 13 TO SP 2
"                               G. J. THROOP, SEPT 78
"
"
"                               --- USEAGE ---
"
"DOES ONE RADIX 4 FFT PASS, AS DETERMINED BY:
"
"       S-PAD REG   NAME     PURPOSE
"
"       14          WD       W (TWIDDLE FACTOR) DELTA
"       15          MDEL     MEMORY DELTA
"       16          ICOUNT   NUMBER OF I-LOOPS IN THIS PASS
"       17          JCOUNT   NUMBER OF J-LOOPS IN THIS PASS
"
"
"SCRATCH:
"       S-PAD:  2 TO 12
"       DATA PAD X:  -4 TO +3 (RELATVE TO DPA)
"       DATA PAD Y:  -4 TO +3
"
"
"                               --- ALGORITHM ---
"
"PROGRAM FLOW:
"
"THE NAMES BELOW ARE ALL PROGRAM LABELS, THE TOP TO BOTTOM ORDER BELOW
"  REFLECTS THE TOP TO BOTTOM ORDER OF THE CODE
"
"   A   V   <   >   ARE ALL ARROWS
"
"                FFT4
"                  !
"   !<-------------!
"   !              V
"   !           ILOOP<-------!
"   !              !         A
"   !              V         !
"   !           ILOOP4<----------------!
"   !              !         !         A
"   !              !      IBACK        !
"   !              V         A       TOIL3
"   !    !<------ISKP        !         A
"   !    V         !         !         !
"   !  IFOR        V         !         !
"   !    !        INV        !         !
"   !    !         !         !         !
"   !    !-------->!         !         !
"   !              V         !         !
"   !            ICOM------->!         !
"   !              !                   !
"   !              V                 TOIL2
"   !---------->JLOOP<-------!         A
"                  !         A         !
"                  !         !         !
"                  !       JBACK       !
"                  V         A       TOIL1
"        !<------JSKP        !         A
"        V         !         !         !
"  !<--JFOR        V         !         !
"  !     !        JNV-->!    !         !
"  !     V         !    !    !         !
"  !     !-------->!    !    !         !
"  !               V    !    !         !
"  !             JCOM------->!         !
"  !               !    !              !
"  !               !------------------>!
"  V                    !
"FDONE                  V
"  !                  IDONE
"  !                    !
"  !-------------->!<---!
"                  !
"                  V
"               DONCOM
"                  !
"                  V
"               RETURN
"
"
"
"A RADIX 4 FFT PASS INVOLVES FETCHING, PROCESSING,
"       AND STORING ALL OF THE DATA POINTS, 4 COMPLEX POINTS AT A TIME.
"
"       TWO NESTED LOOPS ARE INVOLVED IN A PASS:
"          J-LOOP
"               I-LOOP
"
"          I-LOOP DOES THE 'BUTTERFLIES' ON QUADS OF POINTS, 'MDEL'
"          LOCATIONS APART IN MEMORY, STARTING AT THE START OF THE ARRAY
"          AND WORKING TOWARD THE END OF THE ARRAY.  A FIXED SET OF
"          TWIDDLE FACTORS (W, W**2, W**3) IS USED THROUGHOUT AN I-LOOP
"
"          J-LOOP RESETS THE I-LOOP TO THE TOP OF THE ARRAY AND ADVANCES
"          THE TWIDDLE FACTOR 'W' BY 'WD'
"
"          JCOUNT IS THE NUMBER OF J-LOOPS
"          ICOUNT IS THE NUMBER OF I-LOOPS
"
"
"
"THE RADIX 4 BUTTERFLY IS AS FOLLOWS:
"
"1.     FOUR COMPLEX POINTS:  A, C, B, D
"       ARE FETCHED IN THAT ORDER FROM MEMORY
"
"2.     THREE COMPLEX MULTIPLIES ARE DONE:
"       B = B * W
"       C = C * W**2
"       D = D * W**3
"
"
"3.     THEN THE FOLLOWING SET OF COMPLEX ADDS & SUBTRACTS ARE DONE
"       A' = A +  B + C +  D
"       B' = A -+JB - C +-JD
"       C' = A -  B + C -  D
"       D' = A +-JB - C -+JD
"
"           -+ MEANS - FOR FORWARD FFT, + FOR INVERSE FFT
"           +- MEANS + FOR FORWARD FFT, - FOR INVERSE FFT
"
"
"4.     A', B', C', D' ARE THEN STORED BACK INTO MEMORY
"
"
"TO MINIMIZE COMPLEX ADDS THE COMPUTATION IN THE BUTTERFLY IS
"       FACTORED AS FOLLOWS:
"
"
"       APC = A + C
"       AMC = A - C
"       BPD = B + D
"       JBMD - J * (B - D) = (DI-BI, BR-DR)
"
"       A' = APC + BPD
"       C' = APC - BPD
"
"DIRECT FFT:
"       B' = AMC - JBMD
"       D' = AMC + JBMD
"
"INVERSE FFT:
"       B' = AMC + JBMD
"       D' = AMC - JBMD
"
"
"THIS GIVES A TOTAL OF 22 REAL ADDS AND 12 REAL MULTIPLIES
"
"
"
"OUTLINE OF THE INNER LOOP COMPUTATION:
"
"       PASS #1 OF THE LOOP     PASS #2 OF THE LOOP
"       FOR A GIVEN QUAD        FOR A GIVEN QUAD
"
"1.     FETCH AR                AMCR=AR-CR
"                               SAVE APCR
"
"2.     FETCH AI                AMCI=AI-CI
"                               SAVE APCI
"
"3.     FETCH CR                BR=BRR-BII
"                               SAVE AMCR
"
"4.     FETCH W2R               BI=BRI+BIR
"       SAVE AR                 SAVE AMCI
"
"5.     FETCH CI                DR=DRR-DII
"       FETCH W2I               SAVE BR
"       SAVE AI
"
"6.     CRR=W2R*CR              DI=DRI+DIR
"                               SAVE BI
"
"7.     FETCH BR                BPDR=BR+DR
"       FETCH W2R               SAVE DR
"       CIR=W2I*CR
"
"8.     CII=W2I*CI              BPDI=BI+DI
"       FETCH W1R               SAVE DI
"
"9.     FETCH BI                JBMDR=DI-BI
"       CRI=W2R*CI              SAVE BPDR
"       FETCH W1I
"       SAVE CRR
"
"10.    BRR=W1R*BR              JBMDI=BR-DR
"       SAVE CIR                SAVE BPDI
"
"11.    FETCH DR                SAVE JBMDR
"       BIR=W1I*BR
"       CR=CRR-CII
"       FETCH W1R
"
"12.    BII=W1I*BI              SAVE JBMDI
"       CI=CRI+CIR
"       FETCH W3R
"
"13.    FETCH DI                AR'=APCR+BPDR
"       BRI=W1R*BI
"       FETCH W3I
"       SAVE BRR
"       SAVE CR
"
"14.    DRR=W3R*DR              AI'=APCI+BPDI
"       SAVE BIR
"       SAVE CI
"
"15.    DIR=W3I*DR              BR'=AMCR-+JBMDR
"       FETCH W3R               STORE AR
"       SAVE BII
"
"16.    DII=W3I*DI              BI'=AMCI-+JBMDI
"       SAVE BRI                STORE AI'
"
"17.    DRI=W3R*DI              CR'=APCR-BPDR
"       SAVE DRR                STORE BR'
"
"18.    SAVE DIR                CI'=APCI-BPDI
"                               STORE BI'
"
"19.    SAVE DII                DR'=AMCR+-JBDMR
"                               STORE CR'
"
"20.    SAVE DRI                DI'=AMCI+-JBMDI
"                               STORE CI'
"
"21.    APCR=AR+CR              STORE DR'
"
"22.    APCI=AI+CI              STORE DI'
"
"
"
"
"
"DATA PAD X NAMES:
        BPDR $EQU -4            "9 THROUGH 17    BR + DR
        DRR  $EQU -4            "17 THROUGH 5    W3R * DR
        BPDI $EQU -3            "10 THROUGH 18   BI + DI
        DIR  $EQU -3            "18 THROUGH 6    W3I * DR
        AMCR $EQU -2            "                 AR - CR
        AMCI $EQU -1            "                 AI - CI
        CR   $EQU  0            "                 C REAL
        CI   $EQU  1            "                 C IMAGINARY
        BBR  $EQU  2            "5 THROUGH 10     B REAL
        BII  $EQU  2            "15 THROUGH 3     W1I * BI
        BI   $EQU  3            "6 THROUGH 9      B IMAGINARY
        BRI  $EQU  3            "14 THROUGH 4     W1R * BI
"DATA PAD Y NAMES:
        APCR $EQU -4            "                 AR + CR
        APCI $EQU -3            "                 AI + CI
        JBMDR $EQU -2           "11 THROUGH 19    J * (BR - DR)
        DII  $EQU -2            "19 THROUGH 5     W3I * DI
        CRR  $EQU -2            "9 THROUGH 11     W2R * CR
        JBMDI $EQU -1           "12 THROUGH 20    J * (BI - DR)
        DRI  $EQU -1            "20 THROUGH 6     W3R * DI
        CIR  $EQU -1            "10 THROUGH 12    W2I * CR
        AR   $EQU  0            "                 A REAL
        AI   $EQU  1            "                 A IMAGINARY
        DR   $EQU  2            "7 THROUGH 10     D REAL
        BRR  $EQU  2            "13 THROUGH 3     W1R * BR
        DI   $EQU  3            "8 THROUGH 9      D IMAGINARY
        BIR  $EQU  3            "16 THROUGH 4     W1I * BR
"S-PAD NAMES:
"
"THESE ARE NOT ALTERED TROUGHOUT THE PASS
"   (THEY WERE INPUT TO THE MAIN ROUTINE)
        BASE   $EQU  0          "BASE ADDRESS OF ARRAY
        N      $EQU  1          "# OF COMPLEX POINTS (NOT USED HERE)
        MINC   $EQU  2          "MEMORY INCREMENT
"
"THESE ARE SCRATCH VARIABLES
        JBASE  $EQU  3          "BASE FOR EACH J-LOOP
        READ   $EQU  4          "READ POINTER
        WRITE  $EQU  5          "WRITE POINTER
        ICTR   $EQU  6          "I-LOOP COUNTER
        JCTR   $EQU  7          "J-LOOP COUNTER
        TEMP   $EQU 10          "TEMPORARY
        W1     $EQU 11          "W**1 POINTER
        W2     $EQU 12          "W**2 POINTER
        W3     $EQU 13          "W**3 POINTER
"
"
"THESE ARE VARIABLES WHICH DETERMINE WHICH PASS IT IS, THEY ARE
"  ALTERED BY THE MAIN PROGRAM
        WD     $EQU 14          "W DELTA
        MDEL   $EQU 15          "MEMORY DELTA
        ICOUNT $EQU 16          "I-LOOP COUNT
        JCOUNT $EQU 17          "J-LOOP COUNT
"INTRO TO ILOOP
"
"INITIALIZE POINTERS:
"
"JBASE<BASE
"READ<JBASE
"WRITE<JBASE-MDEL
"ICTR<ICOUNT
"JCTR<JCOUNT
"W1<0
"W2<0
"W3<0
"
"
"START COMPUTATION:
"
"FETCH AR,AI,CR,CI
"SET: BRR=BR, BRI=BI, DRR=DR, DRI=DI
"SET: BIR=0.0, BII=0.0, DIR=0.0, DII=0.0
"
"
XFFT4:  MOV BASE,JBASE                                  "SET JBASE
        MOV ICOUNT,ICTR                                 "SET ICTR
        MOV JBASE,READ; SETMA                           "FETCH AR
        INCMA;                                          "FETCH AI
           MOV JBASE,WRITE;
           DPX(BII)<ZERO;                               "BII=0.0
           DPY(BIR)<ZERO                                "BIR=0.0
        ADD MDEL,READ; SETMA;                           "FETCH CR
           DPX(DIR)<ZERO;                               "DIR=0.0
           DPY(DII)<ZERO                                "DII=0.0
        INCMA;                                          "FETCH CI
           DPY(AR)<MD;
           SUB MDEL,WRITE                               "SET WRITE
        ADD MDEL,READ; SETMA;                           "FETCH BR
           DPY(AI)<MD
        INCMA;                                          "FETCH BI
           DPX(CR)<MD;
           CLR W1                                       "CLEAR W1
        ADD MDEL,READ; SETMA;                           "FETCH DR
           DPX(CI)<MD
        INCMA;                                          "FETCH DI
           DPY(BRR)<MD;
           CLR W2                                       "CLEAR W2
        DPX(BRI)<MD;
           CLR W3                                       "CLEAR W3
        DPX(DRR)<MD;
           FADD DPY(AR),DPX(CR);                        "APCR=AR+CR
           DEC ICTR                                     "GO TO J-LOOP ???
        DPY(DRI)<MD;
           FADD DPY(AI),DPX(CI);                        "APCI=AI+CI
           MOV JCOUNT,JCTR;                             "SET JCTR
                                                        "TO I-LOOP
           BNE ILOOP                                    "IF NOT YET ZERO
"
"
"IF ICTR ALREADY ZERO, GO TO J-LOOP
        JMP JLOOP
"
"
"
ILOOP:  ADD MDEL,READ; SETMA;                           "1. FETCH AR
                                FSUB DPY(AR),DPX(CR);   "AMCR=AR-CR
                                DPY(APCR)<FA
        INCMA;                                          "2. FETCH AI
                                FSUB DPY(AI),DPX(CI);   "AMCI=AI-CI
                                DPY(APCI)<FA
        ADD MDEL,READ; SETMA;                           "3. FETCH CR
                                FSUB DPY(BRR),DPX(BII); "BR=BRR-BII
                                DPX(AMCR)<FA
ILOOP4: MOV W2,W2; SETTMA;                              "4. FETCH W2R
        DPY(AR)<MD;
                                FADD DPX(BRI),DPY(BIR); "BI=BRI+BIR
                                DPX(AMCI)<FA
        INCMA;                                          "5. FETCH CI
        INCTMA;                                         "FETCH W2I
        DPY(AI)<MD;
                                FSUB DPX(DRR),DPY(DII); "DR=DRR-DII
                                DPX(BBR)<FA
        FMUL TM,MD;                                     "6. W2R*CR
                                FADD DPY(DRI),DPX(DIR); "DI=DRI+DIR
                                DPX(BI)<FA
        ADD MDEL,READ; SETMA;                           "7. FETCH BR
        DECTMA;                                         "FETCH W2R
        FMUL TM,MD;                                     "CIR=W2I*CR
                                FADD DPX(BBR),FA;       "BPDR=BR+DR
                                DPY(DR)<FA
        MOV W1,W1; SETTMA;                              "8. FETCH W1R
        FMUL TM,MD;                                     "CII=W2I*CI
                                FADD DPX(BI),FA;        "BPDI=BI+DI
                                DPY(DI)<FA
        INCMA;                                          "9. FETCH BI
        INCTMA;                                         "FETCH W1I
        FMUL TM,MD;                                     "CRI=W2R*CI
        DPY(CRR)<FM;
                                FSUB DPY(DI),DPX(BI);   "JBMDR=DI-BI
                                DPX(BPDR)<FA
        FMUL TM,MD;                                     "10. BRR=W1R*BR
        DPY(CIR)<FM;
                                FSUB DPX(BBR),DPY(DR);  "JBMDI=BR-DR
                                DPX(BPDI)<FA
        ADD MDEL,READ; SETMA;                           "11. FETCH DR
        DECTMA;                                         "FETCH W1R
        FMUL TM,MD;                                     "BIR=W1I*BR
        FSUBR FM,DPY(CRR);                              "CR=CRR-CII
                                DPY(JBMDR)<FA
        MOV W3,W3; SETTMA;                              "12. FETCH W3R
        FMUL TM,MD;                                     "BII=W1I*BI
        FADD FM,DPY(CIR);                               "CI=CRI+CIR
                                DPY(JBMDI)<FA
        INCMA;                                          "13. FETCH DI
        INCTMA;                                         "FETCH W3I
        FMUL TM,MD;                                     "BRI=W1R*BI
        DPY(BRR)<FM;
        DPX(CR)<FA;
                                FADD DPY(APCR),DPX(BPDR);"AR'=APCR+BPDR
                                BR ISKP                 "SKIP AROUND
"
"
"
"...................................................................
"THIS INSTRUCTION IS ACTUALLY THE LAST
"INSTRUCTION OF ILOOP, IT IS INSERTED HERE SO THAT THE LOOP CAN
"BE CLOSED WITH 'BRANCH' OP-CODES, WHICH HAVE A MAXIMUM
"RANGE OF -16 TO + 15
"
IBACK:  FADD DPY(AI),DPX(CI);                           "22. APCI=AI+CI
                                INCMA; MI<FA;           "STORE DI'
                                BR ILOOP                "LOOP AGAIN
"
"
"HERE IS TOIL3 ON THE WAY TO ILOOP AT ILOOP4
"
TOIL3:  ADD MDEL,READ; SETMA;                           "3. FETCH CR
                                FSUB DPY(BRR),DPX(BII); "BR=BRR-BII
                                DPX(AMCR)<FA;
                                BR ILOOP4
"
".......................................................................
"
"
"
"
ISKP:   FMUL TM,MD;                                     "14. DRR=W3R*DR
        DPY(BIR)<FM;
        DPX(CI)<FA;
                                FADD DPY(APCI),DPX(BPDI);"AI'=APCI+BPDI
                                BIFN INV                "INVERSE FFT???
"
"FORWARD FFT, COMPUTE B', C', AND D'
IFOR:   DECTMA;                                         "15. FETCH W3R
        FMUL TM,MD;                                     "DIR=W3I*DR
        DPX(BII)<FM;
                                FSUB DPX(AMCR),DPY(JBMDR); "BR'=AMCR-JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE AR'
        FMUL TM,MD;                                     "16. DII=W3I*DI
        DPX(BRI)<FM;
                                FSUB DPX(AMCI),DPY(JBMDI); "BI'=AMCI-JBMDI
                                INCMA; MI<FA            "STORE AI'
        FMUL TM,MD;                                     "17. DRI=W3R*DI
        DPX(DRR)<FM;
                                FSUB DPY(APCR),DPX(BPDR); "CR'=APCR-BPDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE BR'
        DPX(DIR)<FM;                                    "18.
        FMUL;                                           "PUSH
                                FSUB DPY(APCI),DPX(BPDI); "CI'=APCI-BPDI
                                INCMA; MI<FA            "STORE BI'
        DPY(DII)<FM;                                    "19.
        FMUL;                                           "PUSH
                                FADD DPX(AMCR),DPY(JBMDR); "DR'=AMCR+JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE CR
        DPY(DRI)<FM;                                    "20.
                                FADD DPX(AMCI),DPY(JBMDI); "DI'=AMCI+JBMDI
                                INCMA; MI<FA;           "STORE CI'
                                DEC ICTR;               "ILOOP DONE???
                                BR ICOM                 "BACK TOGETHER
"
"
"INVERSE FFT: COMPUTE B',C', AND D'
INV:    DECTMA;                                         "15. FETCH W3R
        FMUL TM,MD;                                     "DIR=W3I*DR
        DPX(BII)<FM;
                                FADD DPX(AMCR),DPY(JBMDR); "BR'=AMCR+JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE AR'
        FMUL TM,MD;                                     "16. DII=W3I*DI
        DPX(BRI)<FM;
                                FADD DPX(AMCI),DPY(JBMDI); "BI'=AMCI+JBMDI
                                INCMA; MI<FA            "STORE AI'
        FMUL TM,MD;                                     "17. DRI=W3R*DI
        DPX(DRR)<FM;
                                FSUB DPY(APCR),DPX(BPDR); "CR'=APCR-BPDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE BR'
        DPX(DIR)<FM;                                    "18.
        FMUL;                                           "PUSH
                                FSUB DPY(APCI),DPX(BPDI); "CI'=APCI-BPDI
                                INCMA; MI<FA            "STORE BI'
        DPY(DII)<FM;                                    "19.
        FMUL;                                           "PUSH
                                FSUB DPX(AMCR),DPY(JBMDR); "DR'=AMCR-JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE CR
        DPY(DRI)<FM;                                    "20.
                                FSUB DPX(AMCI),DPY(JBMDI); "DI'=AMCI-JBMDI
                                INCMA; MI<FA;           "STORE CI'
                                DEC ICTR                "ILOOP DONE ???
"
"
"BACK TOGETHER AGAIN
ICOM:   FADD DPY(AR),DPX(CR);                           "21. APCR=AR+CR
                                ADD MDEL,WRITE; SETMA; MI<FA;"STORE DR'
                                BNE IBACK               "BRANCH IF NOT DONE
"
"
"
"COME HERE WHEN DONE WITH ILOOP,
"       DO #22 AND THEN FALL INTO JLOOP
"
        FADD DPY(AI),DPX(CI);                           "22. APCI=AI+CI
                                INCMA; MI<FA;           "STORE DI'
                                BR JLOOP
"
"
"
"................................................................
"
"HERE IS TOIL2 ON THE WAY BACK TO ILOOP
"
TOIL2:  INCMA;                                          "2. FETCH AI
                                FSUB DPY(AI),DPX(CI);   "AMCI=AI-CI
                                DPY(APCI)<FA;
                                BR TOIL3
"
"...................................................................
"
"
"
"
"RESETING OF POINTERS FOR J-LOOP
"
"JBASE<JBASE+2
"READ<JBASE
"W1<W1+WD
"W2<W1*2
"W3<W1*3
"ICTR<ICOUNT
"
"
"WRITE<JBASE-MDEL
"
JLOOP:  ADD MINC,JBASE;  SETMA;                         "1. FETCH AR
                                                        "ADVANCE JBASE
                                FSUB DPY(AR),DPX(CR);   "AMCR=AR-CR
                                DPY(APCR)<FA
        INCMA;                                          "2. FETCH AI
        ADD WD,W1;                                      "ADVANCE W1
                                FSUB DPY(AI),DPX(CI);   "AMCI=AI-CI
                                DPY(APCI)<FA
        ADD MDEL,JBASE; SETMA;                          "3. FETCH CR
                                                        "ADVANCE JBASE ONE
                                                        "STEP TOO FAR
                                FSUB DPY(BRR),DPX(BII); "BR=BRR-BII
                                DPX(AMCR)<FA
        MOVL W1,W2; SETTMA;                             "4. FETCH W2R
                                                        "W2=W1*2
        DPY(AR)<MD;
                                FADD DPX(BRI),DPY(BIR); "BI=BRI+BIR
                                DPX(AMCI)<FA
        INCMA;                                          "5. FETCH CI
        MOV JBASE,READ;                                 "SET READ=JBASE
        INCTMA;                                         "FETCH W2I
        DPY(AI)<MD;
                                FSUB DPX(DRR),DPY(DII); "DR=DRR-DII
                                DPX(BBR)<FA
        FMUL TM,MD;                                     "6. W2R*CR
        SUB MDEL,JBASE;                                 "RESET JBASE
                                FADD DPY(DRI),DPX(DIR); "DI=DRI+DIR
                                DPX(BI)<FA
        ADD MDEL,READ; SETMA;                           "7. FETCH BR
        DECTMA;                                         "FETCH W2R
        FMUL TM,MD;                                     "CIR=W2I*CR
                                FADD DPX(BBR),FA;       "BPDR=BR+DR
                                DPY(DR)<FA
        MOV W1,W1; SETTMA;                              "8. FETCH W1R
        FMUL TM,MD;                                     "CII=W2I*CI
                                FADD DPX(BI),FA;        "BPDI=BI+DI
                                DPY(DI)<FA
        INCMA;                                          "9. FETCH BI
        MOV JBASE,TEMP;                                 "TO SETUP WRITE
        INCTMA;                                         "FETCH W1I
        FMUL TM,MD;                                     "CRI=W2R*CI
        DPY(CRR)<FM;
                                FSUB DPY(DI),DPX(BI);   "JBMDR=DI-BI
                                DPX(BPDR)<FA
        FMUL TM,MD;                                     "10. BRR=W1R*BR
        MOV W2,W3;                                      "TO SETUP W3
                                                        "TO W1+W2
        DPY(CIR)<FM;
                                FSUB DPX(BBR),DPY(DR);  "JBMDI=BR-DR
                                DPX(BPDI)<FA
        ADD MDEL,READ; SETMA;                           "11. FETCH DR
        DECTMA;                                         "FETCH W1R
        FMUL TM,MD;                                     "BIR=W1I*BR
        FSUBR FM,DPY(CRR);                              "CR=CRR-CII
                                DPY(JBMDR)<FA
        ADD W1,W3; SETTMA;                              "12. FETCH W3R
                                                        "W3=W1*3
        FMUL TM,MD;                                     "BII=W1I*BI
        FADD FM,DPY(CIR);                               "CI=CRI+CIR
                                DPY(JBMDI)<FA
        INCMA;                                          "13. FETCH DI
        SUB MDEL,TEMP;                                  "SETUP WRITE
        INCTMA;                                         "FETCH W3I
        FMUL TM,MD;                                     "BRI=W1R*BI
        DPY(BRR)<FM;
        DPX(CR)<FA;
                                FADD DPY(APCR),DPX(BPDR);"AR'=APCR+BPDR
                                BR JSKP                 "SKIP AROUND
"
"
"
"...................................................................
"THIS INSTRUCTION IS ACTUALLY THE LAST
"INSTRUCTION OF JLOOP, IT IS INSERTED HERE SO THAT THE LOOP CAN
"BE CLOSED WITH 'BRANCH' OP-CODES, WHICH HAVE A MAXIMUM
"RANGE OF -16 TO + 15
"
JBACK:  FADD DPY(AI),DPX(CI);                           "22. APCI=AI+CI
        MOV TEMP,WRITE;                                 "WRITE=JBACK-MDEL
                                INCMA; MI<FA;           "STORE DI'
                                BR JLOOP                "LOOP AGAIN
"
"
"HERE IS TOIL1 ON THE WAY BACK TO ILOOP
"
TOIL1:  ADD MDEL,READ; SETMA;                           "1. FETCH AR
                                FSUB DPY(AR),DPX(CR);   "AMCR=AR-CR
                                DPY(APCR)<FA;
                                BR TOIL2
"
".......................................................................
"
"
"
"
JSKP:   FMUL TM,MD;                                     "14. DRR=W3R*DR
        DPY(BIR)<FM;
        DPX(CI)<FA;
                                FADD DPY(APCI),DPX(BPDI);"AI'=APCI+BPDI
                                BIFN JNV                "INVERSE FFT???
"
"FORWARD FFT, COMPUTE B', C', AND D'
JFOR:   DECTMA;                                         "15. FETCH W3R
        FMUL TM,MD;                                     "DIR=W3I*DR
        DPX(BII)<FM;
                                FSUB DPX(AMCR),DPY(JBMDR); "BR'=AMCR-JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE AR'
        FMUL TM,MD;                                     "16. DII=W3I*DI
        MOV ICOUNT,ICTR;                                "RESET ICTR=ICOUNT
        DPX(BRI)<FM;
                                FSUB DPX(AMCI),DPY(JBMDI); "BI'=AMCI-JBMDI
                                INCMA; MI<FA            "STORE AI'
        FMUL TM,MD;                                     "17. DRI=W3R*DI
        DPX(DRR)<FM;
                                FSUB DPY(APCR),DPX(BPDR); "CR'=APCR-BPDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE BR'
        DPX(DIR)<FM;                                    "18.
        FMUL;                                           "PUSH
                                FSUB DPY(APCI),DPX(BPDI); "CI'=APCI-BPDI
                                INCMA; MI<FA;           "STORE BI'
                                DEC JCTR                "JLOOP DONE ???
        DPY(DII)<FM;                                    "19.
        FMUL;                                           "PUSH
                                FADD DPX(AMCR),DPY(JBMDR); "DR'=AMCR+JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA;"STORE CR
                                BEQ FDONE               "BRANCH IF JLOOP DONE
        DPY(DRI)<FM;                                    "20.
                                FADD DPX(AMCI),DPY(JBMDI); "DI'=AMCI+JBMDI
                                INCMA; MI<FA;           "STORE CI'
                                DEC ICTR;               "ILOOP DONE???
                                BR JCOM                 "BACK TOGETHER
"
"
"INVERSE FFT: COMPUTE B',C', AND D'
JNV:    DECTMA;                                         "15. FETCH W3R
        FMUL TM,MD;                                     "DIR=W3I*DR
        DPX(BII)<FM;
                                FADD DPX(AMCR),DPY(JBMDR); "BR'=AMCR+JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE AR'
        FMUL TM,MD;                                     "16. DII=W3I*DI
        MOV ICOUNT,ICTR;                                "RESET ICTR=ICOUNT
        DPX(BRI)<FM;
                                FADD DPX(AMCI),DPY(JBMDI); "BI'=AMCI+JBMDI
                                INCMA; MI<FA            "STORE AI'
        FMUL TM,MD;                                     "17. DRI=W3R*DI
        DPX(DRR)<FM;
                                FSUB DPY(APCR),DPX(BPDR); "CR'=APCR-BPDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE BR'
        DPX(DIR)<FM;                                    "18.
        FMUL;                                           "PUSH
                                FSUB DPY(APCI),DPX(BPDI); "CI'=APCI-BPDI
                                INCMA; MI<FA;           "STORE BI'
                                DEC JCTR                "JLOOP DONE ???
        DPY(DII)<FM;                                    "19.
        FMUL;                                           "PUSH
                                FSUB DPX(AMCR),DPY(JBMDR); "DR'=AMCR-JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA;"STORE CR
                                BEQ IDONE               "BRANCH IF JLOOP DONE
        DPY(DRI)<FM;                                    "20.
                                FSUB DPX(AMCI),DPY(JBMDI); "DI'=AMCI-JBMDI
                                INCMA; MI<FA;           "STORE CI'
                                DEC ICTR                "ILOOP DONE ???
"
"
"BACK TOGETHER AGAIN
JCOM:   FADD DPY(AR),DPX(CR);                           "21. APCR=AR+CR
                                ADD MDEL,WRITE; SETMA; MI<FA;"STORE DR'
                                BEQ JBACK               "BRANCH IF WE MUST
                                                        "STAY IN JLOOP
"
"
"COME HERE IF WE MUST LOOP BACK TO ILOOP . . . WHICH WE DO
"       IN THREE STEPS
"
        FADD DPY(AI),DPX(CI);                           "22. APCI=AI+CI
        MOV TEMP,WRITE;                                 "WRITE=JBASE-MDEL
                                INCMA; MI<FA;           "STORE DI'
                                BR TOIL1
"
"
"
"COME HERE WHEN DONE WITH A FORWARD FFT PASS
"
FDONE:                          FADD DPX(AMCI),DPY(JBMDI); "20. DI'=AMCI+JBMDI
                                INCMA; MI<FA;            "STORE CI'
                                BR DONCOM
"
"
"COME HERE WHEN DONE WITH AN INVERSE FFT PASS
"
IDONE:                          FSUB DPX(AMCI),DPY(JBMDI); "20. DI'=AMCI-JBMDI
                                INCMA; MI<FA            "STORE CI'
"
"
"COMMON WHEN DONE WITH A PASS
DONCOM:                         FADD;                   "21. PUSH
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE DR'
                                INCMA; MI<FA;           "22. STORE DI'
                                RETURN
        $END
"****** XREALT = EXPANDED REAL FFT PASS /FAST/ = REL 3.0, NOV 78 *****
"
        $TITLE XREALT
        $RADIX 8
        $ENTRY XREALT                          "USER-DIRECTED-CALL ENTRY
        $EXT STSTAT,CLSTAT
"                  --- ABSTRACT ---
"EXPANDED REAL FFT UNRAVEL AND FINAL PASS
"USED AFTER A DIRECT FFT, OR BEFORE AN INVERSE FFT
"WHEN TRANSFORMING REAL DATA
"
"                  --- STATISTICS ---
"LANGUAGE:    APAL
"EQUIPMENT:   AP-120B WITH FAST (1 CYCLE) MEMORY)
"SIZE:       49 LOCATIONS + STATUS (19) = 68
"SPEED:      .42 US. PER REAL POINT
"SUBROUTINES USED:     STSTAT,CLSTAT
"
"     ---HISTORY---
"ORIGINAL:  FEB 77, A.E. CHARLESWORTH
" REV 2.1:  JUL 77, R.S. NORIN          JMP CLSTAT REPLACES  JSR CLSTAT, NOP, RE
" REV 2.2:      SEPT 78, G. J. THROOP
"               CHANGES S-PAD USEAGE TO CONFORM WITH XCFFT AND XRFFT
" REVISED:  NOV 78, R.S. NORIN          LABEL !FFTX4 REPLACES TBLSZE*4
"                                         FOR APAL3 COMPATIBILITY
"
"
"
"                  --- USEAGE ---
"S-PAD PARAMETERS:
"       NAME          NUMBER            PURPOSE
        A      $EQU   0                 "BASE ADDRESS OF INPUT ARRAY
        C      $EQU   0                 "BASE ADDRESS OF OUTPUT ARRAY
        N      $EQU   1                 "NUMBER OF REAL POINTS
        MDEL   $EQU   2                 "MEMORY SPACING
        F      $EQU   3                 "+1 FOR DIRECT, -1 FOR INVERSE
"THE INPUT/OUTPUT AND USEAGE DEPENDS UPON WHETHER WE ARE GOING
"       DIRECT OR INVERSE WITH THE TRANSFORM
"
"DIRECT......
"
"INPUT:          N REAL TIME DOMAIN POINTS
"OUTPUT:     N+1 COSINE AND N-1 SINE FREQUENCY COEFFICIENTS
"                  THE FIRST AND THE NTH SINE COEFFICIENTS(IMAG PARTS)
"                  ARE ALWAYS ZERO, SO THE NTH COSINE COEFFICIENT IS
"                  STORED IN THE IMAGINARY PART OF THE FIRST LOCATION
"
"INVERSE......
"
"INPUT:         N+1 COSINE AND N-1 SINE FREQUENCY COEFFICIENTS
"                  STORED AS EXPLAINED ABOVE
"OUTPUT:         N REAL TIME DOMAIN POINTS
"
"USEAGE:
"
"DIRECT:        DO AN N/2 POINT COMPLEX DIRECT TRANSFORM
"               THEN CALL THIS SUBROUTINE
"INVERSE:       CALL THIS SUBROUTINE
"               THEN DO AN N/2 POINT INVERSE COMPLEX TRANSFORM
"
"                  --- SCRATCH ---
"S-PAD:  10-17 (OCTAL)
"DPX:   -4 TO +2   (RELATIVE TO DPA)
"DPY:   -4 TO +1    (RELATIVE TO DPA)
"                  --- ALGORITHM ---
"
"WE TAKE PAIRS OF POINTS, TREATING
"       THEM AS COMPLEX PAIRS
"ONE PAIR FROM THE FRONT OF THE ARRAY, AND ONE PAIR FROM
"       THE BACK, WORKING TOWARD THE MIDDLE
"
"THE COMPUTATION IS:
"       APCR=AR+CR
"       AMCR=AR-CR
"       APCI=AI+CI
"       AMCI=AI-CI
"
"       RE=WR*APCI+WI*AMCR
"       IM=WI*APCI-WR*AMCR
"
"       CR'=APCR-RE
"       CI'=IM-AMCI
"       AR'=APCR+RE
"       AI'=IM+AMCI
"WHERE: (AR,AI) ARE FROM THE FRONT OF THE ARRAY
"     (CR,CI) ARE FROM THE BACK OF THE ARRAY
"
"(WR,WI) ARE A COMPLEX EXPONENTIAL:
"       WR=COS(THETA)
"       WI=SIN(THETA)
"
"IF DIRECT, THETA GOES FROM 0 TO -PI/2
"IF INVERSE, THETA GOES FROM PI TO PI/2
"THETA INCREMENTS BY PI*2.0/N
"
"THE COMPUTATION INVOLVING THE FIRST AND LAST PAIR IS A SPECIAL CASE
"        SINCE A AND C ARE THE SAME AND HAVE SPECIAL MEANINGS:
"DIRECT:
"       AR' = 2(AR+AI),   AI' = 0
"       CR' = 2(AR-AI),   CI' = 0
"BUT, CR' IS STORED INTO AI', SO:
"       AR' = 2(AR+AI),  AI' = 2(AR-AI)
"INVERSE:
"       AR' = AR+CR,     AI' = AR-CR
"BUT, CR WAS PUT INTO AI, SO:
"       AR' = AR+AI,   AI' = AR-AI
"SIZE OF FFT COSINE TABLE
        TBLSZE $EQU !FFTSZ
"
"LOCATION IN TM OF 1.0 AND 2.0
        ONEADR $EQU !ONE
        TWOADR $EQU !TWO
"
"
"
"DATA PAD X NAMES:
        AR $EQU -4      "A REAL
        AI $EQU -3      "A IMAGINARY
        RE $EQU -2      "WR*APCI - WI*AMCR
        IM $EQU -1      "WI*APCI - WR*AMCR
        AMCR $EQU 0     "AR - CR
        APCI $EQU 1     "AI + CI
        TR $EQU 2       "TEMP REAL
"
"DATA PAD Y NAMES
        CR $EQU -4      "C REAL
        CI $EQU -3      "C IMAGINARY
        APCR $EQU -2    "AR + CR
        AMCI $EQU -1    "AI - CI
        RR $EQU 0       "WR*APCR
        RI $EQU 1       "WR*AMCI
"
"
"S-PAD NAMES:  (NOT PARAMETERS)
        W $EQU 10       "W POINTER
        WD $EQU 11      "W DELTA
        XN      $EQU  12          "TOP OF ARRAY = N*MDEL/2
        ICTR $EQU 13    "LOOP COUNTER
        AREAD $EQU 14   "A READ POINTER
        CREAD $EQU 15   "C READ POINTER
        AWRITE $EQU 16  "A WRITE POINTER
        CWRITE $EQU 17  "C WRITE POINTER
"
"
"
"       TAB-STOPS: 9 25 41 57
"
"
"INTRO ...
"
"INITIALIZATION OF PARAMETERS
"       AREAD<A
"       AWRITE<C
"       CREAD<A+N-MDEL
"       CWRITE<C+N-MDEL
"       W<0          DIRECT
"       W<TBLSZE*4   INVERSE
"       WD<TBLSZE*4
"ICTR<N/4
"FIRST SET UP DEPENDING ON FORWARD OR INVERSE FFT
XREALT: MOV F,16                                        "TEST DIRECTION
        LDSPI WD; DB=!FFTX4;                            "SET W DELTA  (11/78)
           BGT DIRECT                                   "FORWARD OR INVERSE???
"
"INVERSE REAL PASS:
"SET INITIAL ANGLE TO PI
INVERSE:LDTMA; DB=ONEADR;                               "GET A 1.0
           MOV WD,W;                                    "SET TO PI
           BR COMMON
"
"FORWARD REAL PASS:
"SET INITIAL ANGLE TO 0
DIRECT: LDTMA; DB=TWOADR;                               "GET 2.0
           CLR W                                        "SET TO ZERO
"
"COMMON AGAIN
"SET FFT MODE BITS IN AP-STATUS REGISTER,
"   AND GET LOG2(N/2) IN S-PAD 17
COMMON: MOVR N,XN
        MOVR MDEL,17
UP:     DEC 17
        MOVL XN,XN; BGT UP
        "XN NOW EQUALS N*MDEL/2
        MOVR N,17;                                      "N/2 COMPLEX PTS
           DPX(TR)<TM                                   "SAVE 1.0 OR 2.0
        JSR STSTAT                                      "SET FFT STATUS
"
"NOW COMPUTE WD/N, DO THIS BY SHIFTING
"   WD RIGHT THE NUMBER OF TIMES IN S-PAD 17
DIVL:   DEC 17                                          "COUNT
        MOVR WD,WD;                                     "SHIFT WD
        BNE DIVL                                        "GO BACK
"
"
"NOW START ON THE FIRST COMPUTATION...........
"
"A SPECIAL CASE:  AR'(0)=TR * (AR(0) + AI(0))
"                 AI'(0)=TR * (AR(0) - AI(0))
"WHERE TR IS 2.0 FOR DIRECT, OR 1.0 FOR INVERSE
"
"
        MOV A,AREAD; SETMA                              "1. FETCH AR(0)
        INCMA;                                          "2. FETCH AI(0)
           MOV A,CREAD
        ADD XN,CREAD                                    "3. SET CREAD=C+N
        DPX(AR)<MD;                                     "4
           MOV C,CWRITE
        FADD DPX(AR),MD;                                "5. AR(0)+AI(0)
           DPY(CR)<MD;
           ADD XN,CWRITE                                "   SET CWRITE=A+N
        FSUB DPX(AR),DPY(CR);                           "6. AR(0)-AI(0)
           MOVRR N,ICTR                                 "   SET COUNTER
        FMUL DPX(TR),FA; FADD                           "7.TR * (AR+CR)
        FMUL DPX(TR),FA                                 "8. TR * (AR-CR)
        FMUL                                            "9.
        MI<FM; FMUL;                                    "10. STORE AR(0)
           MOV C,AWRITE; SETMA
        MI<FM; INCMA                                    "11. STORE AI(0)
"
"
"
"THE 1ST PASS......
"
        ADD MDEL,AREAD; SETMA                           "1. FETCH AR
        INCMA                                           "2. FETCH AI
        SUB MDEL,CREAD; SETMA                           "5. FETCH CR
        INCMA; DPX(AR)<MD                               "6. FETCH CI
        DPX(AI)<MD                                      "7.
        FSUB DPX(AR),MD;                                "8. AMCR=AR-CR
        ADD WD,W; SETTMA;                               "FETCH WR
        DPY(CR)<MD
        FADD DPX(AI),MD;                                "9. APCI=AI+CI
        DPY(CI)<MD
        FMUL TM,FA;                                     "10. RR=WR*AMCR
        INCTMA;                                         "FETCH WI
        DPX(AMCR)<FA;
        FADD
"
"
"
"THE 2ND PASS ...........
"
        ADD MDEL,AREAD;                                 "1. FETCH AR
        SETMA;
                        FMUL TM,FA;                     "RI=WR*APCI
                        DPX(APCI)<FA
        INCMA;                                          "2. FETCH AI
                        FMUL TM,DPX(AMCR)               "IR=WI*AMCR
                        FADD DPX(AR),DPY(CR);           "3. APCR=AR+CR
                        FMUL;
                        DPY(RR)<FM
        DPX(AR)<MD;                                     "4.
                        FSUB DPX(AI),DPY(CI);           "AMCI=AI-CI
                        FMUL;
                        DPY(RI)<FM
        SUB MDEL,CREAD;                                 "5. FETCH CR
        SETMA;
        DPX(AI)<MD;
                        DPY(APCR)<FA;
                        FADD
        INCMA;                                          "6. FETCH CI
                        DPY(AMCI)<FA
                        FADD FM,DPY(RI);                "7. RE=RI+IR
                        FMUL TM,DPX(APCI)               "II=WI*APCI
        FSUB DPX(AR),MD;                                "8. AMCR=AR-CR
        ADD WD,W; SETTMA;                               "FETCH WR
        DPY(CR)<MD;
                        FMUL
        FADD DPX(AI),MD;                                "9. APCI=AI+CI
        DPY(CI)<MD;
                        DPX(RE)<FA;
                        FMUL
        FMUL TM,FA;                                     "10. RR=WR*AMCR
        INCTMA;                                         "FETCH WI
        DPX(AMCR)<FA;
                        FSUB FM,DPY(RR)                 "IM=II-RR
"
"
" AND FINALLY, THE LOOP .........
"
LOOP:   ADD MDEL,AREAD;                                 "1. FETCH AR
        SETMA;
                        FMUL TM,FA;                     "RI=WR*APCI
                        DPX(APCI)<FA;
                                                         "CR'=APCR-RE
                                        FSUB DPY(APCR),DPX(RE)
        INCMA;                                          "2. FETCH AI
                        FMUL TM,DPX(AMCR);              "IR=WI*AMCR
                                        FSUBR DPY(AMCI),FA; "CI'=IM-AMCI
                                        DPX(IM)<FA
                        FADD DPX(AR),DPY(CR);           "3. APCR=AR+CR
                        FMUL;
                        DPY(RR)<FM;
                                        MI<FA;          "STORE CR'
                                        SUB MDEL,CWRITE;
                                        SETMA
        DPX(AR)<MD;                                     "4.
                        FSUB DPX(AI),DPY(CI);           "AMCI=AI-CI
                        FMUL;
                        DPY(RI)<FM;
                                        MI<FA; INCMA    "STORE CI'
        SUB MDEL,CREAD;                                 "5. FETCH CR
        SETMA;
        DPX(AI)<MD;
                        DPY(APCR)<FA;
                                                        "AR'=APCR+RE
                                        FADD DPY(APCR),DPX(RE)
        INCMA;                                          "6. FETCH CI
                        DPY(AMCI)<FA;
                                                        "AI'=IM+AMCI
                                        FADD DPX(IM),DPY(AMCI)
                        FADD FM,DPY(RI);                "7. RE=RI+IR
                        FMUL TM,DPX(APCI);              "II=WI*APCI
                                        MI<FA;          "STORE AR'
                                        ADD MDEL,AWRITE;
                                        SETMA
        FSUB DPX(AR),MD;                                "8. AMCR=AR-CR
        ADD WD,W; SETTMA;                               "FETCH WR
        DPY(CR)<MD;
                        FMUL;
                                        MI<FA; INCMA    "STORE AI'
        FADD DPX(AI),MD;                                "9. APCI=AI+CI
        DPY(CI)<MD;
                        DPX(RE)<FA;
                        FMUL;
                                        DEC ICTR        "DONE ????
        FMUL TM,FA;                                     "10. RR=WR*AMCR
        INCTMA;                                         "FETCH WI
        DPX(AMCR)<FA;
                        FSUB FM,DPY(RR);                "IM=II-RR
                                        BNE LOOP        "GO BACK
"
"
"DONE, CLEAR FFT STATUS BITS AND RETURN
        JMP CLSTAT                          "EXIT THRU CLSTAT
        $END
"****** RTOC = REAL TO COMPLEX SCRAMBLE / COMMON / = REL 2.3, MAR 80 ***
        $TITLE RTOC
        $RADIX 8
        $ENTRY RTOC,4                          "USER-DIRECTED-CALL ENTRY
        $EXT SPMUL
"
"
"              --- ABSTRACT ---
"
"
        "THIS PROGRAM SCRAMBLES THE RESULT OF TWO REAL FFT
        "INTO THE FORMAT OF A COMPLEX FFT.
        "IF X1 AND X2 ARE REAL SEQUENCES, THEN CONSIDER A
        "COMPLEX SEQUENCE X = X1 * I*X2, WHERE I =
        "SQUARE ROOT(-1).  THEN THE FOURIER TRANSFORM OF
        "X IS A = A1 + I*A2.  THE TRANSFORMS OF THE REAL
        "SEQUENCES SCRAMBLE INTO THE COMPLEX SEQUENCE BY
        "               A1(M) = 0.5*(CC(A(N-M)) + A(M))
        "               A2(M) = 0.5*I*(CC(A(N-M)) - A(M))
        "WHERE CC(A(M)) = COMPLEX CONJUGATE OF A(M)
        "AR(M) = A1R(M) - A2I(M)
        "AI(M) = A1I(M) + A2R(M)
        "AR(N-M) = A1R(M) + A2I(M)
        "AI(N-M) = A2R(M) - A1I(M)
        "THE INITIAL DATA IS ASSUMED TO PACKED IN FPS
        "COMPLEX FORMAT, WITH X1 IN THE REAL POSITIONS
        "AND X2 IN THE IMAGINARY POSITIONS.
        "THE REAL POSITIONS ARE ASSUMED TO BE SEPARATED BY
        "A MEMORY INCREMENT MDEL >= 2.
        "THE SCRAMBLED DATA ARE PACKED IN THE FORM OF
        "OUTPUT FROM CFFT.
        "INITIALLY, DATA IS ASSUMED SO THAT THE
        "RFFT TRANSFORM OF X1 WILL APPEAR IN THE REAL
        "POSITIONS OF THE ORIGINAL ARRAY.
        "THE RFFT OF X2 WILL APPEAR IN THE IMAGINARY
        "POSITIONS OF THE ORIGINAL ARRAY.
"         --- STATISTICS
"
"LANGUAGE:      APAL
"EQUIPMENT:     AP-120B WITH EITHER MEMORY
"SIZE:          139 PS WORDS
"
"
"
"          --- HISTORY ---
"
"ORIGINAL:      G.J. THROOP DEC 77
"REVISION:      T. E. SKINNER MAR 80  MODS TO HANDLE THE CASE OF N*MDEL=64K
"
"
        "NAMES FOR S-PAD
        "THE FOLLOWING ARE PARAMETERS
        BASE $EQU 0             "ARRAY BASE ADDRESS
        N $EQU 1                "ARRAY LENGTH (A POWER OF 2)
        MDEL $EQU 3             "MEMORY SPACING (A POWER OF 2)
        "THE FOLLOWING ARE SCRATCH
        LBASE $EQU 4
        MBASE $EQU 5
        WBASE $EQU 6
        TBASE $EQU 7
        N2 $EQU 10
        A $EQU 11
        B $EQU 12
        EBASE $EQU 13
        MDEL2 $EQU 14
        "NAMES FOR DPX
        ARL $EQU -4
        ARNL $EQU -3
        ARK $EQU -2
        A1R $EQU 3
        A2R $EQU 2
        TSR $EQU -1
        TR $EQU 1
        "NAMES FOR DPY
        AIL $EQU -4
        AINL $EQU -3
        AIK $EQU -2
        TSI $EQU -1
        A1I $EQU 3
        A2I $EQU 2
        TI $EQU 1
        "SCRATCH:
        "SP(4-12,15), DPX(-4 TO 3), DPY(-4 TO 3), TM,FA,FM,MD
RTOC:   MOV BASE,WBASE
        LDTMA; DB=!HALF;                "FETCH 1/2
        MOV BASE,17                     "BECAUSE SPMUL CLOBBERS BASE
"NOTE: MDEL(=256)*N(=256) = 0,  NOT = 64K
"THUS, DECREMENT AND THEN MULTIPLY, NOT THE CONVERSE
        MOV MDEL,0
        DEC 1
        JSR SPMUL
        MOV 0,MBASE                     "MBASE=MDEL*(N-1) VS MDEL*N-MDEL
        INC 1
        MOVR MDEL,0
        JSR SPMUL
        MOV 0,N2                        "N2=(MDEL/2)*N VS (MDEL*N)/2
        MOV 17,BASE                     "RESTORE BASE FROM SPMUL
        ADD BASE,MBASE                  "SET TO TOP OF ARRAY
        ADD BASE,N2                     "SET TO A(N/2)
        MOV BASE,LBASE
        "FIRST DO ZERO TERM
        "FROM ABOVE FORMULAS A1R(0) = AR(0) AND
        "A2R(0) = AI(0), AND ALSO A1R(0) = 0
        "AND A2I(0) = 0 SO DO NOTHING
        ADD MDEL,LBASE; SETMA           "FETCH A1R(N/2)
        MOV LBASE,WBASE
        INCMA                           "FETCH A2R(N/2)
        DPX(TSR)<MD                     "SAVE A1R(N/2)
        ADD MDEL,LBASE; SETMA           "FETCH A1R(1)
        DPY(TSI)<MD                     "SAVE A2R(N/2)
        INCMA                           "FETCH A2R(1)
        DPX(A1R)<MD                     "SAVE A1R(1)
        ADD MDEL,LBASE; SETMA           "FETCH A1I(1)
        DPX(A2R)<MD                     "SAVE A2R(1)
        INCMA                           "FETCH A2I(1)
        DPY(A1I)<MD                     "SAVE A1I(1)
        MOV MBASE,MBASE; SETMA          "FETCH A1R(N/2-1)
        DPY(A2I)<MD                     "SAVE A2I(1)
        INCMA                           "FETCH A2R(N/2-1)
        DPX<MD                          "SAVE A1R(N/2-1)
        LDSPI 17; DB=4                  "TO TEST IF N = 4
        DPY<MD;                         "SAVE A2R(N/2-1)
        FSUB DPX(A1R),DPY(A2I)          "DO A1R(1) - A2I(1)
        FADD
        MOV WBASE,WBASE; SETMA; MI<FA;  "STORE AR(1)
        FADD DPY(A1I),DPX(A2R)          "DO A1I(1) + A1R(1)
        FADD
        INCMA; MI<FA;                   "STORE AI(1)
        FADD DPX(A1R),DPY(A2I)          "DO A1R(1) + A2I(1)
        FADD
        MOV MBASE,MBASE; SETMA; MI<FA;  "STORE AR(N-1)
        FSUB DPX(A2R),DPY(A1I)          "DO A2R(1) - A1I(1)
        FADD
        INCMA; MI<FA                    "STORE AI(N-1)
        MOV WBASE,B
        ADD MDEL,B; SETMA; MI<DPX(TSR)  "SAVE AR(N-1)
        SUB# 17,N                       "TEST FOR N = 4
        INCMA; MI<DPY(TSI);             "SAVE AI(N-1)
        BGT .+2                         "BRANCH IF N >= 4
        RETURN
        ADD MDEL,B; SETMA; MI<DPX       "SAVE A1R(N/2)
        INCMA; MI<DPY                  "SAVE A1I(N/2)
        ADD MDEL,LBASE                  "UPDATE READ ADDRESS
SHIFT:  MOV LBASE,LBASE; SETMA          "FETCH AR(L)
        DPY(TI)<MD;                     "SAVE A2R(K)
        ADD MDEL,WBASE                  "UPDATE WRITE ADDRESS
        INCMA                           "FETCH A2R(K)
        DPX(A1R)<MD                     "SAVE A1R(L)
        ADD MDEL,LBASE; SETMA;           "FETCH A1I(L)
        DPY(ARL)<DPX(A1R)
        DPX(A2R)<MD                     "SAVE A2R(L)
        INCMA                           "FETCH A2I(L)
        SUB MDEL,MBASE;                 "UPDATE MBASE
        DPY(A1I)<MD                     "SAVE A1I(L)
XXX:    MOV MBASE,MBASE; SETMA          "FETCH A2(N/2-L)
        DPY(A2I)<MD                     "SAVE A2I(L)
        INCMA                           "FETCH A2(N/2-L)
        DPX(TSR)<MD                     "SAVE A2(N/2-L)
        MOV WBASE,A; SETMA              "FETCH R(L+J)
        DPY(TSI)<MD                     "SAVE A2(N/2-L)
        INCMA                           "FETCH I(L+J)
        DPX<MD                          "SAVE R(L+J)
        FSUB DPX(A1R),DPY(A2I)          "DO A1R(L) - A2I(L)
        DPY<MD;
        FADD
JLOOP:  MOV A,A; SETMA                  "FETCH R(L+J+1)
        NOP
        MOV A,A; SETMA; MI<DPX          "STORE R(L+J)
        DPX<MD                          "SAVE R(L+J+1)
        INCMA                           "FETCH I(L+J+1)
        NOP
        INC# A; SETMA; MI<DPY           "STORE I(L+J)
        ADD MDEL,A;
        DPY<MD                          "SAVE I(L+J+1)
        SUB# A,LBASE
"BRANCHES ON EQ AND BNC HAVE BEEN ADDED TO THE BGT DIRECTIVES THROUGHOUT
"THE CODE;  THIS IS BECAUSE THE S-PAD BRANCH INSTRUCTIONS CONSIDER BIT 15
"AS THE SIGN BIT, AND THUS ONLY POSITIVE NUMBERS LESS THAN 32K MAY BE
"CONSIDERED DIRECTLY;  FOR EXAMPLE 140000-020000 RESULTS IN A NEGATIVE
"SIGN BIT INDICATOR, BUT THE FACT THAT THE CARRY-BIT IS ALSO SET ENABLES
"A CHECK FOR THE TRULY POSITIVE RESULT.
        BEQ .+3
        SUB# A,LBASE
        BGT JLOOP; BNC JLOOP            "BRANCH IF NOT DONE
        MOV WBASE,WBASE; SETMA; MI<FA;  "STORE AR(L)
        FADD DPY(A1I),DPX(A2R)          "STORE A1I(L) + A1R(L)
        FADD
        INCMA; MI<FA;                   "STORE AI(L)
        FADD DPX(A1R),DPY(A2I)          "DO A1R(L) + A2I(L)
        MOV MBASE,B; FADD
        MOV MBASE,MBASE; SETMA; MI<FA;  "STORE AR(N-L)
        FSUB DPX(A2R),DPY(A1I)          "DO A2R(I) - A1I(1)
        SUB MDEL,B; FADD
        INCMA;MI<FA                     "STORE AI(N-L)
        SUB MDEL,B
        SUB# LBASE,MBASE
        BEQ .+3
        SUB# LBASE,MBASE
        BGT YYY; BNC YYY
        MOV LBASE,TBASE
        ADD MDEL,TBASE; BR ZZZ
YYY:    MOV LBASE,LBASE; SETMA;         "STORE AR(N/2-K)
        MI<DPX(TSR)
        ADD MDEL,LBASE                  "UPDATE READ BASE
        INCMA; MI<DPY(TSI);             "STORE AI(N/2-K)
        MOV LBASE,TBASE
ZZZ:    SUB# TBASE,MBASE                "TEST FOR END OF SHIFT
        BEQ .+3
        SUB# TBASE,MBASE
        BGT .+2; BNC .+2
        MOVL MDEL,MDEL2; BR .+2
        JMP SHIFT
        SUB MDEL2,LBASE
SHIFT2: MOV LBASE,LBASE; SETMA          "FETCH A1I(L)
        NOP
        INCMA                           "FETCH A2I(L)
        DPY(A1I)<MD
        ADD# MDEL,LBASE; SETMA          "FETCH A1R(L)
        DPY(A2I)<MD
        INCMA
        DPX(A1R)<MD;
        ADD MDEL,WBASE                  "UPDATE WRITE BASE
        MOV WBASE,A; SETMA              "FETCH R(L+J)
        DPX(A2R)<MD
        INCMA                           "FETCH I(L+J)
        DPX<MD                          "SAVE R(L+J) FOR KLOOP
        FSUB DPX(A1R),DPY(A2I)          "DO A1R(L) - A2I(L)
        DPY<MD;                         "SAVE I(L+J) FOR KLOOP
        FADD
KLOOP:  MOV A,A; SETMA                  "FETCH R(L+J+1)
        NOP
        MOV A,A; SETMA; MI<DPX          "STORE R(L+J)
        DPX<MD                          "SAVE R(L+J+1)
        INCMA                           "FETCH I(L+J+1)
        NOP
        INC# A; SETMA; MI<DPY           "STORE I(L+J)
        ADD MDEL,A; DPY<MD              "SAVE I(L+J+1)
        SUB# A,LBASE
        BGE KLOOP; BNC KLOOP
        MOV WBASE,WBASE; SETMA; MI<FA;  "STORE AR(L)
        FADD DPY(A1I),DPX(A2R)          "DO A1I(L) + A1R(L)
        FADD
        INCMA; MI<FA;                   "STORE AI(L)
        FADD DPX(A1R),DPY(A2I)          "DO A1R(L) + A2I(L)
        FADD
        SUB MDEL,MBASE; SETMA;MI<FA;    "STORE AR(N-L)
        FSUB DPX(A2R),DPY(A1I)          "STORE A2R(L) - A1I(L)
        SUB MDEL,LBASE;                 "UDATE READ ADDRESS
        FADD
        INCMA; MI<FA                    "STORE AI(N-L)
        NOP
        SUB# WBASE,LBASE
        BEQ .+3
        SUB# WBASE,LBASE                "TEST FOR END OF SHIFT2
        BGT .+2; BNC .+2
        RETURN
        JMP SHIFT2
        $END
"****** CTOR = COMPLEX TO REAL UNSCRAMBLE / COMMON / = REL 2.3, MAR 80 ***
        $TITLE CTOR
        $RADIX 8
        $ENTRY CTOR,4                          "USER-DIRECTED-CALL ENTRY
        $EXT SPMUL
"
"
"          --- ABSTRACT ---
"
"
        "THIS PROGRAM UNSCRAMBLES THE RESULT OF A COMPLEX FFT
        "ON TWO SEQUENCES OF REAL DATA.
        "IF X1 AND X2 ARE REAL SEQUENCES, THEN CONSIDER A
        "COMPLEX SEQUENCE X = X1 * I*X2, WHERE I =
        "SQUARE ROOT(-1).  THEN THE FOURIER TRANSFORM OF
        "X IS A = A1 + I*A2.  THE TRANSFORMS OF THE REAL
        "SEQUENCES ARE UNSCRAMBLED BY
        "               A1(M) = 0.5*(CC(A(N-M)) + A(M))
        "               A2(M) = 0.5*I*(CC(A(N-M)) - A(M))
        "WHERE CC(A(M)) = COMPLEX CONJUGATE OF A(M)
        "A1R(M) = 0.5*{AR(N-M) + AR(M)}
        "A1I(M) = 0.5*{AI(M) - AI(N-M)}
        "A2R(M) = 0.5*{AI(N-M) + AI(M)}
        "A2I(M) = 0.5*{AR(N-M) - AR(M)}
        "THE INITIAL DATA IS ASSUMED TO PACKED IN FPS
        "COMPLEX FORMAT, WITH X1 IN THE REAL POSITIONS
        "AND X2 IN THE IMAGINARY POSITIONS.
        "THE REAL POSITIONS ARE ASSUMED TO BE SEPARATED BY
        "A MEMORY INCREMENT MDEL >= 2.
        "THE UNSCRAMBLED DATA ARE UNPACKED IN THE FORM OF
        "OUTPUT FROM FPS SUBROUTINE RFFT.
        "THE TRANSFORM OF X1 WILL APPEAR IN THE REAL
        "POSITIONS OF THE ORIGINAL ARRAY.
        "THE TRANSFORM OF X2 WILL APPEAR IN THE IMAGINARY
        "POSITIONS OF THE ORIGINAL ARRAY.
        "NOTE THAT THE SPACING OF ALL ELEMENTS OF THE
        "TRANSFORMED ARRAYS WILL BE MDEL, AND REAL
        "AND IMAGINARY PARTS OF A NUMBER WILL NO LONGER
        "BE IN ADJACENT MEMORY LOCATIONS.
"
"          --- STATISTICS ---
"
"LANGUAGE:      APAL
"EQUIPMENT:     AP-120B WITH EITHER MEMORY
"SIZE:          74 PS WORDS
"
"
"
"          --- HISTORY ---
"
"ORIGINAL:      G. J. THROOP DEC 77
"REVISION:      T. E. SKINNER MAR 80  MODS TO HANDLE THE OF N*MDEL=64K
"
"
"
        "NAMES FOR S-PAD
        "THE FOLLOWING ARE PARAMETERS
        BASE $EQU 0
        N $EQU 1
        MDEL $EQU 3
        "THE FOLLOWING ARE SCRATCH
        LBASE $EQU 4
        MBASE $EQU 5
        WBASE $EQU 6
        TBASE $EQU 7
        N2 $EQU 10
        A $EQU 11
        "NAMES FOR DPX
        ARL $EQU -4
        ARNL $EQU -3
        ARK $EQU -2
        A1R $EQU 3
        A2R $EQU 2
        TSR $EQU -1
        "NAMES FOR DPY
        AIL $EQU -4
        AINL $EQU -3
        AIK $EQU -2
        TSI $EQU -1
        A1I $EQU 3
        A2I $EQU 2
        "SCRATCH:    SP(4-9,15),DPX(-4 TO 3),DPY(-4 TO 3), TM,FA,FM,MD
CTOR:   MOV BASE,WBASE
        LDTMA; DB=!HALF;                "FETCH 1/2
        MOV BASE,17                     "BECAUSE SPMUL CLOBBERS BASE
"NOTE: MDEL(=256)*N(=256) = 0,  NOT = 64K
"THUS, DECREMENT AND THEN MULTIPLY, NOT THE CONVERSE
        MOV MDEL,0
        DEC 1
        JSR SPMUL
        MOV 0,MBASE                     "MBASE=MDEL*(N-1) VS MDEL*N-MDEL
        INC 1
        MOVR MDEL,0
        JSR SPMUL
        MOV 0,N2                        "N2=(MDEL/2)*N VS (MDEL*N)/2
        MOV 17,BASE                     "TO RESTORE BASE FROM SPMUL
        ADD BASE,MBASE                  "SET TO TOP OF ARRAY
        ADD BASE,N2                     "SET TO A(N/2)
        MOV BASE,LBASE
        ADD MDEL,LBASE; SETMA           "FETCH AR(1)
        NOP
        INCMA                           "FETCH AI(1)
        DPX<MD                          "SAVE AR(1)
        MOV N2,N2; SETMA                "FETCH AR(N/2)
        DPY<MD                          "SAVE AI(N/2)
        INCMA
        DPX(TSR)<MD                     "SAVE AR(N/2)
        MOV LBASE,LBASE; SETMA;         "STORE AR(N/2)
        MI<DPX(TSR)
        INCMA; MI<MD                    "STORE AI(N/2)
        MOV LBASE,A
JLOOP:  ADD MDEL,A; SETMA               "FETCH R(L+J)
        NOP
        MOV A,A; SETMA; MI<DPX          "STORE R(L+J-1)
        DPX<MD                          "SAVE R(L+J)
        INCMA                           "FETCH I(L+J)
        NOP
        INC# A; SETMA; MI<DPY           "STORE I(L+J+1)
        SUB# A,N2;                      "TO TEST FOR END OF LOOP
        DPY<MD                          "SAVE I(L+J)
        BEQ SHIFTB
        SUB# A,N2
        BGT JLOOP; BNC JLOOP
"BRANCHES ON EQ AND BNC HAVE BEEN ADDED TO THE BGT DIRECTIVES THROUGHOUT
"THE CODE;  THIS IS BECAUSE THE S-PAD BRANCH INSTRUCTIONS CONSIDER BIT 15
"AS THE SIGN BIT, AND THUS ONLY POSITIVE NUMBERS LESS THAN 32K MAY BE
"CONSIDERED DIRECTLY;  FOR EXAMPLE 140000-020000 RESULTS IN A NEGATIVE
"SIGN BIT INDICATOR, BUT THE FACT THAT THE CARRY-BIT IS ALSO SET ENABLES
"A CHECK FOR THE TRULY POSITIVE RESULT.
SHIFTB: ADD MDEL,LBASE; SETMA           "FETCH AR(L)
        NOP
        INCMA                           "FETCH AI(L)
        DPY(ARL)<MD                     "SAVE AR(L)
        MOV MBASE,MBASE; SETMA          "FETCH AR(N-L)
        DPX(AIL)<MD                     "SAVE AI(L)
        INCMA                           "FETCH AI(N-L)
        FADD DPY(ARL),MD;               "AR(L) + AR(N-L)
        DPX(ARNL)<MD                    "SAVE AR(N-L)
        FSUB DPX(ARNL),DPY(ARL);        "AR(N-L) - AR(L)
        ADD# MDEL,LBASE; SETMA          "FETCH AR(K)
        FSUB DPX(AIL),MD;               "AI(L) - AI(N-L)
        DPY(AINL)<MD;                   "STORE AI(N-L)
        FMUL TM,FA                      "0.5*(AR(N-L) - AR(L))
        FADD DPX(AIL),DPY(AINL);        "AI(L) + AI(N-L)
        INCMA;                          "FETCH AI(K)
        FMUL TM,FA                      "0.5*(AR(N-L) - AR(L))
        FADD;
        DPX<MD;                         "SAVE AR(K)
        FMUL TM,FA                      "0.5*(AI(L) - AI(N-L))
        FMUL TM,FA;                     "0.5*(AI(L) + AI(N-L))
        DPX(A1R)<FM
        DPY<MD                          "SAVE AI(K)
        FMUL;
        DPY(A2I)<FM
        FMUL;
        DPY(A1I)<FM
        MOV LBASE,LBASE; SETMA;         "STORE A1R(K)
        MI<DPX(A1R);
        DPX(A2R)<FM
        MOV LBASE,WBASE
        INCMA;MI<DPX(A2R);              "STORE AR(K)
        ADD MDEL,WBASE
"MOVE 2ND ADD MDEL,WBASE TO AFTER END TEST, AS COUNTER MUST TERMINATE
"AT 0 FOR 64K CASE, SINCE THE SIGN BIT CANNOT BE USED FOR A LT CHECK,
"AND THE COUNTER WILL START OVER, THUS CAUSING AN INFINITE LOOP.
        ADD MDEL,LBASE; SETMA;          "STORE A1I(K)
        MI<DPY(A1I)
        INCMA; MI<DPY(A2I);             "STORE A2I(K)
        MOV LBASE,A
        SUB# WBASE,MBASE
        BEQ .+3
        SUB# WBASE,MBASE                "TO TEST FOR END
        BGT .+2; BNC .+2
        RETURN
        ADD MDEL,WBASE
KLOOP:  ADD MDEL,A; SETMA               "FETCH R(L+J)
        NOP
        MOV A,A; SETMA; MI<DPX          "STORE R(L+J+1)
        DPX<MD                          "SAVE R(L+J)
        INCMA                           "FETCH I(L+J)
        NOP
        INC# A; SETMA; MI<DPY           "STORE I(L+J+1)
        SUB# A,MBASE;                   "TO TEST FOR END OF LOOP
        DPY<MD                          "SAVE I(L+J)
        BEQ .+3
        SUB# A,MBASE
        BGT KLOOP; BNC KLOOP
        JMP SHIFTB
        $END
"++++++ END OF 2D FFT UTILITIES ++++++++++
"****** BITREV = BIT REVERSE PASS /FAST/ = REL 2.0  , JAN 78 *******************
"
        $TITLE BITREV
        $RADIX 8
        $ENTRY BITREV                          "USER-DIRECTED-CALL ENTRY
"
"                  --- ABSTRACT ---
"TAKES A COMPLEX DATA ARRAY AND PUTS IT IN BIT-REVERSED (RADIX 2) ORDER
"                  --- STATISTICS ---
"LANGUAGE:         AP-120B ASSEMBLER
"EQUIPMENT:        AP-120B WITH 1 CYCLE (FAST) MEMORY
"SIZE:  45 LOCATIONS
"SPEED: 0.88 US./COMPLEX POINT
"
"       --- HISTORY ---
"ORIGINAL:  AUG 76  A.E. CHARLESWORTH (REV2)
"REV 2.1:   AUG 77  R.S. NORIN      CORRECTED FOR CASE WHEN N=2
"
"                  --- USEAGE ---
"S-PAD PARAMETERS:
"       0 BASE                          BASE ADDRESS OF ARRAY
"       1 N                             NUMBER OF COMPLEX ELEMENTS
"
"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
"ALSO EXPECTS THE STATUS REGISTER BITREVERSE BITS SET PROPERLY TO
"      IAND(15-LOG2(N),7)
"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
"                  --- SCRATCH ---
"S-PAD:              11-16 (OCTAL)
"DATA PAD:         X - 0           (RELATIVE TO DPA)
"                  --- ALGORITHM ---
"       WE USE THE ADDRESS BIT-REVERSING BUILT INTO THE S-PAD, WHICH
"       BIT-REVERSES THE SUBSCRIPT TO A COMPLEX DATA ARRAY (ELEMENTS
"         OCCUPY PAIRS OF MEMORY LOCATIONS SO THE LSB OF THE SUBSCRIPT
"         IS TAKEN TO BE 0.
"       WE SPECIFY THE ARRAY LENGTH (MUST BE A POWER OF 2) IN THE
"         STATUS REGISTER BITS 13-15: 15-LOG2(N)
"WE HAVE TWO SEPARATE LOOPS, DEPENDING UPON WHETHER N IS LESS THAN 256.
"       IF N IS SMALL WE SET THE STATUS BITS TO 7-LOG2(N), AND THEN
"         SHIFT THE SUBSCRIPT LEFT 8 PLACES BEFORE BIT-REVERSING, WHICH
"         TOGETHER GIVES THE PROPER BIT-REVERSED SUBSCRIPT.
"S - PAD REGISTER MNEMONICS
"PARAMETERS, UNCHANGED:
        BASE $EQU 0        "ARRAY BASE ADDRESS
        N $EQU 1           "N (NUMBER OF COMPLEX POINTS)
"
"LOCAL VARIABLES
        BASEP1 $EQU 11  "BASE + DI
        BASEP2 $EQU 12  "BASE + 2 * DI
        I $EQU 13       "ARRAY SUBSCRIPT
        T $EQU 14       "ARRAY SUBSCRIPT SHIFTED LEFT 8 (*256)
        DT $EQU 15      "DELTA FOR T (2 * 256 = 512)
        DI $EQU 16      "DELTA FOR I (2)
"
"
BITREV: MOVL N,I                "SET I TO END OF ARRAY
        LDSPI DI; DB=2
        MOV BASE,BASEP1
        ADD DI,BASEP1
        MOV BASEP1,BASEP2
        LDSPI T; DB=256.         "FOR TESTING N
        SUB# T,N                 "SEE IF N .GE. 256
        BGE BIG;                 "YES, A 'BIG' ARRAY
          ADD DI,BASEP2
        JMP SMALL               "NO, A SMALL ARRAY
"ARRAY 256 ELEMENTS OR LARGER  .........
"BIT-REVERSE BITS OF STATUS REGISTER SET TO 15.-LOG2(N)
"
"NOTE: THE LOOP WILL TERMINATE AS FOLLOWS, A(1) WILL BE SWAPPED,
"   BUT NOT A(0), SO 'I' REACHING ZERO WILL BE CAUGHT IN THE
"   'NOSWAP' BRANCH
"
BIG:    SUB DI,I;                       "START IN THE CHECKING LOOP
          BR CKBIG
"
"       FINISH A SWAP AND THEN CHECK THE NEXT ELEMENT
NOSWAP: ADD# I,BASEP2; SETMA; MI<FA;    "STORE NEW RE(I)
          FADD;
          DB=DPX                        "FOR TESTING I (WAS SAVED IN DPX)
        INCMA; MI<FA;                   "STORE NEW IM(I)
          BDBN DONBIG                   "DONE IF I IS NOW DOWN BELOW ZERO
"
"SUBSCRIPT CHECKING LOOP, COMPARE THE SUBSCRIPT AGAINST ITSELF
"   BIT-REVERSED - SWAP COMPLEX ELEMENTS ONLY IF BIT-REVERSED
"   VALUE IS LOWER.  I.E. SWAP THE PAIR THE SECOND TIME
"   WE PASS IT ON OUR WAY DOWN FROM THE TOP OF THE ARRAY
CKBIG:  SUB# &I,I                       "TEST BITREV(I) AGAINST I
        SUB DI,I;                       "DECREMENT I ONE COMPLEX LOCATION
          BGE BIG                       "BRANCH IF BITREV(I).LT.I
"
"WE COME HERE IF WE HAVE TO SWAP ELEMENTS......................
"NOTE THAT I WAS BEEN DECREMENTED ONE ELEMENT BELOW THE PAIR
"   THAT MUST BE SWAPPED
SWAPBG:  ADD# I,BASEP1; SETMA           "FETCH RE(I)
        INCMA;                          "FETCH IM(I)
          ADD DI,I                      "BACK UP I TO CURRENT ELEMENT
        ADD# &I,BASE; SETMA             "FETCH RE(BITREV(I))
        INCMA;                          "FETCH IM(BITREV(I))
          FADD ZERO,MD;                 "SAVE RE(I)
          SUB DI,I                      "RESTORE I BACK TO WHERE IT WAS
        FADD ZERO,MD                    "SAVE IM(I)
        DECMA; MI<FA;                   "STORE NEW RE(BITREV(I))
          FADD ZERO,MD;                  "SAVE OLD RE(BITREV(I))
          SUB# &I,I                     "TEST NEXT PAIR
        INCMA; MI<FA;                   "STORE NEW IM(BITREV(I))
          FADD ZERO,MD;                 "SAVE OLD IM(BITREV(I))
          SUB DI,I;                     "DECREMENT TO NEXT ELEMENT
          DPX<SPFN;                     "SAVE I FOR LATER TEST
          BGE NOSWAP                   "BRANCH IF DON'T SWAP NEXT PAIR
        ADD# I,BASEP2; SETMA; MI<FA;    "STORE NEW RE(I)
          FADD
        INCMA; MI<FA;                   "STORE NEW IM(I)
          BR SWAPBG                      "GO SWAP NEXT PAIR
"
"DONE WITH BIG BIT-REVERSE:
DONBIG: RETURN
"
"ARRAY SMALLER THAN 256 ELEMENTS  ...........
"BIT-REVERSE FIELD OF STATUS REGISTER SET TO 7-LOG2(N)
SMALL:  LDSPI DT; DB=512.               "DELTA FOR T
        MOVL I,T                        "SHIFT I LEFT 8 PLACES TO GET T
        ADDL T,T                        "!!!
        ADDL T,T                        "!!!
        ADDL T,T                        "!!!
        MOVL T,T
        SUB DI,I                        "DECREMENI I
CKSML:  SUB DT,T; BEQ DONBIG            "DECREMENT T; QUIT IF NO REVERSING TO DO
        SUB# &T,I                       "COMPARE BITREV(T) AND I
        SUB DI,I;                       "DECREMENT I TO NEXT ELEMENT
          BGE CKSML                     "BRANCH IF DON'T SWAP THIS ONE
"SWAP ELEMENTS ..........
        ADD# I,BASEP1; SETMA            "FETCH RE(I)
        INCMA                           "FETCH IM(I), DECREMENT T
        ADD# &T,BASE; SETMA             "FETCH RE(BITREV(I))
        INCMA;                          "FETCH IM(BITREV(I))
          FADD ZERO,MD                  "SAVE RE(I))
        FADD ZERO,MD                    "SAVE IM(I)
        DECMA; MI<FA;                   "STORE NEW RE(BITREV(I))
          FADD ZERO,MD;                 "SAVE OLD RE(BITREV(I))
          MOV I,I                       "FOR TESTING I DOWN TO ZERO
        INCMA; MI<FA;                   "STORE NEW IM(BITREV(I))
          FADD ZERO,MD;                 "SAVE OLD IM(BITREV(I))
          BEQ DONSML                    "BRANCH IF DONE
        ADD# I,BASEP1; SETMA; MI<FA;    "STORE RE(I)
          FADD
        INCMA; MI<FA;                   "STORE IM(I)
          SUB DT,T;                     "DECREMENT T
          BR CKSML + 1                  "LOOP BACK
"
"FINISH OFF LAST SWAP AND RETURN
DONSML: ADD# I,BASEP1; SETMA; MI<FA; FADD
        INCMA; MI<FA; RETURN
        $END
"****** REALTR = REAL FFT PASS /FAST/ = REL 3.0, NOV 78 ************************
"
        $TITLE REALTR
        $RADIX 8
        $ENTRY REALTR                          "USER-DIRECTED-CALL ENTRY
        $EXT STSTAT,CLSTAT
"                  --- ABSTRACT ---
"REAL FFT UNRAVEL AND FINAL PASS
"USED AFTER A DIRECT FFT, OR BEFORE AN INVERSE FFT
"WHEN TRANSFORMING REAL DATA
"
"                  --- STATISTICS ---
"LANGUAGE:    APAL
"EQUIPMENT:   AP-120B WITH FAST (1 CYCLE) MEMORY)
"SIZE:       49 LOCATIONS + STATUS (19) = 68
"SPEED:      .42 US. PER REAL POINT
"SUBROUTINES USED:     STSTAT,CLSTAT
"
"     ---HISTORY---
"ORIGINAL:  FEB 77, A.E. CHARLESWORTH
" REV 2.1:  JUL 77, R.S. NORIN          JMP CLSTAT REPLACES  JSR CLSTAT, NOP, RE
" REVISED:  NOV 78, R.S. NORIN          LABEL !FFTX4 REPLACES TBLSZE*4
"                                         FOR APAL3 COMPATIBILITY
"
"
"
"                  --- USEAGE ---
"S-PAD PARAMETERS:
"       NAME          NUMBER            PURPOSE
        A      $EQU   0                 "BASE ADDRESS OF INPUT ARRAY
        C      $EQU   1                 "BASE ADDRESS OF OUTPUT ARRAY
        N      $EQU   2                 "NUMBER OF REAL POINTS
        F      $EQU   3                 "+1 FOR DIRECT, -1 FOR INVERSE
"THE INPUT/OUTPUT AND USEAGE DEPENDS UPON WHETHER WE ARE GOING
"       DIRECT OR INVERSE WITH THE TRANSFORM
"
"DIRECT......
"
"INPUT:          N REAL TIME DOMAIN POINTS
"OUTPUT:     N+1 COSINE AND N-1 SINE FREQUENCY COEFFICIENTS
"                  THE FIRST AND THE NTH SINE COEFFICIENTS(IMAG PARTS)
"                  ARE ALWAYS ZERO, SO THE NTH COSINE COEFFICIENT IS
"                  STORED IN THE IMAGINARY PART OF THE FIRST LOCATION
"
"INVERSE......
"
"INPUT:         N+1 COSINE AND N-1 SINE FREQUENCY COEFFICIENTS
"                  STORED AS EXPLAINED ABOVE
"OUTPUT:         N REAL TIME DOMAIN POINTS
"
"USEAGE:
"
"DIRECT:        DO AN N/2 POINT COMPLEX DIRECT TRANSFORM
"               THEN CALL THIS SUBROUTINE
"INVERSE:       CALL THIS SUBROUTINE
"               THEN DO AN N/2 POINT INVERSE COMPLEX TRANSFORM
"
"                  --- SCRATCH ---
"S-PAD:  10-17 (OCTAL)
"DPX:   -4 TO +2   (RELATIVE TO DPA)
"DPY:   -4 TO +1    (RELATIVE TO DPA)
"                  --- ALGORITHM ---
"
"WE TAKE PAIRS OF POINTS, TREATING
"       THEM AS COMPLEX PAIRS
"ONE PAIR FROM THE FRONT OF THE ARRAY, AND ONE PAIR FROM
"       THE BACK, WORKING TOWARD THE MIDDLE
"
"THE COMPUTATION IS:
"       APCR=AR+CR
"       AMCR=AR-CR
"       APCI=AI+CI
"       AMCI=AI-CI
"
"       RE=WR*APCI+WI*AMCR
"       IM=WI*APCI-WR*AMCR
"
"       CR'=APCR-RE
"       CI'=IM-AMCI
"       AR'=APCR+RE
"       AI'=IM+AMCI
"WHERE: (AR,AI) ARE FROM THE FRONT OF THE ARRAY
"     (CR,CI) ARE FROM THE BACK OF THE ARRAY
"
"(WR,WI) ARE A COMPLEX EXPONENTIAL:
"       WR=COS(THETA)
"       WI=SIN(THETA)
"
"IF DIRECT, THETA GOES FROM 0 TO -PI/2
"IF INVERSE, THETA GOES FROM PI TO PI/2
"THETA INCREMENTS BY PI*2.0/N
"
"THE COMPUTATION INVOLVING THE FIRST AND LAST PAIR IS A SPECIAL CASE
"        SINCE A AND C ARE THE SAME AND HAVE SPECIAL MEANINGS:
"DIRECT:
"       AR' = 2(AR+AI),   AI' = 0
"       CR' = 2(AR-AI),   CI' = 0
"BUT, CR' IS STORED INTO AI', SO:
"       AR' = 2(AR+AI),  AI' = 2(AR-AI)
"INVERSE:
"       AR' = AR+CR,     AI' = AR-CR
"BUT, CR WAS PUT INTO AI, SO:
"       AR' = AR+AI,   AI' = AR-AI
"SIZE OF FFT COSINE TABLE
        TBLSZE $EQU !FFTSZ
"
"LOCATION IN TM OF 1.0 AND 2.0
        ONEADR $EQU !ONE
        TWOADR $EQU !TWO
"
"
"
"DATA PAD X NAMES:
        AR $EQU -4      "A REAL
        AI $EQU -3      "A IMAGINARY
        RE $EQU -2      "WR*APCI - WI*AMCR
        IM $EQU -1      "WI*APCI - WR*AMCR
        AMCR $EQU 0     "AR - CR
        APCI $EQU 1     "AI + CI
        TR $EQU 2       "TEMP REAL
"
"DATA PAD Y NAMES
        CR $EQU -4      "C REAL
        CI $EQU -3      "C IMAGINARY
        APCR $EQU -2    "AR + CR
        AMCI $EQU -1    "AI - CI
        RR $EQU 0       "WR*APCR
        RI $EQU 1       "WR*AMCI
"
"
"S-PAD NAMES:  (NOT PARAMETERS)
        W $EQU 10       "W POINTER
        WD $EQU 11      "W DELTA
        MDEL $EQU 12    "MEMORY DELTA
        ICTR $EQU 13    "LOOP COUNTER
        AREAD $EQU 14   "A READ POINTER
        CREAD $EQU 15   "C READ POINTER
        AWRITE $EQU 16  "A WRITE POINTER
        CWRITE $EQU 17  "C WRITE POINTER
"
"
"
"       TAB-STOPS: 9 25 41 57
"
"
"INTRO ...
"
"INITIALIZATION OF PARAMETERS
"       AREAD<A
"       AWRITE<C
"       CREAD<A+N-MDEL
"       CWRITE<C+N-MDEL
"       W<0          DIRECT
"       W<TBLSZE*4   INVERSE
"       WD<TBLSZE*4
"ICTR<N/4
"FIRST SET UP DEPENDING ON FORWARD OR INVERSE FFT
REALTR: MOV F,16                                        "TEST DIRECTION
        LDSPI WD; DB=!FFTX4;                            "SET W DELTA (11/78)
           BGT DIRECT                                   "FORWARD OR INVERSE???
"
"INVERSE REAL PASS:
"SET INITIAL ANGLE TO PI
INVERSE:LDTMA; DB=ONEADR;                               "GET A 1.0
           MOV WD,W;                                    "SET TO PI
           BR COMMON
"
"FORWARD REAL PASS:
"SET INITIAL ANGLE TO 0
DIRECT: LDTMA; DB=TWOADR;                               "GET 2.0
           CLR W                                        "SET TO ZERO
"
"COMMON AGAIN
"SET FFT MODE BITS IN AP-STATUS REGISTER,
"   AND GET LOG2(N/2) IN S-PAD 17
COMMON: LDSPI MDEL; DB=2                                "SET MDEL=2
        MOVR N,17;                                      "N/2 COMPLEX PTS
           DPX(TR)<TM                                   "SAVE 1.0 OR 2.0
        JSR STSTAT                                      "SET FFT STATUS
"
"NOW COMPUTE WD/N, DO THIS BY SHIFTING
"   WD RIGHT THE NUMBER OF TIMES IN S-PAD 17
DIVL:   DEC 17                                          "COUNT
        MOVR WD,WD;                                     "SHIFT WD
        BNE DIVL                                        "GO BACK
"
"
"NOW START ON THE FIRST COMPUTATION...........
"
"A SPECIAL CASE:  AR'(0)=TR * (AR(0) + AI(0))
"                 AI'(0)=TR * (AR(0) - AI(0))
"WHERE TR IS 2.0 FOR DIRECT, OR 1.0 FOR INVERSE
"
"
        MOV A,AREAD; SETMA                              "1. FETCH AR(0)
        INCMA;                                          "2. FETCH AI(0)
           MOV A,CREAD
        ADD N,CREAD                                     "3. SET CREAD=C+N
        DPX(AR)<MD;                                     "4
           MOV C,CWRITE
        FADD DPX(AR),MD;                                "5. AR(0)+AI(0)
           DPY(CR)<MD;
           ADD N,CWRITE                                 "   SET CWRITE=A+N
        FSUB DPX(AR),DPY(CR);                           "6. AR(0)-AI(0)
           MOVRR N,ICTR                                 "   SET COUNTER
        FMUL DPX(TR),FA; FADD                           "7.TR * (AR+CR)
        FMUL DPX(TR),FA                                 "8. TR * (AR-CR)
        FMUL                                            "9.
        MI<FM; FMUL;                                    "10. STORE AR(0)
           MOV C,AWRITE; SETMA
        MI<FM; INCMA                                    "11. STORE AI(0)
"
"
"
"THE 1ST PASS......
"
        ADD MDEL,AREAD; SETMA                           "1. FETCH AR
        INCMA                                           "2. FETCH AI
        SUB MDEL,CREAD; SETMA                           "5. FETCH CR
        INCMA; DPX(AR)<MD                               "6. FETCH CI
        DPX(AI)<MD                                      "7.
        FSUB DPX(AR),MD;                                "8. AMCR=AR-CR
        ADD WD,W; SETTMA;                               "FETCH WR
        DPY(CR)<MD
        FADD DPX(AI),MD;                                "9. APCI=AI+CI
        DPY(CI)<MD
        FMUL TM,FA;                                     "10. RR=WR*AMCR
        INCTMA;                                         "FETCH WI
        DPX(AMCR)<FA;
        FADD
"
"
"
"THE 2ND PASS ...........
"
        ADD MDEL,AREAD;                                 "1. FETCH AR
        SETMA;
                        FMUL TM,FA;                     "RI=WR*APCI
                        DPX(APCI)<FA
        INCMA;                                          "2. FETCH AI
                        FMUL TM,DPX(AMCR)               "IR=WI*AMCR
                        FADD DPX(AR),DPY(CR);           "3. APCR=AR+CR
                        FMUL;
                        DPY(RR)<FM
        DPX(AR)<MD;                                     "4.
                        FSUB DPX(AI),DPY(CI);           "AMCI=AI-CI
                        FMUL;
                        DPY(RI)<FM
        SUB MDEL,CREAD;                                 "5. FETCH CR
        SETMA;
        DPX(AI)<MD;
                        DPY(APCR)<FA;
                        FADD
        INCMA;                                          "6. FETCH CI
                        DPY(AMCI)<FA
                        FADD FM,DPY(RI);                "7. RE=RI+IR
                        FMUL TM,DPX(APCI)               "II=WI*APCI
        FSUB DPX(AR),MD;                                "8. AMCR=AR-CR
        ADD WD,W; SETTMA;                               "FETCH WR
        DPY(CR)<MD;
                        FMUL
        FADD DPX(AI),MD;                                "9. APCI=AI+CI
        DPY(CI)<MD;
                        DPX(RE)<FA;
                        FMUL
        FMUL TM,FA;                                     "10. RR=WR*AMCR
        INCTMA;                                         "FETCH WI
        DPX(AMCR)<FA;
                        FSUB FM,DPY(RR)                 "IM=II-RR
"
"
" AND FINALLY, THE LOOP .........
"
LOOP:   ADD MDEL,AREAD;                                 "1. FETCH AR
        SETMA;
                        FMUL TM,FA;                     "RI=WR*APCI
                        DPX(APCI)<FA;
                                                         "CR'=APCR-RE
                                        FSUB DPY(APCR),DPX(RE)
        INCMA;                                          "2. FETCH AI
                        FMUL TM,DPX(AMCR);              "IR=WI*AMCR
                                        FSUBR DPY(AMCI),FA; "CI'=IM-AMCI
                                        DPX(IM)<FA
                        FADD DPX(AR),DPY(CR);           "3. APCR=AR+CR
                        FMUL;
                        DPY(RR)<FM;
                                        MI<FA;          "STORE CR'
                                        SUB MDEL,CWRITE;
                                        SETMA
        DPX(AR)<MD;                                     "4.
                        FSUB DPX(AI),DPY(CI);           "AMCI=AI-CI
                        FMUL;
                        DPY(RI)<FM;
                                        MI<FA; INCMA    "STORE CI'
        SUB MDEL,CREAD;                                 "5. FETCH CR
        SETMA;
        DPX(AI)<MD;
                        DPY(APCR)<FA;
                                                        "AR'=APCR+RE
                                        FADD DPY(APCR),DPX(RE)
        INCMA;                                          "6. FETCH CI
                        DPY(AMCI)<FA;
                                                        "AI'=IM+AMCI
                                        FADD DPX(IM),DPY(AMCI)
                        FADD FM,DPY(RI);                "7. RE=RI+IR
                        FMUL TM,DPX(APCI);              "II=WI*APCI
                                        MI<FA;          "STORE AR'
                                        ADD MDEL,AWRITE;
                                        SETMA
        FSUB DPX(AR),MD;                                "8. AMCR=AR-CR
        ADD WD,W; SETTMA;                               "FETCH WR
        DPY(CR)<MD;
                        FMUL;
                                        MI<FA; INCMA    "STORE AI'
        FADD DPX(AI),MD;                                "9. APCI=AI+CI
        DPY(CI)<MD;
                        DPX(RE)<FA;
                        FMUL;
                                        DEC ICTR        "DONE ????
        FMUL TM,FA;                                     "10. RR=WR*AMCR
        INCTMA;                                         "FETCH WI
        DPX(AMCR)<FA;
                        FSUB FM,DPY(RR);                "IM=II-RR
                                        BNE LOOP        "GO BACK
"
"
"DONE, CLEAR FFT STATUS BITS AND RETURN
        JMP CLSTAT                          "EXIT THRU CLSTAT
        $END
"****** FFT2B = RADIX 2 1ST FFT PASS & BIT-REVERSE /FAST/ = REL 2.0  , JAN 78 **
"REV 2 MARCH 77
"
        $TITLE FFT2B
        $RADIX 8
        $ENTRY FFT2B                          "USER-DIRECTED-CALL ENTRY
        $EXT SET24B
"
"
"                               --- ABSTRACT ---
"DOES THE FIRST RADIX 2 PASS OF AN FFT WHERE THE BIT-REVERSE IS BEING COMBINED
"WITH THE FIRST PASS OF THE FFT, AND THE ARRAY HAS AN ODD POWER OF TWO NUMBER
"OF COMPLEX POINTS
"
"
"                               --- STATISTICS ---
"EQUIPMENT:                     AP-120B WITH FAST (1 CYCLE) MEMORY
"SIZE:                          17 LOCATIONS
"AUTHOR:                        A.E. CHARLESWORTH
"DATE:                          JUNE 1976
"
"
"                               --- USEAGE ---
"DOES THE FIRST PASS OF A NOT-IN-PLACE FFT WHERE A RADIX TWO PASS IS NEEDED
"
"INPUT PARAMETERS:
"       SPAD #   NAME     PURPOSE
"       0        SOURCE   BASE ADDRESS OF INPUT ARRAY
"       1        DEST     BASE ADDRESS OF OUTPUT ARRAY
"       15       MDEL     MEMORY DELTA (BETWEEN COMPLEX PAIRS)
"       16       ICOUNT   NUMBER OF COMPLEX PAIRS IN THE ARRAY
"
"
"                               --- SCRATCH ---
"S-PAD:                         3-6
"DATA PAD X:                    0 AND 1 (RELATIVE TO DPA)
"DATA PAD Y:                    0 THROUGH 3 (RELATIVE TO DPA)
"
"
"                               --- ALGORITHM ---
"
"SINCE THIS IS THE FIRST PASS OF THE FFT, THE TWIDDLE FACTORS ARE 0.0,
"  AND HENCE NO MULTIPLIES NEED BE DONE.
"
"THUS, THE 'BUTTERFLY' IS:
"
"       A' = A + C
"       C' = A - C
"
"WHERE A AND C ARE COMPLEX POINTS
"
"
"
"DATA PAD NAMES:
"       DATA PAD X:
        CR $EQU 0               "C REAL
        CI $EQU 1               "C IMAGINARY
"
"       DATA PAD Y:
        AR $EQU 0               "A REAL
        AI $EQU 1               "A IMAGINARY
        AR1 $EQU 2
        AI1 $EQU 3
"
"
"S-PAD NAMES:
"
"THESE ARE NOT CHANGED
        SOURCE $EQU 0           "BASE ADDRESS OF SOURCE ARRAY
        DEST $EQU 1             "BASE ADDRESS OF DESTINATION ARRAY
        RDEL $EQU 6             "READ POINTER DELTA
"
"SCRATCH VARIABLES
        READ $EQU 3             "READ POINTER
        WRITE $EQU 4            "WRITE POINTER
        ICTR $EQU 5             "LOOP COUNTER
"
"PASS VARIABLES (NOT CHANGED)
        MDEL $EQU 15            "MEMORY DELTA
        ICOUNT $EQU 16          "LOOP COUNT
"
"
"
"INTRO TO THE LOOP ...
FFT2B:  JSR SET24B               "SETUP RDEL DEPENDING ON FFT SIZE
        MOV SOURCE,SOURCE; SETMA                        "1. FETCH AR
        INCMA;                                          "2. FETCH AI
        MOV RDEL,READ
        ADD# &READ,SOURCE; SETMA                        "3. FETCH CR
        INCMA;                                          "4. FETCH CI
        DPY(AR)<MD;
        ADD RDEL,READ                                   "MOVE READ SUBSC
        DPY(AI)<MD;                                     "5.
        MOV ICOUNT,ICTR                                 "SET LOOP COUNTER
        DPX(CR)<MD;                                     "6.
        MOV DEST,WRITE
        DPX(CI)<MD;                                     "7.
        SUB MDEL,WRITE;                                 "SET WRITE=DEST-MDEL
        BR LOOPST
"
"
"
"THE LOOP .........
LOOP:                           MI<FA; INCMA            "8. STORE CI'
LOOPST: ADD# &READ,SOURCE; SETMA;                        "1. FETCH AR
                                DPY(AR1)<DPY(AR)
        INCMA;                                          "2. FETCH AI
        ADD RDEL,READ;                                  "MOVE READ SUBSC
                                DPY(AI1)<DPY(AI)
        ADD# &READ,SOURCE; SETMA;                        "3. FETCH CR
                                FADD DPY(AR1),DPX(CR)   "AR'=AR+CR
        INCMA;                                          "4. FETCH CI
        ADD RDEL,READ;                                  "MOVE READ SUBSC
        DPY(AR)<MD;
                                FADD DPY(AI1),DPX(CI)   "AI'=AI+CI
        DPY(AI)<MD;                                     "5.
                                FSUB DPY(AR1),DPX(CR);  "CR'=AR-CR
                                MI<FA; ADD MDEL,WRITE; SETMA "STORE AR'
        DPX(CR)<MD;                                     "6.
                                FSUB DPY(AI1),DPX(CI);  "CI'=AI-CI
                                MI<FA; INCMA;           "STORE AI'
                                DEC ICTR                "SEE IF DONE ??
        DPX(CI)<MD;                                     "7.
                                MI<FA; ADD MDEL,WRITE; SETMA;"STORE CR'
                                FADD;
                                BNE LOOP                "GO BACK ...
"
"
"FINISH UP THE LAST LOOP ...
                                MI<FA; INCMA;           "8. STORE CI'
                                RETURN
        $END
"****** FFT4B = RADIX 4 FFT 1ST PASS & BIT-REVERSE /FAST/ = REL 2.0  , JAN 78 **
"REV 2  MARCH 77 ADDED ABILITY TO DO SMALL FFTS
"
        $TITLE FFT4B
        $RADIX 8
        $ENTRY FFT4B                          "USER-DIRECTED-CALL ENTRY
        $EXT SET24B
"
"
"                               --- ABSTRACT ---
"DOES THE FIRST RADIX 4 FFT PASS WHEN THE BIT-REVERSE IS
"COMBINED WITH THE FIRST PASS OF AN FFT
"
"
"                               --- STATISTICS ---
"LANGUAGE:                      APAL
"EQUIPMENT:                     AP-120B WITH FAST (1-CYCLE) MEMORY
"SIZE:                          35 LOCATIONS + SET24B (8) = 43
"
"              ---HISTORY---
"ORIGINAL:  JUN 76, A.E. CHARLESWORTH
" REV 2.1:  FEB 77, A.E. CHARLESWORTH     ADDED ABILITY TO DO SMALL FFTS
" REV 2.2:  JUL 77, R.S. NORIN            SAVED 1 WORD BY MERGING RETURN INTO
"                                           PREVIOUS INSTRUCTION
"
"
"                               --- USEAGE ---
"DOES A COMBINES BIT-REVERSE AND RADIX 4 FIRST FFT PASS.
"THE PASS IS DONE NOT-IN-PLACE, I.E. FROM ONE ARRAY TO ANOTHER
"
"INPUT PARAMETER:
"       SPAD #   NAME     PURPOSE
"       0        SOURCE   INPUT ARRAY LOCATION
"       1        DEST     OUTPUT ARRAY LOCATION
"       15       MDEL     MEMORY DELTA (BETWEEN COMPLEX PAIRS)
"       16       ICOUNT   # OF PAIRS OF COMPLEX POINTS
"
"
"                               --- SCRATCH ---
"S-PAD:                         3 THROUGH 6
"DATA PAD X:                    -4 THROUGH +3 (RELATIVE TO DPA)
"DATA PAD Y:                    -4 THROUGH +3 (RELATIVE TO DPA)
"
"
"
"                               --- ALGORITHM ---
"
"SINCE THIS IS THE FIRST PASS OF THE FFT, THE TWIDDLE FACTORS ARE 0.0,
"   AND HENCE NO MULTPLIES NEED BE DONE.
"
"THUS, THE 'BUTTERFLY' IS LIKE THAT FOR A REGULAR RADIX 4 PASS,
"   BUT THE INITIAL THREE COMPLEX MULTIPLIES ARE NOT DONE:
"
"
"1.     FOUR COMPLEX POINTS:  A, C, B, D
"       ARE FETCHED IN THAT ORDER FROM MEMORY
"
"2.     THEN THE FOLLOWING SET OF COMPLEX ADDS & SUBTRACTS ARE DONE
"       A' = A +  B + C +  D
"       B' = A -+JB - C +-JD
"       C' = A -  B + C -  D
"       D' = A +-JB - C -+JD
"
"           -+ MEANS - FOR FORWARD FFT, + FOR INVERSE FFT
"           +- MEANS + FOR FORWARD FFT, - FOR INVERSE FFT
"
"
"3.     A', B', C', D' ARE THEN STORED BACK INTO MEMORY
"
"
"TO MINIMIZE COMPLEX ADDS THE COMPUTATION IN THE BUTTERFLY IS
"       FACTORED AS FOLLOWS:
"
"
"       APC = A + C
"       AMC = A - C
"       BPD = B + D
"       JBMD - J * (B - D) = (DI-BI, BR-DR)
"
"       A' = APC + BPD
"       C' = APC - BPD
"
"DIRECT FFT:
"       B' = AMC - JBMD
"       D' = AMC + JBMD
"
"INVERSE FFT:
"       B' = AMC + JBMD
"       D' = AMC - JBMD
"
"
"THIS GIVES A TOTAL OF  REAL ADDS
"
"
"
"DATA PAD X NAMES:
        BPDR $EQU -4            "BR + DR
        APCI $EQU -3            "AI + CI
        AMCR $EQU -2            "AR - CR
        AMCI $EQU -1            "AI - CI
        CR   $EQU  0            "C REAL
        CI   $EQU  1            "C IMAGINARY
        BBR  $EQU  2            "B REAL
        BI   $EQU  3            "B IMAGINARY
"DATA PAD Y NAMES:
        APCR $EQU -4            "AR + CR
        BPDI $EQU -3            "BI + DI
        JBMDR $EQU -2           "J * (BR - DR)
        JBMDI $EQU -1           "J * (BI - DR)
        AR   $EQU  0            "A REAL
        AI   $EQU  1            "A IMAGINARY
        DR   $EQU  2            "D REAL
        DI   $EQU  3            "D IMAGINARY
"S-PAD NAMES:
"
"NOT CHANGED
        SOURCE $EQU  0          "BASE ADDRESS OF SOURCE ARRAY
        DEST   $EQU  1          "BASE ADDRESS OF DESTINATION ARRAY
"
"SCRATCH VARIABLES
        READ   $EQU  3          "READ POINTER
        WRITE  $EQU  4          "WRITE POINTER
        ICTR   $EQU  5          "I-LOOP COUNTER
        RDEL   $EQU  6          "READ POINTER DELTA
"
"PASS VARIABLES (NOT CHANGED)
        MDEL   $EQU 15          "MEMORY DELTA
        ICOUNT $EQU 16          "I-LOOP COUNT
"INTRO TO ILOOP
FFT4B:  JSR SET24B                  "SETUP RDEL DEPENDING UPON FFT SIZE
        MOV SOURCE,SOURCE; SETMA                         "1. FETCH AR
        INCMA;                                          "2. FETCH AI
        MOV RDEL,READ                                   "SETUP READ
        ADD# &READ,SOURCE; SETMA                         "3. FETCH CR
        INCMA;                                          "4.FETCH CI
        ADD RDEL,READ;                                  "ADVANCE READ
        DPY(AR)<MD
        ADD# &READ,SOURCE; SETMA;                        "5. FETCH BR
        DPY(AI)<MD
        INCMA;                                          "6. FETCH BI
        ADD RDEL,READ;
        DPX(CR)<MD
        ADD# &READ,SOURCE; SETMA;                        "7. FETCH DR
        DPX(CI)<MD
        INCMA;                                          "8. FETCH DI
        ADD RDEL,READ;
        DPX(BBR)<MD
        DPX(BI)<MD;                                     "9.
        MOV ICOUNT,ICTR                                 "SET COUNTER
        DPY(DR)<MD;                                     "10.
        FADD DPY(AR),DPX(CR);                           "APCR=AR+CR
        MOV DEST,WRITE
        DPY(DI)<MD;                                     "11.
        FADD DPY(AI),DPX(CI);                           "APCI=AI+CI
        SUB MDEL,WRITE                                  "SET WRITE=DEST-MDEL
"
"
"
"LOOP ........
LOOP:   ADD# &READ,SOURCE; SETMA;                        "1. FETCH AR
                                FSUB DPY(AR),DPX(CR);   "AMCR=AR-CR
                                DPY(APCR)<FA
        INCMA;                                          "2. FETCH AI
        ADD RDEL,READ;                                  "MOVE READ SUBSC
                                FSUB DPY(AI),DPX(CI);   "AMCI=AI-CI
                                DPX(APCI)<FA
        ADD# &READ,SOURCE; SETMA;                        "3. FETCH CR
                                FADD DPX(BBR),DPY(DR);  "BPDR=BR+DR
                                DPX(AMCR)<FA
        INCMA;                                          "4. FETCH CI
        ADD RDEL,READ;                                  "MOVE READ SUBSC
        DPY(AR)<MD;
                                FADD DPX(BI),DPY(DI);   "BPDI=BI+DI
                                DPX(AMCI)<FA
        ADD# &READ,SOURCE; SETMA;                        "5. FETCH BR
        DPY(AI)<MD;
                                FSUB DPY(DI),DPX(BI);   "JBMDR=DI-BI
                                DPX(BPDR)<FA
        INCMA;                                          "6. FETCH BI
        ADD RDEL,READ;                                  "MOVE READ SUBSC
        DPX(CR)<MD;
                                FSUB DPX(BBR),DPY(DR);  "JBMDI=BR-DR
                                DPY(BPDI)<FA
        ADD# &READ,SOURCE; SETMA;                        "7. FETCH DR
        DPX(CI)<MD;
                                FADD DPY(APCR),DPX(BPDR); "AR'=APCR+BPDR
                                DPY(JBMDR)<FA
        INCMA;                                          "8. FETCH DI
        DPX(BBR)<MD;
                                FADD DPX(APCI),DPY(BPDI); "AI'=APCI+BPDI
                                DPY(JBMDI)<FA;
                                BIFN INV                "BRANCH IF INVERSE
"
"
"FORWARD FFT......
        DPX(BI)<MD;                                     "9.
                                FSUB DPX(AMCR),DPY(JBMDR); "BR'=AMCR-JBMDR
                                MI<FA; ADD MDEL,WRITE; SETMA;"STORE AR'
                                BR SKIP
"
"
".............................................................
"
"THIS IS LOGICALLY THE END OF THE LOOP ...
"
BACK:   FADD DPY(AI),DPX(CI);                           "16. APCI=AI+CI
                                MI<FA; INCMA;           "STORE DI'
                                BR LOOP
"
"....................................................................
"
"
SKIP:   DPY(DR)<MD;                                     "10.
        ADD RDEL,READ;                                  "ADVANCE READ
                                FSUB DPX(AMCI),DPY(JBMDI); "BI'=AMCI-JBMDI
                                MI<FA; INCMA            "STORE AI'
        DPY(DI)<MD;                                     "11.
                                FSUB DPY(APCR),DPX(BPDR); "CR'=APCR-BPDR
                                MI<FA; ADD MDEL,WRITE; SETMA "STORE BR'
                                FSUB DPX(APCI),DPY(BPDI); "12. CI'=APCI-BPDI
                                MI<FA; INCMA            "STORE BI'
                                FADD DPX(AMCR),DPY(JBMDR); "13. DR'=AMCR+JBMDR
                                MI<FA; ADD MDEL,WRITE; SETMA "STORE CR'
                                FADD DPX(AMCI),DPY(JBMDI); "14. DI'=AMCI+JBMDI
                                MI<FA; INCMA;           "STORE CI'
                                DEC ICTR;               "DONE ???
                                BR COMMON
"
"
"INVERSE FFT ........
INV:    DPX(BI)<MD;                                     "9.
                                FADD DPX(AMCR),DPY(JBMDR); "BR'=AMCR+JBMDR
                                MI<FA; ADD MDEL,WRITE; SETMA "STORE AR'
        DPY(DR)<MD;                                     "10.
        ADD RDEL,READ;                                  "ADVANCE READ
                                FADD DPX(AMCI),DPY(JBMDI); "BI'=AMCI+JBMDI
                                MI<FA; INCMA            "STORE AI'
        DPY(DI)<MD;                                     "11.
                                FSUB DPY(APCR),DPX(BPDR); "CR'=APCR-BPDR
                                MI<FA; ADD MDEL,WRITE; SETMA "STORE BR'
                                FSUB DPX(APCI),DPY(BPDI); "12. CI'=APCI-BPDI
                                MI<FA; INCMA            "STORE BI'
                                FSUB DPX(AMCR),DPY(JBMDR); "13. DR'=AMCR-JBMDR
                                MI<FA; ADD MDEL,WRITE; SETMA "STORE CR'
                                FSUB DPX(AMCI),DPY(JBMDI); "14. DI'=AMCI-JBMDI
                                MI<FA; INCMA;           "STORE CI'
                                DEC ICTR                "DONE ???
"
"
"COMMON AGAIN
COMMON: FADD DPY(AR),DPX(CR);                           "15. APCR=AR+CR
                                MI<FA; ADD MDEL,WRITE; SETMA; "STORE DR'
                                BNE BACK                "GO BACK
"
"
"DONE ..... FINISH UP AND RETURN
                                MI<FA; INCMA;           "16. STORE DI'
                                RETURN                  "RETURN
        $END
"****** FFT2 = RADIX 2 FFT 1ST PASS /FAST/ = REL 2.0  , JAN 78 *****************
"
        $TITLE FFT2
        $RADIX 8
        $ENTRY FFT2                          "USER-DIRECTED-CALL ENTRY
"
"                               --- ABSTRACT ---
"DOES THE FIRST RADIX 2 FFT PASS WHERE THE DATA ARRAY HAS A ODD
"POWER OF TWO NUMBER OF POINTS
"
"
"                               --- STATISTICS ---
"LANGUAGE:                      APAL
"EQUIPMENT:                     AP-120B WITH FAST (1-CYCLE MEMORY)
"SIZE:                          16 PROGRAM LOCATIONS
"AUTHOR:                        A.E. CHRLESWORTH
"DATE:                          JUNE 1976
"
"
"                               --- USEAGE ---
"       DOES THE FIRST PASS OF A COMPLEX FFT WHERE A RADIX 2 PASS IS NEEDED
"
"INPUT PARAMETERS:
"       SPAD #   NAME   PURPOSE
"       0        BASE   BASE ADDRESS OF ARRAY
"       15       MDEL   MEMORY DELTA (BETWEEN COMPLEX POINTS)
"       16       ICOUNT # OF PAIRS OF COMPLEX POINTS
"
"SCRATCH:
"S-PAD:   3-5
"DATA PAD X:  0-1  (RELATIVE TO DPA)
"DATA PAD Y:  0-3  (RELATIVE TO DPA)
"
"
"                               --- ALGORITHM ---
"
"SINCE THIS IS THE FIRST PASS OF THE FFT, THE TWIDDLE FACTORS ARE 0.0,
"  AND HENCE NO MULTIPLIES NEED BE DONE.
"
"THUS, THE 'BUTTERFLY' IS:
"
"       A' = A + C
"       C' = A - C
"
"WHERE A AND C ARE COMPLEX POINTS
"
"
"
"DATA PAD NAMES:
"       DATA PAD X:
        CR $EQU 0               "C REAL
        CI $EQU 1               "C IMAGINARY
"
"       DATA PAD Y:
        AR $EQU 0               "A REAL
        AI $EQU 1               "A IMAGINARY
        AR1 $EQU 2
        AI1 $EQU 3
"
"
"S-PAD NAMES:
"
"THIS IS NOT CHANGED
        BASE $EQU 0             "BASE ADDRESS OF ARRAY
"
"SCRATCH VARIABLES
        READ $EQU 3             "READ POINTER
        WRITE $EQU 4            "WRITE POINTER
        ICTR $EQU 5             "LOOP COUNTER
"
"THESE DETERMINE THE PASS AND ARE SET BY THE MAIN PROGRAM
        MDEL $EQU 15            "MEMORY DELTA
        ICOUNT $EQU 16          "LOOP COUNT
"
"
"
"INTRO TO THE LOOP ...
"INITIALIZE POINTERS:
"READ<BASE
"WRITE<BASE-MDEL
"ICTR<ICOUNT
"
FFT2:   MOV BASE,READ; SETMA                            "1. FETCH AR
        INCMA                                           "2. FETCH AI
        ADD MDEL,READ; SETMA                            "3. FETCH CR
        INCMA;                                          "4. FETCH CI
        DPY(AR)<MD
        DPY(AI)<MD;                                     "5.
        MOV ICOUNT,ICTR                                 "SET LOOP COUNTER
        DPX(CR)<MD;                                     "6.
        MOV BASE,WRITE
        DPX(CI)<MD;                                     "7.
        SUB MDEL,WRITE;                                 "SET WRITE=DEST-MDEL
        BR LOOPST
"
"
"THE LOOP .....
LOOP:                           MI<FA; INCMA            "8. STORE CI'
LOOPST: ADD MDEL,READ; SETMA;                           "1. FETCH AR
                                DPY(AR1)<DPY(AR)
        INCMA;                                          "2. FETCH AI
                                DPY(AI1)<DPY(AI)
        ADD MDEL,READ; SETMA;                           "3. FETCH CR
                                FADD DPY(AR1),DPX(CR)   "AR'=AR+CR
        INCMA;                                          "4. FETCH CI
        DPY(AR)<MD;
                                FADD DPY(AI1),DPX(CI)   "AI'=AI+CI
        DPY(AI)<MD;                                     "5.
                                FSUB DPY(AR1),DPX(CR);  "CR'=AR-CR
                                MI<FA; ADD MDEL,WRITE; SETMA "STORE AR'
        DPX(CR)<MD;                                     "6.
                                FSUB DPY(AI1),DPX(CI);  "CI'=AI-CI
                                MI<FA; INCMA;           "STORE AI'
                                DEC ICTR                "SEE IF DONE???
        DPX(CI)<MD;                                     "7.
                                MI<FA; ADD MDEL,WRITE; SETMA;"STORE CR'
                                FADD;
                                BNE LOOP                "GO BACK
"
"
"FINISH UP THE LAST LOOP ...
                                MI<FA; INCMA;           "8. STORE CI'
                                RETURN
        $END
"****** FFT4 = RADIX 4 FFT PASS /FAST/ = REL 2.0  , JAN 78 *********************
"
        $TITLE FFT4
        $RADIX 8
        $ENTRY FFT4                          "USER-DIRECTED-CALL ENTRY
"
"
"
"                               --- ABSTRACT ---
"DOES ONE RADIX 4 COMPLEX FFT PASS
"
"
"                               --- STASTICS ---
"LANGUAGE:                      APAL
"EQUIPMENT:                     AP-120B WITH FAST (1 CYCLE) MEMORY
"PROGRAM SIZE:                  79 LOCATIONS
"AUTHOR:                        A.E. CHARLESWORTH
"DATE:  JUNE 76
"
"
"                               --- USEAGE ---
"
"DOES ONE RADIX 4 FFT PASS, AS DETERMINED BY:
"
"       S-PAD REG   NAME     PURPOSE
"
"       14          WD       W (TWIDDLE FACTOR) DELTA
"       15          MDEL     MEMORY DELTA
"       16          ICOUNT   NUMBER OF I-LOOPS IN THIS PASS
"       17          JCOUNT   NUMBER OF J-LOOPS IN THIS PASS
"
"
"SCRATCH:
"       S-PAD:  2 TO 12
"       DATA PAD X:  -4 TO +3 (RELATVE TO DPA)
"       DATA PAD Y:  -4 TO +3
"
"
"                               --- ALGORITHM ---
"
"PROGRAM FLOW:
"
"THE NAMES BELOW ARE ALL PROGRAM LABELS, THE TOP TO BOTTOM ORDER BELOW
"  REFLECTS THE TOP TO BOTTOM ORDER OF THE CODE
"
"   A   V   <   >   ARE ALL ARROWS
"
"                FFT4
"                  !
"   !<-------------!
"   !              V
"   !           ILOOP<-------!
"   !              !         A
"   !              V         !
"   !           ILOOP4<----------------!
"   !              !         !         A
"   !              !      IBACK        !
"   !              V         A       TOIL3
"   !    !<------ISKP        !         A
"   !    V         !         !         !
"   !  IFOR        V         !         !
"   !    !        INV        !         !
"   !    !         !         !         !
"   !    !-------->!         !         !
"   !              V         !         !
"   !            ICOM------->!         !
"   !              !                   !
"   !              V                 TOIL2
"   !---------->JLOOP<-------!         A
"                  !         A         !
"                  !         !         !
"                  !       JBACK       !
"                  V         A       TOIL1
"        !<------JSKP        !         A
"        V         !         !         !
"  !<--JFOR        V         !         !
"  !     !        JNV-->!    !         !
"  !     V         !    !    !         !
"  !     !-------->!    !    !         !
"  !               V    !    !         !
"  !             JCOM------->!         !
"  !               !    !              !
"  !               !------------------>!
"  V                    !
"FDONE                  V
"  !                  IDONE
"  !                    !
"  !-------------->!<---!
"                  !
"                  V
"               DONCOM
"                  !
"                  V
"               RETURN
"
"
"
"A RADIX 4 FFT PASS INVOLVES FETCHING, PROCESSING,
"       AND STORING ALL OF THE DATA POINTS, 4 COMPLEX POINTS AT A TIME.
"
"       TWO NESTED LOOPS ARE INVOLVED IN A PASS:
"          J-LOOP
"               I-LOOP
"
"          I-LOOP DOES THE 'BUTTERFLIES' ON QUADS OF POINTS, 'MDEL'
"          LOCATIONS APART IN MEMORY, STARTING AT THE START OF THE ARRAY
"          AND WORKING TOWARD THE END OF THE ARRAY.  A FIXED SET OF
"          TWIDDLE FACTORS (W, W**2, W**3) IS USED THROUGHOUT AN I-LOOP
"
"          J-LOOP RESETS THE I-LOOP TO THE TOP OF THE ARRAY AND ADVANCES
"          THE TWIDDLE FACTOR 'W' BY 'WD'
"
"          JCOUNT IS THE NUMBER OF J-LOOPS
"          ICOUNT IS THE NUMBER OF I-LOOPS
"
"
"
"THE RADIX 4 BUTTERFLY IS AS FOLLOWS:
"
"1.     FOUR COMPLEX POINTS:  A, C, B, D
"       ARE FETCHED IN THAT ORDER FROM MEMORY
"
"2.     THREE COMPLEX MULTIPLIES ARE DONE:
"       B = B * W
"       C = C * W**2
"       D = D * W**3
"
"
"3.     THEN THE FOLLOWING SET OF COMPLEX ADDS & SUBTRACTS ARE DONE
"       A' = A +  B + C +  D
"       B' = A -+JB - C +-JD
"       C' = A -  B + C -  D
"       D' = A +-JB - C -+JD
"
"           -+ MEANS - FOR FORWARD FFT, + FOR INVERSE FFT
"           +- MEANS + FOR FORWARD FFT, - FOR INVERSE FFT
"
"
"4.     A', B', C', D' ARE THEN STORED BACK INTO MEMORY
"
"
"TO MINIMIZE COMPLEX ADDS THE COMPUTATION IN THE BUTTERFLY IS
"       FACTORED AS FOLLOWS:
"
"
"       APC = A + C
"       AMC = A - C
"       BPD = B + D
"       JBMD - J * (B - D) = (DI-BI, BR-DR)
"
"       A' = APC + BPD
"       C' = APC - BPD
"
"DIRECT FFT:
"       B' = AMC - JBMD
"       D' = AMC + JBMD
"
"INVERSE FFT:
"       B' = AMC + JBMD
"       D' = AMC - JBMD
"
"
"THIS GIVES A TOTAL OF 22 REAL ADDS AND 12 REAL MULTIPLIES
"
"
"
"OUTLINE OF THE INNER LOOP COMPUTATION:
"
"       PASS #1 OF THE LOOP     PASS #2 OF THE LOOP
"       FOR A GIVEN QUAD        FOR A GIVEN QUAD
"
"1.     FETCH AR                AMCR=AR-CR
"                               SAVE APCR
"
"2.     FETCH AI                AMCI=AI-CI
"                               SAVE APCI
"
"3.     FETCH CR                BR=BRR-BII
"                               SAVE AMCR
"
"4.     FETCH W2R               BI=BRI+BIR
"       SAVE AR                 SAVE AMCI
"
"5.     FETCH CI                DR=DRR-DII
"       FETCH W2I               SAVE BR
"       SAVE AI
"
"6.     CRR=W2R*CR              DI=DRI+DIR
"                               SAVE BI
"
"7.     FETCH BR                BPDR=BR+DR
"       FETCH W2R               SAVE DR
"       CIR=W2I*CR
"
"8.     CII=W2I*CI              BPDI=BI+DI
"       FETCH W1R               SAVE DI
"
"9.     FETCH BI                JBMDR=DI-BI
"       CRI=W2R*CI              SAVE BPDR
"       FETCH W1I
"       SAVE CRR
"
"10.    BRR=W1R*BR              JBMDI=BR-DR
"       SAVE CIR                SAVE BPDI
"
"11.    FETCH DR                SAVE JBMDR
"       BIR=W1I*BR
"       CR=CRR-CII
"       FETCH W1R
"
"12.    BII=W1I*BI              SAVE JBMDI
"       CI=CRI+CIR
"       FETCH W3R
"
"13.    FETCH DI                AR'=APCR+BPDR
"       BRI=W1R*BI
"       FETCH W3I
"       SAVE BRR
"       SAVE CR
"
"14.    DRR=W3R*DR              AI'=APCI+BPDI
"       SAVE BIR
"       SAVE CI
"
"15.    DIR=W3I*DR              BR'=AMCR-+JBMDR
"       FETCH W3R               STORE AR
"       SAVE BII
"
"16.    DII=W3I*DI              BI'=AMCI-+JBMDI
"       SAVE BRI                STORE AI'
"
"17.    DRI=W3R*DI              CR'=APCR-BPDR
"       SAVE DRR                STORE BR'
"
"18.    SAVE DIR                CI'=APCI-BPDI
"                               STORE BI'
"
"19.    SAVE DII                DR'=AMCR+-JBDMR
"                               STORE CR'
"
"20.    SAVE DRI                DI'=AMCI+-JBMDI
"                               STORE CI'
"
"21.    APCR=AR+CR              STORE DR'
"
"22.    APCI=AI+CI              STORE DI'
"
"
"
"
"
"DATA PAD X NAMES:
        BPDR $EQU -4            "9 THROUGH 17    BR + DR
        DRR  $EQU -4            "17 THROUGH 5    W3R * DR
        BPDI $EQU -3            "10 THROUGH 18   BI + DI
        DIR  $EQU -3            "18 THROUGH 6    W3I * DR
        AMCR $EQU -2            "                 AR - CR
        AMCI $EQU -1            "                 AI - CI
        CR   $EQU  0            "                 C REAL
        CI   $EQU  1            "                 C IMAGINARY
        BBR  $EQU  2            "5 THROUGH 10     B REAL
        BII  $EQU  2            "15 THROUGH 3     W1I * BI
        BI   $EQU  3            "6 THROUGH 9      B IMAGINARY
        BRI  $EQU  3            "14 THROUGH 4     W1R * BI
"DATA PAD Y NAMES:
        APCR $EQU -4            "                 AR + CR
        APCI $EQU -3            "                 AI + CI
        JBMDR $EQU -2           "11 THROUGH 19    J * (BR - DR)
        DII  $EQU -2            "19 THROUGH 5     W3I * DI
        CRR  $EQU -2            "9 THROUGH 11     W2R * CR
        JBMDI $EQU -1           "12 THROUGH 20    J * (BI - DR)
        DRI  $EQU -1            "20 THROUGH 6     W3R * DI
        CIR  $EQU -1            "10 THROUGH 12    W2I * CR
        AR   $EQU  0            "                 A REAL
        AI   $EQU  1            "                 A IMAGINARY
        DR   $EQU  2            "7 THROUGH 10     D REAL
        BRR  $EQU  2            "13 THROUGH 3     W1R * BR
        DI   $EQU  3            "8 THROUGH 9      D IMAGINARY
        BIR  $EQU  3            "16 THROUGH 4     W1I * BR
"S-PAD NAMES:
"
"THESE ARE NOT ALTERED TROUGHOUT THE PASS
"   (THEY WERE INPUT TO THE MAIN ROUTINE)
        BASE   $EQU  0          "BASE ADDRESS OF ARRAY
        N      $EQU  1          "# OF COMPLEX POINTS (NOT USED HERE)
"
"THESE ARE SCRATCH VARIABLES
        JBASE  $EQU  2          "BASE FOR EACH J-LOOP
        READ   $EQU  3          "READ POINTER
        WRITE  $EQU  4          "WRITE POINTER
        ICTR   $EQU  5          "I-LOOP COUNTER
        JCTR   $EQU  6          "J-LOOP COUNTER
        TEMP   $EQU  7          "TEMPORARY
        W1     $EQU 10          "W**1 POINTER
        W2     $EQU 11          "W**2 POINTER
        W3     $EQU 12          "W**3 POINTER
"
"THIS IS A CONSTANT SET BY THE MAIN PROGRAM
        MINC   $EQU 13          "MEMORY INCREMENT OF THE ARRAY
"
"THESE ARE VARIABLES WHICH DETERMINE WHICH PASS IT IS, THEY ARE
"  ALTERED BY THE MAIN PROGRAM
        WD     $EQU 14          "W DELTA
        MDEL   $EQU 15          "MEMORY DELTA
        ICOUNT $EQU 16          "I-LOOP COUNT
        JCOUNT $EQU 17          "J-LOOP COUNT
"INTRO TO ILOOP
"
"INITIALIZE POINTERS:
"
"JBASE<BASE
"READ<JBASE
"WRITE<JBASE-MDEL
"ICTR<ICOUNT
"JCTR<JCOUNT
"W1<0
"W2<0
"W3<0
"
"
"START COMPUTATION:
"
"FETCH AR,AI,CR,CI
"SET: BRR=BR, BRI=BI, DRR=DR, DRI=DI
"SET: BIR=0.0, BII=0.0, DIR=0.0, DII=0.0
"
"
FFT4:   MOV BASE,JBASE                                  "SET JBASE
        MOV ICOUNT,ICTR                                 "SET ICTR
        MOV JBASE,READ; SETMA                           "FETCH AR
        INCMA;                                          "FETCH AI
           MOV JBASE,WRITE;
           DPX(BII)<ZERO;                               "BII=0.0
           DPY(BIR)<ZERO                                "BIR=0.0
        ADD MDEL,READ; SETMA;                           "FETCH CR
           DPX(DIR)<ZERO;                               "DIR=0.0
           DPY(DII)<ZERO                                "DII=0.0
        INCMA;                                          "FETCH CI
           DPY(AR)<MD;
           SUB MDEL,WRITE                               "SET WRITE
        ADD MDEL,READ; SETMA;                           "FETCH BR
           DPY(AI)<MD
        INCMA;                                          "FETCH BI
           DPX(CR)<MD;
           CLR W1                                       "CLEAR W1
        ADD MDEL,READ; SETMA;                           "FETCH DR
           DPX(CI)<MD
        INCMA;                                          "FETCH DI
           DPY(BRR)<MD;
           CLR W2                                       "CLEAR W2
        DPX(BRI)<MD;
           CLR W3                                       "CLEAR W3
        DPX(DRR)<MD;
           FADD DPY(AR),DPX(CR);                        "APCR=AR+CR
           DEC ICTR                                     "GO TO J-LOOP ???
        DPY(DRI)<MD;
           FADD DPY(AI),DPX(CI);                        "APCI=AI+CI
           MOV JCOUNT,JCTR;                             "SET JCTR
                                                        "TO I-LOOP
           BNE ILOOP                                    "IF NOT YET ZERO
"
"
"IF ICTR ALREADY ZERO, GO TO J-LOOP
        JMP JLOOP
"
"
"
ILOOP:  ADD MDEL,READ; SETMA;                           "1. FETCH AR
                                FSUB DPY(AR),DPX(CR);   "AMCR=AR-CR
                                DPY(APCR)<FA
        INCMA;                                          "2. FETCH AI
                                FSUB DPY(AI),DPX(CI);   "AMCI=AI-CI
                                DPY(APCI)<FA
        ADD MDEL,READ; SETMA;                           "3. FETCH CR
                                FSUB DPY(BRR),DPX(BII); "BR=BRR-BII
                                DPX(AMCR)<FA
ILOOP4: MOV W2,W2; SETTMA;                              "4. FETCH W2R
        DPY(AR)<MD;
                                FADD DPX(BRI),DPY(BIR); "BI=BRI+BIR
                                DPX(AMCI)<FA
        INCMA;                                          "5. FETCH CI
        INCTMA;                                         "FETCH W2I
        DPY(AI)<MD;
                                FSUB DPX(DRR),DPY(DII); "DR=DRR-DII
                                DPX(BBR)<FA
        FMUL TM,MD;                                     "6. W2R*CR
                                FADD DPY(DRI),DPX(DIR); "DI=DRI+DIR
                                DPX(BI)<FA
        ADD MDEL,READ; SETMA;                           "7. FETCH BR
        DECTMA;                                         "FETCH W2R
        FMUL TM,MD;                                     "CIR=W2I*CR
                                FADD DPX(BBR),FA;       "BPDR=BR+DR
                                DPY(DR)<FA
        MOV W1,W1; SETTMA;                              "8. FETCH W1R
        FMUL TM,MD;                                     "CII=W2I*CI
                                FADD DPX(BI),FA;        "BPDI=BI+DI
                                DPY(DI)<FA
        INCMA;                                          "9. FETCH BI
        INCTMA;                                         "FETCH W1I
        FMUL TM,MD;                                     "CRI=W2R*CI
        DPY(CRR)<FM;
                                FSUB DPY(DI),DPX(BI);   "JBMDR=DI-BI
                                DPX(BPDR)<FA
        FMUL TM,MD;                                     "10. BRR=W1R*BR
        DPY(CIR)<FM;
                                FSUB DPX(BBR),DPY(DR);  "JBMDI=BR-DR
                                DPX(BPDI)<FA
        ADD MDEL,READ; SETMA;                           "11. FETCH DR
        DECTMA;                                         "FETCH W1R
        FMUL TM,MD;                                     "BIR=W1I*BR
        FSUBR FM,DPY(CRR);                              "CR=CRR-CII
                                DPY(JBMDR)<FA
        MOV W3,W3; SETTMA;                              "12. FETCH W3R
        FMUL TM,MD;                                     "BII=W1I*BI
        FADD FM,DPY(CIR);                               "CI=CRI+CIR
                                DPY(JBMDI)<FA
        INCMA;                                          "13. FETCH DI
        INCTMA;                                         "FETCH W3I
        FMUL TM,MD;                                     "BRI=W1R*BI
        DPY(BRR)<FM;
        DPX(CR)<FA;
                                FADD DPY(APCR),DPX(BPDR);"AR'=APCR+BPDR
                                BR ISKP                 "SKIP AROUND
"
"
"
"...................................................................
"THIS INSTRUCTION IS ACTUALLY THE LAST
"INSTRUCTION OF ILOOP, IT IS INSERTED HERE SO THAT THE LOOP CAN
"BE CLOSED WITH 'BRANCH' OP-CODES, WHICH HAVE A MAXIMUM
"RANGE OF -16 TO + 15
"
IBACK:  FADD DPY(AI),DPX(CI);                           "22. APCI=AI+CI
                                INCMA; MI<FA;           "STORE DI'
                                BR ILOOP                "LOOP AGAIN
"
"
"HERE IS TOIL3 ON THE WAY TO ILOOP AT ILOOP4
"
TOIL3:  ADD MDEL,READ; SETMA;                           "3. FETCH CR
                                FSUB DPY(BRR),DPX(BII); "BR=BRR-BII
                                DPX(AMCR)<FA;
                                BR ILOOP4
"
".......................................................................
"
"
"
"
ISKP:   FMUL TM,MD;                                     "14. DRR=W3R*DR
        DPY(BIR)<FM;
        DPX(CI)<FA;
                                FADD DPY(APCI),DPX(BPDI);"AI'=APCI+BPDI
                                BIFN INV                "INVERSE FFT???
"
"FORWARD FFT, COMPUTE B', C', AND D'
IFOR:   DECTMA;                                         "15. FETCH W3R
        FMUL TM,MD;                                     "DIR=W3I*DR
        DPX(BII)<FM;
                                FSUB DPX(AMCR),DPY(JBMDR); "BR'=AMCR-JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE AR'
        FMUL TM,MD;                                     "16. DII=W3I*DI
        DPX(BRI)<FM;
                                FSUB DPX(AMCI),DPY(JBMDI); "BI'=AMCI-JBMDI
                                INCMA; MI<FA            "STORE AI'
        FMUL TM,MD;                                     "17. DRI=W3R*DI
        DPX(DRR)<FM;
                                FSUB DPY(APCR),DPX(BPDR); "CR'=APCR-BPDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE BR'
        DPX(DIR)<FM;                                    "18.
        FMUL;                                           "PUSH
                                FSUB DPY(APCI),DPX(BPDI); "CI'=APCI-BPDI
                                INCMA; MI<FA            "STORE BI'
        DPY(DII)<FM;                                    "19.
        FMUL;                                           "PUSH
                                FADD DPX(AMCR),DPY(JBMDR); "DR'=AMCR+JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE CR
        DPY(DRI)<FM;                                    "20.
                                FADD DPX(AMCI),DPY(JBMDI); "DI'=AMCI+JBMDI
                                INCMA; MI<FA;           "STORE CI'
                                DEC ICTR;               "ILOOP DONE???
                                BR ICOM                 "BACK TOGETHER
"
"
"INVERSE FFT: COMPUTE B',C', AND D'
INV:    DECTMA;                                         "15. FETCH W3R
        FMUL TM,MD;                                     "DIR=W3I*DR
        DPX(BII)<FM;
                                FADD DPX(AMCR),DPY(JBMDR); "BR'=AMCR+JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE AR'
        FMUL TM,MD;                                     "16. DII=W3I*DI
        DPX(BRI)<FM;
                                FADD DPX(AMCI),DPY(JBMDI); "BI'=AMCI+JBMDI
                                INCMA; MI<FA            "STORE AI'
        FMUL TM,MD;                                     "17. DRI=W3R*DI
        DPX(DRR)<FM;
                                FSUB DPY(APCR),DPX(BPDR); "CR'=APCR-BPDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE BR'
        DPX(DIR)<FM;                                    "18.
        FMUL;                                           "PUSH
                                FSUB DPY(APCI),DPX(BPDI); "CI'=APCI-BPDI
                                INCMA; MI<FA            "STORE BI'
        DPY(DII)<FM;                                    "19.
        FMUL;                                           "PUSH
                                FSUB DPX(AMCR),DPY(JBMDR); "DR'=AMCR-JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE CR
        DPY(DRI)<FM;                                    "20.
                                FSUB DPX(AMCI),DPY(JBMDI); "DI'=AMCI-JBMDI
                                INCMA; MI<FA;           "STORE CI'
                                DEC ICTR                "ILOOP DONE ???
"
"
"BACK TOGETHER AGAIN
ICOM:   FADD DPY(AR),DPX(CR);                           "21. APCR=AR+CR
                                ADD MDEL,WRITE; SETMA; MI<FA;"STORE DR'
                                BNE IBACK               "BRANCH IF NOT DONE
"
"
"
"COME HERE WHEN DONE WITH ILOOP,
"       DO #22 AND THEN FALL INTO JLOOP
"
        FADD DPY(AI),DPX(CI);                           "22. APCI=AI+CI
                                INCMA; MI<FA;           "STORE DI'
                                BR JLOOP
"
"
"
"................................................................
"
"HERE IS TOIL2 ON THE WAY BACK TO ILOOP
"
TOIL2:  INCMA;                                          "2. FETCH AI
                                FSUB DPY(AI),DPX(CI);   "AMCI=AI-CI
                                DPY(APCI)<FA;
                                BR TOIL3
"
"...................................................................
"
"
"
"
"RESETING OF POINTERS FOR J-LOOP
"
"JBASE<JBASE+2
"READ<JBASE
"W1<W1+WD
"W2<W1*2
"W3<W1*3
"ICTR<ICOUNT
"
"
"WRITE<JBASE-MDEL
"
JLOOP:  ADD MINC,JBASE;  SETMA;                         "1. FETCH AR
                                                        "ADVANCE JBASE
                                FSUB DPY(AR),DPX(CR);   "AMCR=AR-CR
                                DPY(APCR)<FA
        INCMA;                                          "2. FETCH AI
        ADD WD,W1;                                      "ADVANCE W1
                                FSUB DPY(AI),DPX(CI);   "AMCI=AI-CI
                                DPY(APCI)<FA
        ADD MDEL,JBASE; SETMA;                          "3. FETCH CR
                                                        "ADVANCE JBASE ONE
                                                        "STEP TOO FAR
                                FSUB DPY(BRR),DPX(BII); "BR=BRR-BII
                                DPX(AMCR)<FA
        MOVL W1,W2; SETTMA;                             "4. FETCH W2R
                                                        "W2=W1*2
        DPY(AR)<MD;
                                FADD DPX(BRI),DPY(BIR); "BI=BRI+BIR
                                DPX(AMCI)<FA
        INCMA;                                          "5. FETCH CI
        MOV JBASE,READ;                                 "SET READ=JBASE
        INCTMA;                                         "FETCH W2I
        DPY(AI)<MD;
                                FSUB DPX(DRR),DPY(DII); "DR=DRR-DII
                                DPX(BBR)<FA
        FMUL TM,MD;                                     "6. W2R*CR
        SUB MDEL,JBASE;                                 "RESET JBASE
                                FADD DPY(DRI),DPX(DIR); "DI=DRI+DIR
                                DPX(BI)<FA
        ADD MDEL,READ; SETMA;                           "7. FETCH BR
        DECTMA;                                         "FETCH W2R
        FMUL TM,MD;                                     "CIR=W2I*CR
                                FADD DPX(BBR),FA;       "BPDR=BR+DR
                                DPY(DR)<FA
        MOV W1,W1; SETTMA;                              "8. FETCH W1R
        FMUL TM,MD;                                     "CII=W2I*CI
                                FADD DPX(BI),FA;        "BPDI=BI+DI
                                DPY(DI)<FA
        INCMA;                                          "9. FETCH BI
        MOV JBASE,TEMP;                                 "TO SETUP WRITE
        INCTMA;                                         "FETCH W1I
        FMUL TM,MD;                                     "CRI=W2R*CI
        DPY(CRR)<FM;
                                FSUB DPY(DI),DPX(BI);   "JBMDR=DI-BI
                                DPX(BPDR)<FA
        FMUL TM,MD;                                     "10. BRR=W1R*BR
        MOV W2,W3;                                      "TO SETUP W3
                                                        "TO W1+W2
        DPY(CIR)<FM;
                                FSUB DPX(BBR),DPY(DR);  "JBMDI=BR-DR
                                DPX(BPDI)<FA
        ADD MDEL,READ; SETMA;                           "11. FETCH DR
        DECTMA;                                         "FETCH W1R
        FMUL TM,MD;                                     "BIR=W1I*BR
        FSUBR FM,DPY(CRR);                              "CR=CRR-CII
                                DPY(JBMDR)<FA
        ADD W1,W3; SETTMA;                              "12. FETCH W3R
                                                        "W3=W1*3
        FMUL TM,MD;                                     "BII=W1I*BI
        FADD FM,DPY(CIR);                               "CI=CRI+CIR
                                DPY(JBMDI)<FA
        INCMA;                                          "13. FETCH DI
        SUB MDEL,TEMP;                                  "SETUP WRITE
        INCTMA;                                         "FETCH W3I
        FMUL TM,MD;                                     "BRI=W1R*BI
        DPY(BRR)<FM;
        DPX(CR)<FA;
                                FADD DPY(APCR),DPX(BPDR);"AR'=APCR+BPDR
                                BR JSKP                 "SKIP AROUND
"
"
"
"...................................................................
"THIS INSTRUCTION IS ACTUALLY THE LAST
"INSTRUCTION OF JLOOP, IT IS INSERTED HERE SO THAT THE LOOP CAN
"BE CLOSED WITH 'BRANCH' OP-CODES, WHICH HAVE A MAXIMUM
"RANGE OF -16 TO + 15
"
JBACK:  FADD DPY(AI),DPX(CI);                           "22. APCI=AI+CI
        MOV TEMP,WRITE;                                 "WRITE=JBACK-MDEL
                                INCMA; MI<FA;           "STORE DI'
                                BR JLOOP                "LOOP AGAIN
"
"
"HERE IS TOIL1 ON THE WAY BACK TO ILOOP
"
TOIL1:  ADD MDEL,READ; SETMA;                           "1. FETCH AR
                                FSUB DPY(AR),DPX(CR);   "AMCR=AR-CR
                                DPY(APCR)<FA;
                                BR TOIL2
"
".......................................................................
"
"
"
"
JSKP:   FMUL TM,MD;                                     "14. DRR=W3R*DR
        DPY(BIR)<FM;
        DPX(CI)<FA;
                                FADD DPY(APCI),DPX(BPDI);"AI'=APCI+BPDI
                                BIFN JNV                "INVERSE FFT???
"
"FORWARD FFT, COMPUTE B', C', AND D'
JFOR:   DECTMA;                                         "15. FETCH W3R
        FMUL TM,MD;                                     "DIR=W3I*DR
        DPX(BII)<FM;
                                FSUB DPX(AMCR),DPY(JBMDR); "BR'=AMCR-JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE AR'
        FMUL TM,MD;                                     "16. DII=W3I*DI
        MOV ICOUNT,ICTR;                                "RESET ICTR=ICOUNT
        DPX(BRI)<FM;
                                FSUB DPX(AMCI),DPY(JBMDI); "BI'=AMCI-JBMDI
                                INCMA; MI<FA            "STORE AI'
        FMUL TM,MD;                                     "17. DRI=W3R*DI
        DPX(DRR)<FM;
                                FSUB DPY(APCR),DPX(BPDR); "CR'=APCR-BPDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE BR'
        DPX(DIR)<FM;                                    "18.
        FMUL;                                           "PUSH
                                FSUB DPY(APCI),DPX(BPDI); "CI'=APCI-BPDI
                                INCMA; MI<FA;           "STORE BI'
                                DEC JCTR                "JLOOP DONE ???
        DPY(DII)<FM;                                    "19.
        FMUL;                                           "PUSH
                                FADD DPX(AMCR),DPY(JBMDR); "DR'=AMCR+JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA;"STORE CR
                                BEQ FDONE               "BRANCH IF JLOOP DONE
        DPY(DRI)<FM;                                    "20.
                                FADD DPX(AMCI),DPY(JBMDI); "DI'=AMCI+JBMDI
                                INCMA; MI<FA;           "STORE CI'
                                DEC ICTR;               "ILOOP DONE???
                                BR JCOM                 "BACK TOGETHER
"
"
"INVERSE FFT: COMPUTE B',C', AND D'
JNV:    DECTMA;                                         "15. FETCH W3R
        FMUL TM,MD;                                     "DIR=W3I*DR
        DPX(BII)<FM;
                                FADD DPX(AMCR),DPY(JBMDR); "BR'=AMCR+JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE AR'
        FMUL TM,MD;                                     "16. DII=W3I*DI
        MOV ICOUNT,ICTR;                                "RESET ICTR=ICOUNT
        DPX(BRI)<FM;
                                FADD DPX(AMCI),DPY(JBMDI); "BI'=AMCI+JBMDI
                                INCMA; MI<FA            "STORE AI'
        FMUL TM,MD;                                     "17. DRI=W3R*DI
        DPX(DRR)<FM;
                                FSUB DPY(APCR),DPX(BPDR); "CR'=APCR-BPDR
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE BR'
        DPX(DIR)<FM;                                    "18.
        FMUL;                                           "PUSH
                                FSUB DPY(APCI),DPX(BPDI); "CI'=APCI-BPDI
                                INCMA; MI<FA;           "STORE BI'
                                DEC JCTR                "JLOOP DONE ???
        DPY(DII)<FM;                                    "19.
        FMUL;                                           "PUSH
                                FSUB DPX(AMCR),DPY(JBMDR); "DR'=AMCR-JBMDR
                                ADD MDEL,WRITE; SETMA; MI<FA;"STORE CR
                                BEQ IDONE               "BRANCH IF JLOOP DONE
        DPY(DRI)<FM;                                    "20.
                                FSUB DPX(AMCI),DPY(JBMDI); "DI'=AMCI-JBMDI
                                INCMA; MI<FA;           "STORE CI'
                                DEC ICTR                "ILOOP DONE ???
"
"
"BACK TOGETHER AGAIN
JCOM:   FADD DPY(AR),DPX(CR);                           "21. APCR=AR+CR
                                ADD MDEL,WRITE; SETMA; MI<FA;"STORE DR'
                                BEQ JBACK               "BRANCH IF WE MUST
                                                        "STAY IN JLOOP
"
"
"COME HERE IF WE MUST LOOP BACK TO ILOOP . . . WHICH WE DO
"       IN THREE STEPS
"
        FADD DPY(AI),DPX(CI);                           "22. APCI=AI+CI
        MOV TEMP,WRITE;                                 "WRITE=JBASE-MDEL
                                INCMA; MI<FA;           "STORE DI'
                                BR TOIL1
"
"
"
"COME HERE WHEN DONE WITH A FORWARD FFT PASS
"
FDONE:                          FADD DPX(AMCI),DPY(JBMDI); "20. DI'=AMCI+JBMDI
                                INCMA; MI<FA;            "STORE CI'
                                BR DONCOM
"
"
"COME HERE WHEN DONE WITH AN INVERSE FFT PASS
"
IDONE:                          FSUB DPX(AMCI),DPY(JBMDI); "20. DI'=AMCI-JBMDI
                                INCMA; MI<FA            "STORE CI'
"
"
"COMMON WHEN DONE WITH A PASS
DONCOM:                         FADD;                   "21. PUSH
                                ADD MDEL,WRITE; SETMA; MI<FA "STORE DR'
                                INCMA; MI<FA;           "22. STORE DI'
                                RETURN
        $END
"****** STSTAT = (STATUS) SET FFT STATUS REGISTERS /COMMON/ = REL 2.0  , JAN 78
"****** CLSTAT = (STATUS) CLEAR FFT STAT REGISTERS /COMMON/ = REL 2.0  , JAN 78
"****** ILOG2  = (STATUS) LOGARITHM BASE 2 /COMMON/ = REL 2.0  , JAN 78 ********
"   FOR EITHER MEMORY
"
        $TITLE STATUS
        $RADIX 8
        $ENTRY STSTAT                          "USER-DIRECTED-CALL ENTRY
        $ENTRY CLSTAT                          "USER-DIRECTED-CALL ENTRY
        $ENTRY ILOG2                          "USER-DIRECTED-CALL ENTRY
"FFT UTILITY SUBROUTINES
"
"                  --- ABSTRACT ---
"THESE SUBROUTINES PERFORM THREE TASKS COMMON TO FFT RELATED PROGRAMS
"
"                  --- STATISTICS ---
"LANGUAGE:     AP-120B ASSEMBLER
"EQUIPMENT:    AP-120B WITH EITHER SPEED MEMORY
"STORAGE:      13 PROGRAM LOCATIONS
"AUTHOR:       A.E.CHARLESWORTH
"DATE:         JUNE 1976
"
"                  --- USEAGE ---
"       STSTAT
"SETS THE FFT-MODE AND BIT-REVERSE BITS IN THE AP-STATUS REGISTER
"ARGUMENTS:
"       SP(17)  N:  NUMBER OF COMPLEX POINTS
"       SP(16)  FLAG: +1 FOR DIRECT, -1 FOR INVERSE TRANSFORM
"                               OR 0 FOR NO TRANSFORM
"
"RESULTS:
"       SP(17)  SET TO LOG2(N)
"SCRATCH: SP(14-17)
"
"         CLSTAT
"CLEARS THE FFT MODE BITS IN THE AP STATUS REGISTER
"RESULTS:  AP-STATUS RETURNED IN SP(14)
"SCRATCH: SP(14-15)
"         ILOG2
"COMPUTES  LOG2 ( SP(17) )
"ARGUMENTS:  INPUT   SP(17)
"            ANSWER  SP(17)
"SCRATCH: SP(16-17)
 "STSTAT   ---   SET THE TWO FFT MODE STATUS BITS
"       DEPENDING ON SP(16)
"       AND THE BIT-REVERSE BITS DEPENDING UPON SP(17)
STSTAT: JSR CLSTAT                      "CLEAR THE FIVE BITS
        ADDL 16,16              "SHIFT LEFT 2 PLACES
        LDSPI 15; DB=14         "MASK FOR FFT-MODE BITS
        ANDL 15,16              "PROPER FFT-MODE BITS
        OR 16,14                "OR INTO STATUS REGISTER
        JSR ILOG2               "GET LOG2( SP(17) )
        LDSPI 16; DB=15.        "WE WANT 15.-LOG2(N)
        SUB 17,16               "BIT REVERSE SHIFT
        LDSPI 15; DB=7          "MASK FOR SHIFT
        AND 15,16               "PROPER BIT-REVERSE BITS
        OR 16,14; DB=SPFN;      "OR INTO STATUS REGISTER
          LDAPS; RETURN         "AND RETURN
"CLEAR THE TWO FFT MODE STATUS BITS
CLSTAT: RAPS; LDSPNL 14                 "GET AP STATUS
        LDSPI 15;  DB=177740            "GET MASK
        AND 15,14;  DB=SPFN;            "MASK OUT THE UNWANTED BITS
          LDAPS;  RETURN                "  RESET STATUS
"ILOG2  ---   HERE WE GET LOG2 ( SP(17) )
"NOTE:  IF THE INPUT IS NOT A POWER OF 2,  THE RESULT WILL BE THE
"            NEXT LOWER POWER OF 2
ILOG2:  MOV 17,16
        CLR 17                  "CLEAR OUR COUNTER
"
"
LOOP:   MOVR 16,16                      "DIVIDE BY 2
        INC 17; BGT LOOP                "COUNT UP RESULT
        DEC 17; RETURN          "DECREMENT ANSWER AND RETURN
        $END
"****** ADV4 = (ADV) ADVANCE: RADIX 4 TO RADIX 4 PASS /COMMO= REL 2.0  , JAN 78
"****** ADV2 = (ADV) ADVANCE: RADIX 2 TO RADIX 4 PASS /COMMO= REL 2.0  , JAN 78
"
        $TITLE ADV
        $RADIX 8
        $ENTRY ADV4                          "USER-DIRECTED-CALL ENTRY
        $ENTRY ADV2                          "USER-DIRECTED-CALL ENTRY
"
"                               --- ABSTRACT ---
"
"ADVANCES THE POINTERS USED IN AN FFT FROM ONE PASS TO ANOTHER
"
"
"                               --- STATISTICS ---
"EQUIPMENT:                     AP-120B WITH EITHER MEMORY
"SIZE:                          7 LOCATIONS
"
"         --- HISTORY ---
"ORIGINAL:  JUN 76  A.E. CHARLESWORTH
" REV 2.1:  JUL 77  R.S. NORIN         MINOR MOD TO SAVE 1 WORD
"
"
"
"                               --- USEAGE ---
"THIS IS 'CALLED' AT THE END OF EACH PASS OF AN FFT,
"   ADV4   FOR A RADIX 4 PASS
"   ADV2   FOR A RADIX 2 PASS
"
"THE FOUR PARAMETERS WHICH DEFINE THE PASS OF AN FFT
"ARE UPDATED:
"
"       S-PAD #   NAME    PURPOSE
"       14        WD      W DELTA (INCREMENT BETWEEN SUCESSIVE W'S)
"       15        MDEL    MEMORY DELTA (INCREMENT BETWEEN COMPLEX PAIRS)
"       16        ICOUNT  I-LOOP COUNT
"       17        JCOUNT  J-LOOP COUNT
"
"
"THESE ARE ADVANCED AS FOLLOWS:
"
"       WD = WD / R
"       MDEL = MDEL * R
"       JCOUNT = JCOUNT * R
"       ICOUNT = ICOUNT / 4
"
"WHERE 'R' IS THE RADIX OF THE PRECEEDING FFT PASS,
"   EITHER 2 OR 4.
"
"IN ADDITION, THE LAST 'SPFN' IS ICOUNT / 4
"WHICH SHOULD BE TESTED BY THE CALLING PROGRAM IN THE
"INSTRUCTION FOLLOWING THE RETURN TO SEE WHETHER THE
"FFT IS DONE.
"
"THE FFT IS DONE WHEN ICOUNT IS SHIFTED DOWN TO ZERO
"
"
"                               --- SCRATCH ---
"NONE
"
"
"
"S-PAD DEFINITIONS:
"
        WD     $EQU 14          "W DELTA
        MDEL   $EQU 15          "MEMORY DELTA
        ICOUNT $EQU 16          "I-LOOP COUNT
        JCOUNT $EQU 17          "J-LOOP COUNT
"
"
"ADVANCE POINTERS FROM ONE RADIX 4 PASS TO THE NEXT
"
"MDEL<MDEL*4
"WD<WD/4
"JCOUNT<JCONT*4
"ICOUNT<ICOUNT/4
"
"
ADV4:   ADDL MDEL,MDEL          "MDEL=MDEL*4
        MOVRR WD,WD             "WD=WD/4
        ADDL JCOUNT,JCOUNT;     "JCOUNT=JCOUNT*4
           BR DONE              "FINISH UP AND EXIT
"
"
"ADVANCE FROM A RADIX 2 PASS TO A RADIX 4 PASS:
"       MDEL<MDEL*2
"       WD<WD/2
"       JCOUNT=JCOUNT*2
"       ICOUNT<ICOUNT/4
"
ADV2:   MOVL MDEL,MDEL          "MDEL=MDEL*2
        MOVR WD,WD              "WD=WD/2
        MOVL JCOUNT,JCOUNT      "JCOUNT=JCOUNT*2
DONE:   MOVRR ICOUNT,ICOUNT;    "ICOUNT=ICOUNT/4
           RETURN
        $END
"****** SET24B = SETUP FOR FFT2B AND FFT4B /COMMON/ = REL 2.0  , JAN 78 *******
"
        $TITLE SET24B
        $RADIX 8
        $ENTRY SET24B                          "USER-DIRECTED-CALL ENTRY
"
"                       --- ABSTRACT ---
"       USED BY FFT2B AND FFT4B WHEN DOING FFT'S SMALLER THAN 256 POINTS
"
"                       --- STATISTICS ---
"LANGUAGE:      APAL
"EQUIPMENT:     AP-120B WITH EITHER SPEED MEMORY
"SIZE:          8 LOCATIONS
"AUTHOR:        A.E. CHARLESWORTH
"DATE:          MARCH 1977
"
"
"                       --- USEAGE ---
"MULTPLIES BY 256 (8 LEFT SHIFTS) THE INCREMENT TO ADD TO 'MDEL'
"WHEN DOING THE COMBINED FIRST PASS & BIT-REVERSE.  THIS SUPPLIES
"THE EXTRA 8 RIGHT LEFT SHIFTS REQUIRED WHEN BIT-REVERSING FOR
"ARRAYS SMALLER THAN 256.
"
"S-PAD PARAMETERS:
"       NAME            S-PAD # PURPOSE
        N       $EQU    2       "NUMBER OF COMPLEX POINTS (INPUT)
        RDEL    $EQU    6       "READ POINTER DELTA (OUTPUT)
        MDEL    $EQU    15      "MEMORY DELTA
"
"
"                       --- SCRATCH ---
"S-PAD 7
"
        TEMP $EQU 7
"
"
"
SET24B: LDSPI TEMP; DB=256.
        SUB# TEMP,N             "TEST FOR 256 OR GREATER
        BGE BIG; MOV MDEL,RDEL  "IF SO, MERELY SET RDEL TO MDEL
"
" ELSE, MULTIPLY MDEL BY 256 (LEFT SHIFT BY 8 PLACES)
SMALL:  ADDL RDEL,RDEL
        ADDL RDEL,RDEL
        ADDL RDEL,RDEL
        ADDL RDEL,RDEL; RETURN
"
BIG:    RETURN
        $END
"****** VFCL1 = VECTOR FUNCTION CALLER (1 ARG) /COMMON/ = REL 2.1, SEP 79
"  FOR EITHER MEMORY
         $TITLE VFCL1
        $RADIX 8
         $ENTRY VFCL1                          "USER-DIRECTED-CALL ENTRY
"VECTOR FUNCTION CALLER FOR SINGLE ARGUEMENT FUNCTIONS
"               --- ABSTRACT ---
"CALLS SINGLE COMPUTATION FUNCTIONS THAT WORK
"       OUT OF DATA PAD FOR A SERIES OF ARGUEMENTS,
"       I.E. FROM A VECTOR IN MEMORY
"               --- STASTICS ---
"LANGUAGE:      AP-120B ASSEMBLER
"EQUIPMENT:     AP-120B WITH EITHER MEMORY
"STORAGE:       PS - 11.
"SCRATCH:          SP:0,2,4,6;   DPX: 0  (REL TO DPA)
"
"    --- HISTORY ---
"ORIGINAL:  NOV 75  A.E. CHARLESWORTH
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"               --- USEAGE ---
"PARAMETERS IN S-PAD:
"0      A      BASE ADDRESS OF VECTOR A
"1      I      INCREMENT FOR A
"2      C      BASE ADDRESS OF C
"3      K      INCREMENT FOR C
"4      N      COUNT
"5      ADR    RELATIVE ADDRESS OF FUNCTION TO BE CALLED
"6       LOC   BASE (LOC - 1) TO WHICH THE FUNCTION ADDRESS IS RELATIVE
"ON ENTRY LOC CONTAINS ONE LESS THAN THE BASE ADDRESS TO WHICH ADR IS
"        RELATIVE
"RECOMENDED CALLING SEQUENCE:
"        RPSA; LDSPNL LOC    "GET PSA INTO LOC
"        LDSPI ADR; DB=FUNCTION  "GET FUNCTION ADDRESS
"        JSR VFCL1           "GO TO THE VECTOR CALLER
"DOES C = FUNCTION ( A )
"A IS LOADED INTO DPX
"S-PAD MNEMONICS:
        A $EQU 0
        I $EQU 1
        C $EQU 2
        K $EQU 3
        N $EQU 4
        ADR $EQU 5
         LOC $EQU 6
VFCL1:  MOV A,A; SETMA          "GET A(0)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        BEQ DONE;               "EXIT IF COUNT = 0
         INC LOC              "TO GET THE CORRECT ADDRESS
         SUB K,C
         ADD I,A; SETMA      "FETCH A(1)
LOOP1:   ADD# ADR,LOC; SETTMA;  "SET FUNCTION ADDRESS
               DPX<MD        "  SAVE A(M)
         JSRT                "GO DO F(A)
         ADD K,C; SETMA; MI<DPX   "STORE C(M)
         DEC N               "SEE IF DONE????
         ADD I,A; SETMA;     "FETCH A(M+2)
           BNE LOOP1         "  BRANCH BACK IF NOT DONE
DONE:   RETURN                  "EXIT
         $END
"****** VFCL2 = VECTOR FUNCTION CALLER (2 ARGS) /COMMON/ = REL 2.1, SEP 79
"   FOR EITHER MEMORY
         $TITLE VFCL2
        $RADIX 8
         $ENTRY VFCL2                          "USER-DIRECTED-CALL ENTRY
"VECTOR FUNCTION CALLER FOR DOUBLE ARGUEMENT FUNCTIONS
"               --- ABSTRACT ---
"CALLS SINGLE COMPUTATION FUNCTIONS THAT WORK
"       OUT OF DATA PAD FOR A SERIES OF ARGUEMENTS,
"       I.E. FROM A VECTOR IN MEMORY
"               --- STASTICS ---
"LANGUAGE:      AP-120B ASSEMBLER
"EQUIPMENT:     AP-120B WITH EITHER MEMORY
"STORAGE:       PS - 12.
"SCRATCH:          0,2,4,6,8; DPX:0;  DPY: 0  (REL TO DPA)
"
"    --- HISTORY ---
"ORIGINAL:  NOV 75  A.E. CHARLESWORTH
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"               --- USEAGE ---
"PARAMETERS IN S-PAD:
"0      A      BASE ADDRESS OF VECTOR A
"1      I      INCREMENT FOR A
"2      B      BASE ADDRESS OF B
"3      INCREMENT FOR B
"4      C      BASE ADDRESS OF C
"5      K      INCREMENT FOR C
"6      N      COUNT
"7      ADR    RELATIVE ADDRESS OF FUNCTION TO BE CALLED
"10      LOC   BASE (LOC - 1) TO WHICH THE FUNCTION ADDRESS IS RELATIVE
"ON ENTRY LOC CONTAINS ONE LESS THAN THE BASE ADDRESS TO WHICH ADR IS
"        RELATIVE
"RECOMENDED CALLING SEQUENCE:
"        RPSA; LDSPNL LOC    "GET PSA INTO LOC
"        LDSPI ADR; DB=FUNCTION  "GET FUNCTION ADDRESS
"        JSR VFCL2           "GO TO THE VECTOR CALLER
"DOES C = FUNCTION ( A , B )
"       A IS LOADED INTO DPX AND B INTO DPY
"S-PAD MNEMONICS:
        A $EQU 0
        I $EQU 1
        B $EQU 2
        J $EQU 3
        C $EQU 4
        K $EQU 5
        N $EQU 6
        ADR $EQU 7
         LOC $EQU 10
VFCL2:   MOV A,A; SETMA      "FETCH A(0)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        BEQ DONE;               "EXIT IF COUNT = 0
         INC LOC               "GET PROPER ADDRESS
         SUB K,C
         MOV B,B; SETMA      "FETCH B(0)
LOOP2:   ADD# LOC,ADR; SETTMA;  "SET FUNCTION ADDRESS
           DPX<MD            "  SAVE A(M) IN DPX
         ADD I,A; SETMA      "FETCH A(M+1)
         JSRT;               "GO DO F(A,B)
           DPY<MD            "  SAVE B(M)
         ADD K,C; SETMA; MI<DPX  "STORE C(M)
         DEC N               "SEE IF DONE????
         ADD J,B; SETMA;     "FETCH B(M+1)
           BNE LOOP2         "  BRANCH BACK IF NOT DONE
DONE:   RETURN                  "EXIT
         $END
"****** SPFLT = S-PAD FLOAT /COMMON/ = REL 2.0  , JAN 78 ***********************
       $TITLE SPFLT
        $RADIX 8
       $ENTRY SPFLT                          "USER-DIRECTED-CALL ENTRY
"THIS IS A UTILITY SUBROUTINE TO FLOAT AN INTEGER
"TO BE USED AS THE NUMBER OF ITERATIONS OF A LOOP WHEN
"LOOP CONTROL IS DONE BY THE FLOATING ADDER.  THE
"CONSTANT ONE IS CALLED FROM TABLE MEMORY TO BE USED
"AS A COUNTER INCREMENT OF DECREMEMNT.
"DATE: JULY 76
"SCRATCH:  S-PAD 16,17;  DPX 1 (REL TO DPA); TM
"S-PADS PARAMETERS:
       NM $EQU 17
       C27 $EQU 16
"DATA-PAD PARAMETERS:
       NN $EQU 1
SPFLT: LDSPI C27;DB=27.
       MOV NM,NM;DPX<SPFN
       FADD ZERO,MDPX; MOV C27,C27
       FADD
       DPX(NN)<FA; LDTMA; DB=!ONE; RETURN
       $END
"****** SPUFLT = S-PAD UNSIGNED FLOAT /COMMON/ = REL 2.2, SEP 78 ***
"
        $TITLE SPUFLT
        $RADIX 8
        $ENTRY SPUFLT                          "USER-DIRECTED-CALL ENTRY
"
"     ---ABSTRACT---
"FLOATS THE 16-BIT UNSIGNED INTEGER IN SP(17) AND RETURNS THE FLOATED
"NUMBER (0 TO 65535) IN DPX(1) AND FA.  ALSO SETS TM TO 1.0.
"
"      EXAMPLES:   177773 (OCTAL) FLOATS TO 65531.0
"                  077777 (OCTAL) FLOATS TO 32767.0
"
"    FORMULA:    DPX(1) = FLOAT( SP(17) ) WHERE SP(17) IS TREATED AS
"                                          16-BIT UNSIGNED INTEGER
"
"     ---HISTORY---
"ORIGINAL:  AUG 78  R.S. NORIN
"
"     ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP WITH EITHER SPEED MEMORY
"SIZE:      8 WORDS
"SPEED:     0.833 US (1.17 IF 32767<SP(17)<65536)
"
"     ---USAGE---
"S-PAD PARAMETERS:
"  NAME         NUMBER
   NM   $EQU      17                    "INTEGER TO BE FLOATED
   C27  $EQU      17                    "TEMP
"
"SCRATCH:  SP(17),DPX(1),DPY(0),FA,TM
"
SPUFLT: MOV NM,NM; DPX(1)<SPFN          "GET NUMBER TO BE FLOATED
        LDSPI C27; DB=27.;              "EXPONENT
         BGE POS                        "BRANCH IF NUMBER 0<=NM<32768
"HERE IF SIGN BIT IS NEGATIVE, MEANING 32767<NM<65536
        RPSF F64K; DPY<DB               "GET 65536
        FADD DPY,MDPX(1); MOV C27,C27;  "FLOAT NUMBER AND ADD 65536
         BR COMM
"HERE IF SIGN BIT IS POSITIVE, MEANING 0<=NM<32768
POS:    FADD ZERO,MDPX(1); MOV C27,C27  "FLOAT NUMBER
COMM:   FADD                            "PUSH RESULT
        DPX(1)<FA;                      "SAVE RESULT
         LDTMA; DB=!ONE;                "FETCH 1.0 FROM TM, FOR COUNTING
         RETURN                         "EXIT
"
"CONSTANTS:
F64K:   $FP  65536.                     "65536.
"
        $END
"++++++ VFCLIB = VECTOR FUNCTION CHAINER LIBRARY = REL 3.0, AUG 77 +++++++++++
"
"++++++ VFCLIB = VECTOR FUNCTION CHAINER LIBRARY = REL 3.0, AUG 77 +++++++++++
"
"****** SAVESP = SAVE S-PAD REGISTERS INTO P.S. /COMMON/ = REL 2.2  , DEC 80 ***
"
        $TITLE SAVESP
        $ENTRY SAVESP                          "USER-DIRECTED-CALL ENTRY
"
"                       --- ABSTRACT ---
"       SAVES UP TO 16 S-PADS INTO A BLOCK OF PROGRAM SOURCE MEMORY LOCATIONS.
"       ALL S-PADS ARE UNCHANGED UPON RETURN TO THE CALLING PROGRAM.
"
"
"
"                        --- HISTORY ---
"
"  ORIGINAL:
"       A.E. CHARLESWORTH
"
"  REVISED:
" 2.1   AUG, 1980; J. ELLIOTT
"               REVISED TO SAVE ALL 16 SPADS.  ALL SPADS ARE NOW
"               UNCHANGED UPON RETURN TO THE CALLING PROGRAM.
"               DATAPADS (-3 TO -1) ARE NOW SCRATCHED.
" 2.2   DEC, 1980; J. ELLIOTT
"               ERROR IN LOOP CONTROL FOR N= 1 OR 2 FIXED.
"
"
"
"                       --- STATISTICS ---
"SIZE:   27. WORDS
"SPEED:  2.33  + 0.75 N  US.
"  IF ONLY TWO SPADS ARE SAVED ADD .16 USEC TO THE ABOVE TIME.
"  NOTE THAT A MULTIPLE OF 2 SPADS WILL ALWAYS BE STORED.
"
"     SCRATCH:  DPX( -3 TO 0 )
"
"                       --- USEAGE ---
"CALLING SEQUENCE:
"       JSR     SAVESP
"       $VAL    0,N,0,PBLK-.
"RETURN HERE
"
"N - # OF S-PADS TO SAVE
"PBLK - ADDRESS OF PARAMETER BLOCK
"S-PAD NAMES:
        N       $EQU    0       "  SAVED IN DPX(-1)
        J       $EQU    1       "  SAVED IN DPX(-2)
        RADR    $EQU    2       "  SAVED IN DPX(-3)
SAVESP: REXIT; LDSPNL RADR;              "GET RETURN ADDRESS
                DPX(-3)<SPFN             " SAVE SP SO WE CAN USE IT.
        MOV RADR,RADR; SETTMA
        RPSLT; DPX<DB                   "GET N
        MOV N,N; DPX(-1)<SPFN            " SAVE SP SO WE CAN USE IT.
        LDSPI N; DB=DPX                 "TO S-PAD
        RPSFT; DPX<DB; INCTMA         "GET P-LIST RELATIVE ADDRESS
        MOV J,J; DPX(-2)<SPFN            " SAVE SP SO WE CAN USE IT.
        LDSPI J; DB=DPX                "TO S-PAD
        SETEXT                          "AND SET RETURN
        ADD J,RADR; SETTMA             "CALCULATE ADDR. OF P-LIST
"  LOOP STARTS AT SPAD 3 AS FIRST 3 SPADS ARE DONE OUTSIDE OF THE LOOP.
"  THEREFORE, INITIALIZE COUNTER TO 3 - 1 = 2.
        LDSPI J; DB=2                 "INITIAL SPAD-1
"       MANUALLY STORE FIRST TWO S-PADS.
        LPSLT; DB=DPX(-1)                " SP 0
        LPSRT; DB=DPX(-2);               " SP 1
                INCTMA                  " INC POINTER FOR NEXT STORE.
"       CHECK TO SEE IF WE ARE DONE.
        DECR N                          "MAKE WORD COUNTER
        BEQ DONE; BLT DONE
"       NOT DONE, SO STORE SP 2 MANUALLY AND ENTER LOOP FOR SP-3
        LPSLT; DB=DPX(-3);                " SP 2
        BR SV2                   " ADJUST COUNTER AND ENTER LOOP.
"       THIS IS THE LOOP TO STORE TWO SPADS AT A TIME.
SVLOOP: BEQ DONE; INC J; LDSPD; DB=SPFN       "SET UP SPD
        LDSPI 0; DPX<SPFN                       "GET SP(J)
        LPSLT; DB=DPX                           "TO LEFT PARAMETER
SV2:    INC J; LDSPD; DB=SPFN                   "GET SP(J+1)
        LDSPI 0; DPX<SPFN                       "
        LPSRT; DB=DPX; INCTMA                   "TO RIGHT PARAMETER
        DEC N; BR SVLOOP
DONE:   MOV# 0,0                        " CLEAR OUT THE LDSPD CONDITION.
        LDSPI 0; DB=DPX(-1)                      " RESTORE SPADS 0-2 AND EXIT.
        LDSPI 1; DB=DPX(-2)
        LDSPI 2; DB=DPX(-3);
        RETURN
        $END
"****** SAVSP0 = SAVE S-PAD 0 INTO PROGRAM MEMORY /COMMON/ = REL 2.1  , MAR 78
"
        $TITLE SAVSP0
        $RADIX 8
        $ENTRY SAVSP0                          "USER-DIRECTED-CALL ENTRY
"
"                       --- ABSTRACT ---
"       SAVES SPAD 0 INTO A PROGRAM SOURCE MEMORY LOCATION
"
"                       --- STATISTICS ---
"SIZE:  11 WORDS
"SPEED: 2.0 US.
"
"     ---HISTORY---
"ORIGINAL:  AUG 77  A.E. CHARLESWORTH
" REV 2.1:  MAR 78  R.S. NORIN    SEPARATE RETURN INSTRUCTION INSERTED
"                                 TO AVOID SUBROUTINE RETURN STACK
"                                 PROBLEMS WHEN LPSRT OR LPSLT IS NOT
"                                 FOLLOWED BY A JSR
"
"                       --- USEAGE ---
"CALLING SEQUENCE:
"       JSR     SAVSP0
"       $VAL    L/R,ADR-.,0,0
"RETURN HERE
"
"ADR - ADDRESS OF P.S. LOCATION TO STORE S-PAD 0
"      BIT 5 OF THE ADDRESS HALFWORD INDICATES:
"            0  ADDRESS IS LEFT HALF OF P.S. WORD
"            1  ADDRESS IS RIGHT HALF OF P.S. WORD
"S-PAD NAMES:
        J       $EQU    16
        RADR    $EQU    17
SAVSP0: MOV 0,0; DPY<SPFN               "GET S-PAD VALUE TO BE STORED
        REXIT; LDSPNL RADR              "GET PARAMETER LIST ADDRESS
        MOV RADR,RADR; SETTMA           "TO TMA
        RPSLT; DPX<DB                   "GET RELATIVE PARAMETER ADDRESS
        LDSPI J; DB=DPX;                "TO SPAD
          INCTMA                        "BUMP TO RETURN
        SETEXT                          "SET RETURN
        ADD RADR,J; SETTMA;             "ABSOLUTE PARAMETER ADDRESS
          DB=DPX                        "TEST FOR RIGHT OR LEFT HALF
        BDBZ LH                         "BRANCH IF LEFT HALF
"
"STORE IN RIGHT HALF ----
RH:     LPSRT; DB=DPY; BR DONE           "STORE SP(0) IN RIGHT HALF
"
LH:     LPSLT; DB=DPY                   "STORE SP(0) IN LEFT HALF
DONE:   RETURN
        $END
"
"
"****** SETSP = LOAD S-PAD FROM P.S. /COMMON/ = REL 2.2  , AUG 80 *************
"****** SET2SP = LOAD 2 S-PADS FROM P.S. /COMMON/ = REL 2.1  , AUG 80 *********
"
        $TITLE SETSP
        $RADIX 8
        $ENTRY SETSP
        $ENTRY SET2SP
"
"                       --- ABSTRACT ---
"       LOADS SPAD FROM PROGRAM SOURCE MEMORY LOCATIONS
"
"      --- HISTORY ---
"ORIGINAL:  JAN 78  A.E. CHARLESWORTH
" REVISED:  AUG 79  R.S. NORIN         LEFT QUARTER OF 1ST WORD OF CALL
"                                      SPECIFIES STARTING SPAD NUMBER
"
"       AUG 80 J. ELLIOTT       ADD THE ABILITY TO SET ALL 16 SPADS.
"  THIS IS IMPLEMENTED BY USING THE FLOATING ADDER AS A COUNTER TO INDICATE
"  WHEN WE ARE SETTING THE LAST 4 SPADS. WHEN WE ARE IN THIS AREA, THE
"  IN DPX IN A SOFTWARE IMPLEMENTED "LIFO" STACK, WHERE DPA IS THE STACK POINTER
"  FA IS ALLOWED TO COUNT DOWN TO TELL US HOW MANY ENTRIES THERE ARE ON THE
"  LIFO STACK.  JUST BEFORE THE EXIT, IF THIS SPECIAL CODE WAS ENTERED,
"  A SPECIAL LOOP DUMPS THE DATA STORED IN THE LIFO STACK IN DPX INTO
"  THE SPECIFIED SPADS.
"  IF THE LAST FOUR SPADS ARE NOT SET, THEY ARE USED AS SCRATCH BY THIS ROUTINE.
"
"
"                       --- STATISTICS ---
"
"  SCRATCH:  DPX( -4 TO 0 )
"                DPX( -4 TO -1 ) ARE ONLY USED IF THE LAST 4 SPADS ARE LOADED.
"               SPADS 12. TO 15. IF THEY ARE NOT SET BY THIS ROUTINE.
"
"SIZE:  47. WORDS
"
"
"SETSP ENTRY:
"SIZE OF CALL: (FOR N-PARAMETERS):
"              (N+1)/2 + 3  WORDS  (FOR COMPLETE SUBR CALL)
"SPEED:        3.165 US + 1.50C + 2.33V
"               IF LAST 4 SPADS ADD THE FOLLOWING TIME TO THE ABOVE:
"               .16US + .5 * N4
"               WHERE N4 IS THE NUMBER OF SPADS ABOVE 12. THAT ARE BEING SET.
"
"
"
"SET2SP ENTRY
"SIZE OF CALL: 1 WORD
"SPEED:        1.87 US + 1.50C + 2.33V
"
"              WHERE C IS THE NUMBER OF CONSTANT PARAMETERS
"                AND V IS THE NUMBER OF VARIABLE PARAMETERS
"
"                       --- USEAGE ---
"CALLING SEQUENCE:
"
"       JSR SETSP
"       STARTING SPAD & NR PARAMS     ADDRESS OF PARAMETER #0
"       ADDRESS OF PARAMETER #1       ADDRESS OF PARAMETER #2
"       . . .      . . .              . . .      . . .
"       ADDRESS OF PARAMETER #N-1
"
"       RETURN IS TO HERE
"
"
"STARTING SPAD AND NR PARAMETERS HALFWORD:
"   LEFT HALF  =  (STARTING SPAD NUMBER)*8, I.E. SPAD IN BITS 6-3
"   RIGHT HALF =  N  =  NUMBER OF PARAMETERS
"
"PARAMETER ADDRESS HALFWORD:
"
"       BIT 4   1  INDICATES A IMMEDIATE CONSTANT
"               0  INDICATES A RELATIVE ADDRESS OF A VARIABLE
"
"       (USED ONLY FOR VARIABLES)
"       BIT 5   0  INDICATES ADDRESS POINTS TO LEFT HALF
"               1  INDICATES ADDRESS POINTS TO RIGHT HALF
"
"       00      VARIABLE ADDRESS, VARIABLE IS IN LEFT HALF
"       01      VARIABLE ADDRESS, VARIABLE IS IN RIGHT HALF
"       10      CONSTANT VALUE
"
"NOTE:  IF THE P.S. HALFWORD IS REGUARDED AS THE RIGHT 32 BITS OF
"       A 38-BIT FLOATING POINT NUMBER, THEN:
"
"       1. THE INDIRECT/IMMEDIATE FLAG IS THE SIGN BIT
"       2. THE LEFT/RIGHT FLAG IS THE NEXT BIT
"
"       OF THE MANTISSA PART OF THAT NUMBER
"
"
"PARAMETER ADDRESSES REFER TO P.S. MEMORY
"PARAMETER VALUES ARE 16-BIT INTEGERS
"
"S-PAD NAMES:
        TEMP $EQU 16  "  USED FOR 1 LEVEL OF INDIRECT LOAD OF VARIABLES.
        N $EQU 15 "  LOOP CONTROL
        J $EQU 14   "  POINTER TO S-PAD TO BE LOADED.
        RADR $EQU 17  "  POINTER TO PARAMETER LIST IN PS.
"
"       FA (FLOATING ADDER) IS A COUNTER THAT INDICATES WHEN WE ARE TRYING TO
"               LOAD THE LSAT FOUR S-PADS AND HOW MANY WE HAVE TRIED TO LOAD.
"
"
"
"SETSP ENTRY --- SET N SPADS
"
SETSP:  REXIT; LDSPNL RADR      "GET RETURN ADDRESS
           RPSF F13; DPX(-1)<DB     " SET UP COUNTER FOR LAST 4 S-PADS.
           RPSF F1; DPX(-2)<DB      " SET UP COUNTER FOR LAST 4 S-PADS.
        MOV RADR,RADR; SETTMA;
           FSUBR ZERO,DPX(-1)            " GET 13. INTO A2
        RPSLT; DPX<DB;           "GET N
           FSUBR DPX(-2),NC              " GET 1 INTO A1
        LDSPI N; DB=DPX;         "TO S-PAD
           FADD                      " PUT 12. ONTO FA, INITIAL COUNTER VALUE.
        LDSPT J; DB=DPX         "GET STARTING SPAD NUMBER (8/79)
        MOVR N,TEMP             "COMPUTE RADR+N/2+1 = NEW RETURN
        INC TEMP
        ADD RADR,TEMP; SETTMA
        SETEXT                  "SET NEW RETURN FROM TMA
        DEC J                   "INITIAL SPAD-1 (8/79)
        MOV N,N; BR RIGHT       "TEST N=0 AND LOOP
"
"
"SET2SP ENTRY --- SET SPADS 0 AND 1
"    N IS IMPLICITLY 2, THE ADDRESSES ARE IN THE TWO HALVES OF THE FOLLOWING
"    P.S. WORD AFTER THE CALL
"
SET2SP: REXIT; LDSPNL RADR      "GET PARAMETER POINTER
           RPSF F13; DPX(-1)<DB          " SETUP OF LAST FOUR COUNTER IN FA.
           RPSF F1; DPX(-2)<DB
        INC# RADR; SETTMA;       "SET RETURN
           FSUBR ZERO,DPX(-1)            " PUT 13. ONTO A2.
        LDSPI N; DB=2;           "PARAMETER COUNT IS 2
           FSUBR DPX(-2),NC              " PUT 1 ONTO A1.
        LDSPI J; DB=-1;          "SET INITIAL S-PAD ADDRESS
           FADD                 " PUSH FA TO INITIAL VALUE OF 12.
        SETEXT; DECTMA; BR LEFT1   "POINT TMA TO LEFT PARAMETER AND LOOP
"
"
"-------PARAMETER FILLING LOOP
"
MORRIT: RPSFT; DPX<DB           "GET RIGHT PARAMETER
        NOP;                     "SO RPSF DOUEN'T CLOBBER JSR
                FSUBR NC,FA     " DEC LAST 4 COUNTER.
        JSR GETVAL;             "GO STORE IT
          DB=DPX;                "TEST SIGN BIT OF POINTER
                FADD            " PUSH
"
LEFT:   BEQ DONE;               "BRANCH IF DONE
          INC RADR;             "INCREMENT PARAMETER POINTER
          SETTMA                "AND SET ADDRESS
LEFT1:  RPSLT; DPX<DB           "GET LEFT PARAMETER
        NOP;                     "SO RPSL DOESN'T CLOBBER JSR
                FSUBR NC,FA             " DEC LSAT 4 COUNTER
        JSR GETVAL;             "GO STORE IT
          DB=DPX;                "TEST SIGN BIT OF POINTER
                FADD            " PUSH
RIGHT:  BNE MORRIT;             "BRANCH IF NOT DONE
          MOV RADR,RADR;        "SET ADDRESS FOR NEXT PARAMETER FETCH
          SETTMA
"
"
DONE:   BFGE DONEB;             " EXIT IF LAST 4 MOD WAS NOT ENTERED.
"  NOW START SETUP FOR LOADING LAST 4 SPADS FROM SAVED DPX.
                FADD NC,FA;          " GET FA GOING TO COUNT UP FOR
                                     " LOOP CONTROL.
                INC J                   " GET J READY TO USE AS SPAD POINTER.
                FADD                    " PUSH
"  WE HAVE BUILT UP A "LIFO" STACK IN THE CVAL2 LOOP.
"  HERE WE WILL CAREFULLY UNLOAD THE STACK INTO THE SPADS. THE HIGHEST
"  SPAD TO BE LOADED WILL BE FIRST AND SPAD 14 WILL BE LAST.  SPAD 14
"  IS USED AS A SPAD LOAD ADDRESS POINTER IN THIS LOOP, AND WILL BE
"  OVERWRITTEN ONLY ON THE LAST CYCLE OF THE LOOP.
LOOPD:  FADD NC,FA              " LOOP CONTROL
        DEC J; LDSPD; DB=SPFN           " CONTROLS SPAD LOAD ON NEXT CYCLE.
        FADD;                           " PUSH
        LDSPI 0; DB=DPX(1);            " LOAD SPAD POINTED TO BY J.
        INCDPA;                         " RESTORE DPA THAT WAS CHANGED IN MAIN
                                        " LOOP.
        BFNE LOOPD                      " BRANCH BACK UNTIL ALL SPADS LOADED.
DONEB:  RETURN                  " EXIT
"
"
"
"GETVAL ---
"
GETVAL: BDBN CVAL               "BRANCH IF A CONSTANT VALUE
                            " FA VALID BY THIS POINT, CAN TEST IT NEXT CYCLE.
"
"
"ADDRESS OF VARIABLE PARAMETER ----
VVAL:   LDSPI TEMP; DB=DPX      "GET ADDRESS TO S-PAD
        ADD RADR,TEMP; SETTMA;  "MAKE ADDRESS ABSOLUTE
          DB=DPX                "TEST FOR LEFT/RIGHT HALF
        BDBZ LH                 "BRANCH IF PARAMETER IN LEFT HALF
"
"RIGHT HALF PARAMETER VALUE ----
RH:     RPSFT; DPX<DB; BR CVAL
"
"LEFT HALF PARAMETER VALUE ---
LH:     RPSLT; DPX<DB
"
"
"CONSTANT PARAMETER VALUE ----  (IN DPX)
CVAL:   INC J; DB=SPFN;         "SET S-PAD PARAMETER ADDRESS
          LDSPD;
                BFGE CVAL3      " CHECK FOR LAST 4 SPADS.
                " THIS CYCLE NEEDED IF BRANCH IS TAKEN BECAUSE OF LDSPD.
                BR CVAL2        " BRANCH IF LOADING LAST 4 S-PADS
CVAL3:  DB=DPX; LDSPI 0         "PUT VALUE INTO SPAD(J)
        DEC N; RETURN           "TEST N AND RETURN
"
"
"   IF TRYING TO LOAD LAST 4 SPADS, LEAVE THE VALUE IN DPX(0) AND
"       DECREMENT DPA.  THUS, BY THE NEXT CYCLE THE VALUE IS IN DPX(+1)
"       RELATIVE TO THE CURRENT DPA.
"   THIS IS A SOFTWARE LIFO STACK USING DPA AS THE POINTER.
        "   VALUE IS IN DPX(0), SO WE KEEP IT THERE AND MOVE POINTER (DPA).
CVAL2:  DECDPA; DEC N; RETURN  " NEXT VALUE WILL GO INTO WHAT WAS DPX(-1)
"
"
"   CONSTANTS NEEDED TO INITIALIZE THE FA COUNTER.
F13:    $FP 13.
F1:     $FP 1.
        $END
"****** SPNEG = SPAD NEGATE /COMMON/ = REL 2.0  , JAN 78 ***********************
"
        $TITLE SPNEG
        $RADIX 8
        $ENTRY SPNEG                          "USER-DIRECTED-CALL ENTRY
"
"                       --- ABSTRACT ---
"       NEGATE S-PAD 0
"
"                       --- STATISTICS ---
"AUTHOR:A.E. CHARLESWORTH
"SIZE:  2 WORD
"SPEED: 0.333 US.
"
"                       --- USEAGE ---
"-SP(0) => SP(0)
"ARGUEMENTS:
"       S-PAD 0      SOURCE ARGUEMENT
"       S-PAD 0     DESTINATION ARGUEMENT
"
"       RESULT RETURNED IN S-PAD 0
"
"                       --- ERROR CONDITIONS ---
"       NO CHECKING IS DONE FOR OVERFLOW, THE LOW 16-BITS OF RESULTS TOO
"       LARGE TO FIT IN 16-BITS ARE RETURNED.
"
"                       --- SCRATCH ---
"NONE
"
          C $EQU  0
"
SPNEG:  COM C
        INC C; RETURN                   "DO NEGATE AND RETURN
        $END
"
"****** SPNOT = SPAD NOT /COMMON/ = REL 2.0  , JAN 78 **************************
"
        $TITLE SPNOT
        $RADIX 8
        $ENTRY SPNOT                          "USER-DIRECTED-CALL ENTRY
"
"                       --- ABSTRACT ---
"       NOTS TWO S-PAD REGISTERS TOGETHER
"
"                       --- STATISTICS ---
"AUTHOR:A.E. CHARLESWORTH
"SIZE:  1 WORD
"SPEED: 0.167 US.
"
"                       --- USEAGE ---
".NOT. SP(0) => SP(0)
"ARGUEMENTS:
"       S-PAD 0     SOURCE ARGUEMENT
"       S-PAD 0     DESTINATION ARGUEMENT
"
"       RESULT RETURNED IN S-PAD 0
"
"                       --- ERROR CONDITIONS ---
"       NO CHECKING IS DONE FOR OVERFLOW, THE LOW 16-BITS OF RESULTS TOO
"       LARGE TO FIT IN 16-BITS ARE RETURNED.
"
"                       --- SCRATCH ---
"NONE
"
          C $EQU  0
"
SPNOT:  COM C; RETURN                   "DO .NOT. AND RETURN
        $END
"
"****** SPADD = SPAD ADD /COMMON/ = REL 2.0  , JAN 78 **************************
"
        $TITLE SPADD
        $RADIX 8
        $ENTRY SPADD                          "USER-DIRECTED-CALL ENTRY
"
"                       --- ABSTRACT ---
"       ADDS TWO S-PAD REGISTERS TOGETHER
"
"                       --- STATISTICS ---
"AUTHOR:A.E. CHARLESWORTH
"SIZE:  1 WORD
"SPEED: 0.167 US.
"
"                       --- USEAGE ---
"SP(0) + SP(1) => SP(0)
"ARGUEMENTS:
"       S-PAD 0     DESTINATION ARGUEMENT
"       S-PAD 1     SOURCE ARGUEMENT
"
"       RESULT RETURNED IN S-PAD 0
"
"                       --- ERROR CONDITIONS ---
"       NO CHECKING IS DONE FOR OVERFLOW, THE LOW 16-BITS OF RESULTS TOO
"       LARGE TO FIT IN 16-BITS ARE RETURNED.
"
"                       --- SCRATCH ---
"NONE
"
          A $EQU  0
          B $EQU  1
"
SPADD:  ADD B,A; RETURN                 "DO SUM AND RETURN
        $END
"
"****** SPSUB = SPAD SUBTRACT /COMMON/ = REL 2.0  , JAN 78 *********************
"
        $TITLE SPSUB
        $RADIX 8
        $ENTRY SPSUB                          "USER-DIRECTED-CALL ENTRY
"
"                       --- ABSTRACT ---
"       SUBTRACTS TWO S-PAD REGISTERS
"
"                       --- STATISTICS ---
"AUTHOR:A.E. CHARLESWORTH
"SIZE:  1 WORD
"SPEED: 0.167 US.
"
"                       --- USEAGE ---
"SP(0) - SP(1) => SP(0)
"ARGUEMENTS:
"       S-PAD 0     DESTINATION ARGUEMENT
"       S-PAD 1     SOURCE ARGUEMENT
"
"       RESULT RETURNED IN S-PAD 0
"
"                       --- ERROR CONDITIONS ---
"       NO CHECKING IS DONE FOR OVERFLOW, THE LOW 16-BITS OF RESULTS TOO
"       LARGE TO FIT IN 16-BITS ARE RETURNED.
"
"                       --- SCRATCH ---
"NONE
"
          A $EQU  0
          B $EQU  1
"
SPSUB:  SUB B,A; RETURN                 "DO SUM AND RETURN
        $END
"
"****** SPRS = SPAD RIGHT SHIFT /COMMON/ = REL 2.0  , JAN 78 *******************
"
        $TITLE SPRS
        $RADIX 8
        $ENTRY SPRS                          "USER-DIRECTED-CALL ENTRY
"
"                       --- ABSTRACT ---
"       SHIFT S-PAD 0 RIGHT BY S-PAD 1 PLACES WITH ZERO FILL
"
"                       --- STATISTICS ---
"AUTHOR:A.E. CHARLESWORTH
"SIZE:  5 WORD
"SPEED: 0.5 + 0.33N US., WHERE N IS THE SHIFT COUNT
"
"                       --- USEAGE ---
"RIGHT SHIFT SP(0) BY (SP(1)) PLACES => SP(0), WITH ZERO FILL
"ARGUEMENTS:
"       S-PAD 0     DESTINATION ARGUEMENT
"       S-PAD 1     SHIFT COUNT
"
"       RESULT RETURNED IN S-PAD 0
"
"                       --- ERROR CONDITIONS ---
"       NO CHECKING IS DONE FOR OVERFLOW, THE LOW 16-BITS OF RESULTS TOO
"       LARGE TO FIT IN 16-BITS ARE RETURNED.
"
"                       --- SCRATCH ---
"NONE
"
          A $EQU  0
          B $EQU  1
"
SPRS:   MOV B,B
        BLT DONE; BEQ DONE              "DON'T SHIFT IF COUNT .LE. 0
LOOP:   DEC B
        MOVR A,A; BGT LOOP              "MORE IF NOT COUNTED DOWN TO ZERO
DONE:   RETURN
        $END
"
"****** SPLS = SPAD LEFT SHIFT /COMMON/ = REL 2.0  , JAN 78 ********************
"
        $TITLE SPLS
        $RADIX 8
        $ENTRY SPLS                          "USER-DIRECTED-CALL ENTRY
"
"                       --- ABSTRACT ---
"       SHIFT S-PAD 0 LEFT BY S-PAD 1 PLACES WITH ZERO FILL
"
"                       --- STATISTICS ---
"AUTHOR:A.E. CHARLESWORTH
"SIZE:  5 WORD
"SPEED: 0.5 + 0.33N US., WHERE N IS THE SHIFT COUNT
"
"                       --- USEAGE ---
"LEFT SHIFT SP(0) BY (SP(1)) PLACES => SP(0), WITH ZERO FILL
"ARGUEMENTS:
"       S-PAD 0     DESTINATION ARGUEMENT
"       S-PAD 1     SHIFT COUNT
"
"       RESULT RETURNED IN S-PAD 0
"
"                       --- ERROR CONDITIONS ---
"       NO CHECKING IS DONE FOR OVERFLOW, THE LOW 16-BITS OF RESULTS TOO
"       LARGE TO FIT IN 16-BITS ARE RETURNED.
"
"                       --- SCRATCH ---
"NONE
"
          A $EQU  0
          B $EQU  1
"
SPLS:   MOV B,B
        BLT DONE; BEQ DONE              "DON'T SHIFT IF COUNT .LE. 0
LOOP:   DEC B
        MOVL A,A; BGT LOOP              "MORE IF NOT COUNTED DOWN TO ZERO
DONE:   RETURN
        $END
"
"****** SPAND = SPAD AND /COMMON/ = REL 2.0  , JAN 78 **************************
"
        $TITLE SPAND
        $RADIX 8
        $ENTRY SPAND                          "USER-DIRECTED-CALL ENTRY
"
"                       --- ABSTRACT ---
"       ANDS TWO S-PAD REGISTERS TOGETHER
"
"                       --- STATISTICS ---
"AUTHOR:A.E. CHARLESWORTH
"SIZE:  1 WORD
"SPEED: 0.167 US.
"
"                       --- USEAGE ---
"SP(0) AND SP(1) => SP(0)
"ARGUEMENTS:
"       S-PAD 0     DESTINATION ARGUEMENT
"       S-PAD 1     SOURCE ARGUEMENT
"
"       RESULT RETURNED IN S-PAD 0
"
"                       --- ERROR CONDITIONS ---
"        NONE
"                       --- SCRATCH ---
"NONE
"
          A $EQU  0
          B $EQU  1
"
SPAND:  AND B,A; RETURN                 "DO .AND. AND RETURN
        $END
"
"****** SPOR = SPAD OR /COMMON/ = REL 2.0  , JAN 78 ****************************
"
        $TITLE SPOR
        $RADIX 8
        $ENTRY SPOR                          "USER-DIRECTED-CALL ENTRY
"
"                       --- ABSTRACT ---
"       ORS TWO S-PAD REGISTERS TOGETHER
"
"                       --- STATISTICS ---
"AUTHOR:A.E. CHARLESWORTH
"SIZE:  1 WORD
"SPEED: 0.167 US.
"
"                       --- USEAGE ---
"SP(0) OR SP(1) => SP(0)
"ARGUEMENTS:
"       S-PAD 0     DESTINATION ARGUEMENT
"       S-PAD 1     SOURCE ARGUEMENT
"
"       RESULT RETURNED IN S-PAD 0
"
"                       --- ERROR CONDITIONS ---
"       NONE
"
"                       --- SCRATCH ---
"NONE
"
          A $EQU  0
          B $EQU  1
"
SPOR:  OR B,A; RETURN                   "DO .OR. AND RETURN
        $END
"****** SSDM = SINGLE SINGLE DOUBLE PRECISION MULTIPLY /COMMO= REL 2.0  , JAN 78
        $TITLE SSDM
        $RADIX 8
        $ENTRY SSDM                          "USER-DIRECTED-CALL ENTRY
        $EXT DDDA
        "DOES A*B WHERE A AND B ARE SINGLE PRECISION NUMBERS.
        "AND THE PRODUCT IS DOUBLE PRECISION.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER(APAL)
        "EQUIPMENT:     AP-120B WITH EITHER MEMORY
        "AUTHOR:        J. THROOP
        "DATE:          FEB. 1977
        "SIZE:          81 LOCATIONS(TOTAL) = 33 + DDDA (48)
        "SPEED:         11.5 MICROSECONDS
        "A*B MUST BE FORMED BY A SSD MULTIPLICATION.  THEN
        "TO DO A SSD MULTIPLY WE BREAK A AND B EACH UP INTO
        "TWO 14 BIT SEGMENTS.
        "A = C1 + C2 AND B = D1 + D2.
        "SO A*B = C1*D1 + C1*D2 + C2*D1 + C2*D2.  THE INDIVIDUAL
        "PRODUCTS CAN BE FORMED SINGLE PRECISION WITHOUT ROUNDING.
        "THE PARTIAL SUM C1*D1 + C1*D2 = E1 + E2 IS FORMED
        "BY A SSD ADDITION.
        "ALSO THE PARTIAL SUM C2*D1 + C2*D2 = F1 + F2 IS
        "FORMED BY A SSD ADDITION.  THEN E1 + E2 + F1 + F2
        "ARE ADDED BY A DDD ADDITION.
        "A = DPX(A1)
        "B = DPX(B1)
        "ANSWER RETURNS AS DPX(A1) + DPY(A2)
        "S PAD MNEMONICS
        EX $EQU 17
        "DATA PAD MNEMONICS
        A1 $EQU 0
        A2 $EQU 0
        B1 $EQU 1
        B2 $EQU 1
        C1 $EQU 2
        C2 $EQU 2
        D1 $EQU 3
        D2 $EQU 3
        E1 $EQU 0
        E2 $EQU 0
        F1 $EQU 1
        F2 $EQU 1
        T $EQU -1
        S1 $EQU -2
        S2 $EQU -2
        MH $EQU -1
        ML $EQU -2
        "SCRATCH:
        "S PADS:        17
        "DPX: -2,-1,0,1,2,3;  DPY: -1,0,2,3 RELATIVE TO DPA
SSDM:   RPSF MSKH; DPX(MH)<DB   "FETCH MASK FOR HIGH BITS
        RPSF MSKL; DPX(ML)<DB   "MASK FOR LOW BITS
        LDSPE EX; DB=DPX(A1);
        DPY(A1)<DPX(A1)
        FAND DPY(A1),MDPX(ML); MOV EX,EX        "GET LOW PART OF A1
        FAND DPY(A1),MDPX(MH); MOV EX,EX        "GET HIGH PART OF A1
        FADD ZERO,FA; LDSPE EX; DB=DPX(B1);      "NORMALIZE LOW PART OF A1
        DPY(B1)<DPX(B1)
        DPX(C1)<FA; FAND DPY(B1),MDPX(ML); MOV EX,EX    "GET LOW PART OF B1
        DPY(C2)<FA; FAND DPY(B1),MDPX(MH); MOV EX,EX    "GET HIGH PART OF B1
        FADD ZERO,FA            "NORMALIZE LOW PART OF B1
        DPY(D1)<FA; FMUL DPX(C1),FA;     "C1*D1
        FADD ZERO,FA
        DPX(D2)<FA; FMUL DPX(C1),FA;             "C1*D2
        FADD ZERO,FA
        FMUL DPY(C2),FA;         "D1*C2
        FADD
        FMUL DPY(C2),FA; DPX(E1)<FM     "D2*C2, STORE C1*D1
        DPY(E2)<FM; FMUL;               "STORE C1*D2
        FABS DPX(E1)            "START SSDA OF E1 + E2
        DPY(F1)<FM; FMUL;               "STORE C2*D1
        FABS DPY(E2)
        DPX(F2)<FM;             "STORE C2*D2
        FADD DPX(E1),DPY(E2); DPY(T)<FA
        FSUB DPY(T),FA
        DPY(S1)<FA; FSUBR DPX(E1),FA;
        DPX(S1)<FA
        FSUBR DPY(E2),DPX(S1)
        BFGE AGTB; FSUB DPY(E2),FA
        FSUB DPX(E1),FA
AGTB:   FABS DPX(F2); DPX(E1)<DPY(S1)           "START SSDA OF F1 + F2
        DPY(E2)<FA; FABS DPY(F1)                "E1 + E2 = SSD SUM OF C1*D1 + C1
        FADD DPX(F1),DPY(F2); DPX(T)<FA
        FSUB DPX(T),FA
        DPY(S1)<FA; FSUBR DPX(F2),FA;
        DPX(S1)<FA
        FSUBR DPY(F1),DPX(S1)
        BFGE AGTB1; FSUB DPY(F1),FA
        FSUB DPX(F2),FA
AGTB1:  FADD; DPY(F1)<DPY(S1)
        DPX(F2)<FA; JMP DDDA            "F1 + F2 = SSD SUM OF C2*D1 + C2*D2
        "DDDA DOES A DOUBLE PRECISION ADD E1 + E2 + F1 + F2 >= A1 + A2
        "DPX(E1) + DPY(E2) + DPY(F1) + DPX(F2) >= DPX(A1) + DPY(A2)
        "ANSWER IS DPX(A1) + DPY(A2)           EXIT IS THRU DDDA
MSKH:   $VAL 0,0,7777,140000    "MASK FOR HIGH 14 BITS
MSKL:   $VAL 0,0,0,37777        "MASK FOR LOW 14 BITS
        $END
"****** DDDM = DOUBLE PRECISION MULTIPLY /COMMON/ = REL 2.0  , JAN 78 **********
        $TITLE DDDM
        $RADIX 8
        $ENTRY DDDM                          "USER-DIRECTED-CALL ENTRY
        $EXT DDDA
        $EXT SDDA
        "DOES THE DOUBLE PRECISION MULTIPLY OF TWO DOUBLE PRECISION NUMBERS.
        "S = A*B, WHERE
        "A = DPX(A1) + DPY(A2)
        "B = DPX(B1) + DPY(B2)
        "S = DPX(S1) + DPY(S2)
        "A1,B1,S1 ARE THE HIGH WORDS AND A2,B2,S2 ARE THE LOW WORDS.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER(APAL)
        "EQUIPMENT:     AP-120B WITH EITHER MEMORY
        "AUTHOR:        J. THROOP
        "DATE:          FEB. 1977
        "SIZE:          117 LOCATIONS(TOTAL) = 41 + DDDA (48) + SDDA (28)
        "SPEED:         18.5 MICROSECONDS
        "DOES A*B WHERE A AND B ARE DOUBLE PRECISION NUMBERS.
        "A = A1 + A2 AND B = B1 + B2 WHERE A1,A2,B1,B2 ARE
        "SINGLE PRECISION NUMBERS.  THE PRODUCT IS APPROXIMATELY
        "A*B = (A1 + A2)*(B1 + B2) = A1*B1 + A1*B2 + A2*B1
        "AND THE HIGH ORDER TERM A2*B2 IS DISCARDED.  THE
        "PRODUCTS A1*B2 AND B1*A2 ARE DONE SINGLE PRECISION
        "AND ARE ADDED SINGLE PRECISION.  THE PRODUCT
        "A1*B1 MUST BE FORMED BY A SSD MULTIPLICATION.  THEN
        "THE DOUBLE PRECISION PRODUCT A1*B1 IS ADDED TO THE
        "SINGLE PRECISION SUM A1*B2 + A2*B1 BY A  SDD ADDITION.
        "TO DO A SSD MULTIPLY WE BREAK A1 AND B1 EACH UP INTO
        "TWO 14 BIT SEGMENTS.
        "A1 = C1 + C2 AND B1 = D1 + D2.
        "SO A1*B1 = C1*D1 + C1*D2 + C2*D1 + C2*D2.  THE INDIVIDUAL
        "PRODUCTS CAN BE FORMED SINGLE PRECISION WITHOUT ROUNDING.
        "THE PARTIAL SUM C1*D1 + C1*D2 = E1 + E2 IS FORMED
        "BY A SSD ADDITION.
        "ALSO THE PARTIAL SUM C2*D1 + C2*D2 = F1 + F2 IS
        "FORMED BY A SSD ADDITION.  THEN E1 + E2 + F1 + F2
        "ARE ADDED BY A DDD ADDITION.  THIS FORMS THE HIGH PART OF
        "THE PRODUCT WHICH IS THEN ADDED SDD TO THE LOW PART.
        "S PAD MNEMONICS
        EX $EQU 17              "SCRATCH PAD FOR EXPONENT
        "DATA PAD MNEMONICS
        A1 $EQU 0
        A2 $EQU 0
        B1 $EQU 1
        B2 $EQU 1
        C1 $EQU 2
        C2 $EQU 2
        D1 $EQU 3
        D2 $EQU 3
        E1 $EQU 0
        E2 $EQU 0
        F1 $EQU 1
        F2 $EQU 1
        T $EQU -1
        S1 $EQU -2
        S2 $EQU -2
        MH $EQU -1
        ML $EQU -2
        HP1 $EQU 0
        HP2 $EQU 0
        LP $EQU -3
        B $EQU 1
        "SCRATCH:
        "S PADS:        17
        "DPX: -2,-1,0,1,2,3;  DPY: -3,-2,-1,0,1,2,3 RELATIVE TO DPA
DDDM:   FMUL DPX(A1),DPY(B2)            "START LOW ORDER PRODUCT
        FMUL DPX(B1),DPY(A2)
        FMUL
        DPY(T)<FM; FMUL         "STORE A1*B2
        FADD  FM,DPY(T)         "ADD A1*B2 + B1*A2
        FADD
        DPY(LP)<FA              "STORE LOW ORDER PRODUCT
        RPSF MSKH; DPX(MH)<DB  "FETCH MASK FOR HIGH BITS
        RPSF MSKL; DPX(ML)<DB   "MASK FOR LOW BITS
        LDSPE EX; DB=DPX(A1);
        DPY(A1)<DPX(A1)
        FAND DPY(A1),MDPX(ML); MOV EX,EX        "GET LOW PART OF A1
        FAND DPY(A1),MDPX(MH); MOV EX,EX        "GET HIGH PART OF A1
        FADD ZERO,FA; LDSPE EX; DB=DPX(B1);      "NORMALIZE LOW PART OF A1
        DPY(B1)<DPX(B1)
        DPX(C1)<FA; FAND DPY(B1),MDPX(ML); MOV EX,EX    "GET LOW PART OF B1
        DPY(C2)<FA; FAND DPY(B1),MDPX(MH); MOV EX,EX    "GET HIGH PART OF B1
        FADD ZERO,FA            "NORMALIZE LOW PART OF B1
        DPY(D1)<FA; FMUL DPX(C1),FA;     "C1*D1
        FADD ZERO,FA
        DPX(D2)<FA; FMUL DPX(C1),FA;             "C1*D2
        FADD ZERO,FA
        FMUL DPY(C2),FA;         "D1*C2
        FADD
        FMUL DPY(C2),FA; DPX(E1)<FM     "D2*C2, STORE C1*D1
        DPY(E2)<FM; FMUL;               "STORE C1*D2
        FABS DPX(E1)            "START SSDA OF E1 + E2
        DPY(F1)<FM; FMUL;               "STORE C2*D1
        FABS DPY(E2)
        DPX(F2)<FM;             "STORE C2*D2
        FADD DPX(E1),DPY(E2); DPY(T)<FA
        FSUB DPY(T),FA
        DPY(S1)<FA; FSUBR DPX(E1),FA;
        DPX(S1)<FA
        FSUBR DPY(E2),DPX(S1)
        BFGE AGTB; FSUB DPY(E2),FA
        FSUB DPX(E1),FA
AGTB:   FABS DPX(F2); DPX(E1)<DPY(S1)           "START SSDA OF F1 + F2
        DPY(E2)<FA; FABS DPY(F1)                "E1 + E2 = SSD SUM OF C1*D1 + C1
        FADD DPX(F1),DPY(F2); DPX(T)<FA
        FSUB DPX(T),FA
        DPY(S1)<FA; FSUBR DPX(F2),FA;
        DPX(S1)<FA
        FSUBR DPY(F1),DPX(S1)
        BFGE AGTB1; FSUB DPY(F1),FA
        FSUB DPX(F2),FA
AGTB1:  FADD; DPX(F1)<DPY(S1)
        DPY(F2)<FA; JSR DDDA            "F1 + F2 = SSD SUM OF C2*D1 + C2*D2
        "DDDA DOES A DOUBLE PRECISION ADD E1 + E2 + F1 + F2 >= HP1 + HP2
        "DPX(E1) + DPY(E2) + DPX(F1) + DPY(F2) >= DPX(HP1) + DPY(HP2)
        "NOW THE ANSWER IS FOUND BY SDDA DPX(HP1) + DPY(HP2) + DPY(B)
        "DPY(B) WILL HAVE THE LOW ORDER PART OF THE PRODUCT
        DPY(B)<DPX(LP); JMP SDDA        "EXIT IS THRU SDDA
        "ANSWER IS DPX(A1) + DPY(A2)
MSKH:   $VAL 0,0,7777,140000    "MASK FOR HIGH 14 BITS
MSKL:   $VAL 0,0,0,37777        "MASK FOR LOW 14 BITS
        $END
"****** SSDA = SINGLE SINGLE DOUBLE PRECISION ADDITION /COMMO= REL 2.0  , JAN 78
        $TITLE SSDA
        $RADIX 8
        $ENTRY SSDA                          "USER-DIRECTED-CALL ENTRY
        "DOES THE DOUBLE PRECISION ADDITION OF TWO SINGLE PRECISION NUMBERS
        "IN DPX AND DPY AND STORES THE ANSWERS IN DPX AND DPY
        "DPX(A) + DPY(B) >= DPX(S1) + DPY(S2), WHERE S1 IS THE HIGH WORD OF
        "THE SUM AND S2 IS THE LOW WORD OF THE SUM.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER(APAL)
        "EQUIPMENT:     AP-120B WITH EITHER MEMORY
        "AUTHOR:        J. THROOP
        "DATE:          FEB. 1977
        "SIZE:          10 LOCATIONS
        "SPEED:         1.5 MICROSECONDS
        "DATA PAD NAMES:
        A $EQU 0                "FOR DPX(A)
        B $EQU 0                "FOR DPY(B)
        S1 $EQU 2               "DPX(S1) IS HIGH WORD OF SUM
        S2 $EQU 2               "DPY(S2) IS LOW WORD OF SUM
        C $EQU 1
        "SCRATCH:
        "DPX: 1, 2;  DPY:  2.
SSDA:   FABS DPX(A)
        FABS DPY(B)
        FADD DPX(A),DPY(B); DPX(C)<FA   "GET A + B; STORE ABS(A)
        FSUB DPX(C),FA          "TO TEST ABS(A) >= ABS(B)
        DPY(S1)<FA; FSUBR DPX(A),FA;     "FOR A >= B
        DPX(S1)<FA
        FSUBR DPY(B),DPX(S1)            "FOR B > A
        BFGE AGTB; FSUB DPY(B),FA       "FOR A >= B
        FSUB DPX(A), FA                "FOR B > A
AGTB:   FADD
        DPX(S2)<FA; RETURN              "SSD OF A + B >= S1 + S2
        $END
"****** SDDA = SINGLE DOUBLE DOUBLE PRECISION ADDITION /COMMO= REL 2.0  , JAN 78
        $TITLE SDDA
        $RADIX 8
        $ENTRY SDDA                          "USER-DIRECTED-CALL ENTRY
        "DOES THE DOUBLE PRECISION ADDITION OF A SINGLE PRECISION NUMBER
        "TO A DOUBLE PRECISION NUMBER.
        "DOES A + B >= S
        "WHERE A = DPX(A1) + DPY(A2), B = DPY(B)
        "S = DPX(S1) + DPY(S2)
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER(APAL)
        "EQUIPMENT:     AP-120B WITH EITHER MEMORY
        "AUTHOR:        J. THROOP
        "DATE:          FEB. 1977
        "SIZE:          28 LOCATIONS
        "SPEED:         4.5 MICROSECONDS
        "ALGORITHM:
        "LET C1 + C2 = SSD SUM OF B + A1
        "LET D1 + D2 = SSD SUM OF C2 + A2
        "LET E1 + E2 = SSD SUM OF C1 + D1
        "LET F = SSS SUM OF E2 + D2
        "LET S1 = E1 AND S2 = F
        "THEN S = S1 + S2 IS THE SDD SUM OF A + B
        "DATA PAD MNEMONICS
        A1 $EQU 0              "HIGH WORD OF A
        A2 $EQU 0               "LOW WORD OF A
        B $EQU 1
        C1 $EQU 2
        C2 $EQU 2
        D1 $EQU 3
        D2 $EQU 3
        E1 $EQU -1
        E2 $EQU -1
        S1 $EQU 0               "HIGH WORD OF SUM
        S2 $EQU 0               "LOW WORD OF SUM
        T $EQU -2
        "SCRATCH:
        "DPX: -2,-1,0,2,3;  DPY: -1,0,2,3
SDDA:   FABS DPX(A1)
        FABS DPY(B)
        FADD DPX(A1),DPY(B); DPX(T)<FA
        FSUB DPX(T),FA
        DPX(C1)<FA; FSUBR DPX(A1),FA;
        DPY(C1)<FA
        FSUBR DPY(B),DPX(C1)
        BFGE AGTB1; FSUB DPY(B),FA
        FSUB DPX(A1),FA
AGTB1:  FABS DPY(A2)
        DPX(C2)<FA; FABS FA
        FADD DPX(C2),DPY(A2); DPX(T)<FA
        FSUB DPX(T),FA
        DPY(D1)<FA; FSUBR DPX(C2),FA;
        DPX(D1)<FA
        FSUBR DPY(A2),DPX(C2)
        BFGE AGTB2; FSUB DPY(A2),FA
        FSUB DPX(C2),FA
AGTB2:  FABS DPX(D1)
        DPY(D2)<FA; FABS DPY(C1)
        FADD DPX(D1),DPY(C1); DPX(T)<FA
        FSUB DPX(T),FA
        DPY(E1)<FA; FSUBR DPX(D1),FA;
        DPX(E1)<FA
        FSUBR DPY(C1),DPX(E1)
        BFGE AGTB3; FSUB DPY(C1),FA
        FSUB DPX(D1),FA
AGTB3:  FADD
        DPX(E2)<FA; FADD DPY(D2),FA
        FADD
        DPY(S2)<FA; DPX(S1)<DPY(E1); RETURN
        $END
"****** DDDA = DOUBLE PRECISION ADDITION /COMMON/ = REL 2.0  , JAN 78 **********
        $TITLE DDDA
        $RADIX 8
        $ENTRY DDDA                          "USER-DIRECTED-CALL ENTRY
        "DOES DOUBLE PRECISION ADDITION OF A + B
        "A = DPX(A1) + DPY(A2)
        "B = DPX(B1) + DPY(B2)
        "ANSWER S = DPX(S1) + DPY(S2)
        "WHERE A1,B1,S1 ARE THE HIGH WORDS AND
        "A2,B2,S2 ARE THE LOW WORDS
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER
        "EQUIPMENT:     AP-120B WITH EITHER MEMORY
        "AUTHOR:        J. THROOP
        "DATE:          FEB. 1977
        "SIZE:          48 LOCATIONS
        "SPEED:         7.5 MICROSECONDS
                        "ALGORITHM:
        "LET C1 + C2 = SSD SUM OF A1 + B1
        "LET D1 + D2 = SSD SUM OF A2 + B2
        "LET E1 + E2 = SSD SUM OF C2 + D1
        "LET F1 + F2 = SSD SUM OF C1 + E1
        "LET G = SSS SUM OF F2 + E2
        "LET H = SSS SUM OF G + D2
        "LET S1 + S2 = SSD SUM OF F1 + H
        "THEN S = S1 + S2 IS THE CLEAN DDD SUM OF A + B
        "DATA PAD MNEMONICS
        A1 $EQU 0               "HIGH WORD OF A
        A2 $EQU 0               "LOW WORD OF A
        B1 $EQU 1               "HIGH WORD OF B
        B2 $EQU 1               "LOW WORD OF B
        C1 $EQU 2
        C2 $EQU 2
        D1 $EQU 3
        D2 $EQU 3
        E1 $EQU -1
        E2 $EQU -1
        F1 $EQU 1
        F2 $EQU 1
        G $EQU 2
        H $EQU 2
        C $EQU -2
        S1 $EQU 0               "HIGH WORD OF SUM
        S2 $EQU 0               "LOW WORD OF SUM
        "SCRATCH:
        "DPX: -2,-1,0,1,2,3.  DPY: -1,0,2,3 RELATIVE TO DPA
DDDA:   DPX(C)<DPX(B1)          "SWAP ARGUMENTS SO B = DPY(B1) + DPX(B2)
        FABS DPX(A1);           "START SSD ADD A1 + B1 >= C1 + C2
        DPX(B2)<DPY(B2)
        FABS DPX(C); DPY(B1)<DPX(C)
        FADD DPX(A1),DPY(B1); DPX(C)<FA
        FSUB DPX(C),FA
        DPY(C1)<FA; FSUBR DPX(A1),FA;   "DPY(C1) = HIGH WORD
        DPX(C1)<FA
        FSUBR DPY(B1),DPX(C1)
        BFGE AGTB1; FSUB DPY(B1),FA
        FSUB DPX(A1),FA
AGTB1:  FABS DPX(B2)            "START SSD ADD A2 + B2 >= D1 + D2
        DPX(C2)<FA; FABS DPY(A2)        "DPX(C2) = LOW WORD
        FADD DPX(B2),DPY(A2); DPX(C)<FA
        FSUB DPX(C),FA
        DPY(D1)<FA; FSUBR DPX(B2),FA;   "DPY(D1) = HIGH WORD
        DPX(D1)<FA
        FSUBR DPY(A2),DPX(D1)
        BFGE AGTB2; FSUB DPY(A2),FA
        FSUB DPX(B2),FA
AGTB2:  FABS DPX(C2)    "START SSDA DD OF C2 + D1 >= E1 + E2
        DPX(D2)<FA;FABS DPY(D1) "DPX(D2) = LOW WORD
        FADD DPX(C2),DPY(D1); DPX(C)<FA
        FSUB DPX(C),FA
        DPY(E1)<FA; FSUBR DPX(C2),FA;      "DPY(E1) = HIGH WORD
        DPX(E1)<FA
        FSUBR DPY(D1),DPX(E1)
        BFGE AGTB3; FSUB DPY(D1),FA
        FSUB DPX(C2),FA
AGTB3:  DPX(C1)<DPY(C1); FABS DPY(C1)   "START SSDADD C1 + E1 >= F1 + F2
        DPX(E2)<FA; FABS DPY(E1)        "DPX(E2) = LOW WORD
        FADD DPX(C1),DPY(E1); DPX(C)<FA
        FSUB DPX(C),FA
        DPY(F1)<FA; FSUBR DPX(C1),FA;   "DPY(F1) = HIGH WORD
        DPX(F1)<FA
        FSUBR DPY(E1),DPX(F1)
        BFGE AGTB4; FSUB DPY(E1),FA
        FSUB DPX(C1),FA
AGTB4:  FADD
        FADD DPX(E2),FA         "FA = F2
        FADD
        FADD DPX(D2),FA         "FA - G; DO G + D2 >= H
        FADD
        DPX(H)<FA; FABS FA
        FABS DPY(F1)
        FADD DPX(H),DPY(F1); DPX(C)<FA
        FSUB DPX(C),FA
        DPY(S1)<FA; FSUBR DPX(H),FA;    "S1 = HIGH WORD OF AANSWER
        DPX(S1)<FA
        FSUBR DPY(F1),DPX(S1)
        BFGE AGTB5; FSUB DPY(F1),FA
        FSUB DPX(H),FA
AGTB5:  FADD
        DPY(S2)<FA; RETURN              "S2 = LOW WORD OF ANSWER
        $END
"
"****** APNOP = DO A NOP, A DUMMY ROUTINE /COMMON/ = REL 2.0, MAY 79 *****
                $TITLE APNOP
        $RADIX 8
                $ENTRY APNOP,0
"
"       A DUMMY ROUTINE TO MAINTAIN SMS TEMPLATES AND INSTALLATION
"       PROCEDURES.  ALL FORMER FORTRAN CALLABLE UTILITY ROUTINES
"       HAVE BEEN MOVED TO THE BAB LIBRARY.
"
"       ONE POSSIBLE USE OF THIS ROUTINE IS TO GET TIMING INFORMATION.
"
        APNOP:  RETURN
                $END
$ENDLIB
