$LIB
"****** DGNSRC = AP DIAGNOSTIC LIBRARY /FAST/ = REL 2.1, JUL 80 **********
"
"     ---REVISION HISTORY---
"REV 2.1:  JUL 80
"       1. ADDS THE FOLLOWING ROUTINES:
"            APFET   --  DETERMINE AP FEATURES
"            ZMDFT   --  CLEAR MD AND DETERMINE AP FEATURES
"       2. ADDS $RADIX 8 TO ALL ROUTINES SO THAT THEY WILL
"          ASSEMBLE PROPERLY EVEN IF FOR SOME REASON THE
"          ASSEMBLER DEFAULT RADIX HAS BEEN CHANGED TO 10 OR 16
"       3. RMTST AND ACHK CLEAR APSTATUS REGISTER, PREVENTING PARITY
"          HALTS.
"
"REV 2.0:  JAN 78          RELEASE NUMBER CHANGE ONLY
"REV 3.1:  DEC 77
"     THIS IS A NEW LIBRARY.  THE FOLLOWING ROUTINES USED TO BE IN BASSRC,
"     REL 3.0:
"            SCFIFT
"            FGRN
"            FCHK
"     THE REST ARE NEW.
"
"============================================================================
"
"****** SCFIFT = FFT SELF-CHECKING IDENTITY CHECK /COMMON/ = REL 2.0, JAN 78 *
"
        $TITLE SCFIFT
        $RADIX 8
        $ENTRY SCFIFT,4
        $EXT FGRN,CFFT,FCHK,ILOG2
"
"    --- ABSTRACT ---
"GIVEN INTEGER RANDOM NUMBER SEEDS FOR THE EXPONENT AND THE MANTISSA,
"GENERATES A BUFFER OF RANDOM NUMBERS AND THEN PERFORMS THE FORWARD
"COMPLEX FFT FOLLOWED BY THE INVERSE COMPLEX FFT.  THE FINAL RESULT
"IS COMPARED TO THE ORIGINAL DATA AND SP(17) IS SET TO ZERO IF NO
"ERRORS WERE MADE, SP(17) IS SET TO ONE IF ERRORS WERE DETECTED.
"COMPATABLE WITH 'FIFFT' CALLING PROGRAM IN THE HOST
"
"
"      --- STATISTICS ----
"LANGUAGE: APAL
"EQUIPEMENT: AP 120B WITH EITHER MEMORY
"SIZE: 19 + SLFCHK (54) + CFFT (186 FAST, 184 SLOW)
"        = 259 (FAST), 257 (SLOW)
"S-PAD PARAMETERS:
"
        BASE $EQU 0  "BASE ADDRESS OF ARRAY
        N $EQU 1       "NUMBER OF COMPLEX POINTS
        IX $EQU 2       "RANDOM NUMBER SEEDS
        IY $EQU 3
        M $EQU 3       "M=LOG2(N)
"
"
"S-PAD 17 SET TO 0 IF NO ERROR, 1 IF AN ERROR
"
"
"
"
"SETUP FOR GENERATION OF RANDOM DATA
SCFIFT:MOVL N,N; REFR; DECDPA         "MAKE N NUMBER OF REAL POINTS
        MOV IX,IX; DPX(-4)<DB;DB=SPFN "PUT AWAY RANDOM NUMBER SEED VALUES
        MOV IY,IY; DPY(-4)<DB;DB=SPFN
        MOV N,17; INCDPA
        JSR ILOG2              "GET M FOR NEXT CALL
        MOV 17,2
        JSR FGRN                "CALL FGRN(BASE,N,M)
"SETUP FOR FORWARD COMPLEX FFT
        MOVR N,N                 "MAKE N NUMBER OF COMPLEX POINTS
        LDSPI 2; DB=1            "SET FLAG FOR FORWARD FFT
        JSR CFFT                "CALL CFFT(BASE,N,1)
"SETUP FOR INVERSE COMPLEX FFT
        LDSPI 2; DB=-1
        JSR CFFT                "CALL CFFT(BASE,N,-1)
"SETUP FOR CHECK
        MOV 1,17
        JSR ILOG2               "GET LOG2(N) INTO SP(17)
        MOVL N,N                "MAKE N NUMBER OF REAL POINTS
        MOV 17,2                "SET M
        JSR FCHK                "CALL FCHK(BASE,N,M)
        MOVR N,N                 "RESTORE N AND RETURN
        RETURN
        $END
"****** FGRN = (SLFCHK) GENERATE RANDOM NUM FOR SCFIFT /COMMON= REL 2.0, JAN 78
"****** FCHK = (SLFCHK) CHECK BUFFER AGAINST RANDOM NUM /COMMO= REL 2.0, JAN 78
"
"
         $TITLE SLFCHK
        $RADIX 8
        $ENTRY FGRN
        $ENTRY FCHK
"
"
"FGRN  -  GENERATE A BUFFER OF RANDOM FLOATING POINT NUMBERS
"FCHK  -  CHECK A BUFFER AGAINST THE RE-GENERATED RANDOM NUMBERS
"
"
"    --- STATISTICS ---
"LANGUAGE: APAL
"EQUIPMENT:  AP120B WITH EITHER MEMORY
"SIZE:  54 LOCATIONS
"EXECUTION          TYPICAL                   SETUP(US)
"TIME/LOOP(US):     2.67                       4.67            FGRN
"                   4.33                       4.83            FCHK
"
"
"
"PARAMETERS:
"DATA PAD:
"       DPX(-5) = XN1     IN LMAN
"       DPY(-5) = YN1     IN LMAN
"S-PAD:
"       SP(0)   = BASE
"       SP(1)   = SIZE
"       SP(2)   = LOG2(N)
"       SP(3)   = IFFT
"       SP(17)  = 0 IF NO ERRORS, 1 IF AN ERROR
"
"LOCAL VARIABLES:
"       SP(11) = COUNTER
"       SP(14) = M FOR GRN
"       SP(15)  = XN
"       SP(16)  = YN
"       SP(4)  = BB
"
"SCRATCH VARIABLES:
"       SPAD 10,12-13
"
"
"
"SPAD MNEMONICS
        BASE $EQU 0
        SIZE $EQU 1
        L2N  $EQU 2
        ERRFLG $EQU 17
        TMP  $EQU 10
        CNTR $EQU 11
        EXP1 $EQU 12
        EXP2 $EQU 13
        M    $EQU 14
        XN   $EQU 15
        YN   $EQU 16
        BB  $EQU 4
"
"
"DATA PAD USAGE
"       DPX(-5) = XN1
"       DPY(-5) = YN1
"       DPX(-4) = GRN RESULT
"       DPX(-3) = TEMP FOR ELIM
"       DPY(-3) = TEMP FOR GRN
"
FGRN:   CLR M                  "INIT M
        MOV SIZE,CNTR          "SET COUNT
        JSR GRN1               "GET FIRST ARG
        MOV BASE,BASE;         "PUT IN MD
            SETMA; MI<DPX(-4)
LOOP:   JSR GRN                "GO FOR ANOTHER
        INCMA;                 "GET NEXT
            MI<DPX(-4);        "DEC INGRN
            BNE LOOP
        RETURN
"
"
"
"    GRN GENERATES A PSEUDO-RANDOM FPN IN
"EXPONENT RANGE 1001+M TO 1033+M, WHERE
"M IS SUPPLIED BY CALLING ROUTINE .
"RESULT IN DPX(-4)
"          DPY(-3) = SCRATCH
"ENTRY AT GRN1 GENERATES BB, XN, YN, EXP1
"  AND EXP2 IN SPAD
"ENTRY AT GRN ASSUMES THEY ARE SETUP
"    GRN DOES A DEC CNTR FOR THE CALLING
"    ROUTINES LOOP COUNT.
"ALGORITHM -- XN,YN < (XN,YN) + (YN,BB)
"     XN IS A 16-BIT PSEUDO-RANDOM NUMBER.
"TWO VALUES OF XN ARE GENERATED XN(1), XN(2)
"  FPN = 2**(47+M)*XN(1) + 2**(30+M)*XN(2)
"
GRN1:   LDSPI BB; DB=156043    "SET BB
        DECDPA                 "DECREMENT DPA
        LDSPI XN; DB=DPX(-4)   "SET XN=XN1
        LDSPI YN; DB=DPY(-4)   "SET YN=YN1
        INCDPA                 "RESTORE DPA
        LDSPI EXP1; DB=47
        LDSPI EXP2; DB=30
        ADD M,EXP1
        ADD M,EXP2
GRN:    ADD YN,XN              "FIRST RANDOM INTEGER
        ADD BB,YN             "ADD BB
        BZC .+2
        INC XN                 "PROPAGATE CARRY
        MOV XN,XN; DB=SPFN;    "GET FIRST PART
            DPX(-4)<DB
        MOV EXP1,EXP1;         "NORMALIZE
            FADD ZERO,MDPX(-4)
        FADD;                  "PUSH PIPE
            ADD YN,XN          "START NEXT RNG
        ADD BB,YN; DPY(-3)<FA  "GET FIRST PART
        BZC .+2
        INC XN                 "PROPAGATE CARRY
        MOVR# XN,XN; DB=SPFN;  "CLEAR SIGN
            DPX(-4)<DB         "PUT IN DPX
        FADD DPY(-3),MDPX(-4); "AND SECOND HALF
            MOV EXP2,EXP2
        FADD                    "PUSH
        DPX(-4)<FA;            "GET RESULT
            RETURN; DEC CNTR   "BUMP COUNTER
"
"
"
FCHK:   MOV SIZE,CNTR          "GET COUNT
        MOV L2N,M              "SET SCALE FACTOR
        MOV BASE,BASE; SETMA   "READ FIRST
        CLR ERRFLG             "CLEAR ERROR FLAG
        JSR GRN1
FLOP1:  FSUB DPX(-4),MD;       "COMPARE WITH
            LDSPI TMP; DB=100  "ACTUAL
        FADD; ADD M,TMP;       "PUSH
            DPX(-3)<DB;        "COMPUTE MANTISSA
            DB=SPFN            "OF ELIM
        FABS FA;               "TAKE ABSOLUTE
            LDSPI TMP; DB=33   "VALUE
        FADD                    "PUSH
        ADD M,TMP; DB=SPFN;    "GEN. EXPONENT
            DPX(-3)<DB; WRTEX  "OF ELIM
        FSUBR DPX(-3),FA       "COMPARE
        FADD                    "PUSH
        NOP                    "WAIT
        BFGT ERR;              "ERROR?
            MOV CNTR,CNTR      "TEST LOOP COUNT
FLOOP:  BEQ DONE; INCMA        "FETCH NEXT ACTUAL
        JSR GRN                "GET NEXT EXP
        BR FLOP1
DONE:   RETURN
"
"
ERR:      LDSPI ERRFLG; DB=1  "SET ERROR FLAG TO 1
        HALT
        NOP
        CLR ERRFLG
        MOV CNTR,CNTR
        BR FLOOP
        $END
"****** RMTST = RANDOM MD MEMORY TEST /COMMON/ = REL 2.1, JUL 80 ************
        $TITLE RMTST
        $RADIX 8
        $ENTRY RMTST,3
        $EXT    BITS
        $EXT    BCHK
        $EXT    RGEN
"
"     -- HISTORY --
"REL 2.1:  JUL 80  L.A. POEHLITZ
"          ADDED ZERO OF APSTATUS REG
"
"FILLS AND CHECKS 'CT' MEMORY LOCATIONS STARTING AT 'CA' WITH RANDOM
"NUMBERS GENERATED FROM SEED 'RPAR'. ON ERROR, RETURNS WITH
"'ERRS' = 1, 'REX', 'RHM' AND 'RLM' EQUAL TO THE EXPONENT,
"HI MANTISSA AND LO MANTISSA ACTUALLY FOUND IN LOCATION 'CA'.
"ALSO SETS 'EX', 'HM' AND 'LM' EQUAL THE EXPECTED EX, HM AND LM.
"SPAD PARAMETERS
        CT   $EQU 0     "ITERATION COUNT
        CA   $EQU 1     "CURRENT ADDRESS
        RPAR $EQU 2     "RANDOM NUMBER PARAMETER (TEMP FOR CALL)
        EX   $EQU 2     "EXPONENT
        HM   $EQU 3     "HI MANTISSA
        LM   $EQU 4     "LO MANTISSA
        REX  $EQU 5     "RECEIVED EXPONENT
        RHM  $EQU 6     "RECEIVED HI MANTISSA
        RLM  $EQU 7     "RECEIVED LO MANTISSA
        RND  $EQU 10    "RANDOM NUMBER SEED
        ERRS $EQU 17    "ERROR SWITCH
"GET RANDOM NUMBER FM FORTRAN CALL INTO 'RND'
" CLEAR APSTATUS REG DISABLING PARITY HALTS
RMTST:  MOV RPAR,RND; DB=ZERO ; LDAPS
"GET 'RND' INTO LO MANTISSA
LOOP:   MOV RND,LM
"GET BIT REVERSED 'RND' INTO HI MANTISSA; SEE IF 'RND' WAS NEGATIVE
        MOVR &RND,HM; BGE .+2
"IF 'RND' WAS NEGATIVE, COMPLEMENT HI MANTISSA
        COM HM
"MOVE SHIFTED 'RND' INTO EXPONENT
        MOVR RND,EX
"SEE IF IT WAS ODD OR EVEN
        BZC .+2
"IF IT WAS ODD, COMPLEMENT EXPONENT
        COM EX
"WRITE EX, HM & LM INTO MEMORY LOCATION 'CA'
        JSR BITS
"READ BACK AND CHECK IF CORRECT
        JSR BCHK
"LOOK AT ERROR SWITCH
        MOV ERRS,ERRS
"IF ZERO, SKIP
        BEQ .+2
"IF SET, RETURN
        RETURN
"GET NEW RANDOM NUMBER
        JSR RGEN
"DECREMENT COUNTER
        DEC CT
"INCREMENT MEMORY ADDRESS; IF NOT FINISHED GOTO LOOP
        INC CA; BNE LOOP
"IF FINISHED, RETURN.
        RETURN
        $END
"****** BITS = FILLS 38 BIT MD LOC FROM 3 S-PADS /COMMON/ = REL 2.0, JAN 78 *
        $TITLE BITS
        $RADIX 8
        $ENTRY BITS,5
"PUTS NUMBERS IN SPAD 'EX', 'HM', 'LM' INTO THE EXPONENT, HIGH MANTISSA
"AND LOW MANTISSA OF MAIN DATA LOCATION 'CA', ALSO INTO DPX.
"SPAD PARAMETERS
        CT   $EQU 0     "ITERATION COUNT
        CA   $EQU 1     "CURRENT ADDRESS
        EX   $EQU 2     "EXPONENT
        HM   $EQU 3     "HI MANTISSA
        LM   $EQU 4     "LO MANTISSA
        T1   $EQU 14    "TEMPORARY REGISTER
        M15  $EQU 15    "15 BIT MASK
        N12  $EQU 16    "NUMBER 12
"SET UP 15 BIT MASK TO FORCE POSITIVE NUMBERS
BITS:   LDSPI M15; DB=77777
"GET DPY EXPONENT = 0
        CLR N12; DB=SPFN; DPY<DB
"SET UP DECIMAL 12 TO ALIGN EXPONENTS AFTER 12 POSITION SHIFT
        LDSPI N12; DB=12.
"GET LO MANTISSA ONTO SPFN SO WE CAN SEE IF IT IS NEGATIVE
        MOV LM,LM
"SHIFT HI MANTISSA LEFT 1 BIT; IF LM WAS POSITIVE SKIP NEXT INSTR
        MOVL HM,T1; BGE .+2
"IF LM WAS NEGATIVE, ATTACH BIT TO RIGHT OF SHIFTED HM
        INC T1
"FORCE POSITIVE LM, WRITE INTO DPY MANTISSA, LEAVE EXP OF ZERO
        AND# M15,LM; DB=SPFN; DPY<DB; WRTMAN
"SHIFT HM LEFT 2 PLACES
        ADDL T1,T1
"SHIFT HM LEFT ONE MORE PLACE, THEN GET INTO DPX MANTISSA
        MOVL T1,T1; DB=SPFN; DPX<DB
"NORMALIZE IT, START WITH EXP OF 12 SO SHIFT LEFT 12 PLACES
"- WHICH ALIGNS IT CORRECTLY IN HM - GIVES EXP OF ZERO
        FADD ZERO,MDPX; MOV N12,N12
"PUSH; GET FINAL EXPONENT IN DPX
        FADD; MOV EX,EX; DB=SPFN; DPX<DB
"ADD TO DPY, WHICH CONTAINS LM AND ZERO IN HM, FORMING WHOLE MANTISSA
"ALSO GET FINAL EXPONENT IN MEM AT CURRENT ADDRESS
        FADD DPY,FA; MOV CA,CA; SETMA; DB=DPX; MI<DB
"PUSH; GET ZERO IN T1
        FADD; CLR T1
"SCALE TIL EXPONENT IS ZERO (BY GETTING 1 ON SPFN)
        INC T1; FSCLT FA
"PUSH
        FADD
"WRITE MANTISSA IN MEM AT CURRENT ADDRESS; ALSO IN DPX
        MOV CA,CA; SETMA; MI<FA; DPX<FA; WRTMAN; RETURN
        $END
"****** BCHK = CHECK 38 BIT MD LOC EQUALS 3 S-PADS /COMMON/ = REL 2.0, JAN 78
        $TITLE BCHK
        $RADIX 8
        $ENTRY BCHK,5
"CHECKS THAT MEMORY LOCATION 'CA' CONTAINS EXPONENT 'EX',
"HI MANTISSA 'HM' AND LO MANTISSA 'LM'. IF NOT, RETURNS WITH
"'ERRS' = 1, 'REX', 'RHM' AND 'RLM' EQUAL TO THE EXPONENT,
"HI MANTISSA AND LO MANTISSA ACTUALLY FOUND IN LOCATION 'CA'.
"ALSO SETS 'EX', 'HM' AND 'LM' EQUAL THE EXPECTED EX, HM AND LM.
"SPAD PARAMETERS
        CT   $EQU 0     "ITERATION COUNT
        CA   $EQU 1     "CURRENT ADDRESS
        EX   $EQU 2     "EXPONENT
        HM   $EQU 3     "HI MANTISSA
        LM   $EQU 4     "LO MANTISSA
        REX  $EQU 5     "RECEIVED EXPONENT
        RHM  $EQU 6     "RECEIVED HI MANTISSA
        RLM  $EQU 7     "RECEIVED LO MANTISSA
        T1   $EQU 12    "TEMPORARY REGISTER
        T2   $EQU 13    "TEMPORARY REGISTER
        M10  $EQU 14    "10 BIT MASK
        M12  $EQU 15    "12 BIT MASK
        N17  $EQU 16    "NUMBER 17
        ERRS $EQU 17    "ERROR SWITCH
"SET UP 10 BIT MASK FOR EXPONENT
BCHK:   LDSPI M10; DB=1777
"SET UP 12 BIT MASK FOR HI MANTISSA
        LDSPI M12; DB=7777
"SET UP DECIMAL 17 TO SCALE HM TO LM SO WE CAN LDSPI THE HM
        LDSPI N17; DB=17.
"GET CONTENTS OF MEMORY LOCATION TO TEST
GETM:   MOV CA,CA; SETMA
"CLEAR ERROR FLAG; GET EXPONENT OF 0 IN DPX
        CLR ERRS; DB=SPFN; DPX<DB
"TEMPORARILY SAVE CORRECT EXPONENT
        MOV EX,T1
"TEMPORARILY SAVE CORRECT HI MANTISSA
        MOV HM,T2
"GET RECEIVED HI MANTISSA IN DPX WITH EXP & LO MANTISSA OF ZERO
        DPX<DB; DB=MD; WRTHMN
"GET RECEIVED LO MANTISSA IN RLM
        LDSPI RLM; DB=MD
"SCALE DPX TO GET HI MANTISSA MOVED TO LO MANTISSA POSITION
        FSCLT DPX; MOV N17,N17
"PUSH; GET RECEIVED EXPONENT IN REX
        FADD; LDSPE REX; DB=MD
"GET ADDER RESULT (LM<HM) IN DPX; SEE IF LO MANTISSA CORRECT
        DPX<FA; SUB# RLM,LM
"GET RECEIVED HI MANTISSA IN RHM; IF LM WAS WRONG GOTO ERR
        LDSPI RHM; DB=DPX; BNE ERR
"CHECK IF REX WAS EQUAL TO EX.
        SUB REX,T1
"MASK OUT UPPER BITS
        AND M10,T1
"CHECK IF RHM WAS EQUAL TO HM; IF REX WAS BAD, GOTO ERR.
        SUB RHM,T2; BNE ERR
"MASK OUT UPPER BITS
        AND M12,T2
"IF RHM WAS BAD GOTO ERR.
        BNE ERR
"IF ALL WAS GOOD, RETURN WITH ERRS = 0
        RETURN
"SET ERRS = 1
ERR:    LDSPI ERRS; DB=1
"MASK HM, RHM, EX, REX TO PROPER LENGTH; RETURN WITH ERRS = 1
        AND M12,HM
        AND M12,RHM
        AND M10,EX
        AND M10,REX; RETURN
        $END
"****** RGEN = GENERATE PSUEDO-RANDOM BINARY SEQ /COMMON/ = REL 2.0, JAN 78 *
        $TITLE RGEN
        $RADIX 8
        $ENTRY RGEN
"GENERATES 16 BIT RANDOM NUMBERS FROM SEED IN SP10, THEN UPDATES SEED.
"SPAD PARAMETERS
        T1   $EQU 2     "TEMPORARY REGISTER
        T2   $EQU 3     "TEMPORARY REGISTER
        N1   $EQU 4     "NUMBER 1
        RND  $EQU 10    "RANDOM NUMBER SEED
"GET RND INTO T1; FIND OUT IF IT IS ZERO
RGEN:   MOV RND,T1
"SHIFT RND LEFT SO WE CAN ADD NEW BIT; SKIP NEXT INSTR IF RND NOT ZERO
        MOVL RND,RND; BNE .+2
"IF ZERO GET NEW VALUE AND RETURN.
        LDSPI RND; DB=8646.; RETURN
"GET DECIMAL 1 INTO 'N1'
        LDSPI N1; DB=1
"GET BIT 13 INTO BIT 15 OF T2
        MOVRR T1,T2
"GET ZERO IN APS; GET BIT 15 + BIT 13 IN BIT 14
        LDAPS; DB=ZERO; ADDL T1,T2
"GET 4 IN APS; GET BIT 14 = SUM OF BITS 0, 13 + 15
        LDAPS; DB=4; ADD &T1,T2
"GET BIT 15 = SUM OF BITS 0, 3, 13 + 15
        ADDR &T1,T2
"GET RID OF EVERYTHING BUT BIT 15
        AND N1,T2
"NOW ADD THIS BIT IN TO GET NEW RANDOM NUMBER.
        ADD T2,RND; RETURN
        $END
"****** BADD = STORE ADDR IN EX, HMAN, AND LMAN OF MD /COMMO= REL 2.0, JAN 78
        $TITLE BADD
        $RADIX 8
        $ENTRY BADD,2
"PUTS NUMBER IN 'CA' INTO THE EXPONENT, HIGH MANTISSA,
"AND LOW MANTISSA OF MAIN DATA LOCATION 'CA', ALSO INTO DPX.
"DECREMENTS COUNTER 'CT', AND INCREMENTS 'CA' UNTIL 'CT' EQUALS ZERO.
"STORES EACH LOCATIONS ADDRESS IN THAT LOCATION.
"SPAD PARAMETERS
        CT   $EQU 0     "ITERATION COUNT
        CA   $EQU 1     "CURRENT ADDRESS
        EX   $EQU 2     "EXPONENT
        HM   $EQU 3     "HI MANTISSA
        LM   $EQU 4     "LO MANTISSA
        T1   $EQU 14    "TEMPORARY REGISTER
        M15  $EQU 15    "15 BIT MASK
        N12  $EQU 16    "NUMBER 12
"SET UP 15 BIT MASK TO FORCE POSITIVE NUMBERS
BADD:   LDSPI M15; DB=77777
"GET DPY EXPONENT = 0
        CLR N12; DB=SPFN; DPY<DB
"SET UP DECIMAL 12 TO ALIGN EXPONENTS AFTER 12 POSITION SHIFT
        LDSPI N12; DB=12.
"GET LO MANTISSA ONTO SPFN SO WE CAN SEE IF IT IS NEGATIVE
LOOP:   MOV CA,LM
"SHIFT HI MANTISSA LEFT 1 BIT; IF LM WAS POSITIVE SKIP NEXT INSTR
        MOVL CA,T1; BGE .+2
"IF LM WAS NEGATIVE, ATTACH BIT TO RIGHT OF SHIFTED HM
        INC T1
"FORCE POSITIVE LM, WRITE INTO DPY MANTISSA, LEAVE EXP OF ZERO
        AND# M15,LM; DB=SPFN; DPY<DB; WRTMAN
"SHIFT HM LEFT 2 PLACES
        ADDL T1,T1
"SHIFT HM LEFT ONE MORE PLACE, THEN GET INTO DPX MANTISSA
        MOVL T1,T1; DB=SPFN; DPX<DB
"NORMALIZE IT, START WITH EXP OF 12 SO SHIFT LEFT 12 PLACES
"- WHICH ALIGNS IT CORRECTLY IN HM - GIVES EXP OF ZERO
        FADD ZERO,MDPX; MOV N12,N12
"PUSH; GET FINAL EXPONENT IN DPX
        FADD; MOV CA,EX; DB=SPFN; DPX<DB
"ADD TO DPY, WHICH CONTAINS LM AND ZERO IN HM, FORMING WHOLE MANTISSA
"ALSO GET FINAL EXPONENT IN MEM AT CURRENT ADDRESS
        FADD DPY,FA; MOV CA,CA; SETMA; DB=DPX; MI<DB
"PUSH; GET ZERO IN T1
        FADD; CLR T1
"SCALE TIL EXPONENT IS ZERO (BY GETTING 1 ON SPFN)
        INC T1; FSCLT FA
"PUSH; DECREMENT COUNTER
        FADD; DEC CT
"WRITE MANTISSA IN MEM AT CURRENT ADDRESS; ALSO IN DPX
        MOV CA,CA; SETMA; MI<FA; DPX<FA; WRTMAN; BEQ .+2
        INC CA; BR LOOP
        RETURN
        $END
"****** ACHK = CHECKS THAT MD LOC CONTAINS ITS ADDR /COMMON/= REL 2.1, JUL 80
        $TITLE ACHK
        $RADIX 8
        $ENTRY ACHK,2
"
"     -- HISTORY --
"REL 2.1:  JUL 80 L.A. POEHLITZ
"           ADDED ZERO OF APSTATUS REG
"
"CHECKS THAT MEMORY LOCATION 'CA' CONTAINS EXPONENT 'CA',
"HI MANTISSA 'CA' AND LO MANTISSA 'CA'. IF NOT, RETURNS WITH
"'ERRS' = 1, 'REX', 'RHM' AND 'RLM' EQUAL TO THE EXPONENT,
"HI MANTISSA AND LO MANTISSA ACTUALLY FOUND IN LOCATION 'CA'.
"ALSO SETS 'EX', 'HM' AND 'LM' EQUAL THE EXPECTED EX, HM AND LM.
"SPAD PARAMETERS
        CT   $EQU 0     "ITERATION COUNT
        CA   $EQU 1     "CURRENT ADDRESS
        EX   $EQU 2     "EXPONENT
        HM   $EQU 3     "HI MANTISSA
        LM   $EQU 4     "LO MANTISSA
        REX  $EQU 5     "RECEIVED EXPONENT
        RHM  $EQU 6     "RECEIVED HI MANTISSA
        RLM  $EQU 7     "RECEIVED LO MANTISSA
        T1   $EQU 12    "TEMPORARY REGISTER
        T2   $EQU 13    "TEMPORARY REGISTER
        M10  $EQU 14    "10 BIT MASK
        M12  $EQU 15    "12 BIT MASK
        N17  $EQU 16    "NUMBER 17
        ERRS $EQU 17    "ERROR SWITCH
" CLEAR APSTATUS REG DISABLING PARITY HALTS
ACHK:   DB=ZERO; LDAPS
"SET UP 10 BIT MASK FOR EXPONENT
        LDSPI M10; DB=1777
"SET UP 12 BIT MASK FOR HI MANTISSA
        LDSPI M12; DB=7777
"SET UP DECIMAL 17 TO SCALE HM TO LM SO WE CAN LDSPI THE HM
        LDSPI N17; DB=17.
"GET CONTENTS OF MEMORY LOCATION TO TEST
GETM:   MOV CA,CA; SETMA
"CLEAR ERROR FLAG; GET EXPONENT OF 0 IN DPX
        CLR ERRS; DB=SPFN; DPX<DB
"TEMPORARILY SAVE CORRECT EXPONENT
        MOV CA,T1
"TEMPORARILY SAVE CORRECT HI MANTISSA
        MOV CA,T2
"GET RECEIVED HI MANTISSA IN DPX WITH EXP & LO MANTISSA OF ZERO
        DPX<DB; DB=MD; WRTHMN
"GET RECEIVED LO MANTISSA IN RLM
        LDSPI RLM; DB=MD
"SCALE DPX TO GET HI MANTISSA MOVED TO LO MANTISSA POSITION
        FSCLT DPX; MOV N17,N17
"PUSH; GET RECEIVED EXPONENT IN REX
        FADD; LDSPE REX; DB=MD
"GET ADDER RESULT (LM<HM) IN DPX; SEE IF LO MANTISSA CORRECT
        DPX<FA; SUB# RLM,CA
"GET RECEIVED HI MANTISSA IN RHM; IF LM WAS WRONG GOTO ERR
        LDSPI RHM; DB=DPX; BNE ERR
"CHECK IF REX WAS EQUAL TO EX.
        SUB REX,T1
"MASK OUT UPPER BITS
        AND M10,T1
"CHECK IF RHM WAS EQUAL TO HM; IF REX WAS BAD, GOTO ERR.
        SUB RHM,T2; BNE ERR
"MASK OUT UPPER BITS
        AND M12,T2
"IF RHM WAS BAD GOTO ERR.
        DEC CT; BNE ERR-1
"IF ALL WAS GOOD, GET NEXT ADDRESS. OR IF FINISHED, RETURN.
        INC CA; BNE GETM
"RETURN
        RETURN
"IF WE DECREMENTED COUNTER, INCREMENT
        INC CT
"SET ERRS = 1
ERR:    LDSPI ERRS; DB=1
"MASK HM, RHM, EX, REX TO PROPER LENGTH; RETURN WITH ERRS = 1
        MOV CA,LM
        MOV CA,EX
        MOV CA,HM
        AND M12,HM
        AND M12,RHM
        AND M10,EX
        AND M10,REX; RETURN
        $END
"****** ZMDFT = CLEAR MD AND DETERMINE AP FEATURES /COMMON/ = REL 2.0, JUL 80
        $TITLE ZMDFT
        $RADIX 8
        $ENTRY ZMDFT,0
        $EXT ZMD,APFET
"
"    --- ABSTRACT ---
"
"CLEARS ALL MD LOCATIONS TO 0 AND THEN
"DETERMINES AP TYPE (120/190 OR 100), MAIN DATA SPEED (STANDARD -- 2 CYCLE,
"OR FAST -- 1 CYCLE), TMROM SIZE (2.5K OR 4.5K), TMRAM STARTING ADDRESS
"(4096 OR 8192), WHETHER TMRAM EXISTS OR NOT.  IN ADDITION THIS ROUTINE
"IS CODED IN SEPARATE VERSIONS FOR STANDARD AND FAST MEMORY SPEED AND
"TMROM SIZE.  COMPARISON IS MADE OF MD TYPE AND TMROM SIZE DETERMINED
"FROM THE AP ON WHICH THIS ROUTINE IS RUN WITH THOSE EXPECTED FROM THE
"ROUTINE.
"
"STATUS INFORMATION IS RETURNED IN SP(17) AND IN TMA AS FOLLOWS:
"(BITS ARE NUMBERED 0-15, LEFT-TO-RIGHT)
"
"   BIT            CONTENTS
"
"   0-6            UNUSED
"
"     7            APTYPE   0 = AP120B/190L
"                           1 = FPS100
"
"     8            RAM      0 = NO TMRAM EXISTS
"                           1 = TMRAM EXISTS
"
"     9            RAMFWA   0 = TMRAM STARTS AT 4096 (EVEN IF NOT THERE)
"                           1 = TMRAM STARTS AT 8192 (EVEN IF NOT THERE)
"
"    10            ROM      0 = 2.5K TMROM
"                           1 = 4.5K TMROM
"
"    11            MDTYPE   0 = 2-CYCLE (STANDARD) MAIN DATA MEMORY
"                           1 = 1-CYCLE (FAST)     MAIN DATA MEMORY
"
"    12            EXPROM   0 = SW EXPECTS 2.5K TMROM
"                           1 = SW EXPECTS 4.5K TMROM
"
"    13            EXPMD    0 = SW EXPECTS 2-CYCLE MAIN DATA MEMORY
"                           1 = SW EXPECTS 1-CYCLE MAIN DATA MEMORY
"
"    14            ROMERR   0 = ROM SIZE SAME AS EXPECTED BY SW
"                           1 = ROM SIZE DIFFERS FROM EXPECTED SIZE
"
"    15            MDERR    0 = MD TYPE SAME AS EXPECTED BY SW
"                           1 = MD TYPE DIFFERS FROM EXPECTED TYPE
"
"
"  --- STATISTICS ---
"SIZE: 2 + APFET (64) + ZMD (29) = 95 PS WORDS
"SPEED: 10.7 USEC (120B/190L), 16.0 USEC (FPS100)
"            PLUS FOR EACH MD WORD:  0.167 USEC (FAST MD 120/190)
"                                    0.25  USEC (FPS100)
"                                    0.333 USEC (STANDARD MD 120/190)
"
"  --- USAGE ---
"FORTRAN CALL:  CALL ZMDFT
"APAL CALL:     JSR ZMDFT
"SCRATCH:       SP(0-17),DPX(0,1),DPY(0),TM,MD,DA
"EXTERNALS:     ZMD, APFET
"
"INPUT PARAMETERS:   NONE
"OUTPUT PARAMETERS:  STATUS IN BITS 7-15 OF TMA AND SP(15)
"
"  --- HISTORY ---
"ORIGINAL:   JUL 80   R.S. NORIN
"
"S-PAD ASSIGNMENTS:  NONE
"
ZMDFT:  JSR ZMD                          "CLEAR MD
        JMP APFET                        "DETERMINE AP FEATURES
                                         "RETURNING THEM IN TMA AND
                                         "SP(15). EXIT THRU APFET
        $END
"****** ZMD = CLEAR ALL PAGES OF MAIN DATA MEMORY /COMMON/ = REL 2.0, JAN 78
"
        $TITLE ZMD
        $RADIX 8
        $ENTRY ZMD,0
"
"                       --- ABSTRACT ---
"
"ZMD CLEARS ALL THE INSTALLED PAGES OF MAIN DATA MEMORY
"
"                       --- STATISTICS ---
"LANGUAGE:      APAL
"AUTHOR:        A.E. CHARLESWORTH
"DATE:          DEC 77
"EQUIPMENT:     AP-120B WITH FAST OR SLOW MAIN DATA MEMORY
"SIZE:          29 LOCATIONS
"SPEED:         0.167 US PER INSTALLED MEMORY LOCATION (FAST MD)  OR
"               0.333 US  "    "    "     "     "   "  (SLOW MD)
"                       PLUS 1.5 US. PER 8K OF INSTALLED MEMORY
"                       PLUS 47 US. IF PAGE SELECT IS INSTALLED,
"                         OR  4 US. IS PAGE SELECT IS NOT INSTALLED
"
"
"S-PAD DEFINITIONS:
        PAGE $EQU 0     "CURRENT PAGE NUMBER
        SIZE $EQU 1     "SIZE OF THE CURRENT PAGE
        MEMINC $EQU 2   "MEMORY INCREMENT
        TEST $EQU 3     "TEST VALUE
        TEMP $EQU 4     "TEST RESULT
        COUNT $EQU 5    "INCREMENT COUNTER
"
"DEFINED CONSTANTS
        MINVAL $EQU 8192.       "MEMORY MODULE INCREMENT
        MODCNT $EQU 8.          "NUMBER OF MEMORY MODULES
        MAXPAG $EQU 15.         "MAXIMUM PAGE NUMBER
        MAE $EQU 30             "MA EXTENSION DEVICE ADDRESS
        TVAL $EQU 7             "TEST VALUE
"
"       FIRST SEE IF THE PAGE SELECT OPTION IS INSTALLED
"
ZMD:  LDSPI TEST; DB=TVAL     "SET TEST VALUE IN SPAD
        DPX(0)<TVAL             "AND DATA PAD
        LDSPI MEMINC; DB=MINVAL "SET MEMORY INCREMENT
        LDDA; DB=MAE            "SET DEVICE ADDRESS TO MAE
        OUT; DB=TVAL            "TRY TO WRITE MAE
        IN; DB=INBS; LDSPI TEMP "AND READ IT BACK
        SUB TEST,TEMP
        BEQ YES                 "BRANCH IF YES
NO:     CLR PAGE; BR PAGELP     "NO, JUST CLEAR PAGE ZERO
YES:    LDSPI PAGE; DB=MAXPAG   "YES, CLEAR ALL POSSIBLE PAGES
"
"-------LOOP FOR EACH PAGE
"
PAGELP: MOV PAGE,PAGE; DB=SPFN; OUT     "SET CURRENT PAGE
        LDSPI SIZE; DB=-1       "INITIAL ADDRESS
        LDSPI COUNT; DB=MODCNT  "SET MODULE COUNT
"
"-------LOOP TO SIZE THE PAGE
"
SIZELP: ADD MEMINC,SIZE; SETMA; "WRITE OUT THE TEST VALUE
           MI<DPX(0)
        MOV SIZE,SIZE; SETMA    "READ IT BACK
        NOP
        NOP
        LDSPI TEMP; DB=MD       "INTO SPAD
        SUB TEST,TEMP
        BNE PAST; DEC COUNT     "BRANCH IF WENT PAST THE END OF A PAGE
        BNE SIZELP
"
"PAGE FULL, GO CLEAR
"
        MOV SIZE,SIZE;
         BR CLRLP
"
"PAST END, SUBTRACT MEMINC TO GET LAST LOCATION
"
PAST:   SUB MEMINC,SIZE
        INC SIZE                "INCREMENT TO GET COUNT OF LOCATIONS
"
"-------LOOP TO CLEAR ALL THE INSTALLED LOCATIONS ON A PAGE
"
"       (THE LOOP ALWAYS CLEARS LOCATION 65535 AFTER CLEARING LOCATION
"        ZERO, EXCEPT WHEN THE SIZE WAS ZERO, IN WHICH CASE LOCATION
"        0 ONLY IS CLEARED)
"
CLRLP:  DEC SIZE; SETMA; MI<ZERO; BNE CLRLP     "CLEAR THE PAGE
"
"SEE IF DONE WITH ALL THE PAGES
"
        DEC PAGE
        BLT DONE
        JMP PAGELP
"
DONE:   RETURN
        $END
"****** APFET = DETERMINE AP FEATURES /FAST/ = REL 2.0, JUL 80 *****
        $TITLE APFET
        $RADIX 8
        $ENTRY APFET,0
"
"    --- ABSTRACT ---
"
"DETERMINES AP TYPE (120/190 OR 100), MAIN DATA SPEED (STANDARD -- 2 CYCLE,
"OR FAST -- 1 CYCLE), TMROM SIZE (2.5K OR 4.5K), TMRAM STARTING ADDRESS
"(4096 OR 8192), WHETHER TMRAM EXISTS OR NOT.  IN ADDITION THIS ROUTINE
"IS CODED IN SEPARATE VERSIONS FOR STANDARD AND FAST MEMORY SPEED AND
"TMROM SIZE.  COMPARISON IS MADE OF MD TYPE AND TMROM SIZE DETERMINED
"FROM THE AP ON WHICH THIS ROUTINE IS RUN WITH THOSE EXPECTED FROM THE
"ROUTINE.
"
"STATUS INFORMATION IS RETURNED IN SP(17) AND IN TMA AS FOLLOWS:
"(BITS ARE NUMBERED 0-15, LEFT-TO-RIGHT)
"
"   BIT            CONTENTS
"
"   0-6            UNUSED
"
"     7            APTYPE   0 = AP120B/190L
"                           1 = FPS100
"
"     8            RAM      0 = NO TMRAM EXISTS
"                           1 = TMRAM EXISTS
"
"     9            RAMFWA   0 = TMRAM STARTS AT 4096 (EVEN IF NOT THERE)
"                           1 = TMRAM STARTS AT 8192 (EVEN IF NOT THERE)
"
"    10            ROM      0 = 2.5K TMROM
"                           1 = 4.5K TMROM
"
"    11            MDTYPE   0 = 2-CYCLE (STANDARD) MAIN DATA MEMORY
"                           1 = 1-CYCLE (FAST)     MAIN DATA MEMORY
"
"    12            EXPROM   0 = SW EXPECTS 2.5K TMROM
"                           1 = SW EXPECTS 4.5K TMROM
"
"    13            EXPMD    0 = SW EXPECTS 2-CYCLE MAIN DATA MEMORY
"                           1 = SW EXPECTS 1-CYCLE MAIN DATA MEMORY
"
"    14            ROMERR   0 = ROM SIZE SAME AS EXPECTED BY SW
"                           1 = ROM SIZE DIFFERS FROM EXPECTED SIZE
"
"    15            MDERR    0 = MD TYPE SAME AS EXPECTED BY SW
"                           1 = MD TYPE DIFFERS FROM EXPECTED TYPE
"
"
"  --- STATISTICS ---
"SIZE: 64 WORDS
"SPEED: 10.7 USEC (120B/190L), 16.0 USEC (FPS100)
"
"  --- USAGE ---
"FORTRAN CALL:  CALL APFET
"APAL CALL:     JSR APFET
"SCRATCH:       SP(6-17),DPX(0,1),DPY(0),TM,MD,DA
"EXTERNALS:     NONE
"
"INPUT PARAMETERS:   NONE
"OUTPUT PARAMETERS:  STATUS IN BITS 7-15 OF TMA AND SP(15)
"
"  --- HISTORY ---
"ORIGINAL:   JUL 80   R.S. NORIN
"
"S-PAD ASSIGNMENTS:
"  NAME       NR
  RAMFWA $EQU  6
  ERRMT  $EQU  7
  MDTYPE $EQU 10
  ACTMT  $EQU 11
  RAM    $EQU 12
  APTYPE $EQU 13
  ROM    $EQU 14
  EXPMT  $EQU 15
"
"THE FOLLOWING VALUE IS DEPENDENT ON THE MD TYPE EXPECTED BY THIS ROUTINE.
"    IF STANDARD (2-CYCLE) MD,    EXMD $EQU 0
"    IF FAST (1-CYCLE) MD,        EXMD $EQU 1
"
        EXMD $EQU 1
"
"TEST FOR AP TYPE (120/190 OR 100) BY DETERMINING WHETHER AN LDSPI
"INSTRUCTION CHANGES SPFN.  THE 120/190 DOES, THE 100 DOESNT.
"SET APTYPE TO 0 IF 120/190, TO 1 IF 100.
"
APFET:  CLR 17
        INC 17                  "SET SPFN TO 1
        LDSPI 17; DB=0
        DPX<SPFN                 "SPFN IS STILL 1 FOR A 100,
                                 "  BUT 0 FOR 120
        LDSPI APTYPE; DB=DPX    "SAVE RESULT, 0 IF 120, 1 IF 100
"
"TEST FOR TMROM SIZE (2.5K OR 4.5K) BY EXAMINING TMROM LOCATION
"4371 (OCTAL).  THIS LOCATION CONTAINS 0.0 IF 2.5K TMROM, NONZERO IF
"4.5K TMROM.  SET SP(ROM) TO 0 IF 2.5K, TO 1 IF 4.5K.
"
TSTROM: LDTMA; DB=4371          "EXAMINE TM LOCATION 4371
        CLR ROM                 "CLEAR RESULT
        DB=TM                   "TEST TM
        BDBZ TSTMD              "BRANCH IF 0.0 (2.5K TMROM)
        INC ROM                 "SET RESULT TO 1 IF 4.5K TMROM
"TEST FOR MD TYPE (1 OR 2 CYCLE) BY PERFORMING THREE CONSECUTIVE
"FETCHES FROM MD.  THE VALUE IN MD IN THE CYCLE IMMEDIATELY FOLLOWING
"THE THIRD FETCH WILL BE THE FIRST VALUE FETCHED IF 1-CYCLE MEMORY,
"OR THE SECOND VALUE FETCHED IF 2-CYCLE MEMORY.
"MD LOCATIONS 0 AND 1 ARE USED FOR THIS TEST BUT ARE RESTORED TO
"THEIR ORIGINAL VALUES.
"S-PAD MDTYPE IS SET TO 0 IF 2-CYCLE (STANDARD) MEMORY, TO 1 IF 1-CYCLE
"(FAST) MEMORY.
"
TSTMD:  CLR 15; SETMA                   "GET MD(0)
        INC# 15; SETMA; DPY(0)<SPFN     "GET MD(1), STORE 1 IN DPY(0)
        LDSPI 17; DB=1                  "ASSUME FAST MEMORY
        DPX(0)<MD                       "SAVE MD(0)
        DPX(1)<MD                       "SAVE MD(1)
        MOV 15,15; SETMA; MI<DPY(0)     "STORE 1 IN MD(0)
        DPY(0)<2                        "PREPARE TO WRITE A 2
        INC# 15; SETMA; MI<DPY(0)       "STORE 2 IN MD(1)
        NOP                             "WAIT
        MOV 15,15; SETMA                "GET MD(0)=1
        INC# 15; SETMA                  "GET MD(1)=2
        MOV 15,15; SETMA                "GET MD(0)=1 AGAIN
        LDSPI 16; DB=MD                 "SAVE MD, VALUE IS 1 IF FAST MD,
                                        " 2 IF STANDARD MEMORY
        SUB 17,16                       "TEST AGAINST 1
        BEQ ONECY;                      "BRANCH IF FAST MD
          MOV 15,15; SETMA; MI<DPX(0)   "RESTORE MD(0)
        CLR 17                          "INDICATE STANDARD MD
ONECY:  MOV 17,MDTYPE;                  "SAVE RESULT   0=STANDARD (2-CYCLE) MD
                                        "              1=FAST (1-CYCLE) MD
          INCMA; MI<DPX(1)              "RESTORE MD(1)
"
"COMPUTE TMRAM STARTING ADDRESS.  4096 IF A 120/190 AND 2.5K TMROM,
"OTHERWISE 8192.
"IF 4096, SET RAMFWA TO 0
"IF 8192, SET RAMFWA TO 1
"
SETFWA: ADD# APTYPE,ROM                 "SEE IF 2.5K TMROM AND 120/190
        BEQ TSTFWA; CLR RAMFWA          "BRANCH IF SO, FWA IS 4096
        INC RAMFWA                      "SET INDICATOR TO 8192 FWA
"
"TEST TO SEE IF TMRAM IS PRESENT BY WRITING AND THEN READING AT THE FWA
"OF TMRAM
"SET SPAD RAM TO 0 IF TMRAM NOT PRESENT
"                1 IF TMRAM IS PRESENT
"
TSTFWA: BEQ FOURK; LDSPI 17; DB=4096.   "SET FWA TO 4096
        MOVL 17,17                      "SET FWA TO 8192
FOURK:  MOV 17,17; SETTMA               "GET TM(FWA)
        LDDA; DB=5                      "SET DA TO TMRAM
        DPX<TM                          "SAVE TM(FWA)
        DPY<1                           "NOW WRITE 1 IN TM(FWA)
        OUT; MOV 17,17; SETTMA; DB=DPY  "WRITE 1 IN TM(FWA)
        CLR RAM                         "ASSUME NO TMRAM
        MOV 17,17; SETTMA               "READ TM(FWA)
        LDSPI 15; DB=1                  "GET 1 TO COMPARE WITH TM
        LDSPI 16; DB=TM                 "SAVE TM(FWA)
        SUB 16,15                       "COMPARE TO 1
        OUT; MOV 17,17; SETTMA; DB=DPX; "RESTORE TM(FWA)
          BNE TSTERR                    "BRANCH IF NOT SAME, MEANS NO RAM
        INC RAM                         "INDICATE TMRAM EXISTS
"
"COMPARE MD TYPE AND TMROM SIZE TO VERSIONS EXPECTED BY THIS ROUTINE.
"MD TYPE EXPECTED IS DETERMINED BY THE VALUE EXMD.
"        EXMD $EQU 0      IF STANDARD MD VERSION OF APFET
"        EXMD $EQU 1      IF FAST MD VERSION OF APFET
"TMROM TYPE EXPECTED IS DETERMINED BY THE VALUE OF !ONE
"        !ONE $EQU 4001   IF 2.5K TMROM
"        !ONE $EQU 10001  IF 4.5K TMROM
"
TSTERR: LDSPI 17; DB=!ONE               "GET VALUE !ONE
        LDSPI EXPMT; DB=4001            "VALUE SHOULD BE 4001 FOR 2.5K
        SUB 17,EXPMT                    "COMPARE TO 4001
        LDSPI 17; DB=EXMD;              "GET EXPECTED MD FLAG
          BEQ SW2K                      "BRANCH IF 2.5K TMROM SW
        LDSPI EXPMT; DB=2               "SET BIT IF 4.5K TMROM SW
SW2K:   ADD 17,EXPMT                    "FORM EXPECTED MD/TMROM WORD
                                        "EXPMT= 0 IF STD MD, 2.5K TMROM
                                        "       1 IF FAST MD, 2.5K TMROM
                                        "       2 IF STD MD, 4.5K TMROM
                                        "       3 IF FAST MD, 4.5K TMROM
        MOVL ROM,ACTMT                  "FORM ACTUAL MD/TMROM WORD
        ADD MDTYPE,ACTMT                "FORM ACTUAL MD/TMROM WORD
        MOV EXPMT,ERRMT                 "PREPARE TO COMPARE EXP AND ACTUAL
        COM ERRMT
        EQV ACTMT,ERRMT                 "ERRMT= 0 IF MD SAME , ROM SAME
                                        "       1 IF MD DIFF , ROM SAME
                                        "       2 IF MD SAME , ROM DIFF
                                        "       3 IF MD DIFF , ROM DIFF
"
"FORM STATUS WORD, RETURNED IN TMA AND IN SP(17)
"
SETSTA: MOVL APTYPE,17                  "APTYPE WILL END UP IN BIT 7
        ADDL RAM,17                     "RAM EXISTENCE BIT IS BIT 8
        ADDL RAMFWA,17                  "RAM FWADD BIT IS BIT 9
        MOVL 17,17
        ADDL ACTMT,17                   "ACTUAL ROMTYPE IS BIT 10
                                        "ACTUAL MD TYPE IS BIT 11
        MOVL 17,17                      "
        ADDL EXPMT,17                   "EXPECTED ROM TYPE IS BIT 12
                                        "EXPECTED MD TYPE IS BIT 13
        MOVL 17,17                      "
        ADD ERRMT,17;                   "ROM AGREEMENT BIT IS BIT 14
                                        "MD AGREEMENT BIT IS BIT 15
          SETTMA; RETURN                "STORE STATUS WORD IN TMA
                                        "AND EXIT
        $END
$ENDLIB
