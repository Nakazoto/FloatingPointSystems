$LIB
"****** AMLSRC = ADVANCED MATH LIBRARY /FAST/ = REL 1.2, JUN 80 *****
"
"====================  CONDITIONAL ASSEMBLY SWITCHES  ==================
"
"    XADC   DETERMINES WHETHER ASSEMBLY WILL INCLUDE BOTH ADC AND UDC
"              ENTRY POINTS, OR ONLY UDC ENTRY POINTS
"           XADC $EQU 1    ASSEMBLE BOTH ADC AND UDC ENTRY POINTS (DEFAULT)
"           XADC $EQU 0    ASSEMBLE ONLY UDC ENTRY POINTS
"
"           TO CHANGE FROM THE DEFAULT (ADC AND UDC) TO UDC ONLY ASSEMBLY,
"           GLOBALLY EDIT THIS FILE TO CHANGE ALL OCCURRENCES (1 PER
"           ROUTINE) OF
"               XADC $EQU 1      TO     XADC $EQU 0
"
"=====================================================================
"      ---HISTORY---
"REV 1.2 AND 1A.2, JUN 80:
"       1. THE STATEMENT   $RADIX 8   HAS BEEN ADDED TO ALL ROUTINES (REV 1.2
"          ONLY) SO THAT THEY WILL ASSEMBLE PROPERLY EVEN IF FOR SOME
"          REASON THE ASSEMBLER DEFAULT RADIX HAS BEEN CHANGED TO 10 OR 16.
"       2. FIXES BUGS IN THE FOLLOWING ROUTINES SO THAT MATRICES 6-BY-6
"          AND LARGER WILL WORK PROPERLY:
"               TRED2
"               IMTQL2
"               UDOTPR
"          AS A RESULT OF THESE FIXES, THE ROUTINE EIGRS ALSO NOW WORKS
"          FOR MATRICES 6-BY-6 AND LARGER.
"       3. (REV 1.2 ONLY) THE ADC LINKAGE FOR RKGIL HAS BEEN CORRECTED.
"
"REV 1.1 AND 1A.1, OCT 79:
"       1. FIXES BUG IN FOLLOWING ROUTINE
"             TRED2
"       2. ALL ROUTINES NOW DO NOTHING WHEN VECTOR LENGTH IS ZERO
"       3. SRFWD FIXED TO WORK PROPERLY WITH EXTENDED MEMORY
"
"REV 1.0, APR 79:
"         INITIAL RELEASE OF LIBRARY CONTAINS:
"    FUNCTION GENERATION ROUTINES:
"              FGEN     FUNCTION GENERATOR
"              FGENT    FUNCTION GENERATOR (NORMALIZED BP)
"              BIN      BINARY SEARCH
"              STEP     STEP SEARCH
"              FUN1     FUNCTIONS OF ONE VARIABLE
"              FUN2     FUNCTIONS OF TWO VARIABLES
"              FUN3     FUNCTIONS OF THREE VARIABLES
"              FUN4     FUNCTIONS OF FOUR VARIABLES
"    EIGENVALUE/EIGENVECTOR ROUTINES:
"              EIGRS    EIGENVALUES, REAL SYMMETRIC
"              TRED2    TRIDIAGONALIZE SYMMETRIC MATRIX
"              IMTQL2   EIGENVALUE AND VECTOR, SYMMETIC
"              INDEX    SETUP INDICES FOR TRED2, IMTQL2
"              UDOTPR   UTILITY DOT PRODUCT
"    INTEGRATION ROUTINES:
"              RKGIL    RUNGE-KUTTA-GILL'S ODE INTEG
"    SPECIAL FORMAT MATRIX ROUTINES:
"              SKYSOL   SKYLINE EQUATION SOLVER
"              SCSFB    SPARSE CMPLX SYMM FWD ELIM, BACK SUBS
"              SCUFB    SPARSE CMPLX UNSYMM FWD ELIM, BACK SUBS
"              SCFWD    SPARSE COMPLEX MATRIX FORWARD ELIM
"              SCBAK    SPARSE COMPLEX BACK SUBSTITUTION
"              SRSFB    SPARSE REAL SYMM FWD ELIM, BACK SUBS
"              SRUFB    SPARSE REAL UNSYMM FWD ELIM, BACK SUBS
"              SRFWD    SPARSE REAL MATRIX FORWARD ELIM
"              SRBAK    SPARSE REAL BACK SUBSTITUTION
"              TSCSFB   SPARSE SYMM CMPLX FWD ELIM, BACK SUBS
"              TSCUFB   SPARSE CMPLX UNSYMM FWD ELIM,BACK SUB
"              TSCFWD   SPARSE COMPLEX MATRIX FORWARD ELIM
"              TSCBAK   SPARSE COMPLEX BACK SUBSTITUTION
"              TSRSFB   SPARSE REAL SYMM FWD ELIM, BACK SUBS
"              TSRUFB   SPARSE REAL UNSYMM FWD ELIM, BACK SUBS
"              TSRFWD   SPARSE REAL MATRIX FORWARD ELIM
"              TSRBAK   SPARSE REAL BACK SUBSTITUTION
"              TCVMUL   COMPLEX VECTOR MULTIPLY WITH TMRAM
"-------------------------------------------------------------------------
"****** FGEN = FUNCTION GENERATOR /COMMON/ = REL 1.0, APR 79 ******************
"       FOR COMMON MEMORY
        $TITLE FGEN
        $RADIX 8
        $ENTRY FGEN,4
        $EXT BIN,STEP,FUN1,FUN2,FUN3,FUN4
"
"
"THE FUNCTION GENERATOR ROUTINE WILL CALCULATE A SERIES OF FUNCTION GROUPS
"AT SEVERAL COORDINATE POSITIONS IN EACH GROUP ALL IN ONE TIME FRAME.
"
" DEFINITIONS:
"-------------
"
"A GROUP IS A CLASS OF FUNCTIONS THAT CAN BE DESCRIBED BY THE SAME VARIABLES AND
"BY THE SAME BREAKPOINTS OF THESE VARIABLES.
"
"A SET IS DEFINED AS THE EVALUATIONS OF THE GROUP FUNCTIONS AT A SPECIFIC INPUT
"COORDINATE VALUE.  THERE CAN BE ONE OR MANY SETS IN A GROUP.
"
"IN EACH SET, THERE MAY BE EVALUATIONS OF ONE OR MANY FUNCTIONS.
""
"SCOPE:
"-------
"
"(FGEN) FUNCTION GENERATION ROUTINE WITH SEARCH THROUGH BREAKPOINTS
"
"
"FGEN ROUTINE WILL CALCULATE SEVERAL GROUPS OF FUNCTIONS OF FROM ONE TO FOUR
"INDEPENDENT VARIABLES IN EACH TIME FRAME WITH A SINGLE APAL ROUTINE. THE
"CALCULATION WILL CONSIST OF TABLE LOOKUP OF FUNCTION VALUES AT BREAKPOINTS
"AND LINEAR INTERPOLATION AS ILLUSTRATED FOR ONE VARIABLE BY:
"
"        F(X) = F(I) + ( (X(I) - X)/(X(I+1) - X(I)) ) (F(I) - F(I+1)) .
"
"THE ROUTINE WILL INVOLVE A SEARCH OF THE INPUT COORDINATE VALUE THROUGH
"A TABLE OF ORDERED BREAKPOINT VALUES. THE NEAREST LOWER BREAKPOINT X(I) IS
"USED TO CALCULATE THE DIFFERENCE, X(I) - X, AND TO GIVE THE TABLE ADDRESSES
"OF THE RATIO, 1/( X(I+1) - X(I) ), AND THE FUNCTIONS, F(I) AND F(I+1).
"THE SEARCH MAY BE EITHER OF TWO METHODS:
"
"        1. BINARY SEARCH - THIS IS AN EXAMINATION OF BREAKPOINT TABLE VALUES
"                AT SUBSEQUENT HALF WAY BREAKPOINT NUMBERS.
"
"        2. STEP SEARCH - THIS IS AN EXAMINATION OF BREAKPOINT TABLE VALUES
"                AT CONSECUTIVE BREAKPOINT NUMBERS BEGINNING AT A PREVIOUSLY
"                OBTAINED VALUE.
"
"TO ATTAIN EXECUTION TIME EFFICIENCY, THE INNERMOST LOOP WILL CYCLE THROUGH
"THE FUNCTION CALCULATIONS AT ONE COORDINATE VALUE. THE CALLING AND SEARCH
"ROUTINES ARE COMMON TO BOTH FAST AND STANDARD MEMORIES AND THE FUNCTION
"ROUTINES ARE DIFFERENT FOR THE TWO MEMORIES.
"THE DATA BASE AND INPUT TABLES WILL ALL BE STORED IN MAIN DATA.  THE OUTPUT
"TABLES WILL BE RETURNED TO MAIN DATA.  SEVERAL FORTRAN APPUT CALLS WILL
"TRANSFER DATA FROM THE HOST TO THE AP.  ONE CALL WILL BE MADE TO THE FUNCTION
"GENERATION ROUTINE WHICH WILL DO ALL THE AP PROCESSING.
"
"
"DATA BASE CONFIGURATION:
"
"ALL DATA WILL BE STORED IN MAIN DATA MEMORY.  THE DATA WILL BE ORGANIZED
"ACCORDING TO THE FUNCTION GROUPS AND CONSIST OF:
"
"
"
"
"
"
"     A.  DATA BASE THAT IS NECESSARY TO PERFORM A PARTICULAR SIMULATION AND
"         THAT IS LOADED ONCE AT BEGINNING OF SIMULATION.
"
"              1.  NUMBER OF GROUPS AND GROUP NUMBER KEYS.
"
"              2.  GROUP PARAMETERS AND TABLE ADDRESSES
"
"              3.  BREAKPOINT AND RATIO TABLES.
"
"              4.  FUNCTION TABLES.
"
"     B.  INPUT DATA TABLES WHICH DETERMINE THE ORDER AND NUMBER OF
"         FUNCTIONS EVALUATED.
"
"              1.  INPUT PARAMETERS AND ADDRESSES.
"
"              2.  COORDINATE VALUES.
"
"     C.  OUTPUT RESULT TABLES
"
"              1.  CALCULATED FUNCTION VALUES.
"
"
"-----------------------------------------------------------------------------
"DATA BASE ORGANIZATION:
"---------------------------------------------------------------------------
"
"        ADDRESS LABEL        CONTENTS                            LENGTH
"---------------------------------------------------------------------------
"A.1 GROUP KEYS
"                   GNA   NUMBER OF GROUPS =                NG
"                         GROUP NO. 1 POINTER =            GN1
"                         GROUP NO. 2 POINTER =            GN2
"                                 .                        .         NG+1
"                                 .                        .        WORDS
"                                 .                        .
"                                 .                        .
"                         GROUP NO. N POINTER =            GNN
"-------------------------------------------------------------------------------
"
"A.2 GROUP PARAMETERS AND TABLE ADDRESSES
"                  GN1    NO. OF VARIABLES =               NV1
"                         TOTAL NUMBER OF FUNCTIONS =      NF1
"                         BREAKPOINT AND RATIO TABLE
"                            ADDRESS =                     BP1
"                         NO. OF BREAKPOINTS OF VAR. 1 =   N11
"                         NO. OF BREAKPOINTS OF VAR. 2 =   N21
"                         NO. OF BREAKPOINTS OF VAR. 3 =   N31      2 X NV1 + 4
"                         NO. OF BREAKPOINTS OF VAR. 4 =   N41      WORDS
"                         FUNCTION TABLE ADDRESS =         FN1
"                         X - COORD. POINTER (OUTPUT) =    S11
"                         Y - COORD. POINTER (OUTPUT) =    S21
"                         Z - COORD. POINTER (OUTPUT) =    S31
"                         W - COORD. POINTER (OUTPUT) =    S41
"-------------------------------------------------------------------------------
"                  GN2                                     NV2
"                                                          NF2
"                                                          BP2
"                                                          N12
"                                                          N22
"                                                           .       2 X NV2 + 4
"                                                           .       WORDS
"                                                           .
"                                                          FN2
"                                                          S12
"                                                          S22
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"                                      .
"                                      .
"                                      .
"                                      .
"-------------------------------------------------------------------------------
"                  GNN                                     NVN
"                                                          NFN
"                                                          BPN
"                                                          N1N      2 X NVN + 4
"                                                          N2N
"                                                           .       WORDS
"                                                           .
"                                                          FNN
"                                                          S1N
"                                                          S2N
"                                                           .
"                                                           .
"
"-------------------------------------------------------------------------------
"A.3 BREAKPOINT AND RATIO TABLE
"                  BP1    BREAKPOINTS X (1ST COORDINATE)          N11 WORDS
"                         RATIO X                                N11 WORDS
"                         BREAKPOINTS Y (2ND COORDINATE)          N21 WORDS
"                         RATIO Y                                N21 WORDS
"                         BREAKPOINTS Z (3RD COORDINATE)               .
"                         RATIO Z                                      .
"                         BREAKPOINTS W (4TH COORDINATE)               .
"                         RATIO W
"-------------------------------------------------------------------------------
"                  BP2    BREAKPOINTS X
"                         RATIO X
"                              .
"                              .
"-------------------------------------------------------------------------------
"                  BPN    BREAKPOINTS X
"                              .
"                              .
"                              .
"-------------------------------------------------------------------------------
"A.4 FUNCTION TABLE
"                  FN1    FUNCTION F11
"                         FUNCTION F21                            N11 X N21X
"                              .                               N31 X N41 X NF1
"                              .                                   WORDS
"                              .
"                                  FN1
"-------------------------------------------------------------------------------
"                  FN2    FUNCTION F12
"                                  F22
"                      ..                                   .
"                      ..          FN2                      .
"                      ..                                   .
"-------------------------------------------------------------------------------
"                  FNN    FUNCTION F1N
"                                  F2N
"                              .
"                              .
"                              .
"                                  FNN
"-------------------------------------------------------------------------------
"
"-------------------------------------------------------------------------------
"B.1 INPUT PARAMETERS AND ADDRESSES
"                  INPUT  NO. OF SETS IN GROUP 1           NS1
"                         ADDRESS OF COORDINATE VALUES     C1
"                         NO. OF FUNCTIONS IN SET 1        NF11     NS1 + 2
"                         NO. OF FUNCTIONS IN SET 2        NF21      WORDS
"                                                            .
"                                                            .
"                                                            .
"
"                         NO. OF SETS IN GROUP 2           NS2
"                         ADDRESS OF COORDINATE VALUES     C2
"                         NO. OF FUNCTIONS IN SET 1        NF12     NS2 + 2
"                                                           .        WORDS
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"B.2 TABLE OF COORDINATE VALUES
"                   C1    COORDINATE 1 SET 1 GROUP 1       X11*      NV1
"                                    2     1       1       Y11      WORDS
"                                    1     2       1       X21
"                                    2     2       1       Y21       NV1 X NS
"                                    1     3       1       X31          WORDS
"                                    2     3       1       Y31
"
"                   C2    COORDINATE 1     1       2       X12
"                                    2     1       2       Y12
"                                    3     1       2       Z12
"                                                  .
"                                                  .
"
"- A SPECIFIC CASE WITH 3 SETS AND 2 VARIABLES IN THE FIRST GROUP AND 1 SET
"AND 3 VARIABLES IN THE SECOND GROUP ..., IS CHOSEN FOR ILLUSTRATION.
"IF THE INPUT VARIABLE IS OUTSIDE THE EXPECTED RANGE, IT IS ASSUMED EQUAL TO
"THE VALUE OF THE NEAREST RANGE LIMIT.
"-------------------------------------------------------------------------------
"C.1 CALCULATED TABLE OF FUNCTIONS
"                 RESULT  CALCULATE FUNCTIONS F1(X11Y11)            NF11  +
"                                             F1(X21Y21)            NF21  +
"                                             F1(X31Y31)            NF31  +
"                                          F2(X12Y12Z12)            NF12  +
"                                          F2(X22Y22Z22)            NF22  +
"                                                 .                  .
"                                                 .                 NFNN
"                                                 .                WORDS
"                                                 .
"-------------------------------------------------------------------------------
"
"
""
"USAGE AND  PERFORMANCE
"---------------------------
"
"FORTRAN CALL:
"---------------
"
"USER MUST TRANSFER INTO AP MAIN MEMORY THE FOLLOWING: DATA BASE INTEGERS AS
"GROUP KEYS, PARAMETERS, AND ADDRESSES WITH ONE APPUT;DATA BASE FLOATING POINT
"TABLES AS BREAKPOINTS, RATIOS, AND FUNCTION VALUES WITH ONE APPUT; ALL
"FLOATING POINT COORDINATE VALUES WITH ONE APPUT. FOLLOWING THE FORTRAN CALL
"TO FGEN HE CAN RECEIVE FROM AP MAIN MEMORY ALL FLOATING POINT CALCULATED
"FUNCTION VALUES WITH ONE APGET.
"
"THE FORTRAN CALL TO PERFORM THE FUNCTION EVALUATION IS
"
"     CALL FGEN (GNA,INPUT,RESULT,F)
"
"
"     WHERE
"
"          GNA    =  BASE ADDRESS FOR KEYS TO DATA BASE
"          INPUT  =  BASE ADDRESS FOR INPUT DATA
"          RESULT =  BASE ADDRESS FOR CALCULATED FUNCTIONS
"          F      =  FLAG INDICATING WHETHER BINARY OR STEP SEARCH
"                    OF BREAKPOINTS
"                       F=0 BINARY SEARCH
"                       F=1 STEP SEARCH
"
"THE ROUTINE REQUIRES THE DATA BASE, INPUT COORDINATES, AND OUTPUT FUNCTIONS
"FOR ALL SETS IN ALL GROUPS STORED IN MAIN DATA MEMORY.  IT IS UNNECESSARY
"FOR A USER TO HAVE TABLE RAM.
"
"
"
"
"-----------------------------------------------------------------------
"HISTORY:
"ORIGINAL -- DEE DAVIS, 2/78
"------------------------------------------------------------------------------
"
"TYPICAL TIMES OF EXECUTION:
"-----------------------
"
"NO. OF VARIABLES                TIME IN USEC
"-------------------            --------------------
"
"----------------------------------------------------------------------------
"FAST MEMORY
"
"       1       T = 1.50 + NG(2.66 + NS(6.00 + BIN + NF(0.67)))
"
"       2       T = 1.50 + NG(2.66 + NS(11.50 + 2XBIN + NF(1.17)))
"
"       3       T = 1.50 + NG(2.66 + NS(15.50 + 3XBIN + NF(2.42)))
"
"       4       T = 1.50 + NG(2.66 + NS(24.16 + 4XBIN + NF(5.08)))
"
"----------------------------------------------------------------------------
"
"STANDARD MEMORY
"
"       1       T = 1.50 + NG(2.66 + NS(6.83 + BIN + NF(1.17)))
"
"       2       T = 1.50 + NG(2.66 + NS(13.67 + 2XBIN + NF(1.83)))
"
"       3       T = 1.50 + NG(2.66 + NS(17.66 + 3XBIN + NF(3.75)))
"
"       4       T = 1.50 + NG(2.66 + NS(28.83 + 4XBIN + NF(7.67)))
"
"----------------------------------------------------------------------------
"LENGTH (WORDS)
"FAST MEMORY
"104(FGEN) +39(BIN) +36(STEP) +18(FUN1) +45(FUN2) +69(FUN3) +131(FUN4) = 442
"STANDARD MEMORY
"104(FGEN) +39(BIN) +36(STEP) +23(FUN1) +48(FUN2) +78(FUN3) +142(FUN4) = 470
"------------------
"
"-----------------------------------------------------------------------------
"
"       S-PADS
        GNA = 0                         "DATA BASE PARAMETER KEYS
        INPUT = 1                       "INPUT PARAMETER ADDRESS
        RESULT = 2                      "ADDRESS OF RESULTS
        F = 3                           "FLAG  F = 0/1, BINARY/STEP SEARCH
"----------------------------------------------------------------------------
"       SCRATCH S-PADS
        ONE = 4                         "INCREMENT FOR DATA FETCHES / STORES
        C = 7                           "ADDRESS FOR COORDINATE VALUES
        GN = 10                         "ADDRESS FOR DATA BASE PARAMETERS
        NG = 10                         "NUMBER OF GROUPS
        NV = 5                          "NUMBER OF VARIABLES
        BP = 6                          "ADDRESS OF BREAKPOINT TABLES
        NS = 11                         "NUMBER OF SETS
        S1 = 14                         "POINTER IN  X - COORD. SEARCH
        S2 = 15                         "POINTER IN  Y - COORD. SEARCH
        S3 = 16                         "POINTER IN  Z - COORD. SEARCH
        S4 = 17                         "POINTER IN  W - COORD. SEARCH
        N = 0                           "TRANSITORY NUMBER OF BREAKPOINTS
        S0 = 17                         "TRANSITORY POINTER IN COORD. SEARCH
        NVP = 13                        "SCRATCH NUMBER OF VARIABLES
"--------------------------------------------------------------------------
"
"
"ALGORITHM
"----------
"
"
"THE DATA BASE, INPUT, AND OUTPUT TABLES ARE STORED IN MAIN MEMORY.  THE DATA
"CONSISTS OF INTEGER AND FLOATING POINT TABLES.
"
"THE ALGORITHM FOLLOWS THE SEQUENCE BELOW:
"
"     1.  READ NUMBER OF GROUPS NG
"     2.  READ GROUP NUMBER ADDRESS GN
"     3.  READ IN PARAMETER  NS
"     4.  READ BREAKPOINT ADDRESS BP
"     5.  READ IN PARAMETERS  NV,N1,N2,N3,N4
"     6.  READ IN ADDRESS  FN
"     7.  READ IN COORDINATE TABLE ADDRESS  C
"     8.  READ IN AN INPUT COORDINATE X
"     9.  SEARCH BREAKPOINTS FOLLOWING ADDRESS  BP
"    10.  GET RATIO R
"    11.  SAVE  D(X) = X(I) - X AND  R(X) = 1 / (X(I+1) - X(I))
"         AND PRODUCT  D(X) X R(X)
"    12.  DECREMENT NUMBER OF VARIABLES NV; IF NOT ZERO,
"         REPEAT STEPS 8 THRU 12 FOR NEXT COORDINATE.
"    13.  JUMP TO APPROPRIATE FUNCTION CALCULATION
"         DEPENDING ON NUMBER OF VARIABLES AND USE
"         TABLES FOLLOWING ADDRESS FN.
"    14.  STORE INTERPOLATED VALUE OF FUNCTION FOLLOWING
"         ADDRESS RESULT AND DECREMENT NUMBER OF FUNCTIONS
"         FOR GIVEN SET; IF NOT ZERO, REPEAT 13 THRU 14.
"    15.  DECREMENT NUMBER OF SETS IN GROUP; IF NOT ZERO,
"         REPEAT 4 THRU 15.
"    16.  DECREMENT NUMBER OF GROUPS; IF NOT ZERO, REPEAT
"         STEPS 2 THRU 16.
"
"-------------------------------------------------------------------------------
FGEN:   LDSPI ONE;DB=1                                 "INCREMENT FOR DATA
                                                       "FETCHES AND STORES
        MOV GNA,GNA;SETMA;                              "FETCH NUMBER OF GROUPS
        DPY(-3)<SPFN                        "SAVE KEY ADDRESS
        SUB ONE,INPUT                                "INITIALIZE INPUT ADDRESS
        MOV RESULT,RESULT;DPY(-1)<SPFN;DECDPA           "SAVE RESULT ADDRESS
        DPY(-4)<MD;INCDPA;LDSPI NG                      "SAVE NUMBER OF GROUPS
        MOV NG,NG
        BGT .+2                                         "TEST FOR NG = 0
        RETURN
"----------------------------------------------------------------------------
GROUP:  ADD ONE,INPUT;SETMA                             "FETCH NUMBER OF SETS
        LDSPI GNA;DB=DPY(-3)                          "KEY ADDRESS BACK IN S-PAD
        ADD ONE,INPUT;SETMA                             "FETCH ADDRESS OF
                                                        "COORDINATES
        DPY(-2)<MD;LDSPI NS                              "SAVE NUMBER OF SETS
        MOV NS,NS
        ADD ONE,GNA;SETMA;BGT .+2                       "FETCH ADDRESS OF GROUP
                                                        "PARAMETERS
                                                        "TEST FOR NS = 0
        RETURN
        LDSPI C;DB=MD                                   "LOAD COORDINATE
                                                        "ADDRESS
        SUB ONE,C                                       "INIT COORD. ADDRESSS
        DPY(-4)<MD                                      "SAVE ADDRESS OF GROUP
                                                        "PARAMETERS
        MOV GNA,GNA;DPY(-3)<SPFN                        "SAVE AGAIN KEY ADDRESS
"---------------------------------------------------------------------------
NEWSET: LDSPI GN;DB=DPY(-4)                             "LOAD GROUP PARA-
                                                        "METER ADDRESS
        MOV GN,GN;SETMA                                 "FETCH NO. OF VARIABLES
        ADD ONE,GN
        ADD ONE,GN;SETMA                                "FETCH BREAKPOINT
                                                        "ADDRESS
        LDSPI NV;DB=MD                                  "LOAD NO. OF VARIABLES
        ADD ONE,GN;SETMA                                "FETCH NUMBER OF BREAK
                                                        "POINTS FOR X-COORD.
        LDSPI BP;DB=MD                                  "LOAD BKPT. ADDRESS
        MOV F,F
        BNE Q1;DPX(-4)<MD;MOV NV,NVP                    "TEST FLAG, F = 0/1 FOR
                                                        "BINARY/STEP SEARCH
                                                        "SAVE NO. OF BKPT.
                                                        "SAVE NO. OF VARIABLES
        JSR BIN                                         "BINARY SEARCH IF F = 0
"-------------------------------------------------------------------------
        DEC NV                                          "DEC COUNT OF NO. VAR.
        MOV S0,S1;BEQ .+2                               "S1 = S0,TEST IF NV > 1
        JMP TWO
        MOV INPUT,INPUT;SETMA;BR R1                     "SET MEMORY POINTER
"-----------------------------------------------------------------------------
Q1:     JSR STEP                                        "STEP SEARCH IF F = 1
"-------------------------------------------------------------------------
        DEC NV                                          "DEC COUNT OF NO. VAR.
        MOV S0,S1;BNE TWO                               "S1 = S0,TEST IF NV > 1
        SUB NVP,INPUT;SETMA                             "SET MEMORY POINTER
R1:     MOV S1,S1;INCMA;MI<SPFN                        "STORE S1 FOR STEP SEARCH
        ADD ONE,INPUT                                  "CATCH UP POINTER
        JSR FUN1                                        "CALCULATE FUNCTION OF
                                                        "ONE VARIABLE
CLEAN:  DEC NS;DPY(-2)<SPFN                             "DECREMENT NO. OF SETS
                                                        "AND SAVE
        BEQ .+2
        JMP NEWSET                                    "START NEW SET IF NS not=0
        DECDPA
        LDSPI NG;DB=DPY(-4)                             "LOAD NO. OF GROUPS
        DEC NG;DPY(-4)<SPFN;INCDPA                      "DECREMENT NG AND SAVE
        BEQ .+2
        JMP GROUP                                   "START NEW GROUP IF NG not=0
        RETURN                                          "END IF NG AND NS = 0
TWO:    INCDPA;MOV F,F                                  "SHIFT DATA PAD POINTER
                                                        "FOR NEXT VARIABLE
        BNE Q2
        JSR BIN                                         "BINARY SEARCH IF F = 0
"-------------------------------------------------------------------------
        DEC NV                                          "DEC COUNT OF NO. VAR.
        MOV S0,S2;BEQ .+2                               "S2 = S0,TEST IF NV > 2
        JMP THREE
        MOV INPUT,INPUT;SETMA;BR R2                     "SET MEMORY POINTER
"-----------------------------------------------------------------------------
Q2:     JSR STEP                                        "STEP SEARCH IF F = 1
"-------------------------------------------------------------------------
        DEC NV                                          "DEC COUNT OF NO. VAR.
        MOV S0,S2;BEQ .+2                             "S2 = S0,TEST IF NV > 2
        JMP THREE
        SUB NVP,INPUT;SETMA                             "SET MEMORY POINTER
R2:     MOV S1,S1;INCMA;MI<SPFN                        "STORE S1 FOR STEP SEARCH
        ADD ONE,INPUT                                  "CATCH UP POINTER
        MOV S2,S2;INCMA;MI<SPFN                        "STORE S2 FOR STEP SEARCH
        ADD ONE,INPUT                                  "CATCH UP POINTER
        JSR FUN2                                       "CALCULATE FUNCTION OF
                                                       "TWO VARIABLES
        JMP CLEAN                                       "TRANSITION
THREE:  INCDPA;MOV F,F                                  "SHIFT DATA PAD POINTER
                                                        "FOR NEXT VAR.
        BNE Q3
        JSR BIN                                         "BINARY SEARCH IF F = 0
"-------------------------------------------------------------------------
        DEC NV                                          "DEC COUNT OF NO. VAR.
        MOV S0,S3;BEQ .+2                              "S3 = S0,TEST IF NV > 3
        JMP FOUR
        MOV INPUT,INPUT;SETMA;BR R3                     "SET MEMORY POINTER
"-----------------------------------------------------------------------------
Q3:     JSR STEP                                        "STEP SEARCH IF F = 1
"-------------------------------------------------------------------------
        DEC NV                                          "DEC COUNT OF NO. VAR.
        MOV S0,S3;BEQ .+2                              "S3 = S0,TEST IF NV > 3
        JMP FOUR
        SUB NVP,INPUT;SETMA                             "SET MEMORY POINTER
R3:     MOV S1,S1;INCMA;MI<SPFN                        "STORE S1 FOR STEP SEARCH
        ADD ONE,INPUT                                  "CATCH UP POINTER
        MOV S2,S2;INCMA;MI<SPFN                        "STORE S2 FOR STEP SEARCH
        ADD ONE,INPUT                                  "CATCH UP POINTER
        MOV S3,S3;INCMA;MI<SPFN                        "STORE S3 FOR STEP SEARCH
        ADD ONE,INPUT                                  "CATCH UP POINTER
        JSR FUN3                                        "CALCULATE FUNCTION OF
                                                        "THREE VARIABLES
        JMP CLEAN                                       "TRANSITION
FOUR:   INCDPA;DPX(2)<DPX(-2);MOV F,F                   "SHIFT DATA PAD POINTTER
                                                        "FOR NEXT VAR.
        BNE Q4
        JSR BIN                                         "BINARY SEARCH IF F = 0
"-------------------------------------------------------------------------
        MOV INPUT,INPUT;SETMA;BR R4                     "SET MEMORY POINTER
"-----------------------------------------------------------------------------
Q4:     JSR STEP                                        "STEP SEARCH IF F = 1
"-------------------------------------------------------------------------
        SUB NVP,INPUT;SETMA                             "SET MEMORY POINTER
"-------------------------------------------------------------------------
R4:     MOV S1,S1;INCMA;MI<SPFN                        "STORE S1 FOR STEP SEARCH
        ADD ONE,INPUT                                  "CATCH UP POINTER
        MOV S2,S2;INCMA;MI<SPFN                        "STORE S2 FOR STEP SEARCH
        ADD ONE,INPUT                                  "CATCH UP POINTER
        MOV S3,S3;INCMA;MI<SPFN                        "STORE S3 FOR STEP SEARCH
        ADD ONE,INPUT                                  "CATCH UP POINTER
        MOV S0,S4;INCMA;MI<SPFN                        "STORE S4 FOR STEP SEARCH
        ADD ONE,INPUT                                  "CATCH UP POINTER
        JSR FUN4                                        "CALCULATE FUNCTION OF
                                                        "FOUR VAR.
        JMP CLEAN                                       "TRANSITION
"-------------------------------------------------------------------
        $END
"****** FGENT = FUNCTION GENERATOR (NORMALIZED BP) /COMMON/ = REL 1.0, APR 79 **
"       FOR COMMON MEMORY
        $TITLE FGENT
        $RADIX 8
        $ENTRY FGENT,3
        $EXT FUN1,FUN2,FUN3,FUN4
"
"
"THE FUNCTION GENERATOR ROUTINE WILL CALCULATE A SERIES OF FUNCTION GROUPS
"AT SEVERAL COORDINATE POSITIONS IN EACH GROUP ALL IN ONE TIME FRAME.
"
" DEFINITIONS:
"-------------
"
"A GROUP IS A CLASS OF FUNCTIONS THAT CAN BE DESCRIBED BY THE SAME VARIABLES AND
"BY THE SAME BREAKPOINTS OF THESE VARIABLES.
"
"A SET IS DEFINED AS THE EVALUATIONS OF THE GROUP FUNCTIONS AT A SPECIFIC INPUT
"COORDINATE VALUE.  THERE CAN BE ONE OR MANY SETS IN A GROUP.
"
"IN EACH SET, THERE MAY BE EVALUATIONS OF ONE OR MANY FUNCTIONS.
""
"SCOPE:
"-------
"
"(FGENT) FUNCTION GENERATION ROUTINE WITH NORMALIZED BREAKPOINTS AND COORDINATES
"
"
"FGEN ROUTINE WILL CALCULATE SEVERAL GROUPS OF FUNCTIONS OF FROM ONE TO FOUR
"INDEPENDENT VARIABLES IN EACH TIME FRAME WITH A SINGLE APAL ROUTINE. THE
"CALCULATION WILL CONSIST OF TABLE LOOKUP OF FUNCTION VALUES AT BREAKPOINTS
"AND LINEAR INTERPOLATION AS ILLUSTRATED FOR ONE VARIABLE BY:
"
"        F(X) = F(I) +  (X(I) - X))  (F(I) - F(I+1)) .
"
"THE BREAKPOINTS, THE COORDINATES FOR WHICH THE FUNCTION IS GIVEN, MUST BE
"NORMALIZED SO THAT THEY ARE EQUALLY SEPARATED. IN THIS WAY, THE BREAK-
"POINTS REPRESENT TABLE ADDRESSES OR POINTERS. THE INPUT COORDINATES MUST
"ALSO BE NORMALIZED CORRESPONDING TO THE BREAKPOINT NORMALIZATION. THE TABLE
"LOOKUP WILL INVOLVE A TRUNCATION OF THE INPUT COORDINATE, WHOSE TRUNCATED
"VALUE IS USED AS A POINTER TO THE FUNCTION TABLE AND WHERE THE DIFFERENCE
"BETWEEN THE INPUT COORDINATE AND ITS TRUNCATED VALUE GIVES D(X) = X(I) - X.
"IN THIS CASE, THE RATIO R(X) = 1/( X(I+1) - X(I) ) = 1.
"
"
"TO ATTAIN EXECUTION TIME EFFICIENCY, THE INNERMOST LOOP WILL CYCLE THROUGH
"THE FUNCTION CALCULATIONS AT ONE COORDINATE VALUE. THE CALLING ROUTINE
"IS COMMON TO BOTH FAST AND STANDARD MEMORIES AND THE FUNCTION ROUTINES
"ARE DIFFERENT FOR THE TWO MEMORY SPEEDS.
"THE DATA BASE AND INPUT TABLES WILL ALL BE STORED IN MAIN DATA.  THE OUTPUT
"TABLES WILL BE RETURNED TO MAIN DATA.  SEVERAL FORTRAN APPUT CALLS WILL
"TRANSFER DATA FROM THE HOST TO THE AP.  ONE CALL WILL BE MADE TO THE FUNCTION
"GENERATION ROUTINE WHICH WILL DO ALL THE AP PROCESSING.
"
"
"DATA BASE CONFIGURATION:
"
"ALL DATA WILL BE STORED IN MAIN DATA MEMORY.  THE DATA WILL BE ORGANIZED
"ACCORDING TO THE FUNCTION GROUPS AND CONSIST OF:
"
"
"
"
"
"
"     A.  DATA BASE THAT IS NECESSARY TO PERFORM A PARTICULAR SIMULATION AND
"         THAT IS LOADED ONCE AT BEGINNING OF SIMULATION.
"
"              1.  NUMBER OF GROUPS AND GROUP NUMBER KEYS.
"
"              2.  GROUP PARAMETERS AND TABLE ADDRESSES
"
"              3.  FUNCTION TABLES.
"
"     B.  INPUT DATA TABLES WHICH DETERMINE THE ORDER AND NUMBER OF
"         FUNCTIONS EVALUATED.
"
"              1.  INPUT PARAMETERS AND ADDRESSES.
"
"              2.  NORMALIZED COORDINATE VALUES.
"
"     C.  OUTPUT RESULT TABLES
"
"              1.  CALCULATED FUNCTION VALUES.
"
"
"-----------------------------------------------------------------------------
"DATA BASE ORGANIZATION:
"---------------------------------------------------------------------------
"
"        ADDRESS LABEL        CONTENTS                            LENGTH
"---------------------------------------------------------------------------
"A.1 GROUP KEYS
"                   GNA   NUMBER OF GROUPS =                NG
"                         GROUP NO. 1 POINTER =            GN1
"                         GROUP NO. 2 POINTER =            GN2
"                                 .                        .         NG+1
"                                 .                        .        WORDS
"                                 .                        .
"                                 .                        .
"                         GROUP NO. N POINTER =            GNN
"-------------------------------------------------------------------------------
"
"A.2 GROUP PARAMETERS AND TABLE ADDRESSES
"                  GN1    NO. OF VARIABLES =               NV1
"                         TOTAL NUMBER OF FUNCTIONS =      NF1
"                         NO. OF BREAKPOINTS OF VAR. 1 =   N11
"                         NO. OF BREAKPOINTS OF VAR. 2 =   N21
"                         NO. OF BREAKPOINTS OF VAR. 3 =   N31      2 X NV1 + 4
"                         NO. OF BREAKPOINTS OF VAR. 4 =   N41      WORDS
"                         FUNCTION TABLE ADDRESS =         FN1
"-------------------------------------------------------------------------------
"                  GN2                                     NV2
"                                                          NF2
"                                                          N12
"                                                          N22
"                                                           .       2 X NV2 + 4
"                                                           .       WORDS
"                                                           .
"                                                          FN2
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"                                      .
"                                      .
"                                      .
"                                      .
"-------------------------------------------------------------------------------
"                  GNN                                     NVN
"                                                          NFN
"                                                          N1N      2 X NVN + 4
"                                                          N2N
"                                                           .       WORDS
"                                                           .
"                                                          FNN
"                                                           .
"                                                           .
"
"-------------------------------------------------------------------------------
"A.3 FUNCTION TABLE
"                  FN1    FUNCTION F11
"                         FUNCTION F21                            N11 X N21X
"                              .                               N31 X N41 X NF1
"                              .                                   WORDS
"                              .
"                                  FN1
"-------------------------------------------------------------------------------
"                  FN2    FUNCTION F12
"                                  F22
"                      ..                                   .
"                      ..          FN2                      .
"                      ..                                   .
"-------------------------------------------------------------------------------
"                  FNN    FUNCTION F1N
"                                  F2N
"                              .
"                              .
"                              .
"                                  FNN
"-------------------------------------------------------------------------------
"
"-------------------------------------------------------------------------------
"B.1 INPUT PARAMETERS AND ADDRESSES
"                  INPUT  NO. OF SETS IN GROUP 1           NS1
"                         ADDRESS OF COORDINATE VALUES     C1
"                         NO. OF FUNCTIONS IN SET 1        NF11     NS1 + 2
"                         NO. OF FUNCTIONS IN SET 2        NF21      WORDS
"                                                            .
"                                                            .
"                                                            .
"
"                         NO. OF SETS IN GROUP 2           NS2
"                         ADDRESS OF COORDINATE VALUES     C2
"                         NO. OF FUNCTIONS IN SET 1        NF12     NS2 + 2
"                                                           .        WORDS
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"B.2 TABLE OF NORMALIZED COORDINATE VALUES
"                   C1    COORDINATE 1 SET 1 GROUP 1       X11*      NV1
"                                    2     1       1       Y11      WORDS
"                                    1     2       1       X21
"                                    2     2       1       Y21       NV1 X NS
"                                    1     3       1       X31          WORDS
"                                    2     3       1       Y31
"
"                   C2    COORDINATE 1     1       2       X12
"                                    2     1       2       Y12
"                                    3     1       2       Z12
"                                                  .
"                                                  .
"
"- A SPECIFIC CASE WITH 3 SETS AND 2 VARIABLES IN THE FIRST GROUP AND 1 SET
"AND 3 VARIABLES IN THE SECOND GROUP ..., IS CHOSEN FOR ILLUSTRATION.
"THE NORMALIZED INPUT VARIABLE MUST BE IN THE EXPECTED RANGE.
"-------------------------------------------------------------------------------
"C.1 CALCULATED TABLE OF FUNCTIONS
"                RESULT  CALCULATED FUNCTIONS F1(X11Y11)            NF11 +
"                                             F1(X21Y21)            NF21 +
"                                             F1(X31Y31)            NF31 +
"                                          F2(X12Y12Z12)            NF12 +
"                                          F2(X22Y22Z22)            NF22 +
"                                                 .                  .
"                                                 .                 NFNN
"                                                 .                WORDS
"                                                 .
"-------------------------------------------------------------------------------
"
"
""
"USAGE AND  PERFORMANCE
"---------------------------
"
"FORTRAN CALL:
"---------------
"
"USER MUST TRANSFER INTO AP MAIN MEMORY THE FOLLOWING: DATA BASE INTEGERS AS
"GROUP KEYS, PARAMETERS, AND ADDRESSES WITH ONE APPUT;DATA BASE FLOATING
"POINT FUNCTION TABLES WITH ONE APPUT; ALL FLOATING POINT
"COORDINATE VALUES WITH ONE APPUT. FOLLOWING THE FORTRAN CALL TO FGENT,
"HE CAN RECEIVE FROM AP MAIN MEMORY ALL FLOATING POINT CALCULATED
"FUNCTION VALUES WITH ONE APGET.
"
"THE FORTRAN CALL TO PERFORM THE FUNCTION EVALUATION IS
"
"     CALL FGENT (GNA,INPUT,RESULT)
"
"
"     WHERE
"
"          GNA    =  BASE ADDRESS FOR KEYS TO DATA BASE
"          INPUT  =  BASE ADDRESS FOR INPUT DATA
"          RESULT =  BASE ADDRESS FOR CALCULATED FUNCTIONS
"
"THE ROUTINE REQUIRES THE DATA BASE, INPUT COORDINATES, AND OUTPUT FUNCTIONS
"FOR ALL SETS IN ALL GROUPS STORED IN MAIN DATA MEMORY.  IT IS UNNECESSARY
"FOR A USER TO HAVE TABLE RAM.
"
"
"
"
"-----------------------------------------------------------------------
"HISTORY:
"ORIGINAL -- DEE DAVIS, 2/78
"------------------------------------------------------------------------------
"
"TYPICAL TIMES OF EXECUTION:
"-----------------------
"
"NO. OF VARIABLES                TIME IN USEC
"-------------------            --------------------
"
"----------------------------------------------------------------------------
"FAST MEMORY
"
"       1       T = 1.50 + NG(2.66 + NS(6.67 +  NF(0.67)))
"
"       2       T = 1.50 + NG(2.66 + NS(13.33 +  NF(1.17)))
"
"       3       T = 1.50 + NG(2.66 + NS(18.50 +  NF(2.42)))
"
"       4       T = 1.50 + NG(2.66 + NS(28.50 +  NF(5.08)))
"
"----------------------------------------------------------------------------
"
"STANDARD MEMORY
"
"       1       T = 1.50 + NG(2.66 + NS(7.50 +  + NF(1.17)))
"
"       2       T = 1.50 + NG(2.66 + NS(14.50 +  NF(1.83)))
"
"       3       T = 1.50 + NG(2.66 + NS(20.66 +  NF(3.75)))
"
"       4       T = 1.50 + NG(2.66 + NS(33.17 +  NF(7.67)))
"
"----------------------------------------------------------------------------
"LENGTH (WORDS)
"FAST -------- 68(FGENT) +18(FUN1) +45(FUN2) +69(FUN3) +131(FUN4) = 331
"STANDARD ---- 68(FGENT) +23(FUN1) +48(FUN2) +78(FUN3) +142(FUN4) = 359
"------------------
"
"-----------------------------------------------------------------------------
"
"       S-PADS
        GNA = 0                         "DATA BASE PARAMETER KEYS
        INPUT = 1                       "INPUT PARAMETER ADDRESS
        RESULT = 2                      "ADDRESS OF RESULTS
"----------------------------------------------------------------------------
"       SCRATCH S-PADS
        ONE = 4                         "INCREMENT FOR DATA FETCHES / STORES
        C = 7                           "ADDRESS FOR COORDINATE VALUES
        GN = 10                         "ADDRESS FOR DATA BASE PARAMETERS
        NG = 10                         "NUMBER OF GROUPS
        NV = 5                          "NUMBER OF VARIABLES
        NS = 11                         "NUMBER OF SETS
        S1 = 14                         "POINTER IN  X - COORD. SEARCH
        S2 = 15                         "POINTER IN  Y - COORD. SEARCH
        S3 = 16                         "POINTER IN  Z - COORD. SEARCH
        S4 = 17                         "POINTER IN  W - COORD. SEARCH
        N = 0                           "TRANSITORY NUMBER OF BREAKPOINTS
        S0 = 17                         "TRANSITORY POINTER IN COORD. SEARCH
        FLT = 13                        "EXPONENT FOR FLOAT
"--------------------------------------------------------------------------
"
"
"ALGORITHM
"----------
"
"
"THE DATA BASE, INPUT, AND OUTPUT TABLES ARE STORED IN MAIN MEMORY.  THE DATA
"CONSISTS OF INTEGER AND FLOATING POINT TABLES.
"
"THE ALGORITHM FOLLOWS THE SEQUENCE BELOW:
"
"     1.  READ NUMBER OF GROUPS NG
"     2.  READ GROUP NUMBER ADDRESS GN
"     3.  READ IN PARAMETER  NS
"     4.  READ IN PARAMETERS  NV,N1,N2,N3,N4
"     5.  READ IN ADDRESS  FN
"     6.  READ IN COORDINATE TABLE ADDRESS  C
"     7.  READ IN AN INPUT COORDINATE X
"     8.  TRUNCATE X TO X(I)
"     9.  GET D(X) = X(I) - X
"    10.  DECREMENT NUMBER OF VARIABLES NV; IF NOT ZERO,
"         REPEAT STEPS 7 THRU 10 FOR NEXT COORDINATE.
"    11.  JUMP TO APPROPRIATE FUNCTION CALCULATION
"         DEPENDING ON NUMBER OF VARIABLES AND USE
"         TABLES FOLLOWING ADDRESS FN.
"    12.  STORE INTERPOLATED VALUE OF FUNCTION FOLLOWING
"         ADDRESS RESULT AND DECREMENT NUMBER OF FUNCTIONS
"         FOR GIVEN SET; IF NOT ZERO, REPEAT 11 THRU 12.
"    13.  DECREMENT NUMBER OF SETS IN GROUP; IF NOT ZERO,
"         REPEAT 4 THRU 13.
"    14.  DECREMENT NUMBER OF GROUPS; IF NOT ZERO, REPEAT
"         STEPS 2 THRU 14.
"
"-------------------------------------------------------------------------------
FGENT:  LDSPI ONE;DB=1                                 "INCREMENT FOR DATA
                                                       "FETCHES AND STORES
        MOV GNA,GNA;SETMA;                              "FETCH NUMBER OF GROUPS
        DPY(-3)<SPFN                                "SAVE KEY ADDRESS
        SUB ONE,INPUT                                 "INITIALIZE INPUT ADDRESS
        MOV RESULT,RESULT;DPY(-1)<SPFN;DECDPA           "SAVE RESULT ADDRESS
        DPY(-4)<MD;INCDPA;LDSPI NG                 "SAVE NUMBER OF GROUPS
        MOV NG,NG
        BGT .+2                                         "TEST FOR NG = 0
        RETURN
                                                       "INITIALIZE INPUT ADDRESS
"----------------------------------------------------------------------------
GROUP:  ADD ONE,INPUT;SETMA                             "FETCH NUMBER OF SETS
        LDSPI GNA;DB=DPY(-3)                          "KEY ADDRESS BACK IN S-PAD
        ADD ONE,INPUT;SETMA                             "FETCH ADDRESS OF
                                                        "COORDINATES
        DPY(-2)<MD;LDSPI NS                             "SAVE NUMBER OF SETS
        MOV NS,NS
        ADD ONE,GNA;SETMA;BGT .+2                       "FETCH ADDRESS OF GROUP
                                                        "PARAMETERS
        RETURN
        LDSPI C;DB=MD                                   "LOAD COORDINATE
                                                        "ADDRESS
        SUB ONE,C                                       "INIT COORD. ADDRESSS
        DPY(-4)<MD                                      "SAVE ADDRESS OF GROUP
                                                        "PARAMETERS
        MOV GNA,GNA;DPY(-3)<SPFN                        "SAVE AGAIN KEY ADDRESS
"---------------------------------------------------------------------------
NEWSET: LDSPI GN;DB=DPY(-4)                             "LOAD GROUP PARA-
                                                        "METER ADDRESS
        MOV GN,GN;SETMA                                 "FETCH NO. OF VARIABLES
        ADD ONE,GN
        ADD ONE,GN;SETMA                                "FETCH NUMBER OF BREAK
                                                        "POINTS FOR X-COORD.
        LDSPI NV;DB=MD                                  "LOAD NO. OF VARIABLES
        NOP
        DPX(-4)<MD                                      "SAVE NO. OF BKPTS.
        JSR TAB                                    "GET FUNCTION TABLE POINTER
                                                        "AND  D(X) = X(I) - X
"-------------------------------------------------------------------------
        DEC NV;DPX<FA                                "DEC COUNT OF NO. VAR.
                                                        "SAVE D(X)=X(I)-X
        MOV S0,S1;BNE TWO                           "S1 = S0,TEST IF NV > 1
        JSR FUN1                                        "CALCULATE FUNCTION OF
                                                        "ONE VARIABLE
CLEAN:  DEC NS;DPY(-2)<SPFN                             "DECREMENT NO. OF SETS
                                                        "AND SAVE
        BEQ .+2
        JMP NEWSET                                    "START NEW SET IF NS not=0
        DECDPA
        LDSPI NG;DB=DPY(-4)                             "LOAD NO. OF GROUPS
        DEC NG;DPY(-4)<SPFN;INCDPA                      "DECREMENT NG AND SAVE
        BEQ .+2
        JMP GROUP                                   "START NEW GROUP IF NG not=0
        RETURN                                          "END IF NG AND NS = 0
TWO:    INCDPA                                         "SHIFT DATA PAD POINTER
                                                        "FOR NEXT VARIABLE
        JSR TAB                                      "GET FUNCTION TABLE POINTER
                                                        "AND D(Y) = Y(I) - Y
"--------------------------------------------------------------------
        DEC NV;DPX<FA                                "DEC COUNT  NO. OF VAR.
                                                        "SAVE D(Y)=Y(I)-Y
        MOV S0,S2;BNE THREE                       "S2 = S0, TEST IF NV > 2
        JSR FUN2                                       "CALCULATE FUNCTION OF
                                                       "TWO VARIABLES
        JMP CLEAN                                       "TRANSITIOM
THREE:  INCDPA                                  "SHIFT DATA PAD POINTER
                                                        "FOR NEXT VAR.
        JSR TAB                                     "GET FUNCTION TABLE POINTER
                                                        "AND  D(Z) = Z(I) - Z
"--------------------------------------------------------------------
        DEC NV;DPX<FA                                    "DEC COUNT OF NO. VAR.
                                                        "SAVE D(Z) = Z(I) - Z
        MOV S0,S3;BNE FOUR                              "S3 = S0, TEST IF NV > 3
        JSR FUN3                                        "CALCULATE FUNCTION OF
                                                        "THREE VARIABLES
        JMP CLEAN                                       "TRANSITION
FOUR:   INCDPA;DPX(2)<DPX(-2)                          "SHIFT DATA PAD POINTER
                                                        "FOR NEXT VAR.
        JSR TAB                                     "GET FUNCTION TABLE POINTER
                                                        "AND  D(W) = W(I) - W
"-------------------------------------------------------------------------
        MOV S0,S4;DPX<FA                                "S4=S0,SAVE D(W)=W(I)-W
        JSR FUN4                                        "CALCULATE FUNCTION OF
                                                        "FOUR VAR.
        JMP CLEAN                                       "TRANSITION
"-------------------------------------------------------------------
TAB:    ADD ONE,C;SETMA                                 "FETCH NORMALIZED COORD.
        LDSPI N;DB=DPX(-4)                                 "LOAD NO. OF BKPTS.
        ADD ONE,GN;SETMA                                "FETCH NEXT NO. OF BKPTS
                                                        "OR FUNCTION ADDRESS
        DPY<MD                                          "SAVE NORMALIZED COORD.
        FIXT DPY;LDSPI FLT;DB=27.                       "TRUNCATE COORD. TO X(I)
        FADD;DPX(-3)<MD                                 "SAVE NEXT NO. OF BKPTS.
                                                        "OR FUNCT.TABLE ADDRESS
        DPX<FA
        FADD ZERO,MDPX;MOV FLT,FLT                      "FLOAT TRUNCATED COORD.
        FADD;LDSPI S0;DB=DPX                            "LOAD POINTER VALUE
        DPX<FA;FSUBR DPY,FA                             "GET  X(I) - X
        FADD;RETURN
"-------------------------------------------------------------------------------
        $END
"****** BIN = BINARY SEARCH /COMMON/ = REL 1.0, APR 79 ****************
"       FOR COMMON MEMORY
        $TITLE BIN
        $RADIX 8
        $ENTRY BIN
"
"
"SCOPE:
"
"(FGEN) FUNCTION GENERATION ROUTINE WITH SEARCH THROUGH BREAKPOINTS
"
"
"FGEN ROUTINE WILL CALCULATE SEVERAL GROUPS OF FUNCTIONS OF FROM ONE TO FOUR
"INDEPENDENT VARIABLES IN EACH TIME FRAME WITH A SINGLE APAL ROUTINE. THE
"CALCULATION WILL CONSIST OF TABLE LOOKUP OF FUNCTION VALUES AT BREAKPOINTS
"AND LINEAR INTERPOLATION AS ILLUSTRATED FOR ONE VARIABLE BY:
"
"        F(X) = F(I) + ( (X(I) - X)/(X(I+1) - X(I)) ) (F(I) - F(I+1)) .
"
"THE TABLE LOOKUP WILL INVOLVE A SEARCH OF THE INPUT COORDINATE VALUE THROUGH
"A TABLE OF ORDERED BREAKPOINT VALUES. THE NEAREST LOWER BREAKPOINT X(I) IS
"USED TO CALCULATE THE DIFFERENCE, X(I) - X, AND TO GIVE THE TABLE ADDRESSES
"OF THE RATIO, 1/( X(I+1) - X(I) ), AND THE FUNCTIONS, F(I) AND F(I+1).
"
"
"
"
"THE FORTRAN CALL TO PERFORM THE FUNCTION EVALUATION IS
"
"     CALL FGEN (GN,INPUT,RESULT,F)
"
"     WHERE
"
"          GN     =  BASE ADDRESS FOR KEYS TO DATA BASE
"          INPUT  =  BASE ADDRESS FOR INPUT DATA
"          RESULT =  BASE ADDRESS FOR CALCULATED FUNCTIONS
"          F      =  FLAG INDICATING WHETHER BINARY OR STEP SEARCH
"                    OF BREAKPOINTS
"                       F=0 BINARY SEARCH
"                       F=1 STEP SEARCH
"
"THE BINARY SEARCH IS AN EXAMINATION OF BREAKPOINT TABLE VALUES
"AT SUBSEQUENT HALF WAY BREAKPOINT NUMBERS AND THE STORAGE IN THE MAIN MEMORY
"GROUP PARAMETER TABLE OF THE LAST POINTERS IN EACH GROUP, S1, S2, S3, AND S4.
"
"
"
"
"THE SEARCH INVOLVES THE BREAKPOINT TABLE IN MAIN MEMORY AS ILLUSTRATED BELOW.
"-------------------------------------------------------------------------------
"
"GROUP PARAMETERS AND TABLE ADDRESSES
"                 GN1    NO. OF VARIABLES =               NV1
"                         TOTAL NUMBER OF FUNCTIONS =      NF1
"                         BREAKPOINT AND RATIO TABLE
"                            ADDRESS =                     BP1
"                         NO. OF BREAKPOINTS OF VAR. 1 =   N11
"                         NO. OF BREAKPOINTS OF VAR. 2 =   N21
"                         NO. OF BREAKPOINTS OF VAR. 3 =   N31      2 X NV1 + 4
"                         NO. OF BREAKPOINTS OF VAR. 4 =   N41      WORDS
"                         FUNCTION TABLE ADDRESS =         FN1
"                         X - COORD. POINTER (OUTPUT) =    S11
"                         Y - COORD. POINTER (OUTPUT) =    S21
"                         Z - COORD. POINTER (OUTPUT) =    S31
"                         W - COORD. POINTER (OUTPUT) =    S41
"-------------------------------------------------------------------------------
"                  GN2                                     NV2
"                                                          NF2
"                                                          BP2
"                                                          N12
"                                                          N22
"                                                           .       2 X NV2 + 4
"                                                           .       WORDS
"                                                           .
"                                                          FN2
"                                                          S12
"                                                          S22
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"                                      .
"                                      .
"                                      .
"                                      .
"-------------------------------------------------------------------------------
"                  GNN                                     NVN
"                                                          NFN
"                                                          BPN
"                                                          N1N      2 X NVN + 4
"                                                          N2N
"                                                           .       WORDS
"                                                           .
"                                                          FNN
"                                                          S1N
"                                                          S2N
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"BREAKPOINT AND RATIO TABLE
"        ADDRESS LABEL           CONTENTS                        LENGTH
"                  BP1    BREAKPOINTS X (1ST COORDINATE)          N11 WORDS
"                         RATIO X                                N11 WORDS
"                         BREAKPOINTS Y (2ND COORDINATE)          N21 WORDS
"                         RATIO Y                                N21 WORDS
"                         BREAKPOINTS Z (3RD COORDINATE)               .
"                         RATIO Z                                      .
"                         BREAKPOINTS W (4TH COORDINATE)               .
"                         RATIO W
"-------------------------------------------------------------------------------
"                  BP2    BREAKPOINTS X
"                         RATIO X
"                              .
"                              .
"-------------------------------------------------------------------------------
"                  BPN    BREAKPOINTS X
"                              .
"                              .
"THE INPUT COORDINATES ARE SUPPLIED BY THE USER IN A TABLE IN MAIN MEMORY AS:
"----------------------------------------------------------------------------
"TABLE OF COORDINATE VALUES
"                   C1    COORDINATE 1 SET 1 GROUP 1       X11*      NV1
"                                    2     1       1       Y11      WORDS
"                                    1     2       1       X21
"                                    2     2       1       Y21       NV1 X NS
"                                    1     3       1       X31          WORDS
"                                    2     3       1       Y31
"
"                   C2    COORDINATE 1     1       2       X12
"                                    2     1       2       Y12
"                                    3     1       2       Z12
"                                                  .
"                                                  .
"
"- A SPECIFIC CASE WITH 3 SETS AND 2 VARIABLES IN THE FIRST GROUP AND 1 SET
"AND 3 VARIABLES IN THE SECOND GROUP ..., IS CHOSEN FOR ILLUSTRATION
"-------------------------------------------------------------------------------
"
"HISTORY:
"ORIGINAL -- DEE DAVIS, 2/78
"------------------------------------------------------------------------------
"
"TIME OF EXECUTION:
"----------------------
"FAST           T = ( 3.67 + n(1.67) ) USEC
"STANDARD       T = ( 3.67 + n(1.83) ) USEC
"       WHERE n = NUMBER OF TIMES THROUGH SEARCH LOOP
"       THIS ROUTINE IS CALLED FOR EACH COORDINATE
"
"------------------------------------------------------------------------------
"LENGTH OF BIN --- 39 WORDS
"
"-------------------------------------------------------------------------------
"SUBROUTINE BIN IS CALLED BY FGEN IF THE FLAG F = 0. THE SEARCH FOR EACH
"COORDINATE IS THE SAME. DURING THIS SUBROUTINE THE COORDINATE VALUE IS
"FETCHED FROM MEMORY. BY PREVIOUS SETTING OF THE DATA PAD POINTER IT IS
"PLACED AS:
"                        X  IN  DPX(0)
"                        Y  IN  DPX(1)
"                        Z  IN  DPX(2)
"                        W  IN  DPX(3)
"                              .
"THE SUBROUTINE FIRST CHECKS TO SEE IF THE COORDINATE IS IN THE EXPECTED
"RANGE.THEN IT UNDERGOES A BINARY SEARCH TO OBTAIN THE POINTER VALUE, S0,
"TO THE LOCATION OF  X  IN THE BREAKPOINT TABLE AND A VALUE OF
"D(X) =  X(I) - X ,WHERE X(I) IS THE NEAREST LOW BREAKPOINT. IT USES
"THE POINTER, S0, TO OBTAIN THE RATIO VALUE R(X) = 1 / ( X(I+1) - X(I) ).
"IT PERFORMS THE MULTIPLICATION, D(X) X R(X), AND PLACES THE PRODUCTS AS:
"                        D(X) X R(X)  IN  DPX(0)
"                        D(Y) X R(Y)  IN  DPX(1)
"                        D(Z) X R(Z)  IN  DPX(2)
"                        D(W) X R(W)  IN  DPX(3)
""
"ON ENTERING THE SUBROUTINE, THE S-PADS ARE ASSUMED LOADED AS:
"                        SP(4) = ONE......1
"                        SP(7) = C........ADDRESS OF COORDINATE LESS ONE
"                        SP(10) = GN.......ADDRESS OF NO. OF BKPTS.
"                        SP(6) = BP.......BREAKPOINT TABLE ADDRESS
"
"
"ON LEAVING THE SUBROUTINE, THE S-PADS ARE ASSUMED LOADED AS:
"                       SP(0) = N.........NO. OF BKPTS.
"                       SP(17) = S0........BKPT. POINTER
"
"THE S-PADS USED FOR SCRATCH ARE:
"                       SP(11) = SC1.......UPPER LIMIT FOR INTERVAL
"                       SP(12) = SC2.......LOWER LIMIT FOR INTERVAL
"                       SP(13) = SC3.......TEMPORARY BKPT. POINTER
"                       SP(2) = SC4.......TEMPORARY USE
"
"
"-----------------------------------------------------------------------------
"       S-PAD VALUES
        ONE = 4                         "INCREMENT FOR DATA FETCHES / STORES
        C = 7                           "ADDRESS OF COORDINATE VALUES
        GN = 10                         "ADDRESS FOR DATA BASE PARAMETERS
        BP = 6                          "ADDRESS OF BREAKPOINT TABLES
        SC1 = 11                        "TEMPORARY USED IN SEARCH
        SC2 = 12                        "    "    "
        SC3 = 13                        "    "    "
        SC4 = 2                         "    "    "
        N = 0                           "TRANSITORY NUMBER OF BREAKPOINTS
        S0 = 17                         "TRANSITORY POINTER IN COORD. SEARCH
"----------------------------------------------------------------------------
BIN:   ADD ONE,C;SETMA                                  "FETCH COORDINATE
        LDSPI N;DB=DPX(-4)                              "LOAD NO. OF BREAKPOINTS
        MOV N,SC1                                       "TEMP. NO. OF BKPTS.
        MOV BP,BP;SETMA;DPX(0)<MD                       "FETCH LOWEST BKPT. L
                                                        "SAVE COORDINATE
        DEC SC1                                         "N - 1
        ADD# SC1,BP;SETMA                               "FETCH HIGHEST BKPT. H
        CLR SC2;FSUBR DPX,MD                            "L - X,TEST LOWEST LIMIT
                                                        "AT BP + (N -1)
        MOVR SC1,SC3;DECMA;FADD                          "SC3 = (N-1)/2
                                                        "FETCH NEXT HIGHEST BKPT
        DPY(1)<MD;FSUB DPX,MD                          "X - H,TEST HIGHEST LIMIT
        BFGE LOWEST                                     "BR. IF X <=LOWEST
        FSUBR DPY(1),MD                             "(H - 1) - H, LAST D(X)
                                                        "WHERE D(X) = X(I) - X
        FADD
        DPY(0)<FA;BFGE HIGHEST                          "BR. IF X >= HIGHEST
                                                        "SAVE LAST D(X)
        JSR BSLOOP                                      "OTHERWISE DO SEARCH
"-----------------------------------------------------------------------
HERE:   ADD N,BP                                        "MOVE TO RATIO TABLE
        ADD# S0,BP;SETMA                                "FETCH RATIO R(X)
        ADD N,BP                                        "MOVE TO NEXT BKPT.TABLE
        ADD ONE,GN;SETMA                                "FETCH NEXT NO. OF BKPT.
                                                      "OR FUNCTION TABLE ADDRESS
        FMUL DPY,MD                                     "D(X) X R(X)
        FMUL
        FMUL;DPX(-3)<MD                                 "SAVE NEXT NO. OF BKPT.
                                                        "OR FUNCT. TABLE ADDRESS
        DPX<FM;RETURN                                   "SAVE D(X) X R(X)
"---------------------------------------------------------------------------
LOWEST: LDSPI S0;DPY(0)<DB;DB=ZERO;BR HERE              "IF X <= LOWEST
                                                        "LET S0 = 0, D(X) = 0
HIGHEST:DEC SC1                                         "N - 2,IF X >= HIGHEST,
        MOV SC1,S0;BR HERE                             "LET S0=N-2,LAST INTERVAL
"---------------------------------------------------------------------------
BSLOOP: ADD# SC3,BP;SETMA                               "FETCH HALF WAY BKPT.
        INCMA                                           "FETCH NEXT BKPT.
        MOV SC3,S0                                      "S0 = SC3 JUST IN CASE
        FSUBR DPX,MD;MOV S0,SC4                         "X(I) - X,SC4 =S0 (LESS)
        FSUB DPX,MD;SUBR SC2,SC4                        "X-X(I+1),SC4 =(S0-LO)/2
                                                                     "(FOR LESS)
        FADD;DPY<FA;ADD SC2,SC4                         "SAVE D(X) = X(I) - X
                                                                     "(FOR LESS)
                                                        "SC4 = LO + (S0-LO)/2
        BFGT LESS                                       "BR. IF X < X(I)
        BFGE BIG;MOV SC1,SC4                            "BR. IF X >= X(I+1)
                                                        "SC4 = HI
"----------------------------------------------------------------------------
EXIT:   RETURN                                       "OTHERWISE SEARCH COMPLETE
"-------------------------------------------------------------------------
LESS:   MOV S0,SC1                                      "REDEFINE UPPER LIMIT,HI
        MOV SC4,SC3;BR BSLOOP                           "SC3 = LO + (S0 - L0)/2
"----------------------------------------------------------------------
BIG:    MOV S0,SC2                                      "REDEFINE LOWER LIMIT,LO
        SUBR SC3,SC4                                    "SC4 = (HI-S0)/2
        ADD SC4,SC3;BR BSLOOP                           "SC3 = S0 + (HI-S0)/2
"-----------------------------------------------------------------------
        $END
"****** STEP = STEP SEARCH /COMMON/ = REL 1.0, APR 79 ****************
"       FOR COMMON MEMORY
        $TITLE STEP
        $RADIX 8
        $ENTRY STEP
"
"
"SCOPE:
"
"(FGEN) FUNCTION GENERATION ROUTINE WITH SEARCH THROUGH BREAKPOINTS
"
"
"FGEN ROUTINE WILL CALCULATE SEVERAL GROUPS OF FUNCTIONS OF FROM ONE TO FOUR
"INDEPENDENT VARIABLES IN EACH TIME FRAME WITH A SINGLE APAL ROUTINE. THE
"CALCULATION WILL CONSIST OF TABLE LOOKUP OF FUNCTION VALUES AT BREAKPOINTS
"AND LINEAR INTERPOLATION AS ILLUSTRATED FOR ONE VARIABLE BY:
"
"        F(X) = F(I) + ( (X(I) - X)/(X(I+1) - X(I)) ) (F(I) - F(I+1)) .     *
"
"THE TABLE LOOKUP WILL INVOLVE A SEARCH OF THE INPUT COORDINATE VALUE THROUGH
"A TABLE OF ORDERED BREAKPOINT VALUES. THE NEAREST LOWER BREAKPOINT X(I) IS
"USED TO CALCULATE THE DIFFERENCE, X(I) - X, AND TO GIVE THE TABLE ADDRESSES
"OF THE RATIO, 1/( X(I+1) - X(I) ), AND THE FUNCTIONS, F(I) AND F(I+1).
"
"
"
"
"THE FORTRAN CALL TO PERFORM THE FUNCTION EVALUATION IS
"
"     CALL FGEN (GN,INPUT,RESULT,F)
"
"     WHERE
"
"          GN     =  BASE ADDRESS FOR KEYS TO DATA BASE
"          INPUT  =  BASE ADDRESS FOR INPUT DATA
"          RESULT =  BASE ADDRESS FOR CALCULATED FUNCTIONS
"          F      =  FLAG INDICATING WHETHER BINARY OR STEP SEARCH
"                    OF BREAKPOINTS
"                       F=0 BINARY SEARCH
"                       F=1 STEP SEARCH
"
"THE STEP SEARCH IS AN EXAMINATION OF BREAKPOINT TABLE VALUES AT THE INITIAL
"POINT AND AT ONE HIGHER OR ONE LOWER BREAKPOINT NUMBER, THE INITIAL STARTING
"POINT BEING THAT WHICH WAS SAVED IN MEMORY FROM A BINARY SEARCH OR FROM
"SOME OTHER MEANS. THE POINTERS, S1, S2, S3, AND S4 ARE AGAIN STORED IN THE
"MAIN MEMORY GROUP PARAMETER TABLE FOR FUTURE USE.
"
"
"
"
"THE SEARCH INVOLVES THE BREAKPOINT TABLE IN MAIN MEMORY AS ILLUSTRATED BELOW.
"-------------------------------------------------------------------------------
"
"GROUP PARAMETERS AND TABLE ADDRESSES
"                  GN1    NO. OF VARIABLES =               NV1
"                         TOTAL NUMBER OF FUNCTIONS =      NF1
"                         BREAKPOINT AND RATIO TABLE
"                            ADDRESS =                     BP1
"                         NO. OF BREAKPOINTS OF VAR. 1 =   N11
"                         NO. OF BREAKPOINTS OF VAR. 2 =   N21
"                         NO. OF BREAKPOINTS OF VAR. 3 =   N31      2 X NV1 + 4
"                         NO. OF BREAKPOINTS OF VAR. 4 =   N41      WORDS
"                         FUNCTION TABLE ADDRESS =         FN1
"                         X - COORD. POINTER (INPUT) =     S11
"                         Y - COORD. POINTER (INPUT) =     S21
"                         Z - COORD. POINTER (INPUT) =     S31
"                         W - COORD. POINTER (INPUT) =     S41
"-------------------------------------------------------------------------------
"                  GN2                                     NV2
"                                                          NF2
"                                                          BP2
"                                                          N12
"                                                          N22
"                                                           .       2 X NV2 + 4
"                                                           .       WORDS
"                                                           .
"                                                          FN2
"                                                          S12
"                                                          S22
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"                                      .
"                                      .
"                                      .
"                                      .
"-------------------------------------------------------------------------------
"                  GNN                                     NVN
"                                                          NFN
"                                                          BPN
"                                                          N1N      2 X NVN + 4
"                                                          N2N
"                                                           .       WORDS
"                                                           .
"                                                          FNN
"                                                          S1N
"                                                          S2N
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"BREAKPOINT AND RATIO TABLE
"        ADDRESS LABEL           CONTENTS                        LENGTH
"                  BP1    BREAKPOINTS X (1ST COORDINATE)          N11 WORDS
"                         RATIO X                                N11 WORDS
"                         BREAKPOINTS Y (2ND COORDINATE)          N21 WORDS
"                         RATIO Y                                N21 WORDS
"                         BREAKPOINTS Z (3RD COORDINATE)               .
"                         RATIO Z                                      .
"                         BREAKPOINTS W (4TH COORDINATE)               .
"                         RATIO W
"-------------------------------------------------------------------------------
"                  BP2    BREAKPOINTS X
"                         RATIO X
"                              .
"                              .
"-------------------------------------------------------------------------------
"                  BPN    BREAKPOINTS X
"                              .
"                              .
"THE COORDINATE VALUES ARE SUPPLIED BY THE USER IN A TABLE IN MAIN MEMORY AS:
"-------------------------------------------------------------------------------
"TABLE OF COORDINATE VALUES
"                   C1    COORDINATE 1 SET 1 GROUP 1       X11*      NV1
"                                    2     1       1       Y11      WORDS
"                                    1     2       1       X21
"                                    2     2       1       Y21       NV1 X NS
"                                    1     3       1       X31          WORDS
"                                    2     3       1       Y31
"
"                   C2    COORDINATE 1     1       2       X12
"                                    2     1       2       Y12
"                                    3     1       2       Z12
"                                                  .
"                                                  .
"
"- A SPECIFIC CASE WITH 3 SETS AND 2 VARIABLES IN THE FIRST GROUP AND 1 SET
"AND 3 VARIABLES IN THE SECOND GROUP ..., IS CHOSEN FOR ILLUSTRATION
"-------------------------------------------------------------------------------
"HISTORY:
"ORIGINAL -- DEE DAVIS, 2/78
"------------------------------------------------------------------------------
"
"
"TIME OF EXECUTION:
"-----------------------
"FAST           T = ( 3.80 + n(1.42) ) USEC
"STANDARD       T = ( 3.80 + n(1.58) ) USEC
"       n = NUMBER OF TIMES THROUGH SEARCH LOOP
"       THE ROUTINE IS CALLED FOR EACH COORDINATE
"--------------------------------------------------------------------------
"LENGTH OF STEP ---  36 WORDS
"------------------------------------------------------------------------
"
"SUBROUTINE STEP IS CALLED BY FGEN IF THE FLAG F = 1. THE SEARCH FOR EACH
"COORDINATE IS THE SAME. DURING THIS SUBROUTINE THE COORDINATE VALUE IS
"FETCHED FROM MEMORY. BY PREVIOUS SETTING OF THE DATA PAD POINTER IT IS
"PLACED AS:
"                        X  IN  DPX(0)
"                        Y  IN  DPX(1)
"                        Z  IN  DPX(2)
"                        W  IN  DPX(3)
"                              .
"THE SUBROUTINE FIRST CHECKS TO SEE IF THE COORDINATE IS IN THE EXPECTED
"RANGE.THEN IT UNDERGOES A STEP SEARCH TO OBTAIN THE POINTER VALUE, S0,
"TO THE LOCATION OF  X  IN THE BREAKPOINT TABLE AND A VALUE OF
"D(X) =  X(I) - X ,WHERE X(I) IS THE NEAREST LOW BREAKPOINT. IT USES
"THE POINTER, S0, TO OBTAIN THE RATIO VALUE R(X) = 1 / ( X(I+1) - X(I) ).
"IT PERFORMS THE MULTIPLICATION, D(X) X R(X), AND PLACES THE PRODUCTS AS:
"                        D(X) X R(X)  IN  DPX(0)
"                        D(Y) X R(Y)  IN  DPX(1)
"                        D(Z) X R(Z)  IN  DPX(2)
"                        D(W) X R(W)  IN  DPX(3)
""
"ON ENTERING THE SUBROUTINE, THE S-PADS ARE ASSUMED LOADED AS:
"                        SP(4) = ONE......1
"                        SP(7) = C........ADDRESS OF COORDINATE LESS ONE
"                        SP(10) = GN.......ADDRESS OF NO. OF BKPTS.
"                        SP(6) = BP.......BREAKPOINT TABLE ADDRESS
"                        SP(13) = NVP......NO. OF VAR. BEFORE DECREMENT
"
"ON LEAVING THE SUBROUTINE, THE S-PADS ARE ASSUMED LOADED AS:
"                       SP(0) = N.........NO. OF BKPTS.
"                       SP(17) = S0........BKPT. POINTER
"
"THE S-PADS USED FOR SCRATCH ARE:
"                       SP(11) = SC1.......UPPER LIMIT FOR INTERVAL
"
"----------------------------------------------------------------------------
"
"
"       S-PAD VALUES
        INPUT = 1                       "INPUT PARAMETER ADDRESS
        ONE = 4                         "INCREMENT FOR DATA FETCHES / STORES
        C = 7                           "ADDRESS FOR COORDINATE VALUES
        GN = 10                         "ADDRESS FOR DATA BASE PARAMETERS
        BP = 6                          "ADDRESS OF BREAKPOINT TABLES
        SC1 = 11                        "TEMPORARY USED IN SEARCH
        N = 0                           "TRANSITORY NUMBER OF BREAKPOINTS
        S0 = 17                         "TRANSITORY POINTER IN COORD. SEARCH
        NVP = 13                        "SCRATCH NUMBER OF VARIABLES
"-------------------------------------------------------------------
STEP:  ADD ONE,C;SETMA                                  "FETCH COORDINATE
        LDSPI N;DB=DPX(-4)                              "LOAD NO. OF BREAKPOINTS
        MOV N,SC1                                       "TEMP. NO. OF BKPTS.
        MOV BP,BP;SETMA;DPX(0)<MD                       "FETCH LOWEST BKPT. L
        DEC SC1
        ADD ONE,INPUT;SETMA                          "FETCH PREVIOUS POINTER, S0
        FSUBR DPX,MD                                 "L - X,TEST LOWEST LIMIT
        ADD# SC1,BP;SETMA;FADD                          "FETCH HIGHEST BKPT. H
                                                        "AT BP + (N-1)
        LDSPI S0;DB=MD                                  "BR. IF X <= LOWEST
        DECMA;BFGE LOWEST                               "FETCH NEXT HIGHEST BKPT
                                                        "BR. IF X <=LOWEST
        DPY(1)<MD;FSUB DPX,MD                          "X - H,TEST HIGHEST LIMIT
        FADD
        FSUBR DPY(1),MD                                 "(H - 1) - H, LAST D(X)
                                                        "WHERE D(X) = X(I) - X
        FADD;BFGE HIGHEST                          "BR. IF X >= HIGHEST
        JSR BSLOOP                                      "OTHERWISE DO SEARCH
"----------------------------------------------------------------------
"---------------------------------------------------------------------------
HERE:   ADD N,BP                                        "MOVE TO RATIO TABLE
        ADD# S0,BP;SETMA                                "FETCH RATIO R(X)
        ADD N,BP                                        "MOVE TO NEXT BKPT.TABLE
        ADD ONE,GN;SETMA                                "FETCH NEXT NO. OF BKPTS
                                                     "OR FUNCTION TABLE ADDRESS
        FMUL DPY,MD                                     "D(X) X R(X)
        FMUL
        FMUL;DPX(-3)<MD                                 "SAVE NEXT NO. OF BKPTS.
                                                      "OR FUNCTION TABLE ADDRESS
        DPX<FM;RETURN                                   "SAVE D(X) X R(X)
"----------------------------------------------------------------------
LOWEST: LDSPI S0;DPY(0)<DB;DB=ZERO;BR HERE              "IF X <= LOWEST
                                                        "LET S0 = 0, D(X) = 0
HIGHEST:DEC SC1;DPY(0)<FA                               "N-2,IF X >= HIGHEST,
        MOV SC1,S0;BR HERE                             "LET S0=N-2,LAST INTERVAL
"---------------------------------------------------------------------------
"----------------------------------------------------------------
BSLOOP: ADD# S0,BP;SETMA                                "FETCH PREVIOS BKPT.
        INCMA                                           "FETCH NEXT BKPT.
        NOP
        FSUBR DPX,MD                                    "X(I) - X
        FSUB DPX,MD                                     "X - X(I+1)
        FADD;DPY<FA                                     "SAVE D(X) = X(I) - X
        BFGT LESS                                       "BR. IF X < X(I)
        BFGE BIG                                        "BR. IF X >= X(I+1)
"--------------------------------------------------------------------------
EXIT:   RETURN                                       "OTHERWISE SEARCH COMPLETE
"------------------------------------------------------------------------------
LESS:   DEC S0;BR BSLOOP                                "DECREMENT POINTER
"----------------------------------------------------------------------------
BIG:    INC S0;BR BSLOOP                                "INCREMENT POINTER
"----------------------------------------------------------------------
"-----------------------------------------------------------------------
        $END
"***** FUN1 = FUNCTIONS OF ONE VARIABLE  /FAST/ = REL 1.0, APR 79 ******
"        FOR FAST MEMORY
        $TITLE FUN1
        $RADIX 8
        $ENTRY FUN1
"
"
"SCOPE:
"
"(FGEN) FUNCTION GENERATION ROUTINE WITH SEARCH THROUGH BREAKPOINTS
"
"
"FGEN ROUTINE WILL CALCULATE SEVERAL GROUPS OF FUNCTIONS OF FROM ONE TO FOUR
"INDEPENDENT VARIABLES IN EACH TIME FRAME WITH A SINGLE APAL ROUTINE. THE
"CALCULATION WILL CONSIST OF TABLE LOOKUP OF FUNCTION VALUES AT BREAKPOINTS
"AND LINEAR INTERPOLATION AS ILLUSTRATED FOR ONE VARIABLE BY:
"
"        F(X) = F(I) + ( (X(I) - X)/(X(I+1) - X(I)) ) (F(I) - F(I+1))
"        OR
"
"        F(X) = F(I) + D(X) X R(X) X ( F(I)-F(I+1) )
"
"        IN THE NOTATION OF THE COMMENTS.
"
"THE TABLE LOOKUP WILL INVOLVE A SEARCH OF THE INPUT COORDINATE VALUE THROUGH
"A TABLE OF ORDERED BREAKPOINT VALUES. THE NEAREST LOWER BREAKPOINT X(I) IS
"USED TO CALCULATE THE DIFFERENCE, X(I) - X, AND TO GIVE THE TABLE ADDRESSES
"OF THE RATIO, 1/( X(I+1) - X(I) ), AND THE FUNCTIONS, F(I) AND F(I+1).
"
"
"THE FUNCTION TABLES FOR EACH GROUP ARE PART OF THE DATA BASE IN MAIN MEMORY AS:
"
"-------------------------------------------------------------------------------
"FUNCTION TABLE
"                  FN1    FUNCTION F11
"                         FUNCTION F21                            N11 X N21X
"                              .                               N31 X N41 X NF1
"                              .                                   WORDS
"                              .
"                                  FN1
"-------------------------------------------------------------------------------
"                  FN2    FUNCTION F12
"                                  F22
"                      ..                                   .
"                      ..          FN2                      .
"                      ..                                   .
"-------------------------------------------------------------------------------
"                  FNN    FUNCTION F1N
"                                  F2N
"                              .
"                              .
"                              .
"                                  FNN
"-------------------------------------------------------------------------------
"
"THE NUMBER OF SETS AND THE NUMBER OF FUNCTIONS CALCULATED IN EACH SET AND
"ALSO THE ADDRESS OF THE INPUT COORDINATES ARE INPUT BY USER IN MAIN MEMORY AS:
"-------------------------------------------------------------------------------
"INPUT PARAMETERS AND ADDRESSES
"                  INPUT  NO. OF SETS IN GROUP 1           NS1
"                         ADDRESS OF COORDINATE VALUES     C1
"                         NO. OF FUNCTIONS IN SET 1        NF11     NS1 + 2
"                         NO. OF FUNCTIONS IN SET 2        NF21      WORDS
"                                                            .
"                                                            .
"                                                            .
"
"                         NO. OF SETS IN GROUP 2           NS2
"                         ADDRESS OF COORDINATE VALUES     C2
"                         NO. OF FUNCTIONS IN SET 1        NF12     NS2 + 2
"                                                           .        WORDS
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"
"
"THE CALCULATED FUNCTIONS ARE STORED IN MAIN MEMORY AS:
"-------------------------------------------------------------------------------
"CALCULATED TABLE OF FUNCTIONS
"                 RESULT  CALCULATE FUNCTIONS F1(X11Y11)            NF11 +
"                                             F1(X21Y21)            NF21 +
"                                             F1(X31Y31)            NF31 +
"                                          F2(X12Y12Z12)            NF12 +
"                                          F2(X22Y22Z22)            NF22 +
"                                                 .                  .
"                                                 .                 NFNN
"                                                 .                WORDS
"                                                 .
"-------------------------------------------------------------------------------
"HISTORY:
"ORIGINAL -- DEE DAVIS, 2/78
"------------------------------------------------------------------------------
"
"TIME OF EXECUTION:
"--------------------
"BEST           T = 2.50 + NF(0.5)   USEC
"TYPICAL        T = 2.50 + NF(0.7)   USEC
"WORST          T = 2.50 + NF(0.8)   USEC
"-------------------------------------------------------------------------
"LENGTH OF FUN1 ---   18 WORDS
"
"---------------------------------------------------------------------------
"
"ON ENTERING THE SUBROUTINE, THE S-PADS ARE ASSUMED LOADED AS:
"                       SP(4) = ONE......1
"                       SP(1) = INPUT....ADDRESS OF COORDINATES
"                       SP(14) = S1.......POINTER FOR X-COORD.
"                       SP(0) = N........NO. OF BKPTS.
"
"ON LEAVING THE SUBROUTINE, THE OUTPUTS ARE ASSUMED LOADED AS:
"                       SP(11) = NS.......NO. OF SETS
"                       F(X) TABULATED AT RESULT
"
"THE S-PADS USED AS SCRATCH ARE:
"                       SP(2) = RESULT...ADDRESS OF RESULT
"                       SP(12) = FN.......FUNCTION TABLE ADDRESS
"                       SP(10) = NF.......NO. OF FUNCTIONS IN SET
"
"
"-------------------------------------------------------------------------
"       S-PAD VALUES
        INPUT = 1                       "INPUT PARAMETER ADDRESS
        RESULT = 2                      "ADDRESS OF RESULTS
        ONE = 4                         "INCREMENT FOR DATA FETCHES / STORES
        NS = 11                         "NUMBER OF SETS
        FN = 12                         "ADDRESS OF FUNCTION TABLES
        NF = 10                         "NUMBER OF FUNCTIONS OF ONE COORD. SET
        S1 = 14                         "POINTER IN  X - COORD. SEARCH
        N = 0                           "TRANSITORY NUMBER OF BREAKPOINTS
"---------------------------------------------------------------------------
FUN1:   LDSPI FN;DB=DPX(-3)                             "LOAD FUNCTION ADDRESS
        ADD ONE,INPUT;SETMA                             "FETCH NO. OF FUNCTIONS
                                                        "FOR THIS SET
        ADD S1,FN; SETMA                                "FETCH FIRST F(I)
                                                       "WITH POINTER FROM SEARCH
        INCMA;LDSPI RESULT;DB=DPY(-1)                   "FETCH FIRST F(I+1)
                                                        "LOAD RESULT ADDRESS
        LDSPI NF;DB=MD                                  "LOAD NO. OF FUNCTIONS
"---------------------------------------------------------------------
        ADD N,FN;SETMA;                                 "FETCH SECOND F(I)
                DPY<MD                                  "SAVE FIRST F(I)
        INCMA;SUB ONE,RESULT;                           "FETCH SECOND F(I+1)
                                                        "INIT. RESULT ADDRESS
                FSUB DPY,MD                             "FIRST F(I) - F(I+1)
        MOV NF,NF;
                FADD;DPX(1)<DPY                         "RESAVE FIRST F(I)
"-------------------------------------------------------------------------
        BGT .+2;                                        "TEST FOR NF <= 0
        ADD N,FN;SETMA;                                 "FETCH THIRD F(I)
                DPY<MD;                                 "SAVE SECOND F(I)
                        FMUL DPX,FA                     "FIRST  D(X) X R(X) X
                                                        "     (F(I) - F(I+1))
        JMP X1
        INCMA;                                          "FETCH THIRD F(I+1)
                FSUB DPY,MD;                            "SECOND F(I)-F(I+1)
                        FMUL;DPY(1)<DPX(1)              "RESAVE FIRST F(I)
                FADD;DPX(1)<DPY;                        "RESAVE SECOND F(I)
                        FMUL
"----------------------------------------------------------------------------
LOOP1:  ADD N,FN;SETMA;                                 "1. FETCH N'TH F(I)
                DPY<MD;                                 "SAVE (N-1)'TH F(I)
                        FMUL DPX,FA;                    "(N-2)'TH D(X) X R(X) X
                                                          "       (F(I)-F(I+1))
                                FADD FM,DPY(1)
                                                  "(N-3)'TH F(I)+ D(X) X R(X) X
                                                        "        (F(I)-F(I+1))
        INCMA;                                          "2. FETCH N'TH F(I+1)
                FSUB DPY,MD;                            "(N-1)'TH F(I)-F(I+1)
                        FMUL;DPY(1)<DPX(1);             "RESAVE (N-2)'TH F(I)
                                DEC NF                  "DEC COUNT NO. OF FUNCT.
                FADD;DPX(1)<DPY;                        "3. RESAVE (N-1)'TH F(I)
                        FMUL;
                                ADD ONE,RESULT;SETMA;MI<FA;BNE LOOP1
                                                        "STORE (N-3)'TH RESULT
"-------------------------------------------------------------------------
X1:     INC RESULT                                      "GET NEXT RESULT ADDRESS
        MOV RESULT,RESULT;DPY(-1)<SPFN                 "SAVE NEXT RESULT ADDRESS
        LDSPI NS;DB=DPY(-2);                            "LOAD NO. OF SETS
        RETURN                                          "RETURN TO FGEN
"----------------------------------------------------------------------
        $END
"***** FUN2 = FUNCTIONS OF TWO VARIABLES /FAST/ = REL 1.0, APR 79 ******
"       FOR FAST MEMORY
        $TITLE FUN2
        $RADIX 8
        $ENTRY FUN2
"
"
"SCOPE:
"
"(FGEN) FUNCTION GENERATION ROUTINE WITH SEARCH THROUGH BREAKPOINTS
"
"
"FGEN ROUTINE WILL CALCULATE SEVERAL GROUPS OF FUNCTIONS OF FROM ONE TO FOUR
"INDEPENDENT VARIABLES IN EACH TIME FRAME WITH A SINGLE APAL ROUTINE. THE
"CALCULATION WILL CONSIST OF TABLE LOOKUP OF FUNCTION VALUES AT BREAKPOINTS
"AND LINEAR INTERPOLATION AS ILLUSTRATED FOR TWO VARIABLES BY:
"
"        F(X,Y)=F(I,J)+D(Y)XR(Y)X { F(I,J)+D(X)XR(X)X (F(I,J)-F(I+1,J))
"                -F(I,J+1)-D(X)XR(X)X (F(I,J+1)-F(I+1,J+1)) }
"        WHERE  D(X) = X(I)-X, D(Y) = Y(I)-Y, R(X) = 1/(X(I+1)-X(I))
"                AND  R(Y) = 1/(Y(I+1)-Y(I))
"
"THE TABLE LOOKUP WILL INVOLVE A SEARCH OF THE INPUT COORDINATE VALUE THROUGH
"A TABLE OF ORDERED BREAKPOINT VALUES. THE NEAREST LOWER BREAKPOINT X(I) IS
"USED TO CALCULATE THE DIFFERENCE, X(I) - X, AND TO GIVE THE TABLE ADDRESSES
"OF THE RATIO, 1/( X(I+1) - X(I) ), AND THE FUNCTIONS, F(I) AND F(I+1).
"
"
"THE FUNCTION TABLES FOR EACH GROUP ARE PART OF THE DATA BASE IN MAIN MEMORY AS:
"
"-------------------------------------------------------------------------------
"FUNCTION TABLE
"                  FN1    FUNCTION F11
"                         FUNCTION F21                            N11 X N21X
"                              .                               N31 X N41 X NF1
"                              .                                   WORDS
"                              .
"                                  FN1
"-------------------------------------------------------------------------------
"                  FN2    FUNCTION F12
"                                  F22
"                      ..                                   .
"                      ..          FN2                      .
"                      ..                                   .
"-------------------------------------------------------------------------------
"                  FNN    FUNCTION F1N
"                                  F2N
"                              .
"                              .
"                              .
"                                  FNN
"-------------------------------------------------------------------------------
"
"THE NUMBER OF SETS AND THE NUMBER OF FUNCTIONS CALCULATED IN EACH SET AND
"ALSO THE ADDRESS OF THE INPUT COORDINATES ARE INPUT BY USER IN MAIN MEMORY AS:
"-------------------------------------------------------------------------------
"INPUT PARAMETERS AND ADDRESSES
"                  INPUT  NO. OF SETS IN GROUP 1           NS1
"                         ADDRESS OF COORDINATE VALUES     C1
"                         NO. OF FUNCTIONS IN SET 1        NF11     NS1 + 2
"                         NO. OF FUNCTIONS IN SET 2        NF21      WORDS
"                                                            .
"                                                            .
"                                                            .
"
"                         NO. OF SETS IN GROUP 2           NS2
"                         ADDRESS OF COORDINATE VALUES     C2
"                         NO. OF FUNCTIONS IN SET 1        NF12     NS2 + 2
"                                                           .        WORDS
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"
"
"THE CALCULATED FUNCTIONS ARE STORED IN MAIN MEMORY AS:
"-------------------------------------------------------------------------------
"CALCULATED TABLE OF FUNCTIONS
"                 RESULT  CALCULATE FUNCTIONS F1(X11Y11)            NF11 +
"                                             F1(X21Y21)            NF21 +
"                                             F1(X31Y31)            NF31 +
"                                          F2(X12Y12Z12)            NF12 +
"                                          F2(X22Y22Z22)            NF22 +
"                                                 .                  .
"                                                 .                 NFNN
"                                                 .                WORDS
"                                                 .
"-------------------------------------------------------------------------------
"HISTORY:
"ORIGINAL -- DEE DAVIS, 2/78
"------------------------------------------------------------------------------
"TIME OF EXECUTION:
"-------------------
"BEST        T = 6.50 + NF(1.0)  USEC
"TYPICAL     T = 6.50 + NF(1.2)  USEC
"WORST       T = 7.00 + NF(1.5)  USEC
"---------------------------------------------------------------------------
"LENGTH OF FUN2 ---   45 WORDS
"
"----------------------------------------------------------------------------
"
"ON ENTERING THE SUBROUTINE, THE S-PADS ARE ASSUMED LOADED AS:
"                       SP(4) = ONE......1
"                       SP(1) = INPUT....ADDRESS OF COORDINATES
"                       SP(14) = S1.......POINTER FOR X-COORD.
"                       SP(15) = S2.......POINTER FOR Y-COORD.
"
"ON LEAVING THE SUBROUTINE, THE OUTPUTS ARE ASSUMED LOADED AS:
"                       SP(11) = NS.......NO. OF SETS
"                       F(X,Y) TABULATED AT RESULT
"
"
"THE S-PADS USED AS SCRATCH ARE:
"                       SP(2) = RESULT...ADDRESS OF RESULT
"                       SP(12) = FN.......FUNCTION TABLE ADDRESS
"                       SP(10) = NF.......NO. OF FUNCTIONS IN SET
"                       SP(13) = N1.......NO. OF X-BKPTS.
"                       SP(11) = NN.......N1 X N2
"                       SP(15) = S2N......S2 X N1
"                       SP(0) = EXP......FOR FLOAT (27.)
"
"
"-----------------------------------------------------------------------------
"       S-PAD VALUES
        INPUT = 1                       "INPUT PARAMETER ADDRESS
        RESULT = 2                      "ADDRESS OF RESULTS
        ONE = 4                         "INCREMENT FOR DATA FETCHES / STORES
        NS = 11                         "NUMBER OF SETS
        FN = 12                         "ADDRESS OF FUNCTION TABLES
        NF = 10                         "NUMBER OF FUNCTIONS OF ONE COORD. SET
        S1 = 14                         "POINTER IN  X - COORD. SEARCH
        S2 = 15                         "POINTER IN  Y - COORD. SEARCH
        EXP = 0                         "EXPONENT USED IN FLOATING INTEGERS
        N1 = 13                         "NUMBER OF BREAKPOINTS FOR  X
        NN = 11                         "PRODUCT  N1 X N2
        S2N = 15                        "PRODUCT  S2 X N1
"---------------------------------------------------------------------------
FUN2:   ADD ONE,INPUT;SETMA                             "FETCH NO. OF FUNCTIONS
        LDSPI EXP;DB=27.                                "LOAD EXP FOR FLOATS
        LDSPI FN;DB=DPX(-3)                             "LOAD FUNCTION ADDRESS
        LDSPI NF;DB=MD                                  "LOAD NO. OF FUNCTIONS
        MOV S2,S2;DPX(1)<SPFN                           "SAVE S2,POINTER FOR Y
        FADD ZERO,MDPX(1);MOV EXP,EXP;DECDPA            "FLOAT S2
        LDSPI N1;DB=DPX(-4)                             "LOAD NO. OF X-BKPTS.
        FADD ZERO,MDPX(-4);MOV EXP,EXP;INCDPA           "FLOAT N1,NO. OF X-BKPTS
        FADD ZERO,MDPX(-4);MOV EXP,EXP;DPX(1)<FA        "FLOAT N2,NO. OF Y-BKPT.
        LDSPI RESULT;DB=DPY(-2);FADD;DPY(1)<FA;FMUL DPX(1),FA
                                                    "LOAD RESULT ADDRESS,S2 X N1
        SUB ONE,RESULT;FMUL DPY(1),FA                   "INIT. RESULT ADDRESS
                                                        "N1 X N2
        FMUL;MOV NF,NF
        FMUL;DPX(1)<FM;BGT .+2                          "SAVE S2N = S2 X N1
                                                        "TEST FOR NF <= 0
        JMP X2
        FIX DPX(1);DPX(2)<FM                            "SAVE NN = N1 X N2
                                                        "MAKE S2N INTEGER
        FIX DPX(2)                                      "MAKE NN INTEGER
        FADD;DPX(1)<FA                                  "SAVE S2N
        LDSPI S2N;DB=DPX(1);DPX(2)<FA                   "LOAD S2N,SAVE NN
        ADD S2N,FN                               "FIRST STEP IN LOCATION OF F(I)
"------------------------------------------------------------------------
        ADD S1,FN;SETMA                                 "FETCH 1'ST F(I,J)
        INCMA;LDSPI NN;DB=DPX(2)                    "FETCH 1'ST F(I+1,J);LOAD NN
        ADD# N1,FN;SETMA                                "FETCH 1'ST F(I,J+1)
        DPY(1)<MD;INCMA                                 "FETCH 1'ST F(I+1,J+1)
        FSUB DPY(1),MD                            "1'ST F(I,J)-F(I+1,J)=D(F(I,J)
"------------------------------------------------------------------------
        ADD NN,FN;SETMA;                                "FETCH 2'ND F(I,J)
                DPY(2)<MD;FADD
                FMUL DPX(-1),FA;FSUB DPY(2),MD     "1'ST D(X) X R(X) X D(F(I,J))
                                            "1'ST F(I,J+1)-F(I+1,J+1)=D(F(I,J+1)
        INCMA;                                          "FETCH 2'ND F(I+1,J)
                FMUL;DPY(-1)<DPY(1);FADD
        ADD# N1,FN;SETMA;DPY(1)<MD;                     "FETCH 2'ND F(I,J+1)
                FMUL DPX(-1),FA               "1'ST D(X) X R(X) X D(F(I,J+1))
        INCMA;                                          "FETCH 2'ND F(I+1,J+1)
                DPX(2)<DPY(2)
        FSUB DPY(1),MD                           "2'ND F(I,J)-F(I+1,J)=D(F(I,J))
"------------------------------------------------------------------
        ADD NN,FN;SETMA;                                "FETCH 3'RD F(I,J)
                DPY(2)<MD;FMUL;
                        FADD FM,DPY(-1)
                                        "1'ST F(I,J)+D(X)XR(X)X D(F(I,J))=F(X,J)
                FMUL DPX(-1),FA;FSUB DPY(2),MD
                                                "2'ND D(X) X R(X) X D(F(I,J))
        INCMA;                                          "3'RD FETCH F(I+1,J)
                FMUL;DPY(-1)<DPY(1);
                        DPX(3)<FA;FADD FM,DPX(2)        "1'ST F(X,J+1)=F(I,J+1)
                                                     "D(X) X R(X) X D(F(X,J+1))
        ADD# N1,FN;SETMA;DPY(1)<MD;                     "3'RD FETCH F(I,J+1)
                FMUL DPX(-1),FA;FADD              "2'ND D(X) X R(X) X D(F(I,J+1)
        INCMA;                                          "3'RD FETCH F(I+1,J+1)
                DPX(2)<DPY(2);
                        FSUB DPX(3),FA          "1'ST F(X,J)-F(X,J+1)=D(F(X,J))
        FSUB DPY(1),MD;
                        DPY(3)<DPX(3)
"---------------------------------------------------------------------
LOOP2: ADD NN,FN;SETMA;                         "FETCH N'TH F(I,J)
                DPY(2)<MD;                              "SAVE F(I,J+1)
                        FADD FM,DPY(-1);              "(N-2)'TH F(X,J)=F(I,J)+
                                                        "D(X)R(X)X D(F(I,J))
                                FMUL DPX,FA     "(N-3)'TH D(Y)X R(Y)X D(F(X,J))
                FMUL DPX(-1),FA;FSUB DPY(2),MD    "(N-1)'TH D(X)XR(X)X D(F(I,J))
                                                 "(N-1)'TH F(I,J+1) - F(I+1,J+1)
        INCMA;                                          "N'TH FETCH F(I+1,J)
                FMUL;DPY(-1)<DPY(1);
                        DPX(3)<FA;FADD FM,DPX(2)    "(N-2)'TH F(X,J+1)=F(I,J+1)+
        ADD# N1,FN;SETMA;DPY(1)<MD;                     "N'TH FETCH F(I,J+1)
                FMUL DPX(-1),FA;                 "(N-1)'TH D(X)XR(X)X D(F(I,J+1)
                                FADD FM,DPY(3)          "(N-3)'TH F(X,Y)=F(X,J)
                                                        "   D(Y)XR(Y)X D(F(X,J))
        INCMA;                                          "N'TH FETCH F(I+1,J+1)
                DPX(2)<DPY(2);
                        FSUB DPX(3),FA;     "(N-2)'TH F(X,J)-F(X,J+1)=D(F(X,J))
                                DEC NF                  "DEC COUNT NO. OF FUNCT.
        FSUB DPY(1),MD;                                 "N'TH F(I,J)-F(I+1,J)
                        DPY(3)<DPX(3);
                                ADD ONE,RESULT;SETMA;MI<FA;BNE LOOP2
                                                        "STORE (N-3)'TH F(X,Y)
"------------------------------------------------------------------------
X2:     DECDPA;                                      "SHIFT BACK DATA-PAD POINTE
        INC RESULT                                      "READY FOR NEXT FUNCTION
        MOV RESULT,RESULT;DPY(-1)<SPFN                 "LOAD NEXT RESULT ADDRESS
        LDSPI NS;DB=DPY(-2);RETURN                      "LOAD NO. OF SETS
"--------------------------------------------------------------------
        $END
"***** FUN3 = FUNCTIONS OF THREE VARIABLES /FAST/ = REL 1.0, APR 79 ******
"       FOR FAST MEMORY
        $TITLE FUN3
        $RADIX 8
        $ENTRY FUN3
"
"
"SCOPE:
"
"(FGEN) FUNCTION GENERATION ROUTINE WITH SEARCH THROUGH BREAKPOINTS
"
"
"FGEN ROUTINE WILL CALCULATE SEVERAL GROUPS OF FUNCTIONS OF FROM ONE TO FOUR
"INDEPENDENT VARIABLES IN EACH TIME FRAME WITH A SINGLE APAL ROUTINE. THE
"CALCULATION WILL CONSIST OF TABLE LOOKUP OF FUNCTION VALUES AT BREAKPOINTS
"AND LINEAR INTERPOLATION AS ILLUSTRATED FOR ONE VARIABLE BY:
"
"        F(X) = F(I) + ( (X(I) - X)/(X(I+1) - X(I)) ) (F(I) - F(I+1)) .
"
"THE TABLE LOOKUP WILL INVOLVE A SEARCH OF THE INPUT COORDINATE VALUE THROUGH
"A TABLE OF ORDERED BREAKPOINT VALUES. THE NEAREST LOWER BREAKPOINT X(I) IS
"USED TO CALCULATE THE DIFFERENCE, X(I) - X, AND TO GIVE THE TABLE ADDRESSES
"OF THE RATIO, 1/( X(I+1) - X(I) ), AND THE FUNCTIONS, F(I) AND F(I+1).
"
"
"THE FUNCTION TABLES FOR EACH GROUP ARE PART OF THE DATA BASE IN MAIN MEMORY AS:
"
"-------------------------------------------------------------------------------
"FUNCTION TABLE
"                  FN1    FUNCTION F11
"                         FUNCTION F21                            N11 X N21X
"                              .                               N31 X N41 X NF1
"                              .                                   WORDS
"                              .
"                                  FN1
"-------------------------------------------------------------------------------
"                  FN2    FUNCTION F12
"                                  F22
"                      ..                                   .
"                      ..          FN2                      .
"                      ..                                   .
"-------------------------------------------------------------------------------
"                  FNN    FUNCTION F1N
"                                  F2N
"                              .
"                              .
"                              .
"                                  FNN
"-------------------------------------------------------------------------------
"
"THE NUMBER OF SETS AND THE NUMBER OF FUNCTIONS CALCULATED IN EACH SET AND
"ALSO THE ADDRESS OF THE INPUT COORDINATES ARE INPUT BY USER IN MAIN MEMORY AS:
"-------------------------------------------------------------------------------
"INPUT PARAMETERS AND ADDRESSES
"                  INPUT  NO. OF SETS IN GROUP 1           NS1
"                         ADDRESS OF COORDINATE VALUES     C1
"                         NO. OF FUNCTIONS IN SET 1        NF11     NS1 + 2
"                         NO. OF FUNCTIONS IN SET 2        NF21      WORDS
"                                                            .
"                                                            .
"                                                            .
"
"                         NO. OF SETS IN GROUP 2           NS2
"                         ADDRESS OF COORDINATE VALUES     C2
"                         NO. OF FUNCTIONS IN SET 1        NF12     NS2 + 2
"                                                           .        WORDS
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"
"
"THE CALCULATED FUNCTIONS ARE STORED IN MAIN MEMORY AS:
"-------------------------------------------------------------------------------
"CALCULATED TABLE OF FUNCTIONS
"                 RESULT  CALCULATE FUNCTIONS F1(X11Y11)            NF11 +
"                                             F1(X21Y21)            NF21 +
"                                             F1(X31Y31)            NF31 +
"                                          F2(X12Y12Z12)            NF12 +
"                                          F2(X22Y22Z22)            NF22 +
"                                                 .                  .
"                                                 .                 NFNN
"                                                 .                WORDS
"                                                 .
"-------------------------------------------------------------------------------
"HISTORY:
"ORIGINAL -- DEE DAVIS, 2/78
"------------------------------------------------------------------------------
"TIME OF EXECUTION:
"-------------------
"FAST             T = 9.17 + NF(2.3)  USEC
"TYPICAL          T = 9.17 + NF(2.4)  USEC
"WORST            T = 9.83 + NF(2.8)  USEC
"---------------------------------------------------------------------------
"LENGTH OF FUN3 ---   69 WORDS
"
"----------------------------------------------------------------------------
"
"ON ENTERING THE SUBROUTINE, THE S-PADS ARE ASSUMED LOADED AS:
"                       SP(4) = ONE......1
"                       SP(1) = INPUT....ADDRESS OF COORDINATES
"                       SP(14) = S1.......POINTER FOR X-COORD.
"                       SP(15) = S2.......POINTER FOR Y-COORD.
"                       SP(16) = S3.......POINTER FOR Z-DOORD.
"
"
"ON LEAVING THE SUBROUTINE, THE OUTPUTS ARE ASSUMED LOADED AS:
"                       SP(11) = NS.......NO. OF SETS
"                       F(X,Y,Z) TABULATED AT RESULT
"
"THE S-PADS USED AS SCRATCH ARE:
"                       SP(2) = RESULT...ADDRESS OF RESULT
"                       SP(12) = FN.......FUNCTION TABLE ADDRESS
"                       SP(10) = NF.......NO. OF FUNCTIONS IN SET
"                       SP(13) = N1.......NO. OF X-BKPTS.
"                       SP(15) = S2N......S2 X N1
"                       SP(11) = NN.......N1 X N2
"                       SP(16) = S3NN.....S3 X N1 X N2
"                       SP(6) = NNN......N1 X N2 X N3
"                       SP(0) = EXP......FOR FLOAT (27.)
"
"
"-----------------------------------------------------------------------------
"       S-PAD VALUES
        INPUT = 1                       "INPUT PARAMETER ADDRESS
        RESULT = 2                      "ADDRESS OF RESULTS
        ONE = 4                         "INCREMENT FOR DATA FETCHES / STORES
        NS = 11                         "NUMBER OF SETS
        FN = 12                         "ADDRESS OF FUNCTION TABLES
        NF = 10                         "NUMBER OF FUNCTIONS OF ONE COORD. SET
        S1 = 14                         "POINTER IN  X - COORD. SEARCH
        S2 = 15                         "POINTER IN  Y - COORD. SEARCH
        S3 = 16                         "POINTER IN  Z - COORD. SEARCH
        EXP = 0                         "EXPONENT USED IN FLOATING INTEGERS
        N1 = 13                         "NUMBER OF BREAKPOINTS FOR  X
        NN = 11                         "PRODUCT  N1 X N2
        S2N = 15                        "PRODUCT  S2 X N1
        NNN = 6                         "PRODUCT N1 X N2 X N3
        S3NN = 16                       "PRODUCT S3 X N1 X N2
"---------------------------------------------------------------------------
"-------------------------------------------------------------------
FUN3:   ADD ONE,INPUT;SETMA                             "FETCH NO. OF FUNCTIONS
        LDSPI EXP;DB=27.                                "LOAD EXP FOR FLOATS
        DECDPA;MOV S2,S2;DPX(1)<SPFN                    "SAVE S2
        DECDPA;LDSPI NF;DB=MD                           "LOAD NO. OF FUNCT.
        FADD ZERO,MDPX(-4);MOV EXP,EXP                  "FLOAT N1
        INCDPA;LDSPI N1;DB=DPX(-4)                      "LOAD N1
        FADD ZERO,MDPX(-4);MOV EXP,EXP                  "FLOAT N2
        INCDPA;DPY(1)<FA;FADD ZERO,MDPX(2);MOV EXP,EXP  "SAVE FLT-N1
                                                        "FLOAT S2
        FMUL DPY(0),FA;FADD;MOV S3,S3;DPX(2)<SPFN       "N1 X N2;SAVE S3
        FMUL DPY(0),FA                                  "N1 X S2
        FMUL;FADD ZERO,MDPX(2);MOV EXP,EXP              "FLOAT S3
        FADD ZERO,MDPX(-4);MOV EXP,EXP                  "FLOAT N3
        DPY(1)<FM;FMUL FM,FA;FADD                       "N1 X N2 X S3
                                                        "SAVE N1 X N2
        FIX DPY(1);DPY(2)<FM;FMUL DPY(1),FA           "FIX N1 X N2, N1 X N2 X N3
                                                        "SAVE N1 X S2
        FIX DPY(2);FMUL                                 "FIX N1 X S2
        DPX(2)<FA;FMUL;DPY(3)<FM;FADD               "SAVE NN=N1XN2,SAVE S3XN1XN2
        LDSPI NN;DB=DPX(2);FIX DPY(3);DPY(-1)<FM;DPX(3)<FA
                                             "LOAD NN,FIX S3XN1XN2,SAVE N1XN2XN3
                                                        "SAVE S2N = S2 X N1
        LDSPI S2N;DB=DPX(3);FIX DPY(-1)                 "LOAD S2N,FIX N1XN2XN3
        FADD;DPY(3)<FA                                  "SAVE S3NN=S3 X N1 X N2
        DPY(-1)<FA;LDSPI S3NN;DB=DPY(3)            "SAVE NNN=N1XN2XN3,LOAD S3NN
        LDSPI FN;DB=DPX(-3)                            "LOAD FUNCT.TABLE ADDRESS
"-----------------------------------------------------------------------------
        ADD S3NN,FN                               "FIRST STEP TO LOCATE F(I,J,K)
        ADD S2N,FN                                      "SECOND STEP
"-------------------------------------------------------------------
        ADD S1,FN;SETMA                                 "FETCH F(I,J,K)
        INCMA;LDSPI NNN;DB=DPY(-1)                    "FETCH F(I+1,J,K),LOAD NNN
        ADD# N1,FN;SETMA                                "FETCH F(I,J+1,K)
        INCMA;DPY(1)<MD                                 "FETCH F(I+1,J+1,K)
        FSUB DPY(1),MD                          "D(F(I,J,K))=F(I,J,K)-F(I+1,J,K)
        FADD;DPY(2)<MD
        FMUL DPX(-2),FA;FSUB DPY(2),MD                "D(X) X R(X) X D(F(I,J,K))
                                                        "WHERE D(X)=X(I)-X
                                                        "AND R=I/(X(I+1)-X(I))
                                                        "AND SIMILARLY FOR Y,Z
                                          "D(F(I,J+1,K))=F(I,J+1,K)-F(I+1,J+1,K)
        ADD NN,FN;SETMA;FMUL;FADD                       "FETCH F(I,J,K+1)
        INCMA;FMUL DPX(-2),FA;LDSPI RESULT;DB=DPY(-3)   "FETCH F(I+1,J,K+1),
                                                     "D(X) X R(X) X D(F(I,J+1,K)
                                                        "LOAD RESULT ADDRESS
        ADD# N1,FN;SETMA;FADD FM,DPY(1);FMUL            "FETCH F(I,J+1,K+1)
                                                        "F(X,J,K) = F(I,J,K) +
                                                        "D(X)XR(X)X D(F(I,J,K))
        INCMA;SUB NN,FN;DPY(3)<MD;FADD;FMUL             "FETCH F(I+1,J+1,K+1)
        FSUB DPY(3),MD;DPY(-1)<FA;SUB ONE,RESULT          "D(F(I,J,K+1))=
                                                      "F(I,J,K+1) - F(I+1,J,K+1)
        FADD FM,DPY(2);DPY(-3)<MD;MOV NF,NF         "F(X,J+1,K) =  F(I,J+1,K) +
                                                        "D(X)XR(X)X D(F(I,J+1,K)
        FMUL DPX(-2),FA;FSUB DPY(-3),MD;BGT .+2           "D(F(I,J+1,K+1)) =
                                                    "F(I,J+1,K+1)-F(I+1,J+1,K+1)
                                                       "D(X)XR(X)X D(F(I,J,K+1))
                                                        "TEST FOR NF <= 0
        JMP X3
"-----------------------------------------------------------------------
        ADD NNN,FN;SETMA;                               "FETCH F(I,J,K)
                FMUL;FSUB DPY(-1),FA            "D(F(X,J,K))=F(X,J,K)-F(X,J+1,K)
        INCMA;                                          "FETCH F(I+1,J,K)
                FADD;FMUL DPX(-2),FA                 "D(X)XR(X)X D(F(I,J+1,K+1))
        ADD# N1,FN;SETMA;                               "FETCH F(I,J+1,K)
                FMUL DPX(-1),FA;FADD FM,DPY(3)          "D(Y)XR(Y)X D(F(X,J,K)
                                                "F(X,J,K+1)=F(I,J,K+1)+
                                                "D(X)XR(X)X D(F(I,J,K+1))
        INCMA;DPY(1)<MD;                                "FETCH F(I+1,J+1,K)
                FADD;FMUL
        FSUB DPY(1),MD;                                 "D(F(I,J,K))=
                                                        "F(I,J,K)-F(I+1,J,K)
                DPY(-2)<FA;DPX(1)<FM;FMUL               "SAVE F(X,J,K+1)
        DPY(2)<MD;
                FADD FM,DPY(-1)                 "F(X,Y,K) = F(X,J,K) +
                                                "D(Y)XR(Y)X D(F(X,J,K))
        FMUL DPX(-2),FA;FSUB DPY(2),MD          "D(X)XR(X)X D(F(I,J,K)
                                                        "D(F(I,J+1,K)=
                                                        "F(I,J+1,K)-F(I+1,J+1,K)
        ADD NN,FN;SETMA;FMUL;                           "FETCH F(I,J,K+1)
                DPX(-3)<FA;FADD DPX(1),DPY(-3)      "F(X,J+1,K+1)=F(I,J+1,K+1)+
                                                    "D(X)XR(X)X D(F(I,J+1,K+1))
        INCMA;FMUL DPX(-2),FA;                          "FETCH F(I+1,J,K+1)
                                                       "D(X)XR(X)X D(F(I,J+1,K))
                FADD
        ADD# N1,FN;SETMA;FADD FM,DPY(1);FMUL;           "FETCH F(I,J+1,K+1)
                                                        "F(X,J,K)=F(I,J,K)+
                                                        "D(X)XR(X)X D(F(I,J,K))
                DPX(1)<FA;DPY(0)<DPX(-3)                "SAVE F(I,J+1,K+1)
        INCMA;SUB NN,FN;FMUL;DPY(3)<MD;                 "FETCH F(I+1,J+1,K+1)
                FSUB DPY(-2),DPX(1)                     "D(F(X,J,K+1))=
                                                        "F(X,J,K+1)-F(X,J+1,K+1)
        FSUB DPY(3),MD;DPY(-1)<FA                       "D(F(I,J,K+1))=
                                                        "F(I,J,K+1)-F(I+1,J,K+1)
        FADD FM,DPY(2);DPY(-3)<MD;                       "F(X,J+1,K)=F(I,J+1,K)
                                                       "+D(X)XR(X)X D(F(I,J+1,K)
                FMUL DPX(-1),FA                         "D(Y)XR(Y)X D(F(X,J,K+1)
        FMUL DPX(-2),FA;FSUB DPY(-3),MD         "D(X)XR(X)X D(F(I,J,K+1))
                                                  "D(F(I,J+1,K+1)) =
                                                "F(I,J+1,K+1)-F(I+1,J+1,K+1)
"----------------------------------------------------------------------------
LOOP3:  ADD NNN,FN;SETMA;                               "FETCH F(I,J,K)
                FSUB DPY(-1),FA;FMUL            "D(F(X,J,K))=F(X,J,K)-F(X,J+1,K)
        INCMA;                                          "FETCH F(I+1,J,K)
                FMUL DPX(-2),FA;                      "D(X)XR(X)X D(F(I,J+1,K+1)
                        FADD FM,DPY(-2)                 "F(X,Y,K+1)=F(X,J,K+1)+
                                                     "D(Y)XR(Y)X D(F(X,J,K+1))
        ADD# N1,FN;SETMA;                               "FETCH F(I,J+1,K)
                FMUL DPX(-1),FA;FADD FM,DPY(3)          "D(Y)XR(Y)X D(F(X,J,K))
                                                        "F(X,J,K+1)=F(I,J,K+1)+
                                                       "D(X)XR(X)X D(F(I,J,K+1))
        INCMA;DPY(1)<MD;                                "FETCH F(I+1,J+1,K)
                FMUL;
                        FSUB DPY(0),FA            "D(F(X,Y,K))=F(X,Y,K)-F(X,Y,K+
        FSUB DPY(1),MD;                          "D(F(I,J,K)=F(I,J,K)-F(I+1,J,K)
                FMUL;DPY(-2)<FA;DPX(1)<FM               "SAVE F(X,J,K+1)
        DPY(2)<MD;
                FADD FM,DPY(-1);                        "F(X,Y,K)=F(X,J,K)+
                                                        "D(Y)XR(Y)X D(F(X,J,K))
                        FMUL DPX(0),FA                  "D(Z)XR(Z)X D(F(X,Y,K))
        FMUL DPX(-2),FA;FSUB DPY(2),MD                  "D(X)XR(X)X D(F(I,J,K)
                                                        "D(F(I,J+1,K))=
                                                        "F(I,J+1,K)-F(I+1,J+1,K)
        ADD NN,FN;SETMA;FMUL;                           "FETCH F(I,J,K+1)
                DPX(-3)<FA;FADD DPY(-3),DPX(1)       "F(X,J+1,K+1)=F(I,J+1,K+1)+
                                                      "D(X)XR(X)X D(F(I,J+1,K+1)
        INCMA;FMUL DPX(-2),FA;                          "FETCH F(I+1,J,K+1)
                                                       "D(X)XR(X)X D(F(I,J+1,K))
                        FADD FM,DPY(0)                  "F(X,Y,Z)=F(X,Y,K)+
                                                        "D(Z)XR(Z)X D(F(X,Y,K))
        ADD# N1,FN;SETMA;FADD FM,DPY(1);FMUL;           "FETCH F(I,J+1,K+1)
                                                        "F(X,J,K)=F(I,J,K)+
                                                        "D(X)XR(X)X D(F(I,J,K))
                DPX(1)<FA;DPY(0)<DPX(-3)                "SAVE F(I,J+1,K+1)
        INCMA;SUB NN,FN;FMUL;DPY(3)<MD;                 "FETCH F(I+1,J+1,K+1)
                FSUB DPY(-2),DPX(1);                    "D(F(X,J,K+1))=
                                                        "F(X,J,K+1)-F(X,J+1,K+1)
                        DPX(2)<FA                       "SAVE F(X,Y,K)
        DPY(-1)<FA;FSUB DPY(3),MD;                      "D(F(X,J,K+1))=
                                                        "F(I,J,K+1)-F(I+1,J,K+1)
                        ADD ONE,RESULT;SETMA;MI<DPX(2)  "STORE F(X,Y,Z)
        FADD FM,DPY(2);DPY(-3)<MD;                      "F(X,J+1,K)=F(I,J+1,K)+
                                                       "D(X)XR(X)X D(F(I,J+1,K))
                FMUL DPX(-1),FA;                        "D(Y)XR(Y)X D(F(X,J,K+1)
                        DEC NF                          "DEC NO. OF FUNCT.
        FMUL DPX(-2),FA;FSUB DPY(-3),MD;                "D(X)XR(X)X D(F(I,J,K+1)
                                                        "D(F(I,J+1,K+1))=
                                                    "F(I,J+1,K+1)-F(I+1,J+1,K+1)
                        BNE LOOP3                       "BR. LOOP3 IF NOT DONE
"----------------------------------------------------------------------------
X3:     DECDPA;INC RESULT                               "GET NEXT RESULT ADDRESS
        DECDPA;MOV RESULT,RESULT;DPY(-2)<SPFN           "SAVE RESULT
        LDSPI NS;DB=DPY(-2);RETURN                      "LOAD NO. OF SETS
                                                        "AND RETURN YO FGEN
"--------------------------------------------------------------------
        $END
"***** FUN4 = FUNCTIONS OF FOUR VARIABLES /FAST/ = REL 1.0, APR 79 ******
"       FOR FAST MEMORY
        $TITLE FUN4
        $RADIX 8
        $ENTRY FUN4
"
"
"SCOPE:
"
"(FGEN) FUNCTION GENERATION ROUTINE WITH SEARCH THROUGH BREAKPOINTS
"
"
"FGEN ROUTINE WILL CALCULATE SEVERAL GROUPS OF FUNCTIONS OF FROM ONE TO FOUR
"INDEPENDENT VARIABLES IN EACH TIME FRAME WITH A SINGLE APAL ROUTINE. THE
"CALCULATION WILL CONSIST OF TABLE LOOKUP OF FUNCTION VALUES AT BREAKPOINTS
"AND LINEAR INTERPOLATION AS ILLUSTRATED FOR ONE VARIABLE BY:
"
"        F(X) = F(I) + ( (X(I) - X)/(X(I+1) - X(I)) ) (F(I) - F(I+1)) .     *
"
"THE TABLE LOOKUP WILL INVOLVE A SEARCH OF THE INPUT COORDINATE VALUE THROUGH
"A TABLE OF ORDERED BREAKPOINT VALUES. THE NEAREST LOWER BREAKPOINT X(I) IS
"USED TO CALCULATE THE DIFFERENCE, X(I) - X, AND TO GIVE THE TABLE ADDRESSES
"OF THE RATIO, 1/( X(I+1) - X(I) ), AND THE FUNCTIONS, F(I) AND F(I+1).
"
"
"THE FUNCTION TABLES FOR EACH GROUP ARE PART OF THE DATA BASE IN MAIN MEMORY AS:
"
"-------------------------------------------------------------------------------
"FUNCTION TABLE
"                  FN1    FUNCTION F11
"                         FUNCTION F21                            N11 X N21X
"                              .                               N31 X N41 X NF1
"                              .                                   WORDS
"                              .
"                                  FN1
"-------------------------------------------------------------------------------
"                  FN2    FUNCTION F12
"                                  F22
"                      ..                                   .
"                      ..          FN2                      .
"                      ..                                   .
"-------------------------------------------------------------------------------
"                  FNN    FUNCTION F1N
"                                  F2N
"                              .
"                              .
"                              .
"                                  FNN
"-------------------------------------------------------------------------------
"
"THE NUMBER OF SETS AND THE NUMBER OF FUNCTIONS CALCULATED IN EACH SET AND
"ALSO THE ADDRESS OF THE INPUT COORDINATES ARE INPUT BY USER IN MAIN MEMORY AS:
"-------------------------------------------------------------------------------
"INPUT PARAMETERS AND ADDRESSES
"                  INPUT  NO. OF SETS IN GROUP 1           NS1
"                         ADDRESS OF COORDINATE VALUES     C1
"                         NO. OF FUNCTIONS IN SET 1        NF11     NS1 + 2
"                         NO. OF FUNCTIONS IN SET 2        NF21      WORDS
"                                                            .
"                                                            .
"                                                            .
"
"                         NO. OF SETS IN GROUP 2           NS2
"                         ADDRESS OF COORDINATE VALUES     C2
"                         NO. OF FUNCTIONS IN SET 1        NF12     NS2 + 2
"                                                           .        WORDS
"                                                           .
"                                                           .
"-------------------------------------------------------------------------------
"
"
"THE CALCULATED FUNCTIONS ARE STORED IN MAIN MEMORY AS:
"-------------------------------------------------------------------------------
"CALCULATED TABLE OF FUNCTIONS
"                 RESULT  CALCULATE FUNCTIONS F1(X11Y11)            NF11 +
"                                             F1(X21Y21)            NF21 +
"                                             F1(X31Y31)            NF31 +
"                                          F2(X12Y12Z12)            NF12 +
"                                          F2(X22Y22Z22)            NF22 +
"                                                 .                  .
"                                                 .                 NFNN
"                                                 .                WORDS
"                                                 .
"-------------------------------------------------------------------------------
"HISTORY:
"ORIGINAL -- DEE DAVIS, 2/78
"------------------------------------------------------------------------------
"TIME OF EXECUTION:
"-------------------
"BEST          T = 16.50 + NF(5.0)  USEC
"TYPICAL       T = 16.50 + NF(5.0)  USEC
"WORST         T = 18.50 + NF(6.0)  USEC
"---------------------------------------------------------------------------
"LENGTH OF FUN4 ---   131 WORDS
"
"----------------------------------------------------------------------------
"
"ON ENTERING THE SUBROUTINE, THE S-PADS ARE ASSUMED LOADED AS:
"                       SP(4) = ONE......1
"                       SP(1) = INPUT....ADDRESS OF COORDINATES
"                       SP(14) = S1.......POINTER FOR X-COORD.
"                       SP(15) = S2.......POINTER FOR Y-COORD.
"                       SP(16) = S3.......POINTER FOR Z-COORD.
"                       SP(17) = S4.......POINTER FOR W-COORD.
"
"
"ON LEAVING THE SUBROUTINE, THE OUTPUTS ARE ASSUMED LOADED AS:
"                       SP(11) = NS.......NO. OF SETS
"                       F(X,Y,Z,W) TABULATED AT RESULT
"
"THE S-PADS USED AS SCRATCH ARE:
"                       SP(2) = RESULT...ADDRESS OF RESULT
"                       SP(12) = FN.......FUNCTION TABLE ADDRESS
"                       SP(10) = NF.......NO. OF FUNCTIONS IN SET
"                       SP(13) = N1.......NO. OF X-BKPTS.
"                       SP(11) = NN.......N1 X N2
"                       SP(15) = S2N......S2 X N1
"                       SP(6) = NNN......N1 X N2 X N3
"                       SP(16) = S3NN.....S3 X N1 X N2
"                       SP(5) = NNNN.....N1 X N2 X N3 X N4
"                       SP(17) = S4NNN....S4 X N1 X N2 X N3
"                       SP(0) = EXP......FOR FLOAT (27.)
"
"
"-----------------------------------------------------------------------------
"       S-PAD VALUES
        INPUT = 1                       "INPUT PARAMETER ADDRESS
        RESULT = 2                      "ADDRESS OF RESULTS
        ONE = 4                         "INCREMENT FOR DATA FETCHES / STORES
        NS = 11                         "NUMBER OF SETS
        FN = 12                         "ADDRESS OF FUNCTION TABLES
        NF = 10                         "NUMBER OF FUNCTIONS OF ONE COORD. SET
        S1 = 14                         "POINTER IN  X - COORD. SEARCH
        S2 = 15                         "POINTER IN  Y - COORD. SEARCH
        S3 = 16                         "POINTER IN  Z - COORD. SEARCH
        S4 = 17                         "POINTER IN  W - COORD. SEARCH
        EXP = 0                         "EXPONENT USED IN FLOATING INTEGERS
        N1 = 13                         "NUMBER OF BREAKPOINTS FOR  X
        NN = 11                         "PRODUCT  N1 X N2
        S2N = 15                        "PRODUCT  S2 X N1
        NNN = 6                         "PRODUCT N1 X N2 X N3
        S3NN = 16                       "PRODUCT S3 X N1 X N2
        NNNN = 5                        "PRODUCT N1 X N2 X N3 X N4
        S4NNN = 17                      "PRODUCT S4 X N1 X N2 X N3
"---------------------------------------------------------------------------
FUN4:   LDSPI FN;DB=DPX(-3)                         "LOAD FUNCTION TABLE ADDRESS
        DPX(-3)<DPX(1)                                  "REPLACE D(X) X R(X)
                                                        "WHERE D(X)=X(I)-X
                                                        "AND R=1/(X(I+1)-X(I))
        ADD ONE,INPUT;SETMA;DECDPA                      "FETCH NO. OF FUNCT.
        LDSPI EXP;DB=27.                                "LOAD EXP FOR FLOATS
        DECDPA;MOV S2,S2;DPX(2)<SPFN                    "SAVE S2
        DECDPA;LDSPI NF;DB=MD                           "LOAD NO. OF FUNCT.
        FADD ZERO,MDPX(-4);MOV EXP,EXP                  "FLOAT N1
        INCDPA;LDSPI N1;DB=DPX(-4)                      "LOAD N1
        FADD ZERO,MDPX(-4);MOV EXP,EXP                  "FLOAT N2
        INCDPA;DPY(1)<FA;FADD ZERO,MDPX(3);MOV EXP,EXP  "FLOAT S2
        FMUL DPY(0),FA;FADD;MOV S3,S3;DPX(3)<SPFN       "N1 X N2, SAVE S3
        FMUL DPY(0),FA                                  "N1 X S2
        FMUL;FADD ZERO,MDPX(3);MOV EXP,EXP              "FLOAT S3
        FADD ZERO,MDPX(-4);MOV EXP,EXP;INCDPA           "FLOAT N3
        DPY(1)<FM;FMUL FM,FA;FADD ZERO,MDPX(-4);MOV EXP,EXP      "N1 X N2 X S3,
                                                                 "AND FLOAT N4
        FIX DPY(1);DPY(2)<FM;FMUL DPY(1),FA;MOV S4,S4;DPX(1)<SPFN
                                                        "FIX N1 X N2, N1 X N2 X
        FIX DPY(2);FMUL;DPX(-4)<FA                               "FIX N1 X N2
        DPX(2)<FA;FMUL;DPY(3)<FM;FADD ZERO,MDPX(1);MOV EXP,EXP
                                                        "SAVE NN=N1XN2,FLOAT S4
        LDSPI NN;DB=DPX(2);FIX DPY(3);DPY(-2)<FM;DPX(3)<FA
                                                        "LOAD NN,FIX N1XN2XN3
                                                        "SAVE S2N = S2 X N1
                                                        "FIX N1 X N2 X N3
        FMUL FM,DPX(-4)                                 "N1 X N2 X N3 X N4
        LDSPI S2N;DB=DPX(3);FMUL DPY(-2),FA             "LOAD S2N,N1XN2XN3XS4
        FIX DPY(-2)                                     "FIX N1XN2XN3
        FADD;DPY(3)<FA;FMUL                             "SAVE S3NN=S3XN1XN2
        DPY(-2)<FA;LDSPI S3NN;DB=DPY(3);DPX(3)<FM;FMUL       "LOAD S3NN,
                                                        "SAVE NNN=N1 X N2 X N3
        LDSPI NNN;DB=DPY(-2);FIX DPX(3);DPY(-3)<FM     "LOAD NNN,FIX N1XN2XN3XN4
        FIX DPY(-3)                                     "FIX N1XN2XN3XS4=S4NNN
        LDSPI RESULT;DB=DPY(-4);DPX(3)<FA;FADD          "LOAD RESULT ADDRESS,
                                                        "SAVE NNNN
        SUB ONE,RESULT;DPY(-3)<FA                       "INIT RESULT,SAVE S4NNN
        LDSPI NNNN;DB=DPX(3);INCDPA                     "LOAD NNNN
        LDSPI S4NNN;DB=DPY(-4);INCDPA                   "LOAD S4NNN
        MOV NF,NF
        BGT .+2                                         "TEST IF NF <= 0
        JMP EX
"--------------------------------------------------------------------------
        ADD S4NNN,FN                            "FIRST STEP IN LOCATING FN
        ADD S3NN,FN                             "SECOND
        ADD S2N,FN                              "THIRD
"-----------------------------------------------------------------------------
        ADD S1,FN;SETMA                                 "FETCH F(I,J,K,L)
        INCMA                                           "FETCH F(I+1,J,K,L)
        ADD# N1,FN;SETMA                                "FETCH F(I,J+1,K,L)
        DPY(-1)<MD;INCMA;DECDPA                         "FETCH F(I+1,J+1,K,L)
        FSUB DPY(0),MD;ADD NN,FN;SETMA                  "D(F(I,J,K,L)) =
                                                        "F(I,J,K,L)-F(I+1,J,K,L)
                                                        "FETCH F(I,J,K+1,L)
        DPY(-2)<MD;INCMA;FADD                           "FETCH F(I+1,J,K+1,L)
        FMUL DPX(-4),FA;FSUB DPY(-2),MD;ADD# N1,FN;SETMA;INCDPA
                                                  "D(X) X R(X) X D(F(I,J,K,L))
                                                        "WHERE D(X)=X(I)-X
                                                        "AND R=1/(X(I+1)-X(I))
                                                        "AND SIMILARLY FOR Y,Z,W
                                                        "D(F(I,J+1,K,L) =
                                                    "F(I,J+1,K,L)-F(I+1,J+1,K,L)
                                                        "FETCH F(I,J+1,K+1,L)
        FADD;FMUL;DPY(0)<MD;INCMA;SUB NN,FN;DECDPA      "FETCH F(I+1,J+1,K+1,L)
        FMUL DPX(-4),FA;FSUB DPY(1),MD;ADD NNN,FN;SETMA;DECDPA
                                                   "D(X) X R(X) X D(F(I,J+1,K,L)
                                                        "D(F(I,J,K+1,L) =
                                                    "F(I+1,J,K+1,L)-F(I,J,K+1,L)
                                                        "FETCH F(I,J,K,L+1)
        FADD FM,DPY(1);DPY(-2)<MD;INCMA;FMUL          "F(X,J,K,L) = F(I,J,K,L) +
                                                    "D(X) X R(X) X D(F(I,J,K,L))
                                                        "FETCH F(I+1,J,K,L+1)
        FMUL DPX(-3),FA;FSUB DPY(-2),MD;ADD# N1,FN;SETMA
                                                     "D(X)XR(X)XD(F(I,J,K+1,L))
                                                        "D(F(I,J+1,K+1,L)=
                                                "F(I,J+1,K+1,L)-F(I+1,J+1,K+1,L)
                                                        "FETCH F(I,J+1,K,L+1)
        DPX(-4)<FA;FADD FM,DPY(-1);DPY(3)<MD;INCMA              "SAVE F(X,J,K,L)
                                                     "F(X,J+1,K,L)=F(I,J+1,K,L)+
                                                      "D(X)XR(X)XD(F(I,J+1,K,L))
                                                        "FETCH F(I+1,J+1,K,L+1)
        FMUL DPX(-3),FA;FSUB DPY(3),MD              "D(X)XR(X)XD(F(I,J+1,K+1,L))
                                                        "D(F(I,J,K,L+1))=
                                                   "F(I,J,K,L+1)-F(I+1,J,K,L+1)
        FSUB DPX(-4),FA;DPY(-3)<MD                              "D(F(X,J,K,L))=
                                                        "F(X,J,K,L)-F(X,J+1,K,L)
        FMUL DPX(-3),FA;FSUB DPY(-3),MD               "D(X)XR(X)XD(F(I,J,K,L+1))
                                                        "D(F(I,J+1,K,L+1))=
                                                "F(I,J+1,K,L+1)-F(I+1,J+1,K,L+1)
        FMUL DPX(-2),FA;FADD FM,DPY(2)          "D(Y)XR(Y)XD(F(X,J,K,L))
                                                "F(X,J,K+1,L)=F(I,J,K+1,L) +
                                                "D(X)XR(X)XD(F(I,J,K+1,L))
        FADD FM,DPY(-2);FMUL DPX(-3),FA;ADD NN,FN;SETMA
                                                  "F(X,J+1,K+1,L)=F(I,J+1,K+1,L)
                                                     "D(X)XR(X)XD(F(I,J+1,K+1,L)
                                                     "D(X)XR(X)XD(F(I,J+1,K,L+1)
                                                           "FETCH F(I,J,K+1,L+1)
        DPY(2)<FA;FADD FM,DPY(3);INCMA               "F(X,J,K,L+1)=F(I,J,K,L+1)+
                                                      "D(X)XR(X)X D(F(I,J,K,L+1)
                                                      "FETCH F(I+1,J,K+1,L+1)
        FSUB DPY(2),FA;ADD# N1,FN;SETMA         "D(F(X,J,K+1,L)=
                                                "F(X,J,K+1,L)-F(X,J+1,K+1,L)
                                                        "FETCH F(I,J+1,K+1,L+1)
        FADD;DPX(2)<FA;DPY(0)<MD;INCMA;SUB NN,FN       "FETCH F(I+1,J+1,K+1,L+1)
        FMUL DPX(-2),FA;FSUB DPY(0),MD;SUB NNN,FN     "D(Y)XR(Y)X D(F(X,J,K+1,L)
                                                        "D(F(I,J,K+1,L+1))=
                                            "F(I,J,K+1,L+1)-F(I+1,J,K+1,L+1)
        FADD FM,DPX(-4);DPY(-4)<MD;FMUL                 "F(X,Y,K,L)=F(X,J,K,L)+
                                                       "D(Y)XR(Y)X D(F(X,J,K,L))
        FMUL DPX(-3),FA;FSUB DPY(-4),MD;DPX(1)<FM
                                          "D(X)XR(X)X D(F(I,J,K+1,L+1))
                                                        "D(F(I,J+1,K+1,L+1))=
                                            "F(I,J+1,K+1,L+1)-F(I+1,J+1,K+1,L+1)
        DPY(-2)<FA;FADD DPX(1),DPY(-3)          "F(X,J+1,K,L+1)=F(I,J+1,K,L+1)+
                                                "D(X)XR(X)X D(F(I,J+1,K,L+1))
        FADD FM,DPY(2);FMUL DPX(-3),FA          "F(X,Y,K+1,L)=F(X,J,K+1,L)+
                                                "D(Y)XR(Y)X D(F(X,J,K+1,L))
                                                 "D(X)XR(X)X D(F(I,J+1,K+1,L+1))
        FSUB DPX(2),FA;FMUL                             "D(F(X,J,K,L+1))=
                                                    "F(X,J,K,L+1)-F(X,J+1,K,L+1)
        DPX(1)<FA;FADD FM,DPY(0);DPY(3)<DPX(2);FMUL
                                                        "SAVE F(X,Y,K+1,L)
                                                "F(X,J,K+1,L+1)=F(I,J,K+1,L+1)+
                                                "D(X)XR(X)X D(F(I,J,K+1,L+1))
        FMUL DPX(-2),FA;FADD FM,DPY(-4);INCDPA  "D(Y)XR(Y)X D(F(X,J,K,L+1))
                                             "F(X,J+1,K+1,L+1)=F(I,J+1,K+1,L+1)+
                                                "D(X)XR(X)X D(F(I,J+1,K+1,L+1))
        FADD;DPY(-1)<FA;FMUL;INCDPA                     "SAVE F(X,J,K+1,L+1)
        FSUB DPY(-2),FA                                 "D(F(X,J,K+1,L+1))=
                                                "F(X,J,K+1,L+1)-F(X,J+1,K+1,L+1)
"------------------------------------------------------------------------
        ADD NNNN,FN;SETMA;                              "FETCH F(I,J,K,L)
                FMUL;FADD
        INCMA;                                          "FETCH F(I+1,J,K,L)
                FADD FM,DPY(1);FMUL DPX(-4),FA  "F(X,Y,K,L+1)=F(X,J,K,L+1)+
                                                     "D(Y)XR(Y)X D(F(X,J,K,L+1))
                                                   "D(Y)XR(Y)X D(F(X,J,K+1,L+1))
        ADD# N1,FN;SETMA;                               "FETCH F(I,J+1,K,L)
                DPX(2)<DPY(-4);FADD
        DPY(-1)<MD;INCMA;DECDPA;                        "FETCH F(I+1,J+1,K,L)
                FSUB DPY(-4),DPX(-1);DPX(3)<FA;FMUL     "D(F(X,Y,K,L))=
                                                      "F(X,Y,K,L)-F(X,Y,K+1,L)
        FSUB DPY(0),MD;ADD NN,FN;SETMA;FMUL             "D(F(I,J,K,L)=
                                                "F(I,J,K,L)-F(I+1,J,K,L)
                                                        "FETCH F(I,J,K+1,L)
        DPY(-2)<MD;INCMA;                               "FETCH F(I+1,J,K+1,L)
                FMUL DPX(-2),FA;FADD FM,DPY(-1)       "D(Z)XR(Z)X D(F(X,Y,K,L))
                                                "F(X,Y,K+1,L+1)=F(X,J,K+1,L+1)+
                                                "D(X)XR(X)X D(F(X,J,K+1,L+1))
        FMUL DPX(-4),FA;FSUB DPY(-2),MD;ADD# N1,FN;SETMA;INCDPA
                                                        "FETCH F(I,J+1,K+1,L)
                                                "D(X)XR(X)X D(F(I,J,K,L))
                                                        "D(F(I,J,K,L))=
                                                "F(I,J,K,L)-F(I+1,J,K,L)
        FMUL;DPY(0)<MD;INCMA;SUB NN,FN;DECDPA;          "FETCH F(I+1,J+1,K+1,L)
                FSUB DPX(3),FA                          "D(F(X,Y,K,L+1))=
                                                "F(X,Y,K,L+1)-F(X,Y,K+1,L+1)
        FMUL DPX(-4),FA;FSUB DPY(1),MD;ADD NNN,FN;SETMA;DECDPA;
                                                "D(X)XR(X)X D(F(I,J+1,K,L))
                                                        "D(F(I,J,K+1,L))=
                                                "F(I,J,K+1,L)-F(I+1,J,K+1,L)
                                                        "FETCH F(I,J,K,L+1)
                DPY(3)<FM
        FADD FM,DPY(1);DPY(-2)<MD;INCMA;                "F(X,J,K,L)=F(I,J,K,L)+
                                                "D(X)XR(X)X D(F(I,J,K,L))
                                                        "FETCH F(I+1,J,K,L+1)
                FMUL DPX(-1),FA                 "D(Z)XR(Z)X D(F(X,Y,K,L+1))
        FMUL DPX(-3),FA;FSUB DPY(-2),MD;ADD# N1,FN;SETMA
                                                "D(X)XR(X)X D(F(I,J,K+1,L))
                                                "D(F(I,J+1,K+1,L))=
                                                "F(I,J+1,K+1,L)-F(I+1,J+1,K+1,L)
                                                        "FETCH F(I,J+1,K,L+1)
        DPX(-4)<FA;FADD FM,DPY(-1);DPY(3)<MD;INCMA   "F(X,J+1,K,L)=F(I,J+1,K,L)+
                                                     "D(X)XR(X)X D(F(I,J+1,K,L))
                                                        "FETCH F(I+1,J+1,K,L+1)
                                                        "SAVE F(X,J,K,L)
        FMUL DPX(-3),FA;FSUB DPY(3),MD             "D(X)XR(X)X D(F(I,J+1,K+1,L))
                                                        "D(F(I,J,K,L))=
                                                "F(I,J,K,L+1)-F(I+1,J,K,L+1)
        FSUB DPX(-4),FA;DPY(-3)<MD;                     "D(F(X,J,K,L))=
                                                "F(X,J,K,L)-F(X,J+1,K,L)
                DPX(3)<FM
        FMUL DPX(-3),FA;FSUB DPY(-3),MD         "D(X)XR(X)X D(F(I,J,K,L+1))
                                                "D(F(I,J+1,K,L+1))=
                                                "F(I,J+1,K,L+1)-F(I+1,J+1,K,L+1)
        FMUL DPX(-2),FA;FADD FM,DPY(2)          "D(Y)XR(Y)X D(F(X,J,K,L))
                                                     "F(X,J,K+1,L)=F(I,J,K+1,L)+
                                                     "D(X)XR(X)X D(F(I,J,K+1,L))
        FADD FM,DPY(-2);FMUL DPX(-3),FA;ADD NN,FN;SETMA
                                                "F(X,J+1,K+1,L)=F(I,J+1,K+1,L)+
                                                "D(X)XR(X)X D(F(I,J+1,K+1,L))
                                                "D(X)XR(X)X D(F(I,J+1,K,L+1))
                                                        "FETCH F(I,J,K+1,L+1)
        DPY(2)<FA;FADD FM,DPY(3);INCMA          "F(X,J,K,L+1)=F(I,J,K,L+1)+
                                                "D(X)XR(X)X D(F(I,J,K,L+1))
                                                        "FETCH F(I+1,J,K+1,L+1)
        FSUB DPY(2),FA;ADD# N1,FN;SETMA         "D(F(X,J,K+1,L))=
                                                "F(X,J,K+1,L)-F(X,J+1,K+1,L)
                                                        "FETCH F(I,J+1,K+1,L+1)
        DPX(2)<FA;DPY(0)<MD;INCMA;SUB NN,FN;FADD       "FETCH F(I+1,J+1,K+1,L+1)
        FMUL DPX(-2),FA;FSUB DPY(0),MD;SUB NNN,FN    "D(Y)XR(Y)X D(F(X,J,K+1,L))
                                                "D(F(I,J,K+1,L+1))=
                                                "F(I,J,K+1,L+1)-F(I+1,J,K+1,L+1)
        FADD FM,DPX(-4);DPY(-4)<MD;FMUL         "F(X,Y,K,L)=F(X,J,K,L)+
                                                      "D(Y)XR(Y)X D(F(X,J,K,L))
        FMUL DPX(-3),FA;FSUB DPY(-4),MD;DPX(1)<FM  "D(X)XR(X)X D(F(I,J,K+1,L+1))
                                                "D(F(I,J+1,K+1,L+1))=
                                           "F(I,J+1,K+1,L+1)-F(I+1,J+1,K+1,L+1)
        DPY(-2)<FA;FADD DPX(1),DPY(-3)     "F(X,J+1,K,L+1)=F(I,J+1,K,L+1)+
                                                "D(X)XR(X)X D(F(I,J+1,K,L+1))
        FADD FM,DPY(2);FMUL DPX(-3),FA          "F(X,Y,K+1,L)=F(X,J,K+1,L)+
                                                "D(Y)XR(Y)X D(F(X,J,K+1,L))
                                                "D(X)XR(X)X D(F(I,J+1,K+1,L+1))
        FSUB DPX(2),FA;FMUL                             "D(F(X,J,K,L+1))=
                                                "F(X,J,K,L+1)-F(X,J+1,K,L+1)
        DPX(1)<FA;FADD FM,DPY(0);DPY(3)<DPX(2);FMUL
                                                "F(X,J,K+1,L+1)=F(I,J,K+1,L+1)+
                                                "D(X)XR(X)X D(F(I,J,K+1,L+1))
        FMUL DPX(-2),FA;FADD FM,DPY(-4);INCDPA  "D(Y)XR(Y)X D(F(X,J,K,L+1))
                                             "F(X,J+1,K+1,L+1)=F(I,J+1,K+1,L+1)+
                                                "D(X)XR(X) D(F(I,J+1,K+1,L+1))
        DPY(-1)<FA;FMUL;INCDPA;
                FADD DPX(3),DPY(3)              "F(X,Y,Z,L)=F(X,Y,K,L)+
                                                "D(Z)XR(Z)X D(F(X,Y,K,L))
        FSUB DPY(-2),FA;                             "D(F(X,J,K+1,L+1))=
                                                "F(X,J,K+1,L+1)-F(X,J+1,K+1,L+1)
                DPY(-3)<DPX(1)
"---------------------------------------------------------------------
LOOP4:  ADD NNNN,FN;SETMA;                              "FETCH F(I,J,K,L)
                FMUL;
                        DPX(0)<FA;FADD DPX(3),DPY(-3)           "SAVE F(X,Y,Z,L)
                                                "F(X,Y,Z,L+1)=F(X,Y,K,L+1)+
                                                "D(Z)XR(Z)X D(F(X,Y,K,L+1))
        INCMA;                                  "FETCH F(I+1,J,K,L)
                FADD FM,DPY(1);FMUL DPX(-4),FA   "F(X,Y,K,L+1)=F(X,J,K,L+1)+
                                                "D(Y)XR(Y)X D(F(X,J,K,L+1))
                                                "D(Y)XR(Y)X D(F(X,J,K+1,L+1))
        ADD# N1,FN;SETMA;                               "FETCH F(I,J+1,K,L)
                DPX(2)<DPY(-4);
                        FSUB DPX(0),FA          "D(F(X,Y,Z,L)=
                                                "F(X,Y,Z,L)-F(X,Y,Z,L+1)
        DPY(-1)<MD;INCMA;DECDPA;                           "FETCH F(I+1,J+1,K,L)
                FSUB DPY(-4),DPX(-1);DPX(3)<FA;FMUL     "D(F(X,Y,K,L))=
                                                    "F(X,Y,K,L)-F(X,Y,K+1,L)
        FSUB DPY(0),MD;ADD NN,FN;SETMA;         "D(F(I,J,K,L)=
                                                "F(I,J,K,L)-F(I+1,J,K,L)
                                                        "FETCH F(I,J,K+1,L)
                        FMUL DPX(-1),FA            "D(W)XR(W)X D(F(X,Y,Z,L))
        DPY(-2)<MD;INCMA;                               "FETCH F(I+1,J,K+1,L)
                FMUL DPX(-2),FA;FADD FM,DPY(-1)     "D(Z)XR(Z)X D(F(X,Y,K,L))
                                                "F(X,Y,K+1,L+1)=F(X,J,K+1,L+1)+
                                                "D(Y)XR(Y)X D(F(X,J,K+1,L+1))
        FMUL DPX(-4),FA;FSUB DPY(-2),MD;ADD# N1,FN;SETMA;INCDPA
                                                "D(X)XR(X)X D(F(I,J,K,L))
                                                "D(F(I,J,K,L)=
                                                "F(I,J,K,L)-F(I+1,J,K,L)
                                                        "FETCH F(I+1,J+1,K+1,L)
        FMUL;DPY(0)<MD;INCMA;SUB NN,FN;DECDPA;          "FETCH F(I+1,J+1,K+1,L)
                FSUB DPX(3),FA;                         "D(F(X,Y,K,L+1))=
                                                "F(X,Y,K,L+1)-F(X,Y,K+1,L+1)
                        DPX(-1)<FM              "SAVE D(W)XR(W)X D(F(X,Y,Z,L))
        FMUL DPX(-4),FA;FSUB DPY(1),MD;ADD NNN,FN;SETMA;DECDPA;
                                                "D(X)XR(X)X D(F(I,J+1,K,L))
                                                "D(F(I,J,K+1,L))=
                                                  "F(I,J,K+1,L)-F(I+1,J,K+1,L)
                                                        "FETCH F(I,J,K,L+1)
                DPY(3)<FM
        FADD FM,DPY(1);DPY(-2)<MD;INCMA;                "F(X,J,K,L)=F(I,J,K,L)+
                                                       "D(X)XR(X)X D(F(I,J,K,L))
                                                        "FETCH F(I+1,J,K,L+1)
                FMUL DPX(-1),FA                 "D(Z)XR(Z)X D(F(X,Y,K,L+1))
        FMUL DPX(-3),FA;FSUB DPY(-2),MD;ADD# N1,FN;SETMA
                                                "D(X)XR(X)X D(F(I,J,K+1,L))
                                                "D(F(I,J+1,K+1,L))=
                                                "F(I,J+1,K+1,L)-F(I+1,J+1,K+1,L)
                                                        "FETCH F(I,J+1,K,L+1)
        DPX(-4)<FA;FADD FM,DPY(-1);DPY(3)<MD;INCMA  "F(X,J+1,K,L)=F(I,J+1,K,L)+
                                                     "D(X)XR(X)X D(F(I,J+1,K,L))
                                                        "FETCH F(I+1,J+1,K,L+1)
        FMUL DPX(-3),FA;FSUB DPY(3),MD          "D(X)XR(X) D(F(I,J+1,K+1,L))
                                                        "D(F(I,J,K,L+1))=
                                                "F(I,J,K,L+1)-F(I+1,J,K,L+1)
        FSUB DPX(-4),FA;DPY(-3)<MD;                             "D(F(X,J,K,L))=
                                                "F(X,J,K,L)-F(X,J+1,K,L)
                DPX(3)<FM
        FMUL DPX(-3),FA;FSUB DPY(-3),MD         "D(X)XR(X)X D(F(I,J,K,L+1))
                                                "D(F(I,J+1,K,L+1))=
                                                "F(I,J+1,K,L+1)-F(I+1,J+1,K,L+11
        FMUL DPX(-2),FA;FADD FM,DPY(2)          "D(Y)XR(Y)X D(F(X,J,K,L))
                                                "F(X,J,K+1,L)=F(I,J,K+1,L)+
                                                "D(X)XR(X)X D(F(I,J,K+1,L))
        FADD FM,DPY(-2);FMUL DPX(-3),FA;ADD NN,FN;SETMA
                                                "F(X,J+1,K+1,L)=F(I,J+1,K+1,L)+
                                                "D(X)XR(X)X D(F(I,J+1,K+1,L))
                                                "D(X)XR(X)X D(F(I,J+1,K,L+1))
                                                        "FETCH F(I,J,K+1,L+1)
        DPY(2)<FA;FADD FM,DPY(3);INCMA  "F(X,J,K,L+1)=F(I,J,K,L+1)+
                                                "D(X)XR(X)X D(F(I,J,K,L+1))
                                                        "FETCH F(I+1,J,K+1,L+1)
        FSUB DPY(2),FA;ADD# N1,FN;SETMA;                        "D(F(X,J,K+1,L))
                                                    "F(X,J,K+1,L)-F(X,J+1,K+1,L)
                                                        "FETCH F(I,J+1,K+1,L+1)
                        DPY(0)<DPX(2)                   "RESAVE F(X,Y,Z,L)
        DPX(2)<FA;DPY(0)<MD;INCMA;SUB NN,FN;          "FETCH F(I+1,J+1,K+1,L+1)
                        FADD DPX(1),DPY(0)              "F(X,Y,Z,W)=F(X,Y,Z,L)+
                                                    "D(W)XR(W)X D(F(X,Y,Z,L))
        FMUL DPX(-2),FA;FSUB DPY(0),MD;SUB NNN,FN    "D(Y)XR(Y)X D(F(X,J,K+1,L))
                                                        "D(F(I,J,K+1,L+1))=
                                                "F(I,J,K+1,L+1)-F(I+1,J,K+1,L+1)
        FADD FM,DPX(-4);DPY(-4)<MD;FMUL;        "F(X,Y,K,L)=F(X,J,K,L)+
                                                "D(Y)XR(Y)X D(F(X,J,K,L))
                        ADD ONE,RESULT;MI<FA;SETMA    "STORE CALCULATED FUNCTION
                                                        "F(X,Y,Z,W)
        FMUL DPX(-3),FA;FSUB DPY(-4),MD;DPX(1)<FM  "D(X)XR(X)X D(F(I,J,K+1,L+1))
                                                        "D(F(I,J+1,K+1,L+1))=
                                           "F(I,J+1,K+1,L+1)-F(I+1,J+1,K+1,L+1)
        DPY(-2)<FA;FADD DPX(1),DPY(-3)          "F(X,J+1,K,L+1)=F(I,J+1,K,L+1)+
                                                "D(X)XR(X)X D(F(I,J+1,K,L+1))
        FADD FM,DPY(2);FMUL DPX(-3),FA          "F(X,Y,K+1,L)=F(X,J,K+1,L+1)+
                                                "D(Y)XR(Y)X D(F(X,J,K+1,L))
                                                "D(X)XR(X)X D(F(I,J+1,K+1,L+1))
        FSUB DPX(2),FA;FMUL                             "D(F(X,J,K,L+1))=
                                                "F(X,J,K,L+1)-F(X,J+1,K,L+1)
        DPX(1)<FA;FADD FM,DPY(0);DPY(3)<DPX(2);FMUL
                                                "F(X,J,K+1,L+1)=F(I,J,K+1,L+1)+
                                                "D(X)XR(X)X D(F(I,J,K+1,L+1))
        FMUL DPX(-2),FA;FADD FM,DPY(-4);INCDPA; "D(Y)XR(Y)X D(F(X,J,K,L+1))
                                             "F(X,J+1,K+1,L+1)=F(I,J+1,K+1,L+1)+
                                                "D(X)XR(X)X D(F(I,J+1,K+1,L+1))
                        DEC NF                          "DEC NO. OF FUNCT.
        DPY(-1)<FA;FMUL;INCDPA;
                FADD DPX(3),DPY(3);                     "F(X,Y,Z,L)=F(X,Y,K,L)+
                                                       "D(Z)XR(Z)X D(F(X,Y,K,L))
                        BEQ EX                          "BR. OUT OF LOOP IF DONE
        FSUB DPY(-2),FA;                                "D(F(X,J,K+1,L+1))=
                                                "F(X,J,K+1,L+1)-F(X,J+1,K+1,L+1)
                DPY(-3)<DPX(1);
                        JMP LOOP4                     "JMP. TO LOOP4 IF NOT DONE
"--------------------------------------------------------------------------
EX:     DECDPA
        DECDPA;INC RESULT                               "READY FOR NEXT RESULT
        DECDPA;MOV RESULT,RESULT;DPY(-4)<SPFN           "SAVE RESULT ADDRESS
        DECDPA;LDSPI NS;DB=DPY(-4)                      "LOAD NO. OF SETS
        DECDPA;RETURN
        $END
"****** EIGRS = EIGENVALUES, REAL SYMMETRIC /COMMON/ = REL 1.0, APR 79 ******
"                       FOR BOTH MEMORIES
                        $TITLE EIGRS
        $RADIX 8
                        $ENTRY EIGRS,5
                        $EXT TRED2,IMTQL2
"
"
"
"                       --- ABSTRACT ---
"
"               THE SUBROUTINE EIGRS DETERMINES THE EIGENVALUES AND EIGEN-
"       VECTORS OF A REAL SYMMETRIC MATRIX.  IT FIRST CALLS SUBROUTINE
"       TRED2 WHICH TRIDIAGONIZES THE MATRIX AND THEN THE SUBROUTINE
"       IMTQL2 WHICH USES THE QL ALGORITHM WITH IMPLICIT ORIGIN SHIFTS
"       AT EACH ITERATION.  THE APAL PROGRAM IS BASED ON THE FORTRAN
"       PROGRAM FOUND IN THE "EISPACK GUIDE," 2ND ED., B.T. SMITH, ET.
"       AL., SPRINGER-VERLAG (1976).  THAT PROGRAM IN TURN IS BASED ON
"       AN ALGOL PROCEDURE DISCUSSED BY MARTIN AND WILKINSON, NUM. MATH.,
"       12, 377 (1968).
"
"
"
"                       --- STATISTICS ---
"
"       LANGUAGE:               AP-120B ASSEMBLER.
"       EQUIPMENT:              AP-120B WITH BOTH MEMORIES.
"       SIZE:                   6 + TRED2(300) + IMTQL2(250) = 556
"       FORTRAN CALL:           CALL EIGRS (NM,N,Z,E,D)
"       AUTHOR:                 WARREN H. INSKEEP
"       DATE:                   DEC 1978
"
"
"
"
"                       --- PARAMETERS ---
"
                        NM      $EQU    0
                        N       $EQU    1
                        Z       $EQU    2
"
                        E       $EQU    3
                        D       $EQU    4
"
"                       NOTE: THE DIMENSION OF ARRAY  Z  IS  NM*N.
"                             THE DIMENSION OF ARRAY  E  IS  N.
"                             THE DIMENSION OF ARRAY  D  IS  N.
"
"               UPON COMPLETION OF THE ROUTINE, Z LOCATES THE EIGENVECTORS,
"               AND D LOCATES THE EIGENVALUES.
"
"
"                       --- SCRATCH ---
"
"       DPX:    DPA + (-4 TO +3)  (FOR STANDARD MEMORY)
"               DPA + (-4 TO +3), DPA(=8) + (-4 TO +3),
"               DPA(=0) + (-4,-2,0,1,2,3)  (FOR FAST MEMORY)
"       DPY:    DPA + (-4 TO +3)  (FOR STANDARD MEMORY)
"               DPA + (-4 TO +3), DPA(=0) + (-4,-3,0 TO +3)
"                     (FOR FAST MEMORY)
"       S-PAD:  ALL
"
"
"               FOR ERROR CONDITIONS, FORTRAN CODES AND OTHER DETAILS,
"       PLEASE CHECK WITH ROUTINES TRED2 AND IMTQL2
"
"
"                       --- THROUGHPUT ---
"
"               THROUGHPUT IS SLIGHTLY INCREASED BY TAKING NM AS
"       AN ODD NUMBER.  THE EFFECT IS MUCH MORE DRAMATIC FOR IMTQL2
"       THAN FOR TRED2.
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
      EIGRS:    JSR TRED2
                INC Z
                INC E
                INC D
                JSR IMTQL2
                NOP
                RETURN
                $END
"****** TRED2 = TRIDIAGONALIZE SYMMETRIC MATRIX /FAST/ = REL 1.2, JUN 80 ****
"                       FOR FAST MEMORY
                        $TITLE TRED2
        $RADIX 8
                        $ENTRY TRED2,5
                        $EXT DIV,SQRT,INDEX,UDOTPR
"
"                       --- ABSTRACT ---
"
"            THE SUBROUTINE TRED2 REDUCES A REAL SYMMETRIC MATRIX TO A
"       SYMMETRIC TRIDIAGONAL MATRIX BY ORTHOGONAL SIMILARITY TRANS-
"       FORMATIONS (HOUSEHOLDER TRANSFORMATIONS).  THE TRANSFORMATIONS
"       ARE ACCUMULATED IN ORDER TO EVENTUALLY OBTAIN EIGENVECTORS AT
"       A LATER STAGE OF THE OVERALL EIGENVALUE/EIGENVECTOR CALCULATION.
"       THE PROGRAM IS BASED ON A FORTRAN ROUTINE FROM THE "EISPACK GUIDE"
"       (2ND EDITION) BY B.T. SMITH, ET. AL., SPRINGER-VERLAG (1976).  THE
"       FORTRAN PROGRAM IN TURN IS BASED ON THE ALGOL PROCEDURE OF MARTIN,
"       REINSCH, AND WILKINSON, NUM. MATH. 11, 181-195 (1968).
"
"         A SLIGHTLY MODIFIED VERSION OF THE FORTRAN PROGRAM IS INCLUDED
"       BELOW (MODIFIED SUCH THAT THE INPUT MATRIX IS ALWAYS DESTROYED--
"       IT CAN BE SAVED IN THE HOST).
"
"
"                       --- STATISTICS ---
"
"       LANGUAGE:               AP-120B ASSEMBLER.
"       EQUIPMENT:              AP-120B WITH FAST MEMORY.
"       SIZE:                   259 + DIV(28) + SQRT(28) + INDEX(15) +
"                               UDOTPR(31) = 361 LOCATIONS
"       FORTRAN CALL:           CALL TRED2 (NM,N,Z,E,D)
"
"    --- HISTORY ---
"ORIGINAL:  JAN 79  W.H. INSKEEP AND C. HSIUNG
" REVISED:  SEP 79  C. HSIUNG      FIXED PROBLEM WHERE 1.0 WAS NOT FETCHED
" REV 1.1:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 1.2:  JUN 80  H. SEDINGER    1.0 STORED IN DPY(ONE) AFTER DPA IS SET
"                                  DPA RESTORED AT EXIT
"
"
"                       --- PARAMETERS ---
"
"               NM      $EQU    0       "ROW DIMENSION OF MATRIX
"               N       $EQU    1       "ORDER OF MATRIX
"               Z       $EQU    2       "BASE ADDRESS OF MATRIX
"               E       $EQU    3       "BASE ADDRESS OF CODIAGONAL
                                        "ELEMENTS
"               D       $EQU    4       "BASE ADDRESS OF DIAGONAL
                                        "ELEMENTS
"
"                       NOTE: THE DIMENSION OF ARRAY  Z  IS  NM*N.
"                             THE DIMENSION OF ARRAY  E  IS  N.
"                             THE DIMENSION OF ARRAY  D  IS  N.
"
"
"                       --- SCRATCH ---
"
"       DPX:    DPA(=0) + (-4,-2,0,1,2,3)
"               DPA(=8) + (-4 TO 3)
"       DPY:    DPA(=0) + (-4,-3,0,1,2,3)
"       S-PAD:  ALL.
"
"
"
"                       --- ERROR CONDITIONS ---
"
"                               NONE.
"
"
"                       --- THROUGHPUT ---
"
"               THROUGHPUT IS SLIGHTLY INCREASED BY TAKING NM AS
"               AN ODD NUMBER.  THE EFFECT IS MUCH MORE DRAMATIC
"               IN THE ROUTINE IMTQL2 (IN THE SAME DIRCECTION).
"
"
"------------------------------------------------------------------------------
"-------------------------------------------------------------------------------
"
"                       * * *  TRED2 IN FORTRAN:  * * *
"
"
"             SUBROUTINE TRED2 (NM,N,D,E,Z)
"             REAL  D(N), E(N), Z(NM,N)
"             INTEGER I,J,K,L,N,II,NM,JP1
"             REAL F,G,H,HH,SCALE
"       C
"             IF (N .EQ. 1) GOTO 320
"       C
"       C /*   FOR I=N STEP -1 UNTIL 2 DO ...  */
"       C
"             DO 300      II=2,N
"                  I = N + 2 - II
"                  L = I - 1
"                  H = 0.0
"                  SCALE = 0.0
"                  IF (L .LT. 2) GOTO 130
"       C
"       C          ------------------
"       C          /*  SCALE ROW.  */
"       C          ------------------
"       C
"                  DO 120      K=1,L
"         120           SCALE = SCALE + ABS (Z(I,K))
"       C
"                  IF (SCALE .NE. 0.0) GOTO 140
"         130      E(I) = Z(I,L)
"                  GOTO 290
"       C
"         140      DO 150      K=1,L
"                       Z(I,K) = Z(I,K) / SCALE
"         150           H = H + Z(I,K) * Z(I,K)
"       C
"                  F = Z(I,L)
"                  G = -SIGN (SQRT (H), F)
"                  E(I) =  SCALE * G
"                  H = H - F * G
"                  Z(I,L) = F - G
"                  F = 0.0
"       C
"                  DO 240      J=1,L
"                       Z(J,I) = Z(I,J) / H
"                       G = 0.0
"       C
"       C               --------------------------
"       C               /* FORM ELEMENT OF A*U  */
"       C               --------------------------
"                       DO 180      K=1,J
"         180                G = G + Z(J,K) * Z(I,K)
"       C
"                       JP1 = J + 1
"                       IF (L .LT. JP1) GOTO 220
"       C
"                       DO 200      K=JP1,L
"         200                G = G + Z(K,J) * Z(I,K)
"       C
"       C               --------------------------
"       C               /*  FORM ELEMENT OF P.  */
"       C               --------------------------
"       C
"         220           E(J) = G / H
"                       F = F + E(J) * Z(I,J)
"         240           CONTINUE
"       C
"                  HH = F / (H + H)
"       C
"       C          ------------------------
"       C          /*  FORM REDUCED A.  */
"       C          ------------------------
"       C
"                  DO 260      J=1,L
"                        F = Z(I,J)
"                        G = E(J) - HH * F
"                        E(J) = G
"       C
"                        DO 260      K=1,J
"         260                  Z(J,K) = Z(J,K) - F*E(K) - G*Z(I,K)
"       C
"         290      D(I) = H
"       C
"         300      CONTINUE
"       C
"         320 D(1) = 0.0
"              E(1) = 0.0
"       C
"       C  ------------------------------------------------
"       C  /*  ACCUMULATION OF TRANSFORMATION MATRICES.  */
"       C  ------------------------------------------------
"       C
"             DO 500      I=1,N
"                  IM1 = I - 1
"                  IF (D(I) .EQ. 0.0) GOTO 380
"       C
"                  DO 360      J=1,IM1
"                       G = 0.0
"       C
"                       DO 340      K=1,IM1
"         340                G = G + Z(I,K) * Z(K,J)
"       C
"                       DO 360      K=1,IM1
"         360                Z(K,J) = Z(K,J) - G*Z(K,I)
"       C
"         380      D(I) = Z(I,I)
"                  Z(I,I) = 1.0
"                  IF (IM1 .LT. 1) GOTO 500
"       C
"                  DO 400      J=1,IM1
"                       Z(I,J) = 0.0
"         400           Z(J,I) = 0.0
"       C
"         500 CONTINUE
"       C
"             RETURN
"             END
"
"
"
"-------------------------------------------------------------------------------
"-------------------------------------------------------------------------------
"
"
"
"                       PARAMETERS:
                        NM      $EQU    0
                        N       $EQU    1
                        Z       $EQU    2
                        E       $EQU    3
                        D       $EQU    4
"
"                       POINTERS:
                        EPT     $EQU    5
                        DPT     $EQU    6
                        ZPT     $EQU    7
                        ZPT2    $EQU    10
"
"                       COUNTERS:
                        I       $EQU    11
                        J       $EQU    12
                        K       $EQU    13
                        L       $EQU    14
"
"                       SCRATCH S-PADS:
                        S1      $EQU    15
                        S2      $EQU    16
                        S3      $EQU    17
                        S4      $EQU    3
                        S5      $EQU    5
                        S6      $EQU    6
"
"
"                       DPX NAMES:
                        H       $EQU    2
                        SCALE   $EQU    -3
                        F       $EQU    3
                        RH      $EQU    -2
"
"                       DPY NAMES:
                        G       $EQU    3
                        HH      $EQU    2
                        ONE     $EQU    -4
"
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
TRED2:  DEC# N
        LDTMA; DB=!ONE;                 "FETCH 1.
           DEC Z;
           BNE .+2                      "IS MATRIX OF ORDER 1?
        JMP L320
        MOV N,I
           DEC D;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        RDPA; LDSPNL S3                  "SAVE DPA
        LDDPA; DB=0.;
           DEC E
        DPY(ONE)<TM                                    "SAVE 1.
        MOV S3,S3; DPX(-4)<SPFN         "STORE ORIGINAL DPA
"
"
"               ---------------------------------------
"               /*  ELIMINATE ELEMENTS TO LEFT OF    */
"               /*  SUBDIAGONAL OF ROW I.  WHENCE:   */
"               /*  FOR I = N STEP -1 UNTIL 2 DO.... */
"               ---------------------------------------
"
        L300:   MOV I,L; DPX(H)<ZERO                    "H=0.0
                DEC L;                                  "L=I-1
                   DPX(SCALE)<ZERO                      "SCALE=0.0
                LDSPI S1; DB=3.
                SUB# I,S1                               "IF(L.LT.2)GOTO 130
                BGT L130; MOV I,ZPT
"
"               ------------------
"               /*  SCALE ROW.  */
"               ------------------
"
                ADD Z,ZPT; SETMA                        "FETCH Z(I,1)
                MOV L,K
                NOP
                FABS MD                                 "ABS(Z(I,1))
"
                L120:   ADD NM,ZPT; SETMA;              "FETCH Z(I,K)
                           FADD                         "...
                        NOP;                            "...
                           FADD DPX(SCALE),FA           "FA+ABS(Z)
                        NOP;                            "...
                           FADD; DEC K                  "K=K-1
                        FABS MD;                        "ABS(Z(I,K))
                           DPX(SCALE)<FA;               "SCALE=FA
                           BGT L120                     "IF(K.GT.0)GOTO L120
"
                BFNE L140; DPX(0)<DPX(SCALE)            "IF(SCALE.NE.0)GOTO L140
        L130:   MOV I,S1
                MOV L,S2
"
                JSR INDEX
"
                ADD Z,S3; SETMA                         "FETCH Z(I,L)
                NOP
                NOP
                ADD# I,E; SETMA; MI<MD                  "E(I)=Z(I,L)
                JMP L290                                "GOTO 290
"
         L140:  DPY(0)<DPY(ONE);                              "GET 1./SCALE
"
                JSR DIV
"
                MOV I,ZPT
                ADD Z,ZPT; SETMA
                MOV L,K
                NOP
                FMUL DPX(0),MD
                FMUL; FADD ZERO,ZERO
                FMUL; FADD
"
                L150:   ADD NM,ZPT; SETMA;                      "FETCH Z(I,K+1)
                           DPY(0)<FM                            "...
                        NOP;                                    "...
                           FMUL FM,DPY(0)                       "Z(I,K)**2
                        NOP;                                    "...
                           FMUL; SUB# NM,ZPT; SETMA; MI<DPY(0)  "STORE Z(I,K)
                        FMUL DPX(0),MD;                         "Z(I,K+1)/SCALE
                           NOP
                        FMUL;
                           FADD FM,FA; DEC K                    "FA+Z(I,K)**2
                        FMUL;                                   "...
                           FADD; BNE L150                       "IF(K.NE.0)GOTO
"
                DPX(H)<FA; SUB NM,ZPT; SETMA
                DPX(0)<DPX(H);
"
                JSR SQRT
"
                DPX(F)<MD; FADD ZERO,MD                 "F=Z(I,L)
                FSUB ZERO,DPX(0); MOV I,L
                DEC L; FADD
                BFLT .+2; DPY(G)<DPX(0)
                DPY(G)<FA                               "G=-SIGN(SQRT...ETC.
                FMUL DPX(SCALE),DPY(G)
                FMUL DPY(G),DPX(F)
                FMUL; MOV E,EPT
                ADD  I,EPT; SETMA; MI<FM; FMUL          "E(I)=SCALE*G
                FSUBR FM,DPX(H); DPY(0)<DPY(ONE)
                FSUB DPX(F),DPY(G); DPX(F)<ZERO
                DPX(H)<FA; FADD                         "H=H-F*G
                MOV ZPT,ZPT; SETMA; MI<FA
                DPX(0)<DPX(H);
"
                JSR DIV
"
                DPX(RH)<DPX(0)                         "RH = 1./H
"
"
"               ----------------------------------------------------------------
"               *  *  *  *                FORTRAN:                   *  *  *  *
"
"                       DO 240      J=1,L
"                               Z(J,I) = Z(I,J) / H
"                               G = 0.0
"                               /*  FORM ELEMENT OF A*U.  */
"                               DO 180     K=1,J
"               180                     G = G + Z(J,K) * Z(I,K)
"                               JP1= J + 1
"                               IF (L .LT. JP1) GOTO 220
"                               DO 200     K=JP1,L
"               200                     G = G + Z(K,J) * Z(I,K)
"                               /*  FORM ELEMENT OF P.  */
"               220             E(J) = G / H
"                               F = F + E(J) * Z(I,J)
"               240     CONTINUE
"
"               *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
"
                MOV I,S2
                LDSPI J; DB=1.
                CLR S1
"
                JSR INDEX
"
                ADD Z,S3                                "Z(0,I) POINTER
                MOV I,S2
                ADD Z,S2; SETMA                         "FETCH Z(I,1)
                MOV S3,ZPT2
                MOV Z,S3
                FMUL DPX(RH),MD;                        "FORM Z(I,1)/H
                 MOV J,S1; DPY(1)<MD                    "KEEP Z(I,1)
                FMUL; INC S3
                FMUL; INC S1
                DPX(0)<FM
                LDDPA; DB=8.
        "
        "       TO FREE SOME S-PADS
        "
                MOV 0,0; DPX(-4)<SPFN
                MOV 1,1; DPX(-3)<SPFN
                MOV 2,2; DPX(-2)<SPFN
                MOV 3,3; DPX(-1)<SPFN
                MOV 4,4; DPX(0)<SPFN
                MOV 5,5; DPX(1)<SPFN
                MOV 6,6; DPX(2)<SPFN
                MOV 7,7; DPX(3)<SPFN
                MOV Z,6
                MOV E,7
                MOV NM,3
                LDDPA; DB=0.
                INC S3
                MOV 3,1
                MOV I,0
"
"
                L240:   INC ZPT2; SETMA; MI<DPX(0)      "Z(J,I)=Z(I,J)/H
"
"                       ----------------------------
"                       /*  FORM ELEMENT OF A*U.  */
"                       ----------------------------
"
                        MOV J,4
                        ADD 6,0                         "Z(I,K) BASE
                        MOV J,2
                        ADD 6,2                         "Z(J,K) BASE
"
                        JSR UDOTPR      "SUM Z(J,K)*Z(I,K), K=1,J
"
                        SUB# S1,L; DPY(-1)<FA            "NOTE: S1=J+1
                        BGE .+2; MOV I,4                "IF(L.LT.JP1)GOTO 220
                        JMP L220
                        SUB S1,4                        "K=L-J
                        MOV S3,0                        "Z(J+1,J) POINTER
                        MOV S2,2
                        ADD 3,2                         "Z(I,J+1) POINTER
                        LDSPI 1; DB=1.                  "Z(J+1,J) INCREMENT
"
                        JSR UDOTPR      "SUM Z(K,J)*Z(I,K), K=J+1,L
"
                        FADD DPY(-1),FA
                        FADD
"
"
"                       -------------------------
"                       /*  FORM ELEMENT OF P. */
"                       -------------------------
"
                L220:   FMUL DPX(RH),FA; DPY(G)<FA;
                           ADD  3,S2; SETMA             "  FETCH Z(I,J+1)
                        FMUL; INC S3
                        FMUL; ADD  3,S3
                        ADD# 7,J; SETMA; MI<FM;         "E(J)=G/H
                         FMUL FM,DPY(1)
                        FMUL DPX(RH),MD;                "  FORM Z(I,J+1)/H
                        INC S1; DPY(1)<MD                "  KEEP Z(I,J+1)
                        FMUL; MOV 3,1
                        FMUL; FADD FM,DPX(F); MOV I,0
                        FADD; DPX(0)<FM
                        SUB# L,J  ; DPX(F)<FA           "F=F+E(J)*Z(I,J)
                        BEQ .+2; INC J
                        JMP L240
"
"               *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
"
"
                LDTMA; DB=!HALF
                LDDPA; DB=8.
        "
        "       TO RESTORE S-PADS
        "
                LDSPI 0; DB=DPX(-4)
                LDSPI 1; DB=DPX(-3)
                LDSPI 2; DB=DPX(-2)
                LDSPI 3; DB=DPX(-1)
                LDSPI 4; DB=DPX(0)
                LDSPI 5; DB=DPX(1)
                LDSPI 6; DB=DPX(2)
                LDSPI 7; DB=DPX(3)
                LDDPA; DB=0.
"
                FMUL TM,DPX(F)
                FMUL; MOV I,S3
                FMUL; SUB NM,S3
                FMUL FM,DPX(RH)
                FMUL; ADD Z,S3; DPX(1)<ZERO
                FMUL; CLR J
                DPY(HH)<FM                      "HH=F/(H+H)
"
"
"               ----------------------------------------------------------------
"               *  *  *  *  *       FORTRAN FOR THIS SECTION:      *  *  *  *  *
"
"                               DO 260     J=1,L
"                                       F = Z(I,J)
"                                       G = E(J) - HH * F
"                                       E(J) = G
"                                       DO 260     K =1,J
"                                           Z(J,K) = Z(J,K) - F*E(K) - G*Z(I,K)
"                         260   CONTINUE
"
"               *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
"
"               -----------------------
"               /*  FORM REDUCED A.  */
"               -----------------------
"
                LDTMA; DB=!ONE
"
                L260:   ADD NM,S3; SETMA; FADD DPX(1),DPY(ONE)
                        INC J;  FADD
                        ADD# J,E; SETMA;  DPX(1)<FA             "DPX(1)=FLOAT(J)
                        DPX(F)<MD; FMUL DPY(HH),MD;             "F=Z(I,J)
                         MOV I,ZPT2
                        FMUL; MOV E,EPT
                        FMUL; MOV J,S1
                        FSUBR FM,MD; ADD Z,S1
                        FADD; MOV J,ZPT
                        ADD# J,E; SETMA; MI<FA;                 "G=E(J)-H*F
                         DPY(G)<FA                              "E(J)=G
                        ADD Z,ZPT2; SETMA                       "FETCH Z(I,1)
                        INC EPT; SETMA                          "FETCH E(1)
                        ADD Z,ZPT; SETMA                        "FETCH Z(J,1)
                        FMUL DPY(G),MD; SUB NM,S1               "G*Z(I,1)
                        ADD NM,ZPT2; SETMA;                     "FETCH Z(I,2)
                            FMUL DPX(F),MD                      "F*E(1)
                        INC EPT; SETMA                          "FETCH E(2)
                        ADD NM,ZPT; SETMA;                      "FETCH Z(J,2)
                            DPY<MD
                        FMUL DPY(G),MD                          "G*Z(I,2)
                        ADD NM,ZPT2; SETMA;                     "FETCH Z(I,3)
                            FMUL DPX(F),MD;                     "F*E(2)
                                DPX<FM
                        INC EPT; SETMA;                         "FETCH E(3)
                                FSUBR DPX,DPY
                        ADD NM,ZPT; SETMA;                      "FETCH Z(J,3)
                            DPY<MD;
                                FADD DPX(1),ZERO                "SET COUNTER
                        FMUL DPY(G),MD;                         "G*Z(I,3)
                                FSUBR FM,FA
"
                        L262:   ADD NM,ZPT2; SETMA;             "FETCH Z(I,K+3)
                                    FMUL DPX(F),MD;             "F*E(K+2)
                                        DPX<FM;
                                            FSUBR TM,FA
                                INC EPT; SETMA;                 "FETCH E(K+3)
                                    NOP;
                                        FSUBR DPX,DPY;
                                            DPX<FA
                                ADD NM,ZPT; SETMA;              "FETCH Z(J,K+3)
                                    DPY<MD;
                                        FADD ZERO,FA;           "STORE COUNTER
                                            NOP
                                FMUL DPY(G),MD;                 "G*Z(I,K+3)
                                    NOP;
                                        FSUBR FM,FA;
                                            ADD NM,S1; SETMA;
                                            MI<DPX; BFGT L262   "STORE Z(J,K)
"
                        SUB# J,L
                        BEQ .+2
                        JMP L260
"
"               *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
"
        L290:   ADD# I,D; SETMA; MI<DPX(H)              "D(I)=H
                DEC I
                DEC# I
                BEQ .+2
                JMP L300
"
"       S6,S1 POINT TO Z(1,I)
"       S2 POINTS TO Z(1,J)
"       S3 POINTS TO Z(K,J)
"       S4 POINTS TO Z(I,I)
"       S5 POINTS TO Z(0,I)
"       ZPT POINTS TO Z(K,I)
"       ZPT2 POINTS TO Z(K,J)
"
"
L320:   INC# D; SETMA; MI<ZERO                  "D(1)=0.0
        LDTMA; DB=!ONE
        INC# E; SETMA; MI<ZERO                  "E(1)=0.0
"
"                  ----------------------------------------------------
"                  /***  ACCUMULATION OF TRANSFORMATION MATRICES.  ***/
"                  ----------------------------------------------------
"
        MOV E,E; DPY(-3)<SPFN
        LDSPI I; DB=1.
        LDSPI L; DB=-1.
        LDSPI S6; DB=1.
        ADD Z,S6; FSUBR TM,ZERO
        SUB NM,S6; FADD
        MOV Z,S4; DPY(1)<FA
        SUB NM,S4
        MOV S4,S5
"
        L500:   ADD# I,D; SETMA; FADD TM,DPY(1)                  "FETCH D(I)
                FADD
                LDSPI S2; DB=1.
                FADD ZERO,MD; ADD NM,S5; DPY(1)<FA              "DPY(1)=FLOAT(L)
                FADD; ADD NM,S6
                INC L
                BFNE .+2; ADD Z,S2                       "IF(D(I).EQ.0)GOTO 380
                JMP L380
"
                MOV L,J
                LDDPA; DB=8.
        "
        "       TO FREE SOME S-PADS
        "
                MOV 0,0; DPX(-4)<SPFN
                MOV 1,1; DPX(-3)<SPFN
                MOV 2,2; DPX(-2)<SPFN
                MOV 3,3; DPX(-1)<SPFN
                MOV 4,4; DPX(0)<SPFN
                MOV 5,5; DPX(1)<SPFN
                MOV 6,6; DPX(2)<SPFN
                LDDPA; DB=0.
                MOV S6,S1
                MOV Z,6
                MOV NM,3
                MOV L,4
                LDSPI 1; DB=1.
"
"
"               ----------------------------------------------------------------
"
                L361:   MOV S2,0
                        MOV I,2
                        ADD 6,2                                 "Z(I,K) POINTER
"
                        JSR UDOTPR      "SUM Z(I,K)*Z(K,J), K=1,L
"
                        MOV S1,ZPT; SETMA; DPY(G)<FA            "FETCH Z(1,I)
                        DPY(0)<DPY(1); MOV S2,S3
                        MOV S2,ZPT2; SETMA                      "FETCH Z(1,J)
                        INC ZPT; SETMA;                         "FETCH Z(2,I)
                            FMUL DPY(G),MD                      "G*Z(1,I)
                            FMUL
                        INC ZPT2; SETMA;                        "FETCH Z(2,J)
                            FMUL; DPX<MD
                        INC ZPT; SETMA;                         "FETCH Z(3,I)
                            FMUL DPY(G),MD;                     "G*Z(2,I)
                                FSUBR FM,DPX                    "Z-G*Z
                            FMUL;
                                FSUBR TM,DPY; DEC S3
"
                        L360:   NOP;
                                    INC ZPT2; SETMA;            "FETCH Z(K+2,J)
                                        FMUL; DPX<MD;           "SAVE Z(K+1,J)
                                            FADD ZERO,FA
                                INC ZPT; SETMA;                 "FETCH Z(K+3,I)
                                    FMUL DPY(G),MD;             "G*Z(K+2,I)
                                        FSUBR FM,DPX;           "Z(K+1,J)-G*Z
                                            DPY<FA
                                NOP;
                                    FMUL;
                                        FSUBR TM,DPY;
                        " NOW STORE Z(K,J)
                                            INC S3; SETMA; MI<FA;
                                            BFGT L360
"
                        DEC J
                        BEQ .+2; ADD 3,S2
                        JMP L361
"
"               ----------------------------------------------------------------
"
                LDDPA; DB=8.
        "
        "       TO RESTORE S-PADS
        "
                LDSPI 0; DB=DPX(-4)
                LDSPI 1; DB=DPX(-3)
                LDSPI 2; DB=DPX(-2)
                LDSPI 3; DB=DPX(-1)
                LDSPI 4; DB=DPX(0)
                LDSPI 5; DB=DPX(1)
                LDSPI 6; DB=DPX(2)
                LDDPA; DB=0.
"
"
"       ZPT2 POINTS TO Z(J,I)
"       ZPT POINTS TO Z(I,J)
"
"
        L380:   ADD NM,S4
                INC S4; SETMA                                   "FETCH Z(I,I)
                MOV I,ZPT
                MOV S4,S4; SETMA; MI<DPY(ONE)                   "Z(I,I)=1.
                SUB NM,ZPT
                ADD# I,D; SETMA; MI<MD                          "D(I)=FORMER Z(I
                MOV L,L
                BEQ L499; ADD Z,ZPT                        "IF(L.EQ.0)GOTO 500
"
                MOV L,J
"
                MOV S5,ZPT2; SETMA
                DEC J
                L400:   INCMA; MI<ZERO; DEC J; BNE L400         "Z(J,I)=0.0
"
                MOV L,J
                L401:   DEC J
                        ADD NM,ZPT; SETMA; MI<ZERO;BGT L401     "Z(I,J)=0.0
"
        L499:   SUB# N,I
                BEQ .+2; INC I
                JMP L500
        LDSPI E; DB=DPY(-3)
        LDDPA; DB=DPX(-4); RETURN
        $END
"
"
"
"****** IMTQL2 = EIGENVALUES AND VECTOR, SYMMETIC /FAST/ = REL 1.2, JUN 80 ***
"                    FOR FAST MEMORY
                     $TITLE IMTQL2
        $RADIX 8
                     $ENTRY IMTQL2,5
                     $EXT DIV,SQRT,INDEX
"
"
"
"                       --- ABSTRACT ---
"
"               THE SUBROUTINE IMTQL2 DETERMINES THE EIGENVALUES AND EIGEN-
"       VECTORS OF A SYMMETRIC TRIDIAGONAL MATRIX USING THE QL ALGORITM
"       WITH IMPLICIT ORIGIN SHIFTS AT EACH ITERATION.  THE SIMILARITY
"       TRANSFORMATIONS ARE ACCUMULATED, PRODUCING EIGENVECTORS OF THE
"       ORIGINAL FULL MATRIX.  THE APAL PROGRAM IS BASED ON THE FORTRAN
"       PROGRAM FOUND IN THE "EISPACK GUIDE," 2ND ED., B.T. SMITH, ET.
"       AL., SPRINGER-VERLAG (1976).  THAT PROGRAM IN TURN IS BASED ON
"       AN ALGOL PROCEDURE DISCUSSED BY MARTIN AND WILKINSON, NUM. MATH.,
"       12, 377 (1968).
"
"               THE FORTRAN PROGRAM IS GIVEN BELOW.  COMMENTS IN THE APAL
"       ROUTINE ARE KEYED TO THE FORTRAN.
"
"
"
"                       --- STATISTICS ---
"
"               LANGUAGE:       AP-120B ASSEMBLER.
"               EQUIPMENT:      AP-120B, FAST MEMORY
"               SIZE:           APPX 200 LOCATIONS PLUS DIV, SQRT, INDEX.
"               FORTRAN CALL:   CALL IMTQL2 (NM,N,Z,E,D)
"
"    --- HISTORY ---
"ORIGINAL:  DEC 78  W.H. INSKEEP
" REV 1.1:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 1.2:  JUN 80  H. SEDINGER    1.0 RESTORED TO TM AT L160
"                                  1.0 RESTORED TO DPY(-1) AFTER L182
"
"
"
"                       --- PARAMETERS ---
"
"               NM      $EQU    0       "ROW DIMENSION OF MATRIX.
"               N       $EQU    1       "ORDER OF MATRIX.
"               Z       $EQU    2       "BASE ADDRESS OF VECTORS
"               E       $EQU    3       "BASE ADDRESS OF CODIAGONAL.
"               D       $EQU    4       "BASE ADDRESS OF DIAGONAL.
"
"                       NOTE: THE DIMENSION OF ARRAY  Z  IS  NM*N.
"                             THE DIMENSION OF ARRAY  E  IS  N.
"                             THE DIMENSION OF ARRAY  D  IS  N.
"
"               UPON COMPLETION OF THE ROUTINE, Z LOCATES THE EIGENVECTORS,
"               AND D LOCATES THE EIGENVALUES.
"
"
"                       --- SCRATCH ---
"
"       DPX:    DPA + (-4 TO +3)
"       DPY:    DPZ + (-4 TO +3)
"       S-PAD:  ALL.
"
"
"                       --- ERROR CONDITIONS ---
"
"               IF MORE THAN 30 ITERATIONS ARE REQUIRED TO DETERMINE AN
"       EIGENVALUE, THE PROGRAM TERMINATES, AND S-PAD 15. IS SET TO THE
"       INDEX OF THE EIGENVALUE FOR WHICH FAILURE OCCURS.  PREVIOUSLY
"       CALCULATED RESULTS ARE VALID.  IF THE CALCULATION IS COMPLETELY
"       SUCCESSFUL, S-PAD 15. IS SET TO ZERO.
"
"
"                       --- THROUGHPUT ---
"
"               THERE IS ONLY ONE RATE DETERMINING LOOP IN IMTQL2, L180
"       (FORMS VECTOR).  IT IS CODED WITH 8 APAL INSTRUCTIONS.  HOWEVER,
"       IF NM (THE MATRIX ROW DIMENSION) IS EVEN, THIS LOOP TAKES 14
"       CLOCK CYCLES PER ITERATION.  IF NM IS ODD, IT TAKES 8 CYCLES.
"       THE DIFFERENCE IS DUE TO MEMORY INTERLEAVE CHARACTERISTICS.  THE
"       ROUTINE HAS BEEN CODED SUCH THAT NM MAY TAKE AN ODD VALUE IN THE
"       CASE N (THE ORDER OF THE MATRIX) IS EVEN OR ODD.
"
"
"
"
"-------------------------------------------------------------------------------
"-------------------------------------------------------------------------------
"
"                    * * * *  IMTQL2 IN FORTRAN  * * * *
"
"
"                SUBROUTINE IMTQL2 (NM,N,D,E,Z,IERR)
"          C
"                INTEGER I,J,K,L,M,N,II,NM,MML,IERR
"                REAL D(N), E(N), Z(NM,N)
"                REAL B,C,F,G,P,R,S,MACHEP
"                REAL SQRT,ABS,SIGN
"          C
"          C  /*  MACHEP IS A MACHINE DEPENDENT PARAMETER SPECIFYING  */
"          C  /*  THE RELATIVE PRECISION OF FLOATING POINT ARITHMETIC */
"          C
"                 MACHEP =.0001
"          C
"                IERR = 0
"                IF (N .EQ. 1) GOTO 1001
"          C
"                DO 100      I=2,N
"            100 E(I-1) = E(I)
"          C
"                E(N) = 0.0
"          C
"          C
"          C
"          C
"                DO 240      L=1,N
"                      J = 0
"          C           -------------------------------------------
"          C           /*  LOOK FOR SMALL SUB-DIAGONAL ELEMENT  */
"          C           -------------------------------------------
"          C
"            105       DO 110      M=L,N
"                            IF (M .EQ. N) GOTO 120
"                            IF (ABS(E(M)) .LE. MACHEP*(ABS(D(M))+ABS(D(M+1))))
"               X               GOTO 120
"            110       CONTINUE
"          C
"            120       P = D(L)
"                      IF (M .EQ. L) GOTO 240
"                      IF (J .EQ. 30) GOTO 1000
"                      J = J + 1
"          C
"          C           -----------------------
"          C           /***  FORM SHIFT.  ***/
"          C           -----------------------
"          C
"                      G = (D(L+1) - P) / (2.0 * E(L))
"                      R = SQRT (G*G + 1.0)
"                      G = D(M) - P + E(L)/(G + SIGN(R,G))
"                      S = 1.0
"                      C = 1.0
"                      P = 0.0
"                      MML = M - L
"          C
"          C    ----------------------------------
"          C    /* FORM NEW TRIDIAGONAL MATRIX. */
"          C    ----------------------------------
"                      DO 200      II = 1,MML
"                            I = M - II
"                            F = S * E(I)
"                            B = C * E(I)
"                            IF (ABS(F) .LT. ABS(G)) GOTO 150
"          C
"                            C = G / F
"                            R = SQRT (C*C + 1.0)
"                            E(I+1) = F*R
"                            S = 1.0 / R
"                            C = C * S
"                            GOTO 160
"          C
"            150             S = F / G
"                            R = SQRT (S*S + 1.0)
"                            E(I+1) = G * R
"                            C = 1.0 / R
"                            S = S * C
"          C
"            160             G = D(I+1) - P
"                            R = (D(I) - G) * S + 2.0*C*B
"                            P = S * R
"                            D(I+1) = G + P
"                            G = C*R - B
"          C
"          C                 -------------------
"          C                 /** FORM VECTOR **/
"          C                 -------------------
"          C
"                            DO 180      K=1,N
"                                 F = Z(K,I+1)
"                                 Z(K,I+1) = S * Z(K,I)  +  C * F
"                                 Z(K,I)   = C * Z(K,I)  -  S * F
"            180             CONTINUE
"          C
"            200        CONTINUE
"          C
"          C
"                       D(L) = D(L) - P
"                       E(L) = G
"                       E(M) = 0.0
"                       GOTO 105
"            240 CONTINUE
"          C
"          C
"          C
"          C     ----------------------------------------------
"          C     /*** ORDER EIGENVALUES AND EIGENVECTORS.  ***/
"          C     ----------------------------------------------
"          C
"                DO 300      II=2,N
"                     I = II - 1
"                     K = I
"                     P = D(I)
"          C
"                     DO 260      J=II,N
"                          IF (D(J) .GE. P) GOTO 260
"                            K = J
"                            P = D(J)
"            260      CONTINUE
"          C
"                     IF (K .EQ. I) GOTO 300
"                       D(K) = D(I)
"                       D(I) = P
"          C
"                       DO 280      J=1,N
"                            P = Z(J,I)
"                            Z(J,I) = Z(J,K)
"                            Z(J,K) = P
"            280        CONTINUE
"          C
"            300  CONTINUE
"          C
"          C
"                GOTO 1001
"          C
"          C      /***  SET ERROR -- NO CONVERGENCE TO AN EIGENVALUE  ***/
"          C      /***  AFTER 30 ITERATIONS.                          ***/
"           1000 IERR = L
"           1001 RETURN
"                END
"
"
"-------------------------------------------------------------------------------
"-------------------------------------------------------------------------------
"
"
"
"
"                       /* S-PAD NAMES:  */
                        NM      $EQU    0
                        N       $EQU    1
                        Z       $EQU    2
                        E       $EQU    3
                        D       $EQU    4
"
                        DPT     $EQU    5
                        EPT     $EQU    6
                        ZPT1    $EQU    7
                        ZPT2    $EQU    10
"
                        I       $EQU    11
                        J       $EQU    12
                        K       $EQU    13
                        L       $EQU    2
                        II      $EQU    2
                        M       $EQU    3
"
                        SP13    $EQU    14
                        S1      $EQU    15
                        S2      $EQU    16
                        S3      $EQU    17
"
"
"                 *** DPX NAMES ***
                      F = -4
                      P = -3
                      C = -2
                      S = -1
                      ZS=  3
"
"                 *** DPY NAMES ***
                      G = -4
                      R = -3
                      B = -2
                    ONE = -1
                     DS =  2
                     ES =  3
"
"
"
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
IMTQL2: LDTMA; DB=!ONE
"
        DEC E; DPY(ES)<SPFN             "STORE ARRAY BASES.
        DEC D; DPY(DS)<SPFN
        DEC Z; DPX(ZS)<SPFN
"
        DPY(ONE)<TM;                    "DPY(ONE)=1.
"
        DEC# N                          "IS MATRIX OF ORDER 1?
        BNE .+2
        JMP L1001
"
        MOV E,EPT                       "MOVE SUBDIAGONAL,
        MOV N,I                         "E(I-1)=E(I), I=2,N
        DEC I;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        L100:   INC EPT
                INC EPT; SETMA
                NOP
                DEC I
                DEC EPT; SETMA; MI<MD; BGT L100
        INC EPT; SETMA; MI<ZERO
"
        CLR L
"
        L240:   INC L
                CLR J
"
"                       --------------------------------------------
"                       /** LOOK FOR SMALL SUB-DIAGONAL ELEMENT. **/
"                       --------------------------------------------
"
                L105:   MOV L,M
                        RPSF MACHEP; DPY(0)<DB                  "FETCH MACHEP
                        LDSPI DPT; DB=DPY(DS)
                        ADD M,DPT; SETMA                        "FETCH D(M)
                        LDSPI EPT; DB=DPY(ES)
                        INCMA                                   "FETCH D(M+1)
                        FABS MD                                 "ABS(D(M))
                        FADD; ADD M,EPT; SETMA                  "FETCH E(M)
                        FABS MD; DPX(0)<FA                      "ABS(D(M+1))
                        FADD
                        FADD DPX(0),FA                          "ABS(D(M))+..
                        FABS MD                                 "ABS(E(M))
                        FMUL DPY(0),FA; FADD                    "MACHEP*...
"
                        L110:   INC DPT; SETMA;                 "FETCH D(M+1)
                                   DPX(0)<FA
                                NOP
                                INCMA                           "FETCH D(M+2)
                                   FMUL
                                FABS MD;                        "ABS(D(M+1))
                                   FMUL
                                INC EPT; SETMA;                 "FETCH E(M+1)
                                   FSUB FM,DPX(0)               "MACHEP*(.)-ABS(
                                FABS MD; DPX(0)<FA;             "ABS(D(M+1))
                                   SUB# N,M
                                FADD;
                                   BEQ L120               "IF(M.EQ.N)GOTO L120
                                FADD DPX(0),FA;                 "ABS(D(M+1))+..
                                   BFGT L120                    "IF(MACHEP*...)
                                FABS MD                         "ABS(E(M+1))
                                FMUL DPY(0),FA; FADD;
                                   BR L110; INC M
"
                L120:   DB=DPY(DS); LDSPI DPT
                        ADD L,DPT; SETMA                        "FETCH D(L)
                        DB=30.; LDSPI SP13
                        SUB# L,M; INCMA                         "FETCH D(L+1)
                        DPX(P)<MD; BNE .+2                      "P=D(L)
                        JMP L245
"
                        SUB J,SP13
                        BNE .+2; DB=DPY(ES); LDSPI EPT    "IF(J.EQ.30)GOTO 1000
                        JMP L1000
"
                        INC J; LDTMA; DB=!TWO
"
"                       --------------------------
"                       /*     FORM SHIFT       */
"                       --------------------------
"
                        ADD# L,EPT; SETMA                       "FETCH E(L)
                        FSUBR DPX(P),MD;                        "D(L+1)-P
                         LDSPI DPT; DB=DPY(DS)                  "DPT TO BASE
                        FADD; ADD# M,DPT; SETMA                 "FETCH D(M)
                        FMUL TM,MD; DPX(2)<MD               "2.*E(L), SAVE E(L)
                        FMUL; DPY(0)<FA
                        FMUL
                        DPX(0)<FM;
"
                        JSR DIV         "(D(L+1)-P) / (2.0*E(L))
"
                        FMUL DPX(0),DPX(0); DPY(G)<DPX(0)       "G*G
                        FMUL; FSUBR DPX(P),MD                   "D(M)-P
                        FMUL;         DB=DPX(ZS); LDSPI ZPT2    "ZPT TO BASE
                        FADD FM,DPY(ONE);         ADD N,ZPT2    "G*G+1
                        FADD; DPY(B)<FA;          INC ZPT2      "STORE D(M)-P
                        DPX(0)<FA;
"
                        JSR SQRT        "SQRT(G*G+1.)
"
                        FADD DPY(G),ZERO;         ADD M,DPT
                        FSUB ZERO,DPX(0);         INC DPT
                        FADD; DPX(S)<DPY(ONE);    MOV M,I       "S=1.0
                        BFGE .+2;                 SUB L,I
                        DPX(0)<FA                               "CHANGE SIGN
                        FADD DPY(G),DPX(0);       ADD M,EPT     "G+SIGN(R,G)
                        FADD; DPY(0)<DPX(2);      DEC EPT;SETMA "FETCH E(M-1)
                        DPX(0)<FA;
"
                        JSR DIV         "E(L) / (G+SIGN(R,G))
"
                        FADD DPY(B),DPX(0);    MOV NM,S1        "(D(M)-P)+DIV
                        FADD; DPX(C)<DPY(ONE); MOV M,S2         "C=1.
                        DPY(G)<FA;              "GOING INTO L200...
                                                " ZPT2 POINTS TO Z(            )
                        JSR INDEX               " EPT  POINTS TO E(M-1)
                                                " DPT  POINTS TO D(M+1)
                        ADD S3,ZPT2; DPX(P)<ZERO                "P=0.0
                        INC ZPT2
"
"                               ------------------------------------
"                               /*  FORM NEW TRIDIAGONAL MATRIX.  */
"                               ------------------------------------
"
                        L200:   DEC I; FABS DPY(G)              "ABS(G)
                                FMUL DPX(S),MD                  "S*E(I)
                                FMUL DPX(C),MD; FADD            "C*E(I)
                                FMUL; DPX(0)<FA                 "STORE ABS(G)
                                DPX(F)<FM; FMUL                 "F=S*E(I)
                                FABS DPX(F)                     "ABS(F)
                                DPY(B)<FM; FADD                 "B=C*E(I)
                                FSUB DPX(0),FA
                                FADD;   SUB N,ZPT2
                                DEC  ZPT2
                                DEC DPT; SETMA;
                                 BFGT .+2                       "IF(...)GOTO 150
                                BR .+2;  DPX(0)<DPX(F)
                                JMP L150;  DPX(0)<DPY(G)
"
"                                *    *    *
"
"
                                DPY(0)<DPY(G);
"
                                JSR DIV
"
                                DPX(C)<DPX(0);                  "C=G/F
                                 FMUL DPX(0),DPX(0)             "C*C
                                FMUL; FSUBR DPX(P),MD           "D(I+1)-P
                                FMUL; FADD DPY(B),DPY(B)        "2.*B
                                DPY(G)<FA;                      "G=D(I+1)-P
                                 FADD FM,DPY(ONE)               "C*C+1.
                                DPX(2)<FA; FADD;                "STORE 2.*B
                                 DEC DPT; SETMA                 "FETCH D(I)
                                DPX(0)<FA;
"
                                JSR SQRT
"
                                DPY(R)<DPX(0)                   "R=SQRT(C*C+1.)
                                FMUL DPY(R),DPX(F)              "F*R
                                FMUL; FSUBR DPY(G),MD           "D(I)-G
                                FMUL; FADD; DPY(0)<DPY(ONE)
                                DPY(R)<FA;                      "R=D(I)-G
                                 INC EPT; SETMA; MI<FM          "E(I+1)=F*R
                                DPY(1)<DPX(C);
"
                                JSR DIV
"
                                FMUL DPY(1),DPX(0);             "C*S
                                 DPX(S)<DPX(0)                  "S=1/R
                                FMUL
                                FMUL DPY(R),DPX(S)            "BEGIN S*(D(I)-G)
                                DPX(C)<FM;                      "C=C*S
                                DPY(0)<DPX(2)                   "DPY(0)=2.*B
                                JMP L160
"
"                               *    *    *
"
"
                        L150:   DPY(0)<DPX(F);
"
                                JSR DIV
"
                                DPX(S)<DPX(0);                  "S=F/G
                                 FMUL DPX(0),DPX(0)
                                FMUL; FSUBR DPX(P),MD           "D(I+1)-P
                                FMUL; FADD DPY(B),DPY(B)        "2.*B
                                DPX(F)<FA;                      "F=D(I+1)-P
                                 FADD FM,DPY(ONE)               "S*S+1
                                DPX(2)<FA; FADD;                "STORE 2.*B
                                 DEC DPT; SETMA                 "FETCH D(I)
                                DPX(0)<FA;
"
                                JSR SQRT
"
                                DPY(R)<DPX(0);                  "R=SQRT(S*S+1.)
                                 FMUL DPY(G),DPX(0)             "G*R
                                FMUL; FSUBR DPX(F),MD           "D(I)-'G'
                                FMUL; FADD; DPY(0)<DPY(ONE)
                                DPY(R)<FA;                      "R=D(I)-G
                                 INC EPT; SETMA; MI<FM          "E(I+1)=G*R
                                DPY(1)<DPX(S);
"
                                JSR DIV
"
                                FMUL DPX(0),DPY(1);             "S*C
                                 DPX(C)<DPX(0)                  "C=1/R (OLD)
                                FMUL
                                FMUL; DPY(G)<DPX(F)             "G=D(I+1)-P
                                DPX(S)<FM;                      "S=S*C
                                 DPY(0)<DPX(2);                 "DPY(0)=2.*B
                                 FMUL FM,DPY(R)
"
"                               *    *    *
"
"
                        L160:   LDTMA; DB=!ONE
                                FMUL DPX(C),DPY(0);             "C*(2.*B)
                                 DEC EPT                        "FOR NEXT PASS
                                FMUL
                                LDSPI S3; DB=27.                "FLOAT N
                                FMUL;DPY(0)<FM;  MOV N,N; DPX<SPFN
                                FADD FM,DPY(0);  SUB NM,ZPT2
                                FADD ZERO,MDPX; MOV S3,S3
                                DPY(R)<FA;                      "R=R+2*C*B
                                 FMUL DPX(S),FA;                "S*R
                                  FADD; MOV ZPT2,ZPT1
                                FMUL DPX(C),DPY(R);             "C*R
                                  FSUB ZERO,FA; SUB NM,ZPT1
                                FMUL
                                DPX(P)<FM;                      "P=R*S
                                 FADD FM,DPY(G);                "G+P
                                 FMUL
                                FSUB FM,DPY(B);                 "C*R-B
                                  DPY(-3)<FA
                                INC DPT; SETMA; MI<FA;          "D(I+1)=G+P
                                   FADD TM,DPY(-3)
                                DPY(G)<FA; FADD                 "G=C*R-B
"
"                               ---------------------------
"                               /*    FORM VECTOR.       */
"                               /*  (RATE DETERMINING).  */
"                               ---------------------------
"
                                DPY(-3)<FA;
                                 MOV ZPT2,S2; SETMA             "GET Z(1,I+1)
                                MOV ZPT1,S1; SETMA              "GET Z(1,I)
                                DPY(S)<DPX(S)        "NOTE: S IN TWO REGISTERS.
                                FMUL DPX(C),MD; DPY(0)<MD
                                INC ZPT1; SETMA; FMUL DPX(S),MD "GET Z(2,I)
                                INC ZPT2; SETMA; FMUL DPX(C),MD "GET Z(2,I+1)
                                FMUL DPX(S),DPY(0); FADD FM,ZERO;
                                 DEC S1
                                FMUL DPX(C),MD; DPY(0)<MD;
                                 FADD TM,DPY(-3); DPX(0)<FM;
                                 DEC S2
"
                                L180: INC ZPT2; SETMA;          "GET Z(K+2,I+1)
                                            FMUL DPY(S),MD;     "  S*Z(K+1,I+1)
                                            FADD DPX(0),FA;
                                            DPY(1)<FM
"
                                      INC ZPT1; SETMA;          "GET Z(K+2,I)
                                            FMUL DPX(C),MD;     "  C*Z(K+1,I+1)
                                            FSUBR FM,DPY(1);
                                            DPY(-3)<FA
"
                                      NOP;
                                            FMUL DPX(S),DPY(0); "  S*Z(K+1,I)
                                             INC S2; SETMA;     "STO Z(K,I+1)
                                            MI<FA; FADD FM,ZERO;
                                            BFGT L181
"
                                      FMUL DPX(C),MD;DPY(0)<MD; "  C*Z(K+2,I+1)
                                            FADD TM,DPY(-3);
                                            INC S1; SETMA;      "STO Z(K,I)
                                            MI<FA; DPX(0)<FM
"
                                      INC ZPT1; SETMA;          "GET Z(K+3,I)
                                      FMUL DPY(S),MD; FSUBR DPX(0),FA;
                                            DPY(1)<FM           "  S*Z(K+2,I)
"
                                      INC ZPT2; SETMA;          "GET Z(K+3,I+1)
                                      FMUL DPX(C),MD; DPY(-3)<FA;
                                            FADD FM,DPY(1)      "  C*Z(K+2,I)
"
                                      FMUL DPX(S),DPY(0);       "  S*Z(K+2,I+1)
                                            INC S1; SETMA;      "STO Z(K+1,I)
                                            MI<FA; FADD FM,ZERO;
                                            BFGT L182
"
                                      FMUL DPX(C),MD;           "  C*Z(K+3,I)
                                      DPY(0)<MD;
                                      FADD TM,DPY(-3); DPX(0)<FM;
                                            INC S2; SETMA;      "STO Z(K+1,I+1)
                                            MI<FA; BR L180
"
"
                        L181: INC S1; SETMA; MI<FA; BR .+2
                        L182: INC S2; SETMA; MI<FA
                                MOV I,I; DPY(ONE)<TM
                                BEQ .+2;  DEC EPT; SETMA
                                JMP L200
"
                        DB=DPY(DS); LDSPI DPT
                        ADD L,DPT; SETMA                        "FETCH D(L)
                        DB=DPY(ES); LDSPI EPT
                        ADD L,EPT; SETMA; MI<DPY(G)             "E(L)=G
                        FSUBR DPX(P),MD; SUB L,EPT
                        FADD; ADD M,EPT; SETMA; MI<ZERO         "E(M)=0.0
                        MOV DPT,DPT; SETMA; MI<FA               "D(L)=D(L)-P
                        JMP L105
"
L245:           SUB# N,L
                BEQ .+2
                JMP L240
"
"             --------------------------------------------------
"             /***    ORDER EIGENVALUES AND EIGENVECTORS.   ***/
"             --------------------------------------------------
"
        CLR I
        LDSPI II; DB=1.
        LDSPI SP13; DB=DPX(ZS)
        SUB NM,SP13
        LDSPI DPT; DB=DPY(DS)
"
        L300:   INC II
                INC I
                ADD# I,DPT; SETMA                               "FETCH D(I)
                MOV I,K
                MOV II,J
                INCMA                                           "FETCH D(II)
                DPX(P)<MD                                       "P=D(I)
                DPX(0)<MD
                FSUBR DPX(P),MD
"
                L260:      FADD
                        INCMA
                           BFGE .+2
                           MOV J,K; DPX(P)<MD
                           SUB# N,J
                        FSUBR DPX(P),MD;
                           BNE L260; INC J
"
                SUB# K,I
                BNE .+2; ADD NM,SP13
                JMP L301
                ADD#  K,DPT; SETMA; MI<DPX(0)                   "D(K)=D(I)
                MOV SP13,ZPT1
                ADD# I,DPT; SETMA; MI<DPX(P)                    "D(I)=P
                CLR S1
                MOV K,S2
"
                JSR INDEX
"
                LDSPI ZPT2; DB=DPX(ZS)                          "Z(J,K) POINTER
                ADD S3,ZPT2
                MOV N,J
"
                L280:   INC ZPT1; SETMA                         "FETCH Z(J,I)
                        NOP
                        INC ZPT2; SETMA                         "FETCH Z(J,K)
                        NOP
                        MOV ZPT2,ZPT2; SETMA; MI<MD             "Z(J,K)=Z(J,I)
                        DEC J
                        MOV ZPT1,ZPT1; SETMA; MI<MD; BGT L280    "Z(J,I)=
                                                                 "FORMER Z(J,K)
"
        L301:   SUB# N,II
                BGE .+3
                JMP L300
"
 L1000: MOV L,S3; BR .+2   "SET ERROR FLAG: NO CONVERGENCE AFTER 30 ITERATIONS.
 L1001: CLR S3                  "CLEAR ERROR FLAG:  ALL EIGENVALUES FOUND.
        RETURN
"
          MACHEP:    $FP .00000002
                     $END
"****** UDOTPR = UTILITY DOT PRODUCT /FAST/ = REL 1.1, JUN 80 *****
                        $TITLE UDOTPR
        $RADIX 8
                        $ENTRY UDOTPR,5
"
"
"
"       LANGUAGE:       AP-120B ASSEMBLER
"       EQUIPMENT:      AP-120B WITH ONE CYCLE MEMORY
"       SIZE:           31 LOCATIONS
"
"
"
"    --- HISTORY ---
"ORIGINAL:  JAN 79  W.H. INSKEEP AND C. HSIUNG
" REV 1.1:  JUN 80  H. SEDINGER     CORRECTED TO WORK FOR N>4
"
"
"
"       VECTOR DOT PRODUCT
"          DOES   FA =  SUM( A(MI)*B(MJ) )   FOR M=0,N-1
"
"
"
"       LOOP CONTROL IS DONE IN THE FLOATING ADDER.  N IS FLOATED,
"       AND THEN DECREMENTED WITH THE TM REGISTER (TM=1.00). THIS
"       VERSION TAKES ADVANTAGE OF THE FACT THAT IT IS ALWAYS POSSIBLE
"       TO DO THE DOT PRODUCT WITH NO MEMORY INTERLEAVE FAILURES WHEN
"       BOTH VECTOR INCREMENTS ARE ODD NUMBERS.  THIS IS DONE BY DOUBLING
"       THE LOOP LENGTH, DOING TWO PRODUCT ACCUMULATIONS PER LOOP CYCLE.
"       BUT THE ORDER OF THE MEMORY FETCHING DEPENDS ON WHETHER THE
"       ORIGINS OF THE TWO VECTORS ARE IN THE SAME OR DIFFERENT DATA
"       BANKS.  THE COMPARISON NECESSARY TO ASCERTAIN THIS IS OVERLAPPED
"       IN THE (IN-LINE) FLOAT ROUTINE.  (NOTE: ONE CANNOT ELIMINATE
"       INTERLEAVE MISMATCH IN THIS ROUTINE BY TAKING ONE ORIGIN IN
"       THE EVEN DATA BANK, THE OTHER IN THE ODD, AND BOTH INCREMENTS
"       EVEN).
"
"       THE ROUTINE IS A UTILITY ROUTINE (NON FORTRAN CALLABLE), SINCE
"       WE WISH TO REFERENCE IT FROM OTHER APAL ROUTINES, AND DO NOT
"       WANT THE RESULT GOING INTO MD.  WHENCE THE RESULT JUST ARRIVES
"       IN FA WHEN THE FIRST INSTRUCTION AFTER THE APAL CALLING INSTRUCTION
"       IS EXECUTED.  FOR EXAMPLE:
"
"               JSR UDOTPR
"               NOP
"               BFGT WHEREVER
"
"       THE BRANCH ON THE DOT PRODUCT RESULT WOULD FAIL WITHOUT THE NOP.
"
"
"
"                       PARAMETERS:
                        A       $EQU    0
                        IA      $EQU    1
                        B       $EQU    2
                        IB      $EQU    3
                        N       $EQU    4
"
"                       OTHER S-PAD NAMES:
                        S1      $EQU    5
"
"
"
"       DATA PAD USAGE:   DPX(0), DPX(1), DPY(0)
"
"
"
"
"
"
        UDOTPR: LDSPI S1; DB=27.                        "FLOAT N.
                MOV N,N; DPX<SPFN
                FADD ZERO,MDPX; MOV S1,S1
                LDTMA; DB=!ONE;                         "SET TM=1.0
                  SUBR# A,B                             "WHICH MD COMBO?
                FADD; BZC SAME
                BR DIF; MOV A,A; SETMA                  "FETCH A(1)
"
"
"
"
"       --------------------------------
"       /*  BASES IN SAME MD BANK...  */
"       --------------------------------
"
        SAME:   MOV A, A; SETMA                         "FETCH A(1)
                ADD IA,A; SETMA                         "FETCH A(2)
                MOV  B,B; SETMA                         "FETCH B(1)
                ADD IB,B; SETMA; DPX<MD                 "FETCH B(2)
                ADD IA,A; SETMA;                        "FETCH A(3)
                  DPX(1)<MD                             "STORE A(2)
                ADD IA,A; SETMA;                        "FETCH A(4)
                   FMUL DPX,MD                          "A(1)*B(1)
                ADD IB,B; SETMA;                        "FETCH B(3)
                   FMUL DPX(1),MD; FSUBR TM,FA          "A(2)*B(2)
                ADD IB,B; SETMA; DPX<MD;                "FETCH B(4)
                   FADD ZERO,ZERO
"
                LOOP1:  ADD IA,A; SETMA;                        "FETCH A(5)
                           DPX(1)<MD;
                              FMUL; FSUBR TM,FA                 "DEC COUNT
                        ADD IA,A; SETMA;                        "FETCH A(6)
                           FMUL DPX,MD;                         "A(3)*B(3)
                              FADD FM,FA; BFEQ OUT1             "ACCUM SUM; PUNT
                        ADD IB,B; SETMA;                        "FETCH B(5)
                           FMUL DPX(1),MD; FSUBR TM,FA;         "A(4)*B(4)
                              DPY<FM
                        ADD IB,B; SETMA; DPX<MD;                "FETCH B(6)
                           NOP;
                              FADD DPY,FA; BFGT LOOP1           "ACCUM SUM, LOOP
"
        OUT1:   FADD; RETURN
"
"
"
"
"
"
"       --------------------------------------
"       /*  BASES IN DIFFERENT MD BANKS...  */
"       --------------------------------------
"
        DIF:    MOV  B,B; SETMA                                 "FETCH B(1)
                ADD IB,B; SETMA                                 "FETCH B(2)
                ADD IA,A; SETMA; DPX<MD                         "FETCH A(2)
"
                ADD IA,A; SETMA;                                "FETCH A(3)
                   FMUL DPX,MD                                  "A(1)*B(1)
                ADD IB,B; SETMA;                                "FETCH B(3)
                   DPX<MD
                ADD IB,B; SETMA;                                "FETCH B(4)
                   FMUL DPX,MD; FSUBR TM,FA                     "A(2)*B(2)
                ADD IA,A; SETMA; DPX<MD;                        "FETCH A(4)
                   FADD ZERO,ZERO
"
                LOOP2:  ADD IA,A; SETMA;                "FETCH A(5)
                           FMUL DPX,MD;                 "A(3)*B(3)
                              FSUBR TM,FA               "DEC COUNTER
                        ADD IB,B; SETMA;                "FETCH B(5)
                           DPX<MD;
                              FADD FM,FA; BFEQ OUT2     "ACCUM SUM; PUNT
                        ADD IB,B; SETMA;                "FETCH B(6)
                           FMUL DPX,MD; FSUBR TM,FA;    "A(4)*B(4)
                                NOP
                        ADD IA,A; SETMA; DPX<MD;        "FETCH A(6)
                           NOP;
                              FADD FM,FA; BFGT LOOP2    "ACCUM SUM; LOOP
"
        OUT2:  FADD; RETURN                     "RESULT IN FA.
"
        $END
"****** INDEX = SETUP INDICES FOR TRED2, IMTQL2 /FAST/ = REL 1.0, APR 79 ***
"       THE FOLLOWING ROUTINE IS AN UTILITY ROUTINE CALLED BY
"       IMTQL2 AND TRED2 TO SETUP INDICES.
"
"
"
"
      $TITLE INDEX
        $RADIX 8
      $ENTRY INDEX
"
       I $EQU 15
       J $EQU 16
       N $EQU 17
     N27 $EQU 17
"
INDEX:  MOV 0,N; DPX(0)<SPFN
        LDSPI N27; DB=27.
        FADD ZERO,MDPX(0);
           MOV N27,N27
        FADD; DEC J;
           DPX(0)<SPFN
        FADD ZERO,MDPX(0);
           MOV N27,N27;
           DPX(0)<FA
        FADD
        FMUL DPX(0),FA
        FMUL
        FMUL
        DPX(0)<FM
        FIX DPX(0)
        FADD
        DPX(0)<FA
        LDSPI N; DB=DPX(0)
        ADD I,N; RETURN
        $END
"****** RKGIL = RUNGE-KUTTA-GILL'S ODE INTEG /FAST/ = REL 1.1, JUN 80 ******
"               FOR STANDARD MEMORY
                $TITLE RKGIL
        $RADIX 8
                XADC   $EQU   1
                $ENTRY RKGIL,11
                $EXT   DFUN
"
"
"                       --- ABSTRACT ---
"
"               THE SUBROUTINE RKGIL PERFORMS NUMERICAL INTEGRATION OF A
"       SYSTEM OF ORDINARY DIFFERENTIAL EQUATIONS VIA THE RUNGE-KUTTA-GILL
"       METHOD.  THIS IS A FOURTH ORDER SCHEME WHICH IS CAPABLE OF
"       PERFORMING LARGE NUMBER OF INTEGRATION STEPS.  A FORTRAN VERSION
"       OF THE ALGORITHM IS INCLUDED BELOW.
"
"               THE SYSTEM OF ORDINARY DIFFERENTIAL EQUATIONS HAS TO BE
"       OF THE FOLLOWING FORM:
"
"               DV = F(T,V)
"
"       WHERE  T  IS THE INDEPENDENT VARIABLE, V  IS THE VECTOR OF
"       DEPENDENT VARIABLES, DV  IS THE DERIVATIVE OF  V  WITH RESPECT
"       TO  T  AND  F  IS THE VECTOR OF EQUATIONS. TYPICALLY, IT IS
"       INTEGRATED FOR  T = T0  WITH STEP SIZE  H.  IT IS REQUIRED OF
"       THE USER TO SUPPLY A SUBROUTINE  DFUN  WHICH PROVIDES THE
"       EQUATION  DV = F.  THE ROUTINE  DFUN WILL BE CALLED FOUR TIMES
"       IN EACH OF THE M INTEGRATION STEPS.
"
"               IN WRITING SUBROUTINE  DFUN, THE USER HAS TO USE THE
"       SAME S-PADS AS IN  RKGIL  FOR ITS PARAMETERS.  THEY ARE LISTED
"       AS FOLLOWS:  DFUN(N,H,T,DV,V)
"                    (N = 0; H = 1; T = 7; DV = 4; V = 5)
"       THE USER IS FREE TO USE ALL OTHER S-PADS EXCEPT S-PAD 11
"       (OCTAL), WHICH IS USED TO SAVE THE CURRENT VALUE OF DPA.
"       HE IS FREE TO USE ALL THE DATA PADS RANGING FROM -4 TO 27
"
"               THE CODE IS WRITTEN IN SUCH A WAY TO FACILITATE REPEATED
"       CALLS.  IF IT IS CALLED AGAIN, PERHAPS WITH A DIFFERENT STEP SIZE,
"       SOME OVERHEAD CAN BE SAVED.
"
"               IT IS WELL KNOWN THAT THIS EXPLICIT RUNGE-KUTTA METHOD MAY
"       POSE STABILITY PROBLEM IF THE NUMBER OF INTEGRATIONS IS LARGE.  THE
"       USER IS RESPONSIBLE FOR THE CHOICES OF STEP SIZES AND FOR THE
"       INSTABILITY PHENOMENON.
"
"
"                       --- STATISTICS ---
"
"       LANGUAGE:               AP-120B ASSEMBLER.
"       EQUIPMENT:              AB-120B WITH STANDARD MEMORY.
"       SIZE:                   APPX 80 LOCATIONS PLUS DFUN.
"       SUBROUTINE USED:        DFUN
"       AUTHER:                 CHRISTOPHER C. HSIUNG
"       DATE:                   MARCH 1979
"       REVISED:    JUN 80  R. GELLER  CORRECT ADC LINKAGE
"
"
"                       --- PARAMETERS ---
"
"               N       $EQU      0             "NUMBER OF EQUATIONS
"               H       $EQU      1             "ADDRESS OF THE STEP SIZE
"               T0      $EQU      2             "ADDRESS OF THE INITIAL VALUE OF
"                                               "INDEPENDENT VARIABLE
"               FLAG    $EQU      3             "FLAG FOR FIRST CALL, SET TO
"                                               "ZERO BY USER PRIOR TO FIRST CAL
"               DV      $EQU      4             "BASE ADDRESS OF VECTOR DV
                                                "DIMENSIONED AS N
"               V       $EQU      5             "BASE ADDRESS OF VECTOR V
                                                "DIMENSIONED AS N
"               Z       $EQU      6             "BASE ADDRESS OF WORKING AREA
                                                "DIMENSIONED AS N+10
"               M       $EQU      7             "NUMBER OF TIMES OF
                                                "INTEGRATIONS
"               NDIM    $EQU     10             "DIMENSION OF Z (=N+10)
"
"
"                       --- SCRATCH ---
"
"       DPX:    DPA; DPA + (-4,3)
"       DPY:    DPA; DPA + (-4,3)
"       S-PAD:  (0-17)
"       TM,FA,FM,MD.
"
"
"                       --- ERROR CONDITIONS ---
"
"                              NONE
"
"
"                       --- THROUGHPUT ---
"
"               THROUGHPUT IS SOMEWHAT IMPROVED BY STORING DV, V AND Z
"       IN EITHER EVEN, ODD, EVEN SEQUENCE OR ODD, EVEN, ODD SEQUENCE.
"       THIS IS DUE TO MEMORY INTERLEAVING IN AP.  THE INNER LOOP  L20
"       WILL ONLY TAKE TEN MEMORY CYCLES IN THE ABOVE CASES, WHILE IT
"       MAY TAKE AS MANY AS FOURTEEN CYCLES IF NOT STORED RIGHTLY.
"
"
"---------------------------------------------------------------------------
"---------------------------------------------------------------------------
"
"               ---    FORTRAN CODE OF RUNGE-KUTTA-GILL   ---
"
"
"               SUBROUTINE RKGIL(N,H,T0,DV,V,Z,M)
"               DIMENSION DV(N),V(N),Z(N),A(4),B(4)
"               INTEGER N,I,J,K,M
"               REAL H,T0,T,R1,R2
"               DATA A/.5,.2928932,1.707107,.1666667/,
"       C ARRAY  A  IS STORED AS: 1/2,1-1/SQRT(2),1+1/SQRT(2),1/6
"            &       B/0.,1.,1.,2./
"       C
"               DO 50 K=1,M
"               T = T0
"               DO 10 I=1,N
"       10         Z(I) = 0.
"               DO 20 J=1,4
"                  IF (J.EQ.2.OR.J.EQ.3) T = T0+.5*H
"                  IF (J.EQ.4) T = T0+H
"                  CALL DFUN(N,H,T,DV,V)
"                  DO 20 I=1,N
"                     R1 = H*DV(I)
"                     R2 = A(J)*(R1-B(J)*Z(I))
"                     V(I) = V(I) + R2
"                     R2 = R2+R2+R2
"       20            Z(I) = Z(I) + R2 - A(J)*R1
"               T0 = T
"       50      CONTINUE
"               RETURN
"               END
"
"
"---------------------------------------------------------------------------
"---------------------------------------------------------------------------
"
"               THE ABOVE FORTRAN CODE IS VERY EFFEHICIENT.  BUT, WHEN
"               TRANSLATED IN APAL, IT IS NOT NEARLY AS EFFICIENT AS IT
"               LOOKS.  INSTEAD, WE WILL USE THE FOLLOWING FORTRAN VERSION
"               TO GUIDE OUR APAL PROGRAMMONG.
"
"
"               --- REVISED VERSION OF FORTRAN CODE ---
"
"
"               SUBROUTINE RKGIL(N,H,T0,FLAG,DV,V,Z,M)
"               DIMENSION DV(N),V(N),Z(N),T(4),A(4),B(4)
"               INTEGER N,FLAG,I,J
"               REAL H,T0,R1,R2,R3,R4
"       C
"               T(1) = T0
"               T(2) = T0+.5*H
"               T(3) = T(2)
"               T(4) = T0+H
"               A(1) = .5
"               A(2) = 1. - 1./SQRT(2.)
"               A(3) = 1. + 1./SQRT(2.)
"               A(4) = 1./6.
"               B(1) = 0.
"               B(2) = 1.
"               B(3) = 1.
"               B(4) = 2.
"               DO 50 K=1,M
"               DO 10 I=1,N
"       10         Z(I) = 0.
"               DO 20 J=1,4
"                  CALL DFUN(N,H,T(J),DV,V)
"                  DO 20 I=1,N
"                     R1 = H*DV(I)
"                     R3 = A(J)*R1
"                     R4 = A(J)*B(J)*Z(I)
"                     R2 = R3 - R4
"                     V(I) = V(I) + R2
"       20            Z(I) = Z(I) - 3.*R4 + R3 + R3
"       50      CONTINUE
"               T0 = T(4)
"               RETURN
"               END
"
"
"------------------------------------------------------------------------
"------------------------------------------------------------------------
"
"               -----------------------------------
"               |                                 |
"               |        SAMPLE    DFUN           |
"               |                                 |
"               -----------------------------------
"
"               FOR THE FOLLOWING SECOND ORDER ORDINARY DIFFERENTIAL
"       EQUATION
"
"               Y'' = -4*Y,
"
"               Y(0) = 1
"
"               Y'(0) = 0
"
"       AN EQUIVALENT SYSTEM OF FIRST ORDER DIFFERENTIAL EQUATIONS
"       CAN BE WRITTEN IN THE FOLLOWING FORM
"
"               DV(1) = V(2),
"
"               DV(2) = -4*V(1),
"
"       WITH INITIAL CONDITION
"
"               V(1) = 1    AND    V(2) = 0    AT POINT 0.
"
"       THE FOLLOWING IS A SAMPLE APAL ROUTINE FOR DFUN(N,H,T,DV,V).
"
"               $TITLE DFUN
"               $ENTRY DFUN
"
"
"           --- S-PAD PARAMETERS ---
"               N     $EQU      0                       "THE DIMENSION
"               H     $EQU      1                       "ADDRESS OF STEP SIZE
"               T     $EQU     10                       "ADDRESS OF VARIABLE
"               DV    $EQU      4                       "BASE ADDRESS OF VECTOR
"                                                       "DV
"               V     $EQU      5                       "BASE ADDRESS OF VECTOR
"                                                       "V
"
"
"        DFUN:  MOV V,V; SETMA                          "FETCH V(1)
"               LDTMA; DB=!FOUR                         "FETCH FLOATING POINT
"                                                       "FOUR FROM TABLE MEMORY
"               INCMA                                   "FETCH V(2)
"               FSUBR TM,ZERO;                          "GET -4
"                 DPX(0)<MD                             "SAVE V(1)
"               FADD                                    "PUSH ADDER
"               MOV DV,DV; SETMA; MI<DB;                "STORE V(2) IN DV(1)
"                 DB=MD
"               FMUL DPX(0),FA                          "-4*V(1)
"               FMUL                                    "PUSH MULTIPLIER
"               FMUL                                    "PUSH AGAIN
"               INCMA; MI<FM;                           "STORE -4*V(1) IN DV(2)
"                 RETURN
"               $END
"
"
"------------------------------------------------------------------------
"------------------------------------------------------------------------
"
"                       --- USAGE ---
"
"       FORTRAN CALL:           CALL RKGIL(N,H,T0,FLAG,DV,V,Z,M,NDIM)
"       APAL:   JSR RKGIL
"
"
"               S-PAD PARAMETERS:
"
                N     $EQU      0
                H     $EQU      1
                T0    $EQU      2
                FLAG  $EQU      3
                DV    $EQU      4
                V     $EQU      5
                Z     $EQU      6
                M     $EQU      7
                NDIM  $EQU     10
"
"               RESULTANT ARRAYS:
"
                T     $EQU     10
                A     $EQU     11
                B     $EQU     12
"
"               POINTERS AND COUNTERS:
"
                J     $EQU     13
                I     $EQU     14
                DVPT  $EQU     15
                VPT   $EQU     16
                ZPT   $EQU     17
                VPT1  $EQU      2
                ZPT1  $EQU      3
"
"               DPX NAMES:
"
                VV    $EQU     -4
                ZZ    $EQU     -3
                PAD   $EQU     -1
                TT    $EQU     -2
                SIXTH $EQU     -1
                SCR   $EQU      0
"
"               DPY NAMES:
"
                HH    $EQU     -4
                AA    $EQU     -3
                AB    $EQU     -2
                ATMP  $EQU     -1
                ABTMP $EQU      0
                ONE   $EQU      1
                V1    $EQU      1
                ABZ   $EQU      2
                THREE $EQU      3
"
"" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"" ***   CONDITIONAL ASSEMBLY   ***
        $IF XADC=1
        $SUBR FRKGIL,11
        $EXT  RESLVE
        BITMAP  $EQU   611
        $PARAM  11,    P1/I/IP,P2/R/IP,P3/R/IP/OP,P4/I/IP,P5(#1)/R/IP/OP,
                       P6(#1)/R/IP/OP,P7(#11)/R,P8/I/IP,P9/I/IP
"
FRKGIL: LDSPI 17; DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
RKGIL:  RDPA;                                           "READ DPA IN PENAL BUS
          LDSPNL 17                                     "PUT DPA IN S-PAD 17
        LDSPI 16; DB=8.
        ADD 17,16; DPX(3)<SPFN                          "PUT DPA+8 IN
        MOV 17,17; DPX(2)<SPFN                          "SAVE DPA
L5:     MOV N,I
        BGT .+2;                                        "RETURN IF N=0
          DEC I
        RETURN
        MOV Z,ZPT; SETMA; MI<DB; DB=ZERO;               "ZEROES Z(1)
          BEQ AGAIN                                     "BRANCH IF N=1
        DEC I
LOOP:   INCMA; MI<DB; DB=ZERO; DEC I; BGT LOOP          "ZEROES Z(I)
AGAIN:  MOV H,H; SETMA                                  "FETCH H
        LDTMA; DB=!HALF;                                "FETCH 1/2 FROM TABLE
          MOV Z,T                                       "TO SET UP ADDRESS OF T
        MOV T0,T0; SETMA;                               "FETCH T0
          DPY(AB)<DB; DB=ZERO                           "SAVE A(1)*B(1)
        FMUL TM,MD;                                     "H*.5
          DPY(HH)<MD                                    "SAVE H
        FMUL; DPY(AA)<TM                                "SAVE A(1)
        FMUL; ADD N,T; SETMA; MI<DB;                    "STORE T(1)
          DPX(TT)<MD                                    "SAVE T0
        FADD FM,DPX(TT);                                "T0+.5*H
          LDSPI A; DB=4.                                "TO SET UP A
        FADD; LDSPI B; DB=3.                            "TO SET UP B
        ADD T,A; INCMA; MI<FA;                          "STORE T(2)
          DPX(PAD)<FA;
          FADD DPY(HH),DPX(TT)                          "T0+H
        FADD; LDSPI J; DB=4.                            "PUT 4 IN J
        INCMA; MI<DPX(PAD);                             "STORE T(3)
          ADD A,B
        MOV FLAG,FLAG
        INCMA; MI<FA;                                   "STORE T(4)
          DPX(TT)<FA;                                   "SAVE T(4)
          BEQ .+2                                       "BRANCH IF FIRST CALL
        JMP OLD
"
"       PROCESS IF FIRST CALL
"
        LDTMA; DB=!ISQT2                                "FETCH 1/SQRT(2)
        LDTMA; DB=!ONE                                  "FETCH 1
        DPX(PAD)<TM                                     "SAVE 1/SQRT(2)
        FSUB TM,DPX(PAD);                               "1 - 1/SQRT(2)
          DPY(ONE)<TM
        LDTMA; DB=!SIXTH                                "FETCH 1/6
        FADD DPY(ONE),DPX(PAD)                          "1 + 1/SQRT(2)
        FADD; MOV A,A; SETMA; MI<FA;                    "STORE A(2)
          DPX(SIXTH)<TM                                 "SAVE 1/6
        INCMA; MI<FA                                    "STORE A(3)
        LDTMA; DB=!TWO                                  "FETCH 2
        INCMA; MI<DB; DB=DPX(SIXTH)                     "STORE A(4)
        MOV B,B; SETMA; MI<DB; DB=DPY(ONE)              "STORE B(2)
        DPX(PAD)<TM                                     "SAVE 2
        INCMA; MI<DB; DB=DPY(ONE)                       "STORE B(3)
        INCMA; MI<DPX(PAD)                              "STORE B(4)
"
"       END OF PROCESSING FIRST CALL
"
OLD:    DEC T;
          LDTMA; DB=!THREE                              "FETCH 3 FROM TABLE
        DEC A
        DEC B; DPY(THREE)<TM
        MOV T0,T0; DPX(1)<SPFN                          "SAVE T0
L10:    INC T                                           "POINT TO T FOR DFUN
        MOV Z,Z; DPY(-1)<SPFN                           "SAVE Z
        MOV A,A; DPY(0)<SPFN                            "SAVE A
        MOV B,B; DPY(1)<SPFN                            "SAVE B
        MOV J,J; DPX(-1)<SPFN                           "SAVE J
        MOV M,M; DPX(0)<SPFN                            "SAVE M
        LDSPI 11; DB=DPX(2)                             "SAVE DPA
        LDDPA; DB=DPX(3)                                "SET NEW DPA
        JSR DFUN
        MOV 11,11; SETDPA                               "RESET BACK DPA
        MOV DV,DVPT; SETMA                              "FETCH DV(1)
        LDSPI Z; DB=DPY(-1)
        LDSPI A; DB=DPY(0)
        LDSPI B; DB=DPY(1)
        LDSPI J; DB=DPX(-1)
        LDSPI M; DB=DPX(0)
        MOV V,VPT; SETMA                                "FETCH V(1)
        MOV Z,ZPT; SETMA                                "FETCH Z(1)
        FMUL DPY(HH),MD;                                "H*DV(1)
          MOV N,I
        DPX(VV)<MD;                                     "SAVE V(1)
          FMUL; INC A; SETMA                            "FETCH A(J+1)
        FMUL DPY(AB),MD;                                "A(J)*B(J)*Z(1)
          DPX(ZZ)<MD;                                   "SAVE Z(1)
          INC B; SETMA                                  "FETCH B(J+1)
        FMUL FM,DPY(AA);                                "A(J)*R1
          MOV Z,ZPT1
        INC DVPT; SETMA;                                "FETCH DV(2)
          DPY(ATMP)<MD;                                 "SAVE A(J+1)
          FMUL
        INC VPT; SETMA;                                 "FETCH V(2)
          FMUL FM,DPY(THREE);                           "3*A(J)*B(J)*Z(1)
          DPY(ABZ)<FM                                   "SAVE A(J)*B(J)*Z(1)
        INC ZPT; SETMA;                                 "FETCH Z(2)
          FMUL DPY(ATMP),MD;                            "A(J+1)*B(J+1)
          FADD FM,DPX(ZZ);                              "Z(1)+A(J)*R1
          DPX(PAD)<FM                                   "SAVE A(J)*R1
        FMUL DPY(HH),MD;                                "H*DV(2)
          MOV V,VPT1
        DPY(V1)<MD;                                     "SAVE V(2)
          FSUB DPX(PAD),DPY(ABZ);                       "TO FORM R2
          FMUL; DPX(SCR)<FM;                            "SAVE 3*A(J)*B(J)*Z(1)
          DEC VPT1
        FMUL DPY(AB),MD;                                "A(J)*B(J)*Z(2)
          FSUBR DPX(SCR),FA;                            "FORM NEW Z(1)
          DPY(ABTMP)<FM;                                "SAVE A(J+1)*B(J+1)
          DEC ZPT1
        L20:    INC DVPT; SETMA;                        "FETCH DV(I+2)
                    FMUL FM,DPY(AA);                    "A(J)*R1
                    DPX(ZZ)<MD                          "SAVE Z(I+1)
                INC VPT; SETMA;                         "FETCH V(I+2)
                    DPX(VV)<DPY(V1);                    "SAVE V(I+1)
                    FMUL;
                        FADD DPX(VV),FA                 "V(I)+R2
                INC ZPT; SETMA;                         "FETCH Z(I+2)
                    FMUL FM,DPY(THREE);                 "3*A(J)*B(J)*Z(I+1)
                    DPY(ABZ)<FM;                        "SAVE A(J)*B(J)*Z(I+1)
                        FADD DPX(PAD),FA                "TO FORM NEW Z(I)
                FMUL DPY(HH),MD;                        "H*DV(I+2)
                    FADD FM,DPX(ZZ);                    "TO FORM R2
                    DPX(PAD)<FM;                        "A(J)*R1
                        INC VPT1; SETMA; MI<FA          "STORE V(I)
                DPY(V1)<MD;                             "SAVE V(I+2)
                  FMUL;
                    FSUB DPX(PAD),DPY(ABZ);           "A(J)*R1-A(J)*B(J)*Z(I+1)
                        DEC I; DPX(SCR)<FA              "SAVE NEW Z(I)
                FMUL DPY(AB),MD;                        "A(J)*B(J)*Z(I+2)
                    FSUBR FM,FA;                    "Z(I+1)-3*A(J)*B(J)*Z(I+1)
                                                        "+A(J)*R1
                        INC ZPT1; SETMA; MI<DPX(SCR);   "STORE Z(I)
                        BGT L20                         "BRANCH IF I<N
        DPY(AA)<DPY(ATMP);                                      "SAVE A(J+1)
          DEC J
        DPY(AB)<DPY(ABTMP);                             "SAVE A(J+1)*B(J+1)
          BEQ .+2
        JMP L10
        LDSPI T0; DB=DPX(1)                             "RESTORE T0
        LDSPI FLAG; DB=1.                               "RESTORE FLAG
        DEC M
        MOV T0,T0; SETMA; MI<DPX(TT);                   "STORE NEW T0
          BEQ .+2                                       "BRANCH IF DONE
        JMP L5
        RETURN
        $END
"****** SKYSOL = SKYLINE EQUATION SOLVER /COMMON/ = REL 1.1, OCT 79 ******
        $TITLE SKYSOL
        $RADIX 8
        $ENTRY SKYSOL,8.
        $EXT VINDX2,VDIV,DOTPR,VMOV,VSMA
"
"   --- ABSTRACT ---
" SOLVES A SET OF EQUATIONS USING FORWARD REDUCTION AND BACK SUBSTITUTION.
"THE COEFFICIENT MATRIX IS ASSUMED TO BE SYMETRIC AND IS STORED IN A
"SPECIAL SKYLINE FORMAT.
"
" * DEFINITION OF SKYLINE FORMAT *
" THE SKYLINE FORMAT IS SIMILAR TO A BANDED MATRIX STORAGE FORMAT.
"HOWEVER, A BANDED MATRIX FORMAT IMPLIES A CONSTANT COLUMN HEIGHT; A SKYLINE
"FORMAT PERMITS VARIABLE COLUMN HEIGHTS.  HENCE A SKYLINE STORAGE FORMAT MAY
"BE SIGNIFICANTLY MORE COMPACT THAN A BANDED STORAGE FORMAT WHEN THERE IS
"A WIDE VARIATION OF COEFFICIENT MATRIX COLUMN HEIGHTS.
" SINCE THE MATRIX IS ASSUMED TO BE SYMETRIC, ONLY THE DIAGONAL AND
"UPPER TRIANGLE ELEMENTS NEED BE STORED.
"
" * COEFFICIENT DATA INPUT ARRAYS *
"    A - COEFFICIENT MATRIX STORED IN SKYLINE FORMAT.  DATA IS STORED IN
"      COLUMN ORDER STARTING WITH THE DIAGONAL ELEMENT OF THE COLUMN AND
"      GOING UP THE COLUMN TO THE HIGHEST NON-ZERO ELEMENT. (ANY ZERO ELEMENT
"      BELOW THE HIGHEST NON-ZERO ELEMENT MUST BE STORED ALONG WITH ALL THE
"      NON-ZERO ELEMENTS.)
" MAXA - DIAGONAL ELEMENT POINTER ARRAY.  THIS IS AN INTEGER ARRAY WHOSE
"      ELEMENTS POINT TO THE SUBSCIPT IN 'A' OF EACH DIAGONAL ELEMENT.
"      FOR 'N' DEGREES OF FREEDOM, 'MAXA' CONTAIN 'N+1' ELEMENTS. THE VALUE
"      OF THE LAST ELEMENT MUST BE ONE GREATER THAN THE NUMBER OF VALUES
"      STORED IN 'A'.
" --- STATISTICS ---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 244+VDIV(75)+DOTPR(9)+VMOV(6)+VSMA(14)= **348** (STANDARD MEMORY)
"      244+VDIV(75)+DOTPR(12)+VMOV(7)+VSMA(12)+SPUFLT(8)= **358** (FAST MEMORY)
"
"    --- HISTORY ---
"ORIGINAL:  APR 79  L. TARVESTAD
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"
" --- USAGE ---
"FORTRAN: CALL SKYSOL(A,V,MAXA,NN,MA,NWA,KKK,WS)
"APAL:    JSR SKYSOL
"S-PAD PARAMETERS
         A    $EQU 0    "COEFFICIENT MATRIX. SIZE=NWA.
         V    $EQU 1    "LOAD VECTOR INPUT & SOLUTION VECTOR OUTPUT. SIZE=NN.
         MAXA $EQU 2    "DIAGONAL POINTER ARRAY.  SIZE=NN+1
         NN   $EQU 3    "DEGREES OF FREEDOM.
         MA   $EQU 4    "MAX COLUMN HEIGHT IN COEFFICIENT MATRIX.
         NWA  $EQU 5    "NUMBER OF COEFFICIENT ELEMENTS STORED IN 'A'
         KKK  $EQU 6    "COMPUTATION CONTROL PARAMETER:
"                               1 - MATRIX FACTORIZATION ONLY
"                               2 - REDUCTION & BACK SUBSTITUTION ONLY
"                               3 - COMPLETE SOLUTION
         WS   $EQU 7    "COMPUTATION WORKSPACE. SIZE=NN
"
"  SP(12) AND SP(13) ARE GLOBALLY RESERVED FOR
" LOOP COUNTERS 'N' AND 'J', RESPECTIVELY.
         N    $EQU 12
         J    $EQU 13
"
" *** SPECIAL REGISTER USAGE ***
"  SINCE 'DPA' IS NOT CHANGED BY ANY CALLED ROUTINES, DATA PADS CAN
" BE CONVENIENTLY USED TO SAVE S-PAD VALUES.  THIS ROUTINE SAVES
" THE FORMAL PARAMETERS PASSED FROM THE HOST IN DPX WITH DPA=4,
" AND ALSO SAVES KEY ARRAY INDICES IN DPX WITH DPA=14.
"
"  FORMAL PARAMETERS SAVED IN DPX  (DPA=4)
"     A      DPX(-4)
"     V         (-3)
"     MAXA      (-2)
"     NN        (-1)
"     MA        ( 0)
"     NWA       ( 1)
"     KKK       ( 2)
"     WS        ( 3)
"
"  LOOP INDEX VALUES SAVED IN DPX  (DPA=14)
"     A(KL)    DPX(-4)
"     A(1)        (-3)
"     WS(KL)      (-2)
"     WS(1)       (-1)
"     KL          ( 0)
"     KU-KL+1     ( 1)
"     OUTER LOOP UPPER LIMIT ( 2)
"     INNER LOOP UPPER LIMIT ( 3)
"
"THIS APAL ROUTINE IS A LOOP-BY-LOOP CONVERSION OF THE FOLLOWING FORTRAN CODE.
"
"        SUBROUTINE SKYSOL(A,V,MAXA,NN,MA,NWA,KKK)
"C
"C
"C...........................................................
"C
"C       SOLVE SIMULTANEOUS EQUATIONS IN CORE USING SKYLINE STORAGE
"CMETHODS AND COLUMN REDUCTION SCHEME
"C
"C       A    - MATRIX STORED IN SKYLINE FORM (STARTING WITH DIAG.)
"C       V    - LOAD/DISPLACEMENT VECTORS
"C       MAXA - ADDRESS OF DIAGONAL ELEMENT OF EACH COLUMN
"C       NN   - SIZE OF STIFFNESS MATRIX
"C       MA   - MAX COLUMN HEIGHT (1ST ENTRY TO DIAGONAL)
"C       NWA  - TOTAL NUMBER OF ELEMENTS STORED
"C       KKK  - CONTROL ARGUMENT (KKK=1,2,3 FOR FACTOR ONLY,
"C             REDUCTION AND BACKSUB ONLY, COMPLETE SOLUTION)
"C
"C.....................................................................
"        DIMENSION A(1000),V(100),MAXA(101)
"C
"        IF(NN.EQ.1.AND.KKK.EQ.1) RETURN
"       IF(KKK.EQ.2) GO TO 700
"        DO 200 N=2,NN
"        KL=MAXA(N)+1
"        KU=MAXA(N+1)-1
"        IF(KU-KL) 200,210,210
"210     B=0.0
"C
"        KN=MAXA(N)
"        K=N
"        DO 220 KK=KL,KU
"        K=K-1
"        KI=MAXA(K)
"        C=A(KK)/A(KI)
"        B=B+C*A(KK)
"220     A(KK)=C
"        A(KN)=A(KN)-B
"C
"226     MR=MIN0(MA-1,NN-N)
"        IF(MR) 200,200,228
"228     MN=KU-KL+1
"C
"        DO 240 J=1,MR
"        MJ=MAXA(N+J)+J
"        MNJ=MAXA(N+J+1)-MJ-1
"        IF(MNJ) 240,240,230
"230     ND=MIN0(MN,MNJ)
"        C=0.0
"        KU=KN+ND
"        IC=MJ-KN
"        DO 300 KK=KL,KU
"300     C=C+A(KK)*A(KK+IC)
"        A(KN+IC)=A(KN+IC)-C
"240     CONTINUE
"C
"200     CONTINUE
"        IF(KKK.EQ.1) RETURN
"C
"700     DO 400 N=2,NN
"        KL=MAXA(N)+1
"        KU=MAXA(N+1)-1
"        IF(KU-KL) 400,410,410
"410     K=N
"        C=0.0
"        DO 420 KK=KL,KU
"        K=K-1
"420     C=C+A(KK)*V(K)
"        V(N)=V(N)-C
"400     CONTINUE
"800     DO 480 N=1,NN
"        K=MAXA(N)
"480     V(N)=V(N)/A(K)
"        IF(NN.EQ.1) RETURN
"        N=NN
"        DO 500 L=2,NN
"        KL=MAXA(N)+1
"        KU=MAXA(N+1)-1
"        IF(KU-KL) 500,510,510
"510     K=N
"        DO 520 KK=KL,KU
"        K=K-1
"520     V(K)=V(K)-A(KK)*V(N)
"500     N=N-1
"        RETURN
"        END
SKYSOL:  MOV NN,17                "TEST FOR N.EQ.1
         DEC 17;
          BEQ ZDONE             "EXIT IF COUNT = 0
         BGT .+5
         MOV KKK,17               "RETURN IF N.EQ.1 & KKK.EQ.1
         DEC 17
         BGT .+2
ZDONE:   JMP DONE
         DEC A                    "DECREMENT ARRAY BASE ADDRESSES
         DEC V
         DEC MAXA
         DEC WS
       LDDPA; DB=4             "SAVE FORMAL PARAMETERS AT DPA=4
        MOV 0,0; DPX(-4)<DB; DB=SPFN
        MOV 1,1; DPX(-3)<DB; DB=SPFN
        MOV 2,2; DPX(-2)<DB; DB=SPFN
        MOV 3,3; DPX(-1)<DB; DB=SPFN
        MOV 4,4; DPX(0)<DB; DB=SPFN
        MOV 5,5; DPX(1)<DB; DB=SPFN
        MOV 6,6; DPX(2)<DB; DB=SPFN
        MOV 7,7; DPX(3)<DB; DB=SPFN
         LDSPI 17; DB=2                "BRANCH ON KKK.EQ.2
         SUB KKK,17
         BNE .+2
         JMP SN700
         LDSPI N; DB=2                 "INITIALIZE N
         LDDPA; DB=14                  "MOVE TO INDEX-SAVE DPA
         MOV NN,NN; DPX(2)<DB; DB=SPFN "SAVE UPPER LIMIT IN DPX(2)
DO200:   LDDPA; DB=4                   "MOVE TO FORMAL PARAMETERS DPA
"SPAD SETUP FOR VINDX2
"JSR VINDX2(A(1),MAXA(N-1),-1,WS(1),1,KU-KL+1)
         LDSPI 2; DB=-1           "SP(2)=-1
         LDSPI 1; DB=DPX(-2)      "SP(1)=DECREMENTED 'MAXA' BASE ADDR
         ADD N,1; SETMA           "SP(1)=MAXA(N) & FETCH {MAXA(N)}
         DEC 1                    "SP(1)=MAXA(N-1)
         INCMA                    "FETCH {MAXA(N+1)}
         LDSPI 17; DPX(2)<DB; DB=MD  "SP(17)=DPX(2)={MAXA(N)}=KN
         LDSPI 4; DB=1            "SP(4)=1
         LDSPI 5; DB=MD           "SP(5)={MAXA(N+1)}
         LDSPI 0; DB=DPX(-4)      "SP(0)=DECREMENTED 'A' BASE ADDR
         LDSPI 3; DB=DPX(3)       "SP(3)=DECREMENTED 'WS' BASE ADDR
         LDDPA; DB=14             "MOVE TO INDEX-SAVE DPA
         INC 17; DPX(0)<DB; DB=SPFN       "DPX(0)=KL
         SUB 17,5;  DPX(1)<DB; DB=SPFN    "SP(5)=DPX(1)=KU-KL+1
         BGT .+2
         JMP SN200
         ADD# 17,0; DPX(-4)<DB; DB=SPFN   "DPX(-4)=A(KL)
         INC 0; DPX(-3)<DB; DB=SPFN       "SP(0)=DPX(-3)=A(1)
         ADD# 17,3; DPX(-2)<DB; DB=SPFN   "DPX(-2)=WS(KL)
         INC 3; DPX(-1)<DB; DB=SPFN       "SP(3)=DPX(-1)=WS(1)
         LDDPA; DB=34             "MOVE TO SCRATCH DPA
         JSR VINDX2
"SPAD SETUP FOR VDIV
"JSR VDIV(WS(1),1,A(KL),1,WS(1),1,KU-KL+1)
         LDDPA; DB=14             "MOVE TO INDEX-SAVE DPA
         LDSPI 0; DB=DPX(-1)      "SP(0)=WS(1)
         LDSPI 1; DB=1            "SP(1)=1
         LDSPI 2; DB=DPX(-4)      "SP(2)=A(KL)
         LDSPI 3; DB=1            "SP(3)=1
         LDSPI 4; DB=DPX(-1)      "SP(4)=WS(1)
         LDSPI 5; DB=1            "SP(5)=1
         LDSPI 6; DB=DPX(1)       "SP(6)=KU-KL+1
         LDDPA; DB=34             "MOVE TO SCRATCH DPA
         JSR VDIV
"SPAD SETUP FOR DOTPR
"JSR DOTPR(WS(1),1,A(KL),1,A(KN),KU-KL+1)
         LDDPA; DB=14             "MOVE TO INDEX-SAVE SETUP DPA
         LDSPI 5; DB=DPX(1)       "SP(5)=KU-KL+1
         LDSPI 4; DB=DPX(-4)
         DEC 4; SETMA             "SP(4)=A(KN) & FETCH {A(KN)}
         LDSPI 3; DB=1            "SP(3)=1
         LDSPI 2; DB=DPX(-4)      "SP(2)=A(KL)
         LDSPI 1; DB=1            "SP(1)=1
         LDSPI 0; DB=DPX(-1)      "SP(0)=WS(1)
         LDDPA; DB=34             "MOVE TO SCRATCH DPA
         DPY<DB; DB=MD            "SAVE OLD A(KN) ON DPY
         JSR DOTPR
         FSUB DPY,FA              "SUBTRACT DOTPR FROM OLD A(KN)
         FADD
         MOV 4,4; SETMA; MI<FA    "STORE NEW A(KN)
"SPAD SETUP FOR VMOV
"JSR VMOV(WS(1),1,A(KL),1,KU-KL+1)
         LDDPA; DB=14             "MOVE TO INDEX-SAVE DPA
         LDSPI 0; DB=DPX(-1)      "SP(0)=WS(1)
         LDSPI 1; DB=1            "SP(1)=1
         LDSPI 2; DB=DPX(-4)      "SP(2)=A(KL)
         LDSPI 3; DB=1            "SP(3)=1
         LDSPI 4; DB=DPX(1)       "SP(4)=KU-KL+1
         LDDPA; DB=34             "MOVE TO SCRATCH DPA
         JSR VMOV
         LDDPA; DB=4              "MOVE TO FORMAL PARAMETER DPA
         LDSPI 4; DB=DPX(0)
         DEC 4                    "SP(4)=MA1
         LDSPI 17; DB=DPX(-1)     "SP(17)=NN
         SUB N,17                 "SP(17)=NN-N
         SUB# 17,4                "SP(17) = MR = MIN0(MA1,NN-N)
         BGE .+2; MOV 17,17
         MOV 4,17
         BGT .+2                  "BRANCH IF MR.LE.0
         JMP SN200
         LDSPI J; DB=1            "INITIALIZE J
         LDDPA; DB=14             "SAVE UPPER BOUND AT DPX(3)
         MOV 17,17; DPX(3)<DB; DB=SPFN
DO240:   LDDPA; DB=4             "MOVE TO FORMAL PARAMETER DPA
"SPAD SETUP FOR DOTPR
"JSR DOTPR(A(KL),1,A(KL+IC),1,A(MJ),ND)
         LDSPI 4; DB=DPX(-4)      "SP(4)=DECREMENTED 'A' BASE ADDR
         LDSPI 17; DB=DPX(-2)     "SP(17)=DECREMENTED 'MAXA' BASE ADDR
         ADD N,17
         ADD J,17; SETMA          "SP(17)=MAXA(N+J) & FETCH {MAXA(N+J)}
         LDSPI 1; DB=1            "SP(1)=1
         MOV J,16; INCMA          "SP(16)=J & FETCH {MAXA(N+J+1)}
         LDSPI 17; DB=MD          "SP(17)={MAXA(N+J)}
         ADD 17,16                "SP(16)=MJ
         LDSPI 5; DB=MD           "SP(5)={MAXA(N+J+1)}
         SUB 16,5
         DEC 5                    "SP(5)=MNJ
         LDSPI 3; DB=1; BGT .+2   "SP(3)=1 & BRANCH IF MNJ.LE.0
         JMP SN240
         LDDPA; DB=14             "MOVE TO INDEX-SAVE DPA
         LDSPI 0; DB=DPX(-4)      "SP(0)=A(KL)
         LDSPI 2; DB=DPX(-4)      "SP(2)=A(KL)
         LDSPI 17; DB=DPX(1)      "SP(17)=KU-KL+1
         SUB# 5,17                "SP(5) = ND = MIN0(KU-KL+1,MNJ)
         BGE .+2; ADD 16,4; SETMA "SP(4)=A(MJ) & FETCH {A(MJ)}
         MOV 17,5
         LDSPI 17; DB=DPX(0)      "SP(17)=KL
         DEC 17                   "SP(17)=KN
         SUB 17,16                "SP(16)=IC
         ADD 16,2                 "SP(2)=A(KL+IC)
         LDDPA; DB=34             "MOVE TO SCRATCH DPA
         DPY<DB; DB=MD            "SAVE OLD A(MJ) ON DPY
         JSR DOTPR
         FSUB DPY,FA              "SUBTRACT DOTPR FROM OLD A(MJ)
         FADD
         MOV 4,4; SETMA; MI<FA    "STORE NEW A(MJ)
SN240:   LDDPA; DB=14             "GET LOOP UPPER BOUND
         LDSPI 17; DB=DPX(3)
         SUB# 17,J                "INC COUNTER & BRANCH
         BGE .+3
         INC J
         JMP DO240
SN200:   LDDPA; DB=14             "GET LOOP UPPER BOUND
         LDSPI 17; DB=DPX(2)
         SUB# 17,N                "INC COUNTER & BRANCH
         BGE .+3
         INC N
         JMP DO200
          LDDPA; DB=4              "MOVE TO FORMAL PARAMETERS DPA
         LDSPI 17; DB=DPX(2)      "TEST FOR KKK.EQ.1
         DEC 17
         BNE .+2
         JMP DONE
SN700:   LDSPI N; DB=2            "INITIALIZE COUNTER
         LDDPA; DB=4              "GET UPPER BOUND  'NN'
         LDSPI 17; DB=DPX(-1)
         LDDPA; DB=14             "SAVE UPPER BOUND IN DPX(2)
         MOV 17,17; DPX(2)<DB; DB=SPFN
DO400:  LDDPA; DB=4               "MOVE TO FORMAL PARAMETERS DPA
"SPAD SETUP FOR DOTPR
"JSR DOTPR(A(KL),1,V(N-1),-1,V(N),KU-KL+1)
         LDSPI 0; DB=DPX(-4)      "SP(0)=DECREMENTED A BASE ADDR
         LDSPI 1; DB=+1           "SP(1)=+1
         LDSPI 2; DB=DPX(-3)       "SP(2)=DECREMENTED V BASE ADDR
         LDSPI 4; DB=DPX(-3)       "SP(4)=DECREMENTED V BASE ADDR
         LDSPI 17; DB=DPX(-2)     "SP(17)= DECREMENTED MAXA BASE ADDR
         ADD N,17; SETMA          "SP(17)=MAXA(N) & FETCH {MAXA(N)}
         LDSPI 3; DB=-1           "SP(3)=-1
         INCMA                    "FETCH {MAXA(N+1)}
         LDSPI 16; DB=MD          "SP(16)={MAXA(N)}
         INC 16                   "SP(16)=KL
         LDSPI 5; DB=MD           "SP(5)={MAXA(N+1)}
         ADD 16,0                 "SP(0)=A(KL)
         ADD N,4; SETMA           "SP(4)=V(N) & FETCH {V(N)}
         ADD N,2                  "SP(2)=V(N)
         DEC 2                    "SP(2)=V(N-1)
         SUB 16,5                 "SP(5)=KU-KL+1
         BGT .+2
         JMP SN400
         LDDPA; DB=34             "MOVE TO SCRATCH DPA
         DPY<DB; DB=MD            "SAVE OLD V(N) ON DPY
         JSR DOTPR
         FSUB DPY,FA              "SUBTRACT DOTPR FROM OLD V(N)
         FADD
         MOV 4,4; SETMA; MI<FA    "STORE NEW V(N)
SN400:   LDDPA; DB=14             "GET LOOP UPPER BOUND
         LDSPI 17; DB=DPX(2)
         SUB# 17,N                "INC COUNTER & BRANCH
         BGE .+3
         INC N
         JMP DO400
SN800:   LDDPA; DB=4                   "MOVE TO FORMAL PARAMETERS DPA
"SPAD SETUP FOR INDX2
"JSR INDX2(A(1),MAXA(1),1,WS(1),1,NN)
         LDSPI 0; DB=DPX(-4)      "
         INC 0                    "SP(0)=A(1)
         LDSPI 1; DB=DPX(-2)
         INC 1                    "SP(1)=MAXA(1)
         LDSPI 2; DB=1            "SP(2)=1
         LDSPI 3; DB=DPX(3)       "
         INC 3                    "SP(3)=WS(1)
         LDSPI 4; DB=1            "SP(4)=1
         LDSPI 5; DB=DPX(-1)      "SP(5)=NN
         LDDPA; DB=34             "MOVE TO SCRATCH DPA
         JSR VINDX2
         LDDPA; DB=4              "MOVE TO FORMAL-PARAMETERS DPA
"SPAD SETUP FOR VDIV
"JSR VDIV(WS(1),1,V(1),1,V(1),1,NN)
         LDSPI 0; DB=DPX(3)       "
         INC 0                    "SP(0)=WS(1)
         LDSPI 1; DB=1            "SP(1)=1
         LDSPI 2; DB=DPX(-3)      "
         INC 2                    "SP(2)=V(1)
         LDSPI 3; DB=1
         MOV 2,4                  "SP(4)=V(1)
         MOV 3,5                  "SP(5)=1
         LDSPI 6; DB=DPX(-1)      "SP(6)=NN
         LDDPA; DB=34                  "MOVE TO SCRATCH DPA
         JSR VDIV
         LDSPI J; DB=2            "INITIALIZE COUNTER
         LDDPA; DB=4              "GET LOOP UPPER BOUND 'NN'
         LDSPI 17; DB=DPX(-1)
         LDDPA; DB=14             "SAVE LOOP UPPER BOUND IN DPX(2)
         MOV 17,17; DPX(2)<DB; DB=SPFN
DO500:  LDDPA; DB=4               "MOVE TO FORMAL PARAMETERS DPA
"SPAD SETUP FOR VSMA
"JSR VSMA (A(KL),1,WS(N),V(N-1),-1,V(N-1),-1,KU-KL+1)
"     WHERE WS(N)=-V(N)
         LDSPI 3; DB=DPX(-3)       "SP(3)=DECREMENTED V BASE ADDR
         ADD N,3; SETMA           "SP(3)=V(N) & FETCH {V(N)}
         LDSPI 0; DB=DPX(-4)      "SP(0)=DECREMENTED A BASE ADDR
         LDSPI 4; DB=-1           "SP(4)=-1
         FSUB ZERO,MD;            "NEGATE V(N) &
            LDSPI 17; DB=DPX(-2)  " SP(17)=DECREMENTED MAXA BASE ADDR
         ADD N,17; SETMA; FADD     "SP(17)=MAXA(N) & FETCH {MAXA(N)}
         LDSPI 2; DB=DPX(3)       "SP(2)=DECREMENTED WS BASE ADDR
         INCMA; MOV 4,6           "FETCH {MAXA(N+1)} & SP(6)=-1
         LDSPI 14; DB=MD          "SP(14)={MAXA(N)}
         ADD N,2; SETMA; MI<FA    "SP(2)=WS(N) & STORE -{V(N)}
         LDSPI 7; DB=MD           "SP(7)={MAXA(N+1)}
         DEC 3                    "SP(3)=V(N-1)
         INC 14                   "SP(14)=KL
         ADD 14,0                 "SP(0)=A(KL)
         MOV 3,5                  "SP(5)=V(N-1)
         SUB 14,7                 "SP(7)=KU-KL+1
         BGT .+2
         JMP SN500
         LDDPA; DB=34             "MOVE TO SCRATCH DPA
         JSR VSMA
SN500:   DEC N
         LDDPA; DB=14             "GET LOOP UPPER BOUND
         LDSPI 17; DB=DPX(2)
         SUB# 17,J                "INC COUNTER & BRANCH
         BGE .+3
         INC J
         JMP DO500
DONE:    RETURN
         $END
         $TITLE VINDX2
        $RADIX 8
         $ENTRY VINDX2,6
" FORM A VECTOR 'C' BY USING THE INTEGER VALUES IN VECTOR 'B' AS THE
"ADDRESSES BY WHICH TO SELECT ELEMENTS OF VECTOR 'A'.
"
" -- USAGE --
"APAL: JSR VINDX2
"SPAD PARAMETERS
         A $EQU 0                 "BASE ADDR FOR SOURCE VECTOR
         B $EQU 1                 "BASE ADDR FOR INDEX VECTOR
         J $EQU 2                 "INDEX VECTOR INCREMENT
         C $EQU 3                 "BASE ADDR FOR DESTINATION VECTOR
         K $EQU 4                 "DESTINATION VECTOR INCREMENT
         N $EQU 5                 "ELEMENT COUNT
VINDX2:  MOV B,B; SETMA           "FETCH B(0)
         DEC A                    "DECREMENT 'A' BASE ADDRESS
         SUB K,C                  "DECREMENT 'C' BASE ADDRESS
LOOP:    NOP;
            LDSPI 17; DB=MD       "SP(17)=B(M)
         NOP;
            ADD# 17,A; SETMA      "FETCH A(B(M+1))
         NOP;
            NOP
         ADD J,B; SETMA;          "FETCH B(M+1)
            NOP
         NOP;
            DEC N                 "DECREMENT COUNTER
         NOP;
            ADD K,C; SETMA; MI<MD; BGT LOOP  "STORE C(M) & BRANCH
         RETURN
         $END
" ***** SPMSRC = SPARSE MATRIX LIBRARY /COMMON/ = REL 1.1, JAN 79 *****
"
"     ---HISTORY---
"REV 1.1, JAN 79:
"               1. CORRECTS SCBAK FOR CASE WHERE NO NONZEROS IN A ROW.
"               2. ADDS THE FOLLOWING ROUTINES:
"                    SCUFB  -- SPARSE COMPLEX UNSYMMETRIC FWD ELIM, BACK SUBS
"                    SRSFB  -- SPARSE REAL SYMMETRIC FWD ELIM, BACK SUBS
"                    SRUFB  -- SPARSE REAL UNSYMMETRIC FWD ELIM, BACK SUBS
"                    SRFWD  -- SPARSE REAL FORWARD ELIMINATION
"                    SRBAK  -- SPARSE REAL BACK SUBSTITUTION
"
"****** SCSFB = SPARSE CMPLX SYMM FWD ELIM BACK SUBS/COMMON/ = REL 1.1, OCT 79
"USING MD ONLY
        $TITLE SCSFB
        $RADIX 8
        $ENTRY SCSFB,6.
        $EXT SCFWD,CVMUL,SCBAK
"
"      ---ABSTRACT---
"GIVEN A SPARSE COMPLEX SYMMETRIC COEFFICIENT MATRIX
"THAT HAS BEEN FACTORED INTO LU (LOWER/UPPER TRIANGULAR) FORM, AND STORED
"IN PACKED FORM, THIS ROUTINE COMPLETES THE SOLUTION OF THE COMPLEX EQUATIONS
"BY PERFORMING THE FORWARD AND BACK SUBSTITUTION.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN ROUTINE:
"-----------------------------------------------------
"        SUBROUTINE SCSFB(N,XR,XI,ULR,ULI,DR,DI,IRP,IND,ISKEW)
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF NONZEROS IN L (OR U)
"C       XR = REAL PART OF RIGHT HAND SIDE, B,  (DIMENSION N)
"C       XI = IMAG   "   "    "    "    "   "          "
"C             (SOLUTION X WILL REPLACE B IN XR AND XI)
"C       ULR= REAL PART OF NONZERO VALUES OF L (OR U)  (DIMENSION M)
"C       ULI= IMAG  "    "     "      "     "    "            "
"C       DR = REAL PART OF DIAGONAL ELEMENTS           (DIMENSION N)
"C       DI = IMAG  "    "     "      "                       "
"C       IRP= ARRAY OF ROW POINTERS TO ULR,ULI, AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"        DIMENSION XR(1),XI(1),ULR(1),ULI(1),DR(1),DI(1),IRP(1),IND(1)
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=IRP(I)
"        LAST=IRP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FACR=XR(I)
"        FACI=XI(I)
"        IF(FACR.EQ.0.AND.FACI.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.NE.ISKEW)GO TO 40
"C---------SPECIAL CODE FOR SKEW-SYMMETRIC COMPONENT OF NONZERO----
"                K=IND(JJ+1)
"                XR(K)=XR(K)+FACR*ULR(JJ)-FACI*ULI(JJ)
"                XI(K)=XI(K)+FACI*ULR(JJ)+FACR*ULI(JJ)
"                GO TO 50
"C--------END OF SPECIAL SKEW CODE---
"40              XR(K)=XR(K)-FACR*ULR(JJ)+FACI*ULI(JJ)
"                XI(K)=XI(K)-FACI*ULR(JJ)-FACR*ULI(JJ)
"50              CONTINUE
"100     CONTINUE
"C
"C    DIAGONAL ELEMENTS * SOLUTION VECTOR
"C
"        DO 200 I=1,N
"        TEMPR=DR(I)*XR(I)-DI(I)*XI(I)
"        XI(I)=DI(I)*XR(I)+DR(I)*XI(I)
"        XR(I)=TEMPR
"200     CONTINUE
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.EQ.ISKEW)K=IND(JJ+1)
"                XR(II)=XR(II)-XR(K)*ULR(JJ)+XI(K)*ULI(JJ)
"                XI(II)=XI(II)-XI(K)*ULR(JJ)-XR(K)*ULI(JJ)
"250             CONTINUE
"300     CONTINUE
"        RETURN
"        END
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE COMPLEX MATRIX COEFFICIENTS AND THEIR COLUMN INDEX
"ARE STORED IN INTERLEAVED FASHION IN VECTOR UL.  THE COMPLEX FULL VECTOR
"IS STORED IN INTERLEAVED FASHION IN VECTOR X.  THE COMPLEX DIAGONAL
"ELEMENTS ARE STORED IN INTERLEAVED FASHION IN THE VECTOR D.
"
"      ---HISTORY---
"ORIGINAL:  JUN 78  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY
"SIZE:      22 + SCFWD (51) + CVMUL (25 FAST, 26 STND) + SCBAK (52)
"                      = 150 FAST, 151 STND LOCATIONS
"SPEED:
"SCSFB SETUP TIME: 3.83 US
"SCFWD
"EXECUTION      BEST     TYPICAL      WORST  SETUP/COL(US) SETUP(US)
"TIME/LOOP:     2.0        2.0         2.0       2.33      1.33  167 NS MEMORY
" (US):         2.5        2.5         2.5       2.67      1.33  333 NS MEMORY
"CVMUL
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     1.0        1.0         1.0          2.2           167 NS MEMORY
" (US):         2.0        2.0         2.0          2.0           333 NS MEMORY
"SCBAK
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     1.67       1.67        1.67   2.83-3.13     3.0  167 NS MEMORY
" (US):         1.83       1.83        1.83   3.33-4.13     3.0  333 NS MEMORY
"
"THUS TOTAL EXECUTION TIME FOR N EQUATIONS WITH M NONDIAGONAL NONZEROS IN L (OR
"       3.67M + (6.17-6.50)N + 10.33  US        167 NS MEMORY
"       4.33M + (7.87-8.67)N + 10.17  US        333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL SCSFB(N,X,IRP,UL,SKEW,D)
"APAL CALL:     JSR SCSFB
"SCRATCH:       SP(0-7,9-15),DPX(-3 TO 2),DPY(-2 TO 3),FA,FM,MD
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N      $EQU     0            "NUMBER OF EQUATIONS
   X      $EQU     1            "BASE ADDR (MD) OF COMPLEX WORK VECTOR
                                "  STORED WITH REALS AND IMAGS INTERLEAVED
   IRP    $EQU     2            "BASE ADDR (MD) OF ILOCF (POINTER TO INDEX LIST)
                                " POINTER IS INTEGER IN LOW MANTISSA
   UL     $EQU     3            "BASE ADDR (MD) OF INFO ON COMPLEX NONZERO
                                "  COEFFICIENTS, STORED AS FOLLOWS:
                                "   UL      COL INDEX OF NONZERO COEFFIC   1
                                "   UL+1    REAL PART OF   '       '       '
                                "   UL+2    IMAG PART '    '       '       '
                                "   UL+3    COL INDEX '    '       '       2
                                "   UL+4    REAL PART '    '       '       '
                                "   UL+5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   SKEW   $EQU     4            "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
   D      $EQU     5            "BASE ADDR (MD) OF COMPLEX DIAGONAL ELEMENTS
"
SCSFB: MOV N,N; DPX(-1)<SPFN   "SAVE THE INPUT PARAMETERS
        MOV X,X; DPX(-2)<SPFN;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV IRP,IRP; DPX(-3)<SPFN
        MOV UL,UL; DPY(-1)<SPFN
        MOV SKEW,SKEW; DPY(-2)<SPFN
        JSR SCFWD               "DO FORWARD ELIMINATION
                                "CALL SCFWD(N,X,IRP,UL,SKEW)
        LDSPI 0; DB=DPX(-2)     "RESTORE PARAMETERS FOR CVMUL, X
        MOV D,2                 "GET D
        MOV 0,4
        LDSPI 6; DB=DPX(-1)     "GET N
        LDSPI 1; DB=2           "SET ADDRESS INCREMENT OF 2
        MOV 1,3
        MOV 1,5
        LDSPI 7; DB=1           "NORMAL COMPLEX MULTIPLY FLAG
        JSR CVMUL               "DO COMPLEX MULTIPLY BY DIAGONAL ELEMENTS
                                "CALL CVMUL(X,2,D,2,X,2,N,1)
        LDSPI N; DB=DPX(-1)
        LDSPI X; DB=DPX(-2)
        LDSPI IRP; DB=DPX(-3)
        LDSPI UL; DB=DPY(-1)
        LDSPI SKEW; DB=DPY(-2)
        JMP SCBAK               "DO BACK SUBSTITUTION
                                "CALL SCBAK(N,X,IRP,UL,SKEW)
        $END
"****** SCUFB = SPARSE CMPLX UNSYMM FWD ELIM BACK SUB/COMMON/ = REL 1.1, OCT 79
"USING MD ONLY
        $TITLE SCUFB
        $RADIX 8
        $ENTRY SCUFB,7.
        $EXT SCFWD,CVMUL,SCBAK
"
"      ---ABSTRACT---
"GIVEN A SPARSE COMPLEX UNSYMMETRIC COEFFICIENT MATRIX
"THAT HAS BEEN FACTORED INTO LU (LOWER/UPPER TRIANGULAR) FORM, AND STORED
"IN PACKED FORM, THIS ROUTINE COMPLETES THE SOLUTION OF THE COMPLEX EQUATIONS
"BY PERFORMING THE FORWARD AND BACK SUBSTITUTION.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN ROUTINE:
"-----------------------------------------------------
"        SUBROUTINE SCUFB(N,XR,XI,LR,LI,UR,UI,DR,DI,ICP,IRP,INDL,INDU)
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       ML = NUMBER OF NONZEROS IN L
"C       MU =   "     "    "      " U
"C       XR = REAL PART OF RIGHT HAND SIDE, B,  (DIMENSION N)
"C       XI = IMAG   "   "    "    "    "   "          "
"C             (SOLUTION X WILL REPLACE B IN XR AND XI)
"C       LR = REAL PART OF NONZERO VALUES OF L         (DIMENSION ML)
"C       LI = IMAG  "    "     "      "     "    "            "
"C       UR = REAL PART OF NONZERO VALUES OF U         (DIMENSION MU)
"C       UI = IMAG  "    "     "      "     "    "            "
"C       DR = REAL PART OF DIAGONAL ELEMENTS           (DIMENSION N)
"C       DI = IMAG  "    "     "      "                       "
"C       ICP= ARRAY OF COLUMN POINTERS TO LR,LI, AND INDL  (DIMENSION N+1)
"C       IRP= ARRAY OF ROW POINTERS TO UR,UI, AND INDU  (DIMENSION N+1)
"C       INDL= ARRAY OF ROW INDICES FOR NONZEROS BY ROWS (DIMENSION ML)
"C       INDU= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION MU)
"C
"        REAL LR,LI
"        DIMENSION XR(1),XI(1),LR(1),LI(1),UR(1),UI(1),DR(1),DI(1)
"        DIMENSION ICP(1),IRP(1),INDL(1),INDU(1)
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=ICP(I)
"        LAST=ICP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FACR=XR(I)
"        FACI=XI(I)
"        IF(FACR.EQ.0.AND.FACI.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=IFIRST+J-1
"                K=INDL(JJ)
"                XR(K)=XR(K)-FACR*LR(JJ)+FACI*LI(JJ)
"                XI(K)=XI(K)-FACI*LR(JJ)-FACR*LI(JJ)
"50              CONTINUE
"100     CONTINUE
"C
"C    DIAGONAL ELEMENTS * SOLUTION VECTOR
"C
"        DO 200 I=1,N
"        TEMPR=DR(I)*XR(I)-DI(I)*XI(I)
"        XI(I)=DI(I)*XR(I)+DR(I)*XI(I)
"        XR(I)=TEMPR
"200     CONTINUE
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=INDU(JJ)
"                XR(II)=XR(II)-XR(K)*UR(JJ)+XI(K)*UI(JJ)
"                XI(II)=XI(II)-XI(K)*UR(JJ)-XR(K)*UI(JJ)
"250             CONTINUE
"300     CONTINUE
"        RETURN
"        END
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE COMPLEX COEFFICIENTS FOR THE OFF-DIAGONAL
"NONZEROS IN THE LOWER TRIANGULAR MATRIX AND THEIR ROW INDICES ARE STORED
"BY COLUMNS IN INTERLEAVED FASHION IN VECTOR L.  COEFFICIENTS FOR THE OFF-
"DIAGONAL NONZEROS IN THE UPPER TRIANGULAR MATRIX AND THEIR COLUMN INDICES
"ARE STORED BY ROWS IN INTERLEAVED FASHION IN VECTOR U.  THE COMPLEX FULL VECTOR
"IS STORED IN INTERLEAVED FASHION IN VECTOR X.  THE COMPLEX DIAGONAL
"ELEMENTS ARE STORED IN INTERLEAVED FASHION IN THE VECTOR D.
"
"      ---HISTORY---
"ORIGINAL:  JAN 79  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY
"SIZE:      22 + SCFWD (51) + CVMUL (25 FAST, 26 STND) + SCBAK (52)
"                      = 150 FAST, 151 STND LOCATIONS
"SPEED:
"SCUFB SETUP TIME: 3.83 US
"SCFWD
"EXECUTION      BEST     TYPICAL      WORST  SETUP/COL(US) SETUP(US)
"TIME/LOOP:     2.0        2.0         2.0       2.33      1.33  167 NS MEMORY
" (US):         2.5        2.5         2.5       2.67      1.33  333 NS MEMORY
"CVMUL
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     1.0        1.0         1.0          2.2           167 NS MEMORY
" (US):         2.0        2.0         2.0          2.0           333 NS MEMORY
"SCBAK
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     1.67       1.67        1.67   2.83-3.13     3.0  167 NS MEMORY
" (US):         1.83       1.83        1.83   3.33-4.13     3.0  333 NS MEMORY
"
"THUS TOTAL EXECUTION TIME FOR N EQUATIONS WITH ML NONDIAGONAL NONZEROS IN L
"AND MU NONDIAGONAL NONZEROS IN U IS:
"       2.00ML + 1.67MU + (6.17-6.50)N + 10.33  US        167 NS MEMORY
"       2.50ML + 1.83MU + (7.87-8.67)N + 10.17  US        333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL SCUFB(N,X,ICP,L,IRP,U,D)
"APAL CALL:     JSR SCUFB
"SCRATCH:       SP(0-7,9-15),DPX(-3 TO 2),DPY(-1 TO 3),FA,FM,MD
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N      $EQU     0            "NUMBER OF EQUATIONS
   X      $EQU     1            "BASE ADDR (MD) OF COMPLEX WORK VECTOR
                                "  STORED WITH REALS AND IMAGS INTERLEAVED
   ICP    $EQU     2            "BASE ADDR (MD) OF POINTERS TO L
                                " POINTER IS INTEGER IN LOW MANTISSA
   L      $EQU     3            "BASE ADDR (MD) OF INFO ON COMPLEX OFF-DIAGONAL
                                "  NONZERO COEFFICIENTS IN LOWER TRIANGULAR
                                "  MATRIX, STORED BY COLUMNS AS FOLLOWS:
                                "   L       ROW INDEX OF NONZERO COEFFIC   1
                                "   L +1    REAL PART OF   '       '       '
                                "   L +2    IMAG PART '    '       '       '
                                "   L +3    ROW INDEX '    '       '       2
                                "   L +4    REAL PART '    '       '       '
                                "   L +5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " ROW INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   IRP    $EQU     4            "BASE ADDR (MD) OF POINTERS TO U
                                " POINTER IS INTEGER IN LOW MANTISSA
   U      $EQU     5            "BASE ADDR (MD) OF INFO ON COMPLEX OFF-DIAGONAL
                                "  NONZERO COEFFICIENTS IN UPPER TRIANGULAR
                                "  MATRIX, STORED BY ROWS AS FOLLOWS:
                                "   U       COL INDEX OF NONZERO COEFFIC   1
                                "   U +1    REAL PART OF   '       '       '
                                "   U +2    IMAG PART '    '       '       '
                                "   U +3    COL INDEX '    '       '       2
                                "   U +4    REAL PART '    '       '       '
                                "   U +5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   D      $EQU     6            "BASE ADDR (MD) OF COMPLEX DIAGONAL ELEMENTS
"
SCUFB: MOV N,N; DPX(-1)<SPFN   "SAVE THE INPUT PARAMETERS
        MOV X,X; DPX(-2)<SPFN;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV IRP,IRP; DPX(-3)<SPFN
        MOV U,U; DPY(-1)<SPFN
        CLR 4
        JSR SCFWD               "DO FORWARD ELIMINATION
                                "CALL SCFWD(N,X,ICP,L,0)
        LDSPI 0; DB=DPX(-2)     "RESTORE PARAMETERS FOR CVMUL, X
        MOV D,2                 "GET D
        MOV 0,4
        LDSPI 6; DB=DPX(-1)     "GET N
        LDSPI 1; DB=2           "SET ADDRESS INCREMENT OF 2
        MOV 1,3
        MOV 1,5
        LDSPI 7; DB=1           "NORMAL COMPLEX MULTIPLY FLAG
        JSR CVMUL               "DO COMPLEX MULTIPLY BY DIAGONAL ELEMENTS
                                "CALL CVMUL(X,2,D,2,X,2,N,1)
        LDSPI N; DB=DPX(-1)
        LDSPI X; DB=DPX(-2)
        LDSPI 2; DB=DPX(-3)
        LDSPI 3; DB=DPY(-1)
        CLR 4
        JMP SCBAK               "DO BACK SUBSTITUTION
                                "CALL SCBAK(N,X,IRP,U,0)
        $END
"****** SCFWD = SPARSE COMPLEX MATRIX FORWARD ELIM /COMMON/ = REL 1.1, OCT 78 **
"USING MD ONLY
        $TITLE SCFWD
        $RADIX 8
        $ENTRY SCFWD,5.
"
"      ---ABSTRACT---
"PERFORMS FORWARD ELIMINATION ON A SPARSE COMPLEX LOWER TRIANGULAR SYSTEM
"OF EQUATIONS OF THE FORM LX=B, SOLVING X, GIVEN B.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN CODE:
"-----------------------------------------------------
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF OFFDIAGONAL NONZEROS IN L
"C       XR = REAL PART OF RIGHT HAND SIDE, B,  (DIMENSION N)
"C       XI = IMAG   "   "    "    "    "   "          "
"C             (SOLUTION X WILL REPLACE B IN XR AND XI)
"C       LR= REAL PART OF NONZERO VALUES OF L  (DIMENSION M)
"C       LI= IMAG  "    "     "      "     "    "            "
"C       DR = REAL PART OF DIAGONAL ELEMENTS           (DIMENSION N)
"C       DI = IMAG  "    "     "      "                       "
"C       ICP= ARRAY OF COLUMN POINTERS TO LR,LI, AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF ROW INDICES FOR NONZEROS BY COLUMNS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=ICP(I)
"        LAST=ICP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FACR=XR(I)
"        FACI=XI(I)
"        IF(FACR.EQ.0.AND.FACI.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.NE.ISKEW)GO TO 40
"C---------SPECIAL CODE FOR SKEW-SYMMETRIC COMPONENT OF NONZERO----
"                K=IND(JJ+1)
"                XR(K)=XR(K)+FACR*LR(JJ)-FACI*LI(JJ)
"                XI(K)=XI(K)+FACI*LR(JJ)+FACR*LI(JJ)
"                GO TO 50
"C--------END OF SPECIAL SKEW CODE-----
"40              XR(K)=XR(K)-FACR*LR(JJ)+FACI*LI(JJ)
"                XI(K)=XI(K)-FACI*LR(JJ)-FACR*LI(JJ)
" 50             CONTINUE
"100     CONTINUE
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE COMPLEX MATRIX COEFFICIENTS AND THEIR ROW
"INDEX ARE STORED BY COLUMNS IN MD IN INTERLEAVED FASHION IN VECTOR L.  THE
"COMPLEX FULL VECTOR IS STORED IN INTERLEAVED FASHION IN MD IN VECTOR X.
"
"      ---HISTORY---
"ORIGINAL:  JUN 78  R.S. NORIN
" REVISED:  OCT 78  R.S. NORIN    FIXED SKEW ELEMENT PORTION
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY
"SIZE:      51 LOCATIONS
"EXECUTION      BEST     TYPICAL      WORST  SETUP/COLUMN (US) SETUP
"TIME/LOOP:     2.0        2.0         2.0      2.17         2.0   167 NS MEMORY
" (US):         2.5        2.5         2.5      2.41         2.0   333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL SCFWD(N,X,ICP,L,SKEW)
"APAL CALL:     JSR SCFWD
"SCRATCH:       SP(0-3,8-15),DPX(0-2),DPY(0-3),FA,FM,MD
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N      $EQU     0            "NUMBER OF EQUATIONS
   X      $EQU     1            "BASE ADDR OF COMPLEX WORK VECTOR
                                "  STORED WITH REALS AND IMAGS INTERLEAVED
   ICP    $EQU     2            "BASE ADDR OF POINTERS TO L
                                " POINTER IS INTEGER IN LOW MANTISSA
   L     $EQU     3            "BASE ADDR (MD) OF INFO ON COMPLEX NONZERO
                                "  COEFFICIENTS, STORED AS FOLLOWS:
                                "   L      ROW INDEX OF NONZERO COEFFIC   1
                                "   L+1    REAL PART OF   '       '       '
                                "   L+2    IMAG PART '    '       '       '
                                "   L+3    ROW INDEX '    '       '       2
                                "   L+4    REAL PART '    '       '       '
                                "   L+5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " ROW INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   SKEW   $EQU     4            "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
"TEMPORARY STORAGE:
   LO    $EQU    10            "BASE ADDRESS - 6 FOR L
   LOFF  $EQU    11            "TEMPORARY FOR L OFFSET
   TWO    $EQU    12            "2
   THREE  $EQU    13            "3
   XCUR   $EQU    14            "CURRENT XR,XI FOR COLUMN
   NZ     $EQU    15            "COUNTER FOR NONZEROS IN COLUMN
   ROW    $EQU    16            "ROW INDEX OF CURRENT NONZERO IN COLUMN
   ROWW   $EQU    17            "ROW INDEX OF PREVIOUS NONZERO IN COLUMN
   FIRST  $EQU    17            "TEMPORARY
"DATA PADS:
"  DPX(0)   =   FACR (CURRENT XR FOR COLUMN)
"  DPY(0)   =   FACI (CURRENT XI FOR COLUMN)
"  DPX(1)   =   TEMP
"  DPY(1)   =    ' '
"
SCFWD:  LDSPI TWO; DB=2         "2
        LDSPI THREE; DB=3       "3
        SUB TWO,X               "BACK UP XR,XI POINTER
        INC# ICP; SETMA         "GET LOCATION OF
                                "LAST ELEMENT POINTER IN COLUMN
        MOV X,XCUR              "SET POINTER TO CURRENT COLUMN XR,XI
        MOV L,LO              "COMPUTE BASE ADDR L-6
        DECMA;                  "GET LOC OF 1ST ELT PTR IN 1ST COLUMN
         SUB THREE,LO;         "
         DPY(3)<MD              "SAVE LAST ELEMENT POINTER
        SUB THREE,LO
        LDSPI NZ; DB=DPY(3)     "LAST ELEMENT POINTER
        ADD TWO,ICP; SETMA;     "GET LOC OF LAST ELT PTR IN 2ND COLUMN
         DPY(2)<MD              "SAVE 1ST ELEMENT PTR
        MOVL NZ,LOFF           "COMPUTE L OFFSET OF LAST ELT IN COLUMN
        ADD NZ,LOFF;
         BR OLOOP+1             "ENTER OUTER LOOP
"HERE BEGINS THE OUTER LOOP FOR PROCESSING A COLUMN
OLOOP:  LDSPI NZ; DB=DPY(3)     "SAVE LAST PTR LOCATION
        ADD TWO,XCUR; SETMA     "GET CURRENT XR FOR COLUMN=FACR
        LDSPI FIRST; DB=DPY(2)  "GET PTR TO 1ST ELT OF COLUMN
        INCMA;                  "GET CURRENT XI FOR COLUMN=FACI
         MOV LO,L;            "GET L BASE ADDR
         DPY(1)<MD              "SAVE PTR TO LAST ELT OF NEXT COLUMN
        FADD ZERO,MD;           "SEE IF FACR=0
         SUB FIRST,NZ;          "GET NONZERO COUNT
         DPX(0)<MD              "SAVE FACR
        ADD LOFF,L; SETMA;    "5. GET ROW INDEX FOR LAST
         FADD;                  "    NONZERO IN COLUMN
         DPY(2)<DPY(3);         "   LAST PTR BECOMES 1ST FOR NEXT COLUMN
         BNE J1                 "  BRANCH IF NONZEROS IN COLUMN
"HERE IF NO OFF-DIAGONAL NONZEROS IN COLUMN
        LDSPI FIRST; DB=DPY(1)  "COMPUTE OFFSET FOR NEXT COLUMN
        MOVL FIRST,LOFF;
         DPY(3)<DPY(1)
        ADD FIRST,LOFF;
         BR EOLOOP              "EXIT IF NO NONZEROS
"HERE IF THERE ARE NONZEROS TO PROCESS IN COLUMN
J1:     FADD ZERO,MD;           "6. SEE IF FACI=0
         LDSPI FIRST; DB=DPY(1)  "  COMPUTE OFFSET FOR NEXT COLUMN
        INCMA;                  "7. GET LR VALUE
         MOVL FIRST,LOFF;      "   COMPUTING OFFSET FOR NEXT COLUMN
         FADD;                  "   PUSH
         DPY(3)<DPY(1);         "   SAVE LAST PTR FOR NEXT COLUMN
         BFEQ FACR0             "   BRANCH IF FACR=0
"HERE IF FACR NOT 0
        LDSPI ROW; DB=MD;       "8. SAVE ROW INDEX
         DPY(0)<FA              "   SAVE FACI
        INCMA;                  "9. GET LI VALUE
         ADD FIRST,LOFF;       "   OFFSET FOR NEXT COLUMN
         BR COMM                "   PROCEED ON
"HERE IF FACR=0; MUST TEST FACI ALSO
FACR0:  LDSPI ROW; DB=MD;       "8A. SAVE ROW INDEX
         DPY(0)<FA              "    SAVE FACI
        INCMA;                  "9A. GET LI VALUE
         ADD FIRST,LOFF;       "    OFFSET FOR NEXT COLUMN
         BFEQ EOLOOP            "    BRANCH IF FACI ZERO
"HERE IF COLUMN REALLY NEEDS TO BE PROCESSED
COMM:   FMUL DPX(0),MD;         "10. FACR*LR
         SUB SKEW,ROW;          "    IS ELT SKEW COMPONENT?
         DPX(1)<MD;             "    SAVE LR
         BR LOOP                "    GO TO MAIN INNER LOOP
"HERE IS FINAL STATEMENT OF OUTER LOOP.  IT'S HERE TO AVOID BRANCHING PROBLEMS.
FOLOOP: INC ICP; SETMA;         "GET LOCATION FOR
                                "LAST ROW INDEX OF NEXT COLUMN
         BNE OLOOP              "BRANCH IF MORE COLUMNS
DONE:   RETURN                  "EXIT WHEN ALL COLUMNS FINISHED
"HERE BEGINS THE REAL LOOP
LOOP:       ADDL SKEW,ROW;              "1. 2*ROW FOR OFFSET
             BEQ SKEWL                  "   BRANCH IF SKEW ELEMENT
            ADD X,ROW; SETMA;           "2. GET XR
             FMUL DPY(0),DPX(1);        "   FACI*LR
             BR C3                      "   ON TO CYCLE 3
"THIS IS CYCLE 12 OF LOOP, HERE TO AVOID BRANCH PROBLEMS
C12:     SUB SKEW,ROW;                   "12. TEST FOR SKEW-SYMM ELT
            INCMA; MI<FA;                "    WRITE NEW XI
             BNE LOOP                   "    LOOP THRU ALL NONZEROS IN COLUMN
"WE'RE NOW COMPLETING THE OUTER LOOP
EOLOOP: DEC N;                          "SEE IF MORE COLUMNS
         BR FOLOOP                      "GO TO FINAL OUTER LOOP INSTR
"CONTINUATION OF MAIN INNER LOOP, CYCLES 3-11
C3:         FMUL DPY(0),MD;             "3. FACI*LI
            INCMA;                      "   GET XI
            DPY(1)<MD                   "   SAVE LI
            FMUL DPX(0),DPY(1);         "4. FACR*LI
            MOV ROW,ROWW;               "   SAVE 2*ROW IN CASE NEXT ELT SKEW
             DPX(1)<FM                  "   SAVE FACR*LR
        SUB THREE,L; SETMA;            "5. GET NEXT ROW INDEX
            FMUL;                       "   PUSH
             DPY(1)<FM;                 "   SAVE FACI*LR
             DPX(2)<MD                  "   SAVE XR
            FSUBR FM,DPX(1);            "6. FACR*LR-FACI*LI
             FMUL                       "   PUSH
        INCMA;                          "7. GET LR VALUE
            FADD FM,DPY(1);             "   FACI*LR+FACR*LI
             DPY(1)<MD                  "   SAVE XI
        LDSPI ROW; DB=MD;               "8. SAVE ROW INDEX
        INCMA;                          "   GET LI VALUE
            FSUB DPX(2),FA              "   FORM NEW XR
            FSUB DPY(1),FA              "9. FORM NEW XI
COMM1:  FMUL DPX(0),MD;                 "10. FACR*LR
         DPX(1)<MD;                     "    SAVE LR
            MOV ROWW,ROWW; SETMA; MI<FA "   WRITE NEW XR
            FADD;                       "11. PUSH
             DEC NZ;                    "    DECREMENT COUNT
             BR C12                     "    ON TO CYCLE 12
"HERE IF INDEX FLAGS THE SKEW-SYMMETRIC COMPONENT OF THE NEXT NONZERO
SKEWL:      MOV ROWW,ROWW; SETMA;       "2A. GET LAST XR (SYMMETRIC ELT)
             FMUL DPY(0),DPX(1)         "    FACI*LR
            INCMA;                      "3A. GET XI
             FMUL DPY(0),MD;            "    FACI*LI
             DPY(1)<MD                  "    SAVE LI
            FMUL DPX(0),DPY(1);         "4A. FACR*LI
             DPX(1)<FM                  "    SAVE FACR*LR
        SUB THREE,L; SETMA;            "5A. GET NEXT ROW INDEX
            FMUL;                       "    PUSH
             DPY(1)<FM;                 "    SAVE FACI*LR
             DPX(2)<MD                  "    SAVE XR
            FSUBR FM,DPX(1);            "6A. FACR*LR-FACI*LI
             FMUL                       "    PUSH
        INCMA;                          "7A. GET LR VALUE
            FADD FM,DPY(1);             "    FACI*LR+FACR*LI
             DPY(1)<MD                  "    SAVE XI
        LDSPI ROW; DB=MD;               "8A. SAVE ROW INDEX
        INCMA;                          "    GET LI VALUE
            FADD DPX(2),FA              "    FORM NEW XR
            FADD DPY(1),FA;             "9A. FORM NEW XI
            BR COMM1                    "    BACK INTO MAIN LOOP
        $END
"****** SCBAK = SPARSE COMPLEX BACK SUBSTITUTION /COMMON/ = REL 1.1, JAN 79 ****
"USING MD ONLY
        $TITLE SCBAK
        $RADIX 8
        $ENTRY SCBAK,5.
"
"      ---ABSTRACT---
"PERFORMS THE BACK SUBSTITUTION ON COMPLEX SIMULTANEOUS EQUATIONS UX=B, WHERE
"THE UPPER TRIANGULAR COEFFICIENT MATRIX (RESULTING FROM LU DECOMPOSITION) IS
"SPARSE.  SOLVES FOR X, GIVEN FORCING VECTOR B.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN CODE:
"-----------------------------------------------------
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF NONZEROS IN U
"C       XR = REAL PART OF RIGHT HAND SIDE, B,  (DIMENSION N)
"C       XI = IMAG   "   "    "    "    "   "          "
"C             (SOLUTION X WILL REPLACE B IN XR AND XI)
"C       UR= REAL PART OF NONZERO VALUES OF U  (DIMENSION M)
"C       UI= IMAG  "    "     "      "     "    "            "
"C       DR = REAL PART OF DIAGONAL ELEMENTS           (DIMENSION N)
"C       DI = IMAG  "    "     "      "                       "
"C       IRP= ARRAY OF ROW POINTERS TO UR,UI, AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.EQ.ISKEW)K=IND(JJ+1)
"                XR(II)=XR(II)-XR(K)*UR(JJ)+XI(K)*UI(JJ)
"                XI(II)=XI(II)-XI(K)*UR(JJ)-XR(K)*UI(JJ)
"250             CONTINUE
"300     CONTINUE
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE COMPLEX MATRIX COEFFICIENTS AND THEIR COLUMN INDEX
"ARE STORED IN INTERLEAVED FASHION IN VECTOR U.  THE COMPLEX FUL VECTOR
"IS STORED IN INTERLEAVED FASHION IN VECTOR X.
"
"      ---HISTORY---
"ORIGINAL:  JUN 78  R.S. NORIN
" REVISED:  JAN 79  R.S. NORIN    CORRECTS CASE WHERE NO NONZEROS IN A ROW.
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY
"SIZE:      52 LOCATIONS
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     1.67       1.67        1.67   2.83-3.13     3.0  167 NS MEMORY
" (US):         1.83       1.83        1.83   3.33-4.13     3.0  333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL SCBAK(N,X,IRP,U,SKEW)
"APAL CALL:     JSR SCBAK
"SCRATCH:       SP(0-3,9-15),DPX(0-1),DPY(0-3),FA,FM,MD
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N      $EQU     0            "NUMBER OF EQUATIONS
   X      $EQU     1            "BASE ADDR (MD) OF COMPLEX WORK VECTOR
                                "  STORED WITH REALS AND IMAGS INTERLEAVED
   IRP    $EQU     2            "BASE ADDR (MD) OF POINTERS TO U
                                " POINTER IS INTEGER IN LOW MANTISSA
   U     $EQU     3            "BASE ADDR (MD) OF INFO ON COMPLEX NONZERO
                                "  COEFFICIENTS, STORED BY ROWS AS FOLLOWS:
                                "   U      COL INDEX OF NONZERO COEFFIC   1
                                "   U+1    REAL PART OF   '       '       '
                                "   U+2    IMAG PART '    '       '       '
                                "   U+3    COL INDEX '    '       '       2
                                "   U+4    REAL PART '    '       '       '
                                "   U+5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   SKEW   $EQU     4            "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
"TEMPORARY STORAGE:
   TWO    $EQU    11            "2
   THREE  $EQU    12            "3
   XX     $EQU    13            "POINTER TO CURRENT XI FOR ROW
   LAST   $EQU    14            "CURRENT (LAST) VALUE IN IRP
   NZ     $EQU    15            "COUNTER FOR NONZEROS IN ROW
   COL    $EQU    16            "COLUMN INDEX OF CURRENT NONZERO IN ROW
   TP     $EQU    17            "TEMPORARY
   COLL   $EQU    17            "2 * COLUMN INDEX
"DATA PADS:
"  DPY(0)   =   FACR (CURRENT XR FOR ROW)
"  DPY(1)   =   FACI (CURRENT XI FOR ROW)
"  DPX(0-1) =   TEMP
"  DPY(2-3) =    ' '
"
SCBAK:  ADD N,IRP               "POINT TO LAST ROW IN IRP
        DEC IRP; SETMA          "GET LAST NONZERO NR
        LDSPI TWO; DB=2         "2
        SUB TWO,X               "BACK UP POINTER
        MOV X,XX                "POINT TO XR(N)
        ADD N,XX
        ADD N,XX
        LDSPI LAST; DB=MD       "SAVE LAST NONZERO NR
        LDSPI THREE; DB=3       "3
        MOV LAST,NZ             "COMPUTE OFFSET FOR PACKED DATA
        SUB TWO,NZ              "SUBTRACT 2 FROM NR NONZEROS
        MOVL NZ,TP              "AND THEN MUTIPLY BY 3
        ADD NZ,TP
        ADD TP,U
INTM1:  DEC N;                  "DECREMENT ROW COUNT
         BR INTRO
"HERE IS EXIT
DONE:   RETURN                  "EXIT SCBAK
"HERE IS INTRODUCTION TO INNER LOOP
INTRO:  DEC IRP; SETMA;         "GET NONZERO NR FOR START OF ROW
         BEQ DONE               "EXIT IF ALL ROWS ARE DONE
        MOV LAST,NZ             "SAVE NONZERO NR FOR PREVIOUS ROW
        SUB TWO,XX; SETMA       "GET FACR FOR ROW
        LDSPI LAST; DB=MD       "SAVE CURRENT NONZERO NR
        INCMA                   "GET FACI FOR ROW
        SUB LAST,NZ;            "COMPUTE NR NONZEROS IN ROW
         DPY(0)<MD              "SAVE FACR
        MOV U,U; SETMA;       "2. GET COL INDEX FOR LAST NONZERO IN ROW
         BEQ INTM1              "   BRANCH IF NO NONZEROS IN ROW
        DPY(1)<MD               "3. SAVE FACI
        INCMA                   "4. GET UR
        LDSPI COL; DB=MD        "5. SAVE COL INDEX OF LAST NZ IN ROW
        INCMA;                  "6. GET UI
         MOVL COL,COLL          "   2*COL
        SUB# COL,SKEW;          "7. TEST FOR SKEW-SYMM ELEMENT
         DPX(0)<MD              "   SAVE UR
        ADD X,COLL; SETMA;      "8. GET XR
         BEQ SKEW0              "   BRANCH IF SKEW ELEMENT
        DPX(1)<MD               "9. SAVE UI
        INCMA;                  "10. GET XI
         FADD DPY(0),ZERO;      "    PASS CURRENT FACR
         BR LOOP                "    GO TO INNER LOOP
"HERE BEGINS THE OUTER LOOP FOR PROCESSING A ROW
OLOOP:  INCMA; MI<DPY(1);       "STORE NEW FACI
         DEC N;                 "DECREMENT ROW COUNT
         BR INTRO               "CONTINUE ON INTO NEXT ROW INTRO
"HERE BEGINS THE REAL LOOP
LOOP:       FMUL DPX(0),MD;     "1. UR*XR
            FADD
        SUB THREE,U; SETMA;    "2. GET NEXT COL INDEX
            FMUL DPX(1),MD;     "   UI*XR
            DPY(2)<MD           "   SAVE XR IF NEXT ELEMENT SKEW
            FMUL DPX(1),MD      "3. UI*XI
        INCMA;                  "4. GET UR
            FMUL DPX(0),MD;     "   UR*XI
            FSUBR FM,FA;        "   FACR-UR*XR
            DPY(3)<MD           "   SAVE XI IF NEXT ELEMENT SKEW
COMM:   LDSPI COL; DB=MD;       "5. SAVE COL INDEX
            FMUL;               "   PUSH
            FSUBR FM,DPY(1)     "   FACI-UI*XR
        INCMA;                  "6. GET UI
        MOVL COL,COLL;          "   2*COL
            FMUL;               "   PUSH
            FADD FM,FA          "   FACR+UI*XI-UR*XR
        SUB# COL,SKEW;          "7. TEST FOR SKEW-SYMM ELEMENT
         DPX(0)<MD;             "   SAVE UR
            FSUBR FM,FA         "   FACI-UI*XR-UR*XI
        ADD X,COLL; SETMA;      "8. GET XR
         BEQ SKEWL;             "   BRANCH IF ELEMENT IS SKEW
            FADD;               "   PUSH
            DPY(0)<FA           "   SAVE NEW FACR
        DPX(1)<MD;              "9. SAVE UI
            DEC NZ;             "   DECREMENT COUNT
            DPY(1)<FA           "   SAVE NEW FACI
        INCMA;                  "10. GET XI
         FADD DPY(0),ZERO;      "    PASS ON FACR
            BNE LOOP            "    BACK TO BEGINNING OF LOOP
"WE'RE NOW COMPLETING THE OUTER LOOP
EOLOOP: MOV XX,XX; SETMA; MI<DPY(0);  "STORE NEW FACR
         BR OLOOP               "BRANCH TO BEGINNING OF OUTER LOOP
"HERE IF IN INTRO A SKEW ELEMENT IS FOUND
SKEW0:  DPX(1)<MD               "9A. SAVE UI
        INCMA;                  "10A. GET XI
         FADD DPY(0),ZERO       "     PASS ON FACR
"HERE IS REAL LOOP WHERE SKEW ELEMENT IS BEING PROCESSED
SLOOP:      FMUL DPX(0),DPY(2); "1A. UR*(LAST XR)
            FADD
        SUB THREE,U; SETMA;    "2A. GET NEXT COL INDEX
            FMUL DPX(1),DPY(2); "    UI*(LAST XR)
            DPY(2)<MD           "    SAVE XR IF NEXT ELEMENT SKEW
            FMUL DPX(1),DPY(3)  "3A. UI*(LAST XI)
        INCMA;                  "4A. GET UR
            FMUL DPX(0),DPY(3); "    UR*(LAST XI)
            FSUBR FM,FA;        "    FACR-UR*XI
            DPY(3)<MD;          "    SAVE XI IF NEXT ELEMENT SKEW
            BR COMM             "    GO ON TO MAIN INNER LOOP
"HERE IS LAST PART OF REAL LOOP WHERE SKEW ELEMENT PROCESSING STARTS
SKEWL:  DPX(1)<MD;              "9A. SAVE UI
            DEC NZ;             "    DECREMENT COUNT
            DPY(1)<FA           "    SAVE NEW FACI
        INCMA;                  "10A. GET XI
         FADD DPY(0),ZERO;      "     PASS ON FACR
            BNE SLOOP           "    GO TO NEXT NONZERO
        BR EOLOOP               "GO TO END OF OUTER LOOP
        $END
"****** SRSFB = SPARSE REAL SYMM FWD ELIM BACK SUB /COMMON/ = REL 1.1, OCT 79 *
"USING MD ONLY
        $TITLE SRSFB
        $RADIX 8
        $ENTRY SRSFB,6.
        $EXT SRFWD,VMUL,SRBAK
"
"      ---ABSTRACT---
"GIVEN A SPARSE REAL SYMMETRIC COEFFICIENT MATRIX
"THAT HAS BEEN FACTORED INTO LU (LOWER/UPPER TRIANGULAR) FORM, AND STORED
"IN PACKED FORM, THIS ROUTINE COMPLETES THE SOLUTION OF THE REAL EQUATIONS
"BY PERFORMING THE FORWARD AND BACK SUBSTITUTION.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN ROUTINE:
"-----------------------------------------------------
"        SUBROUTINE SRSFB(N,X,UL,D,IRP,IND,ISKEW)
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF NONZEROS IN L (OR U)
"C       X = RIGHT HAND SIDE, B,  (DIMENSION N)
"C             (SOLUTION X WILL REPLACE B IN X )
"C       UL= NONZERO VALUES OF L (OR U)  (DIMENSION M)
"C       D = DIAGONAL ELEMENTS           (DIMENSION N)
"C       IRP= ARRAY OF ROW POINTERS TO UL AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"        DIMENSION X(1),UL(1),D(1),IRP(1),IND(1)
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=IRP(I)
"        LAST=IRP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FAC=X(I)
"        IF(FAC.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.NE.ISKEW)GO TO 40
"C---------SPECIAL CODE FOR SKEW-SYMMETRIC COMPONENT OF NONZERO----
"                K=IND(JJ+1)
"                X(K)=X(K)+FAC*UL(JJ)
"                GO TO 50
"C--------END OF SPECIAL SKEW CODE---
"40              X(K)=X(K)-FAC*UL(JJ)
"50              CONTINUE
"100     CONTINUE
"C
"C    DIAGONAL ELEMENTS * SOLUTION VECTOR
"C
"        DO 200 I=1,N
"        X(I)=D(I)*X(I)
"200     CONTINUE
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.EQ.ISKEW)K=IND(JJ+1)
"                X(II)=X(II)-X(K)*UL(JJ)
"250             CONTINUE
"300     CONTINUE
"        RETURN
"        END
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE REAL MATRIX COEFFICIENTS AND THEIR COLUMN INDEX
"ARE STORED IN INTERLEAVED FASHION IN VECTOR UL.  THE REAL FULL VECTOR
"IS STORED IN VECTOR X.  THE REAL DIAGONAL
"ELEMENTS ARE STORED IN THE VECTOR D.
"
"      ---HISTORY---
"ORIGINAL:  JAN 79  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY
"SIZE:      21 + SRFWD (33) + VMUL (20 FAST, 11 STND) + SRBAK (35)
"                      = 109 FAST, 100 STND LOCATIONS
"SPEED:
"SRSFB SETUP TIME: 3.33 US
"SRFWD
"EXECUTION      BEST     TYPICAL      WORST  SETUP/COL(US) SETUP(US)
"TIME/LOOP:     1.17       1.17        1.17      1.83      2.00  167 NS MEMORY
" (US):         1.58       1.58        1.58      2.17      2.00  333 NS MEMORY
"VMUL
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.83       0.83        0.83         2.17          167 NS MEMORY
" (US):         1.33       1.33        1.33         1.17          333 NS MEMORY
"SRBAK
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     0.92       0.92        0.92   2.50-2.67     2.17 167 NS MEMORY
" (US):         1.09       1.09        1.09   2.67-3.50     2.17 333 NS MEMORY
"
"THUS TOTAL EXECUTION TIME FOR N EQUATIONS WITH M NONDIAGONAL NONZEROS IN L (OR
"       2.09M + (5.17-5.33)N +  9.83  US        167 NS MEMORY
"       2.67M + (6.17-7.00)N +  8.83  US        333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL SRSFB(N,X,IRP,UL,SKEW,D)
"APAL CALL:     JSR SRSFB
"SCRATCH:       SP(0-6,10-15),DPX(-3 TO 2),DPY(-2 TO 3),FA,FM,MD
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N      $EQU     0            "NUMBER OF EQUATIONS
   X      $EQU     1            "BASE ADDR (MD) OF REAL WORK VECTOR
   IRP    $EQU     2            "BASE ADDR (MD) OF POINTERS TO UL
                                " POINTER IS INTEGER IN LOW MANTISSA
   UL     $EQU     3            "BASE ADDR (MD) OF INFO ON REAL NONZERO
                                "  COEFFICIENTS, STORED AS FOLLOWS:
                                "   UL      COL INDEX OF NONZERO COEFFIC   1
                                "   UL+1    VALUE OF  '       '          '
                                "   UL+2    COL INDEX '    '       '       2
                                "   UL+3    VALUE OF  '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   SKEW   $EQU     4            "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
   D      $EQU     5            "BASE ADDR (MD) OF REAL DIAGONAL ELEMENTS
"
SRSFB: MOV N,N; DPX(-1)<SPFN   "SAVE THE INPUT PARAMETERS
        MOV X,X; DPX(-2)<SPFN;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV IRP,IRP; DPX(-3)<SPFN
        MOV UL,UL; DPY(-1)<SPFN
        MOV SKEW,SKEW; DPY(-2)<SPFN
        JSR SRFWD               "DO FORWARD ELIMINATION
                                "CALL SRFWD(N,X,IRP,UL,SKEW)
        LDSPI 0; DB=DPX(-2)     "RESTORE PARAMETERS FOR VMUL, X
        MOV D,2                 "GET D
        MOV 0,4
        LDSPI 6; DB=DPX(-1)     "GET N
        LDSPI 1; DB=1           "SET ADDRESS INCREMENT OF 1
        MOV 1,3
        MOV 1,5
        JSR VMUL               "DO REAL MULTIPLY BY DIAGONAL ELEMENTS
                                "CALL VMUL(X,1,D,1,X,1,N)
        LDSPI N; DB=DPX(-1)
        LDSPI X; DB=DPX(-2)
        LDSPI IRP; DB=DPX(-3)
        LDSPI UL; DB=DPY(-1)
        LDSPI SKEW; DB=DPY(-2)
        JMP SRBAK               "DO BACK SUBSTITUTION
                                "CALL SRBAK(N,X,IRP,UL,SKEW)
        $END
"****** SRUFB = SPARSE REAL UNSYMM FWD ELIM BACK SUB/COMMON/ = REL 1.1, OCT 79
"USING MD ONLY
        $TITLE SRUFB
        $RADIX 8
        $ENTRY SRUFB,7.
        $EXT SRFWD,VMUL,SRBAK
"
"      ---ABSTRACT---
"GIVEN A SPARSE REAL UNSYMMETRIC COEFFICIENT MATRIX
"THAT HAS BEEN FACTORED INTO LU (LOWER/UPPER TRIANGULAR) FORM, AND STORED
"IN PACKED FORM, THIS ROUTINE COMPLETES THE SOLUTION OF THE REAL EQUATIONS
"BY PERFORMING THE FORWARD AND BACK SUBSTITUTION.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN ROUTINE:
"-----------------------------------------------------
"        SUBROUTINE SRUFB(N,X,L,U,D,ICP,IRP,INDL,INDU)
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       ML = NUMBER OF NONZEROS IN L
"C       MU =   "     "    "      " U
"C       X = RIGHT HAND SIDE, B,  (DIMENSION N)
"C             (SOLUTION X WILL REPLACE B IN X )
"C       L = NONZERO VALUES OF L         (DIMENSION ML)
"C       U = NONZERO VALUES OF U         (DIMENSION MU)
"C       D = DIAGONAL ELEMENTS           (DIMENSION N)
"C       ICP= ARRAY OF COLUMN POINTERS TO L AND INDL  (DIMENSION N+1)
"C       IRP= ARRAY OF ROW POINTERS TO U AND INDU  (DIMENSION N+1)
"C       INDL= ARRAY OF ROW INDICES FOR NONZEROS BY ROWS (DIMENSION ML)
"C       INDU= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION MU)
"C
"        REAL L
"        DIMENSION X(1),L(1),U(1),D(1)
"        DIMENSION ICP(1),IRP(1),INDL(1),INDU(1)
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=ICP(I)
"        LAST=ICP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FAC=X(I)
"        IF(FAC.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=IFIRST+J-1
"                K=INDL(JJ)
"                X(K)=X(K)-FAC*L(JJ)
"50              CONTINUE
"100     CONTINUE
"C
"C    DIAGONAL ELEMENTS * SOLUTION VECTOR
"C
"        DO 200 I=1,N
"        X(I)=D(I)*X(I)
"200     CONTINUE
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=INDU(JJ)
"                X(II)=X(II)-X(K)*U(JJ)
"250             CONTINUE
"300     CONTINUE
"        RETURN
"        END
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE REAL COEFFICIENTS FOR THE OFF-DIAGONAL
"NONZEROS IN THE LOWER TRIANGULAR MATRIX AND THEIR ROW INDICES ARE STORED
"BY COLUMNS IN INTERLEAVED FASHION IN VECTOR L.  COEFFICIENTS FOR THE OFF-
"DIAGONAL NONZEROS IN THE UPPER TRIANGULAR MATRIX AND THEIR COLUMN INDICES
"ARE STORED BY ROWS IN INTERLEAVED FASHION IN VECTOR U.  THE REAL FULL VECTOR
"IS STORED IN VECTOR X.  THE REAL DIAGONAL
"ELEMENTS ARE STORED IN THE VECTOR D.
"
"      ---HISTORY---
"ORIGINAL:  JAN 79  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY
"SIZE:      21 + SRFWD (33) + VMUL (20 FAST, 11 STND) + SRBAK (35)
"                      = 109 FAST, 100 STND LOCATIONS
"SPEED:
"SRUFB SETUP TIME: 3.33 US
"SRFWD
"EXECUTION      BEST     TYPICAL      WORST  SETUP/COL(US) SETUP(US)
"TIME/LOOP:     1.17       1.17        1.17      1.83      2.00  167 NS MEMORY
" (US):         1.58       1.58        1.58      2.17      2.00  333 NS MEMORY
"VMUL
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.83       0.83        0.83         2.17          167 NS MEMORY
" (US):         1.33       1.33        1.33         1.17          333 NS MEMORY
"SRBAK
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     0.92       0.92        0.92   2.50-2.67     2.17 167 NS MEMORY
" (US):         1.09       1.09        1.09   2.67-3.50     2.17 333 NS MEMORY
"
"THUS TOTAL EXECUTION TIME FOR N EQUATIONS WITH ML NONDIAGONAL NONZEROS IN L
"AND MU NONDIAGONAL NONZEROS IN U IS:
"       1.17ML + 0.92MU + (5.17-5.33)N +  9.83  US        167 NS MEMORY
"       1.58ML + 1.09MU + (6.17-7.00)N +  8.83  US        333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL SRUFB(N,X,ICP,L,IRP,U,D)
"APAL CALL:     JSR SRUFB
"SCRATCH:       SP(0-6,10-15),DPX(-3 TO 2),DPY(-1 TO 3),FA,FM,MD
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N      $EQU     0            "NUMBER OF EQUATIONS
   X      $EQU     1            "BASE ADDR (MD) OF REAL WORK VECTOR
   ICP    $EQU     2            "BASE ADDR (MD) OF POINTERS TO L
                                " POINTER IS INTEGER IN LOW MANTISSA
   L      $EQU     3            "BASE ADDR (MD) OF INFO ON REAL OFF-DIAGONAL
                                "  NONZERO COEFFICIENTS IN LOWER TRIANGULAR
                                "  MATRIX, STORED BY COLUMNS AS FOLLOWS:
                                "   L       ROW INDEX OF NONZERO COEFFIC   1
                                "   L +1    VALUE OF       '       '       '
                                "   L +2    ROW INDEX '    '       '       2
                                "   L +3    VALUE OF       '       '       '
                                "   L +5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " ROW INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   IRP    $EQU     4            "BASE ADDR (MD) OF POINTERS TO U
                                " POINTER IS INTEGER IN LOW MANTISSA
   U      $EQU     5            "BASE ADDR (MD) OF INFO ON REAL OFF-DIAGONAL
                                "  NONZERO COEFFICIENTS IN UPPER TRIANGULAR
                                "  MATRIX, STORED BY ROWS AS FOLLOWS:
                                "   U       COL INDEX OF NONZERO COEFFIC   1
                                "   U +1    REAL PART OF   '       '       '
                                "   U +2    IMAG PART '    '       '       '
                                "   U +3    COL INDEX '    '       '       2
                                "   U +4    REAL PART '    '       '       '
                                "   U +5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   D      $EQU     6            "BASE ADDR (MD) OF REAL DIAGONAL ELEMENTS
"
SRUFB: MOV N,N; DPX(-1)<SPFN   "SAVE THE INPUT PARAMETERS
        MOV X,X; DPX(-2)<SPFN;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV IRP,IRP; DPX(-3)<SPFN
        MOV U,U; DPY(-1)<SPFN
        CLR 4
        JSR SRFWD               "DO FORWARD ELIMINATION
                                "CALL SRFWD(N,X,ICP,L,0)
        LDSPI 0; DB=DPX(-2)     "RESTORE PARAMETERS FOR VMUL, X
        MOV D,2                 "GET D
        MOV 0,4
        LDSPI 6; DB=DPX(-1)     "GET N
        LDSPI 1; DB=1           "SET ADDRESS INCREMENT OF 1
        MOV 1,3
        MOV 1,5
        JSR VMUL               "DO REAL MULTIPLY BY DIAGONAL ELEMENTS
                                "CALL VMUL(X,1,D,1,X,1,N)
        LDSPI N; DB=DPX(-1)
        LDSPI X; DB=DPX(-2)
        LDSPI 2; DB=DPX(-3)
        LDSPI 3; DB=DPY(-1)
        CLR 4
        JMP SRBAK               "DO BACK SUBSTITUTION
                                "CALL SRBAK(N,X,IRP,U,0)
        $END
"****** SRFWD = SPARSE REAL MATRIX FORWARD ELIM /COMMON/ = REL 1.1, OCT 79 ****
"USING MD ONLY
        $TITLE SRFWD
        $RADIX 8
        $ENTRY SRFWD,5.
"
"      ---ABSTRACT---
"PERFORMS FORWARD ELIMINATION ON A SPARSE REAL LOWER TRIANGULAR SYSTEM
"OF EQUATIONS OF THE FORM LX=B, SOLVING X, GIVEN B.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN CODE:
"-----------------------------------------------------
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF OFFDIAGONAL NONZEROS IN L
"C       X = RIGHT HAND SIDE, B,  (DIMENSION N)
"C             (SOLUTION X WILL REPLACE B IN X)
"C       L= NONZERO VALUES OF L  (DIMENSION M)
"C       D = DIAGONAL ELEMENTS           (DIMENSION N)
"C       ICP= ARRAY OF COLUMN POINTERS TO L AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF ROW INDICES FOR NONZEROS BY COLUMNS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=ICP(I)
"        LAST=ICP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FAC=X(I)
"        IF(FAC.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.NE.ISKEW)GO TO 40
"C---------SPECIAL CODE FOR SKEW-SYMMETRIC COMPONENT OF NONZERO----
"                K=IND(JJ+1)
"                X(K)=X(K)+FAC*L(JJ)
"                GO TO 50
"C--------END OF SPECIAL SKEW CODE-----
"40              X(K)=X(K)-FAC*L(JJ)
" 50             CONTINUE
"100     CONTINUE
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE MATRIX COEFFICIENTS AND THEIR ROW
"INDEX ARE STORED BY COLUMNS IN MD IN INTERLEAVED FASHION IN VECTOR L.  THE
"REAL FULL VECTOR IS STORED IN MD IN VECTOR X.
"
"      ---HISTORY---
"ORIGINAL:  JAN 79  R.S. NORIN
" REVISED:  OCT 79  R.S. NORIN     REVISES INNER LOOP TO ELIMINATE LDMA
"                                  INSTRUCTION WHICH INADVERTENTLY RESET
"                                  PAGE TO 0.  IN THE PROCESS THE INNER
"                                  LOOP SPEED IS NOT CHANGED AND THE
"                                  SETUP PER ROW IS ACTUALLY SHORTENED
"                                  BY 2 CYCLES.
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY
"SIZE:      33 LOCATIONS
"EXECUTION      BEST     TYPICAL      WORST  SETUP/COLUMN (US) SETUP
"TIME/LOOP:     1.17       1.17        1.17     1.83         2.00  167 NS MEMORY
" (US):         1.58       1.58        1.58     2.17         2.00  333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL SRFWD(N,X,ICP,L,SKEW)
"APAL CALL:     JSR SRFWD
"SCRATCH:       SP(0-4,10-15),DPX(0),DPY(0-3),FA,FM,MD
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N      $EQU     0            "NUMBER OF EQUATIONS
   X      $EQU     1            "BASE ADDR OF REAL WORK VECTOR
   ICP    $EQU     2            "BASE ADDR OF POINTERS TO L
                                " POINTER IS INTEGER IN LOW MANTISSA
   L     $EQU     3            "BASE ADDR (MD) OF INFO ON REAL NONZERO
                                "  COEFFICIENTS, STORED AS FOLLOWS:
                                "   L      ROW INDEX OF NONZERO COEFFIC   1
                                "   L+1    REAL PART OF   '       '       '
                                "   L+2    ROW INDEX '    '       '       2
                                "   L+3    REAL PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " ROW INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   SKEW   $EQU     4            "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
"TEMPORARY STORAGE:
   LO    $EQU    12            "BASE ADDRRESS - 4 FOR L
   LOFF  $EQU    13            "TEMPORARY FOR L OFFSET
   TWO    $EQU    14            "2
   XCUR   $EQU    15            "CURRENT X FOR COLUMN
   NZ     $EQU    16            "COUNTER FOR NONZEROS IN COLUMN
   ROW    $EQU    17            "ROW INDEX OF CURRENT NONZERO IN COLUMN
   FIRST  $EQU    17            "TEMPORARY
"DATA PADS:
"  DPX(0)   =   FAC (CURRENT X FOR COLUMN)
"  DPY(0-1) =    TEMP
"
SRFWD:  LDSPI TWO; DB=2         "2
        DEC X                   "BACK UP X POINTER
        ADD X,SKEW              "ADD BASE ADDRESS TO SKEW INDEX
        INC# ICP; SETMA         "GET LOCATION OF
                                "LAST ELEMENT POINTER IN COLUMN
        MOV X,XCUR              "SET POINTER TO CURRENT COLUMN X
        MOV L,LO              "COMPUTE BASE ADDR L-4
        DECMA;                  "GET LOC OF 1ST ELT PTR IN 1ST COLUMN
         SUB TWO,LO;         "
         DPY(3)<MD              "SAVE LAST ELEMENT POINTER
        SUB TWO,LO
        LDSPI NZ; DB=DPY(3)     "LAST ELEMENT POINTER
        ADD TWO,ICP; SETMA;     "GET LOC OF LAST ELT PTR IN 2ND COLUMN
         DPY(2)<MD              "SAVE 1ST ELEMENT PTR
        MOVL NZ,LOFF;          "COMPUTE L OFFSET OF LAST ELT IN COLUMN
         BR OLOOP+1             "ENTER OUTER LOOP
"HERE BEGINS THE OUTER LOOP FOR PROCESSING A COLUMN
OLOOP:  LDSPI NZ; DB=DPY(3)     "SAVE LAST PTR LOCATION
        INC XCUR; SETMA         "GET CURRENT X FOR COLUMN=FAC
        LDSPI FIRST; DB=DPY(2)  "GET PTR TO 1ST ELT OF COLUMN
        MOV LO,L;               "GET L BASE ADDRR
         DPY(1)<MD              "SAVE PTR TO LAST ELT OF NEXT COLUMN
        FADD ZERO,MD;           "SEE IF FAC=0
         SUB FIRST,NZ;          "GET NONZERO COUNT
         DPX(0)<MD              "SAVE FAC
        ADD LOFF,L; SETMA;    "4. GET ROW INDEX FOR LAST
         FADD;                  "    NONZERO IN COLUMN
         DPY(2)<DPY(3);         "   LAST PTR BECOMES 1ST FOR NEXT COLUMN
         BNE J1                 "  BRANCH IF NONZEROS IN COLUMN
"HERE IF NO OFF-DIAGONAL NONZEROS IN COLUMN
        LDSPI FIRST; DB=DPY(1)  "COMPUTE OFFSET FOR NEXT COLUMN
        MOVL FIRST,LOFF;
         DPY(3)<DPY(1);
         BR EOLOOP              "EXIT IF NO NONZEROS
"HERE IF THERE ARE NONZEROS TO PROCESS IN COLUMN
J1:      LDSPI FIRST; DB=DPY(1); "5. COMPUTE OFFSET FOR NEXT COLUMN
        INCMA                    "  GET L VALUE
        MOVL FIRST,LOFF;         "6. COMPUTING OFFSET FOR NEXT COLUMN
         DPY(3)<DPY(1);         "   SAVE LAST PTR FOR NEXT COLUMN
         BFEQ EOLOOP           "   BRANCH IF FAC=0
"HERE IF FAC NOT 0, SO COLUMN NEEDS PROCESSING
        DPY(0)<MD;                "7. SAVE ROW INDEX
         BR LOOP                  "   ITS ON TO THE MAIN LOOP
"HERE IS FINAL STATEMENT OF OUTER LOOP.  IT'S HERE TO AVOID BRANCHING PROBLEMS.
FOLOOP: INC ICP; SETMA;         "GET LOCATION FOR
                                "LAST ROW INDEX OF NEXT COLUMN
         BNE OLOOP              "BRANCH IF MORE COLUMNS
DONE:   RETURN                  "EXIT WHEN ALL COLUMNS FINISHED
"HERE BEGINS THE REAL LOOP
LOOP:           LDSPI ROW; DB=DPY(0)    "1. SAVE ROW INDEX
                ADD X,ROW; SETMA;       "2. GET X
                FMUL DPX(0),MD          "   FAC*L
                SUB# SKEW,ROW;          "3. TEST FOR SKEW-SYMM ELEMENT
                FMUL                    "   PUSH
        SUB TWO,L; SETMA;               "4. GET ROW INDEX
                FMUL;                   "   PUSH
                BEQ SKEWL               "   BRANCH IF SKEW ELEMENT
        INCMA;                          "5. GET L
                FSUBR FM,MD             "   X-FAC*L
COMM:           FADD;                   "6. PUSH
                DEC NZ                  "   DECREMENT NONZERO COUNT
        DPY(0)<MD;                      "7. SAVE ROW INDEX
                MOV ROW,ROW; SETMA; MI<FA; "STORE NEW X
                BNE LOOP                "   LOOP THRU ALL NONZEROS IN COL
"WE'RE NOW COMPLETING THE OUTER LOOP
EOLOOP: DEC N;                          "SEE IF MORE COLUMNS
         BR FOLOOP                      "GO TO FINAL OUTER LOOP INSTRUCTION
"HERE IF INDEX FLAGS THE SKEW-SYMMETRIC COMPONENT OF THE NEXT NONZERO
SKEWL:  INCMA;                           "5A. GET L
                FADD FM,FA;              "    (LAST X)+FAC*L
                BR COMM                 "    BACK INTO MAIN LOOP
        $END
"****** SRBAK = SPARSE REAL BACK SUBSTITUTION /COMMON/ = REL 1.0, JAN 79 *****
"USING MD ONLY
        $TITLE SRBAK
        $RADIX 8
        $ENTRY SRBAK,5.
"
"      ---ABSTRACT---
"PERFORMS THE BACK SUBSTITUTION ON REAL SIMULTANEOUS EQUATIONS UX=B, WHERE
"THE UPPER TRIANGULAR COEFFICIENT MATRIX (RESULTING FROM LU DECOMPOSITION) IS
"SPARSE.  SOLVES FOR X, GIVEN FORCING VECTOR B.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN CODE:
"-----------------------------------------------------
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF NONZEROS IN U
"C       X = RIGHT HAND SIDE, B,  (DIMENSION N)
"C             (SOLUTION X WILL REPLACE B)
"C       U= NONZERO VALUES OF U  (DIMENSION M)
"C       D = DIAGONAL ELEMENTS           (DIMENSION N)
"C       IRP= ARRAY OF ROW POINTERS TO U AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.EQ.ISKEW)K=IND(JJ+1)
"                X(II)=X(II)-X(K)*U(JJ)
"250             CONTINUE
"300     CONTINUE
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE REAL MATRIX COEFFICIENTS AND THEIR COLUMN INDEX
"ARE STORED IN INTERLEAVED FASHION IN VECTOR U.  THE REAL FULL VECTOR
"IS STORED IN VECTOR X.
"
"      ---HISTORY---
"ORIGINAL:  JAN 79  R.S. NORIN
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY
"SIZE:      35 LOCATIONS
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     0.92       0.92        0.92   2.50-2.67     2.17  167 NS MEMORY
" (US):         1.09       1.09        1.09   2.67-3.50     2.17  333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL SRBAK(N,X,IRP,U,SKEW)
"APAL CALL:     JSR SRBAK
"SCRATCH:       SP(0-3,11-15),DPX(0),DPY(0-1),FA,FM,MD
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N      $EQU     0            "NUMBER OF EQUATIONS
   X      $EQU     1            "BASE ADDR (MD) OF REAL WORK VECTOR
   IRP    $EQU     2            "BASE ADDR (MD) OF POINTERS TO U
                                " POINTER IS INTEGER IN LOW MANTISSA
   U     $EQU     3            "BASE ADDR (MD) OF INFO ON REAL NONZERO
                                "  COEFFICIENTS, STORED BY ROWS AS FOLLOWS:
                                "   U      COL INDEX OF NONZERO COEFFIC   1
                                "   U+1    VALUE OF       '       '       '
                                "   U+2    COL INDEX '    '       '       2
                                "   U+3    VALUE OF       '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   SKEW   $EQU     4            "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
"TEMPORARY STORAGE:
   TWO    $EQU    13            "2
   XX     $EQU    14            "POINTER TO CURENT X FOR ROW
   LAST   $EQU    15            "CURENT (LAST) VALUE IN IRP
   NZ     $EQU    16            "COUNTER FOR NONZEROS IN ROW
   COL    $EQU    17            "COLUMN INDEX OF CURENT NONZERO IN ROW
   TP     $EQU    17            "TEMPORARY
"DATA PADS:
"  DPX(0)   =   TEMP
"  DPY(0-1) =    ' '
"
SRBAK:  ADD N,IRP               "POINT TO LAST ROW IN IRP
        DEC IRP; SETMA          "GET LAST NONZERO NR
        LDSPI TWO; DB=2         "2
        DEC X                   "BACK UP POINTER
        MOV X,XX                "POINT TO X(N)
        ADD N,XX
        LDSPI LAST; DB=MD       "SAVE LAST NONZERO NR
        MOV LAST,NZ             "COMPUTE OFFSET FOR PACKED DATA
        SUB TWO,NZ              "SUBTRACT 3 FROM NR NONZEROS
        MOVL NZ,TP              "AND THEN MUTIPLY BY 2
        ADD TP,U
INTRM2: SUB TWO,U;              "BACK UP POINTER IF DIDNT GO THRU
                                "LOOP ON PREVIOUS ROW
         BR OLOOP                    "START OUTER LOOP
"HERE IS EXIT
DONE:   RETURN                  "EXIT SRBAK
"HERE IS INTRODUCTION TO INNER LOOP
INTRO:  DEC IRP; SETMA;         "GET NONZERO NR FOR START OF ROW
         BEQ DONE               "EXIT IF ALL ROWS ARE DONE
        MOV LAST,NZ             "SAVE NONZERO NR FOR PREVIOUS ROW
        DEC XX; SETMA           "GET FAC FOR ROW
        LDSPI LAST; DB=MD       "SAVE CURENT NONZERO NR
        ADD TWO,U; SETMA        "2. GET COL INDEX FOR LAST NONZERO IN ROW
        SUB LAST,NZ;            "3. COMPUTE NR NONZEROS IN ROW
         FADD ZERO,MD           "   SAVE FAC IN FA
        INCMA;                  "4. GET U
         FADD;
         BEQ INTRM2             "   BRANCH IF NO NONZEROS IN ROW
        LDSPI COL; DB=MD        "5. SAVE COL INDEX OF LAST NZ IN ROW
            ADD# X,COL; SETMA   "1. GET X
        SUB TWO,U; SETMA;       "2. GET NEXT COL INDEX
            DPX(0)<MD           "   SAVE U
        NOP                     "3. WAIT FOR DATA
        INCMA;                  "4. GET U
            DPY(0)<MD           "   SAVE X
        LDSPI COL; DB=MD;       "5. SAVE COL INDEX
            FMUL DPX(0),DPY(0); "   U*X
            BR LOOP             "   GO TO INNER LOOP
"HERE BEGINS THE OUTER LOOP FOR PROCESSING A ROW
OLOOP:  DEC N;                  "DECREMENT ROW COUNT
         BR INTRO               "CONTINUE ON INTO NEXT ROW INTRO
"HERE BEGINS THE REAL LOOP
LOOP:       ADD# X,COL; SETMA;      "1. GET X
                FMUL;
                DPY(1)<DPY(0)       "   SAVE X IF NEXT ELEMENT SKEW
        SUB TWO,U; SETMA;           "2. GET NEXT COL INDEX
            DPX(0)<MD;              "   SAVE U
                FMUL
            SUB SKEW,COL;           "3. TEST FOR SKEW-SYMM ELEMENT
                FSUBR FM,FA         "   FAC-U*X
        INCMA;                      "4. GET U
            DPY(0)<MD;              "   SAVE X
            BEQ SKEWL;              "   BRANCH IF SKEW ELEMENT
                FADD;
                DEC NZ              "   DECREMENT NONZERO COUNT
        LDSPI COL; DB=MD;           "5. SAVE COL INDEX
            FMUL DPX(0),DPY(0);     "   U*X
                BNE LOOP            "    BACK TO BEGINNING OF LOOP
"WE'RE NOW COMPLETING THE OUTER LOOP
EOLOOP: MOV XX,XX; SETMA; MI<FA;      "STORE NEW FAC
         BR OLOOP               "BRANCH TO BEGINNING OF OUTER LOOP
"HERE IF PROCESSING A SKEW ELEMENT
SKEWL:  LDSPI COL; DB=MD;       "5A. SAVE COL INDEX
            FMUL DPX(0),DPY(1); "    U*(LAST X)
                BNE LOOP        "    BACK TO BEGINNING OF LOOP
        BR EOLOOP               "GO TO END OF OUTER LOOP
        $END
" ***** TSMSRC = SPARSE MATRIX LIBRARY FOR TMRAM /COMMON/ = REL 1.1, JAN 79 ****
"
"      ---HISTORY---
"REV 1.1, JAN 79:
"               1. CORRECTS TSCBAK FOR THE CASE WHERE A ROW HAS NO NONZEROS.
"               2. ADDS THE FOLLOWING ROUTINES:
"                    TSCUFB  -- SPARSE COMPLEX UNSYMMETRIC FWD ELIM, BACK SUBS
"                    TSRSFB  -- SPARSE REAL SYMMETRIC FWD ELIM, BACK SUBS
"                    TSRUFB  -- SPARSE REAL UNSYMMETRIC FWD ELIM, BACK SUBS
"                    TSRFWD  -- SPARSE REAL FORWARD ELIMINATION
"                    TSRBAK  -- SPARSE REAL BACK SUBSTITUTION
"
"****** TSCSFB = SPARSE SYMM CMPLX FWD ELIM BACK SUB/COMMON/ = REL 1.1, OCT 79 *
"USING TMRAM AND INTERLEAVED COMPLEX AND PACKED STORAGE
        $TITLE TSCSFB
        $RADIX 8
        $ENTRY TSCSFB,7.
        $EXT TSCFWD,TCVMUL,TSCBAK,MTMOV,TMMOV
"
"      ---ABSTRACT---
"GIVEN A SPARSE COMPLEX SYMMETRIC COEFFICIENT MATRIX
"THAT HAS BEEN FACTORED INTO LU (LOWER/UPPER TRIANGULAR) FORM, AND STORED
"IN PACKED FORM, THIS ROUTINE COMPLETES THE SOLUTION OF THE COMPLEX EQUATIONS
"BY PERFORMING THE FORWARD AND BACK SUBSTITUTION.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN ROUTINE:
"-----------------------------------------------------
"        SUBROUTINE TSCSFB(N,XR,XI,ULR,ULI,DR,DI,IRP,IND,ISKEW)
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF NONZEROS IN L (OR U)
"C       XR = REAL PART OF RIGHT HAND SIDE, B,  (DIMENSION N)
"C       XI = IMAG   "   "    "    "    "   "          "
"C             (SOLUTION X WILL REPLACE B IN XR AND XI)
"C       ULR= REAL PART OF NONZERO VALUES OF L (OR U)  (DIMENSION M)
"C       ULI= IMAG  "    "     "      "     "    "            "
"C       DR = REAL PART OF DIAGONAL ELEMENTS           (DIMENSION N)
"C       DI = IMAG  "    "     "      "                       "
"C       IRP= ARRAY OF ROW POINTERS TO ULR,ULI, AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"        DIMENSION XR(1),XI(1),ULR(1),ULI(1),DR(1),DI(1),IRP(1),IND(1)
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=IRP(I)
"        LAST=IRP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FACR=XR(I)
"        FACI=XI(I)
"        IF(FACR.EQ.0.AND.FACI.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=FIRST+J-1
"                K=IND(JJ)
"                IF(K.NE.ISKEW)GO TO 40
"C---------SPECIAL CODE FOR SKEW-SYMMETRIC COMPONENT OF NONZERO----
"                K=IND(JJ+1)
"                XR(K)=XR(K)+FACR*ULR(JJ)-FACI*ULI(JJ)
"                XI(K)=XI(K)+FACI*ULR(JJ)+FACR*ULI(JJ)
"                GO TO 50
"C-----------------------------------------------------------------
"40              XR(K)=XR(K)-FACR*ULR(JJ)+FACI*ULI(JJ)
"                XI(K)=XI(K)-FACI*ULR(JJ)-FACR*ULI(JJ)
"50              CONTINUE
"100     CONTINUE
"C
"C    DIAGONAL ELEMENTS * SOLUTION VECTOR
"C
"        DO 200 I=1,N
"        TEMPR=DR(I)*XR(I)-DI(I)*XI(I)
"        XI(I)=DI(I)*XR(I)+DR(I)*XI(I)
"        XR(I)=TEMPR
"200     CONTINUE
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.EQ.ISKEW)K=IND(JJ+1)
"                XR(II)=XR(II)-XR(K)*ULR(JJ)+XI(K)*ULI(JJ)
"                XI(II)=XI(II)-XI(K)*ULR(JJ)-XR(K)*ULI(JJ)
"250             CONTINUE
"300     CONTINUE
"        RETURN
"        END
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE COMPLEX MATRIX COEFFICIENTS AND THEIR COLUMN INDEX
"ARE STORED IN INTERLEAVED FASHION IN VECTOR UL.  THE COMPLEX FULL VECTOR
"IS STORED IN INTERLEAVED FASHION IN TMRAM IN VECTOR X.  THE COMPLEX DIAGONAL
"ELEMENTS ARE STORED IN INTERLEAVED FASHION IN MD IN THE VECTOR D.
"
"      ---HISTORY---
"ORIGINAL:  JUN 78  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY AND TMRAM
"SIZE:      31 + TSCFWD (44) + TCVMUL (17) + TSCBAK (44)
"               + MTMOV (6 FAST, 7 STND) + TMMOV (5) = 147 FAST, 148 STND
"SPEED:
"TSCSFB SETUP TIME:  4.5 US
"MTMOV
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.17       0.17        0.17         0.83          167 NS MEMORY
" (US):         0.33       0.33        0.33         0.83          333 NS MEMORY
"TSCFWD
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     1.17       1.17        1.17      2.17      1.33  167 NS MEMORY
" (US):         1.17       1.17        1.17   2.17-2.50    1.33  333 NS MEMORY
"TCVMUL
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     1.0        1.0         1.0          1.83          167 NS MEMORY
" (US):         1.0        1.0         1.0          1.83          333 NS MEMORY
"TSCBAK
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     1.17       1.17        1.17      2.17       3.0  167 NS MEMORY
" (US):         1.17       1.17        1.17   2.17-2.50     3.0  333 NS MEMORY
"TMMOV
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.17       0.17        0.17         0.67          167 NS MEMORY
" (US):         0.33       0.33        0.33         1.67          333 NS MEMORY
"
"THUS TOTAL EXECUTION TIME FOR N EQUATIONS WITH M NONDIAGONAL NONZEROS
"IN L (OR U) IS
"           2.33M +    6.0N      + 12.17        US     167 NS MEMORY
"           2.33M + (6.67-7.33)N + 12.17        US     333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL TSCSFB(N,XMD,X,IRP,UL,SKEW,D)
"APAL CALL:     JSR TSCSFB
"SCRATCH:       SP(0-15),DA,DPX(-4 TO 3),DPY(-2 TO 3),FA,FM,MD,TM
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N   $EQU     0            "NUMBER OF EQUATIONS
   XMD  $EQU     1            "BASE ADDR IN MD FOR RHS AND RESULT
   X    $EQU     2            "BASE ADDR IN TMRAM OF COMPLEX WORK VECTOR
                                "  STORED WITH REALS AND IMAGS INTERLEAVED
   IRP $EQU     3            "BASE ADDR (MD) OF ILOCF (POINTER TO INDEX LIST)
                                " POINTER IS INTEGER IN LOW MANTISSA
   UL  $EQU     4            "BASE ADDR (MD) OF INFO ON COMPLEX NONZERO
                                "  COEFFICIENTS, STORED AS FOLLOWS:
                                "   UL      COL INDEX OF NONZERO COEFFIC   1
                                "   UL+1    REAL PART OF   '       '       '
                                "   UL+2    IMAG PART '    '       '       '
                                "   UL+3    COL INDEX '    '       '       2
                                "   UL+4    REAL PART '    '       '       '
                                "   UL+5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
  SKEW $EQU     5               "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
   D   $EQU     6            "BASE ADDR (MD) OF COMPLEX RECIPROCAL DIAGONAL
                             "  ELEMENTS
"
TSCSFB: MOV N,N; DPX(-1)<SPFN "SAVE THE INPUT PARAMETERS
        MOV XMD,17; DPX(-2)<SPFN;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV X,1; DPX(-3)<SPFN
        MOV IRP,IRP; DPX(-4)<SPFN
        MOV UL,UL; DPY(-1)<SPFN
        MOV SKEW,SKEW; DPY(-2)<SPFN
        MOVL N,2
        MOV 17,0
        JSR MTMOV               "MOVE DATA TO TMRAM
                                "CALL MTMOV(XMD,X,N)
        LDSPI N; DB=DPX(-1)
        LDSPI 1; DB=DPX(-3)
        LDSPI 2; DB=DPX(-4)
        LDSPI 3; DB=DPY(-1)
        LDSPI 4; DB=DPY(-2)
        JSR TSCFWD               "DO FORWARD ELIMINATION
                                 "CALL TSCFWD(N,X,IRP,UL,SKEW)
        LDSPI 0; DB=DPX(-3)     "RESTORE PARAMETERS FOR TCVMUL
        MOV D,1
        LDSPI 2; DB=DPX(-1)
        JSR TCVMUL              "DO COMPLEX MULTIPLY BY DIAGONAL ELEMENTS
                                "CALL TCVMUL(X,D,N)
        LDSPI N; DB=DPX(-1)
        LDSPI 1; DB=DPX(-3)
        LDSPI 2; DB=DPX(-4)
        LDSPI 3; DB=DPY(-1)
        LDSPI 4; DB=DPY(-2)
        JSR TSCBAK               "DO BACK SUBSTITUTION
                                 "CALL TSCBAK(N,X,IRP,UL,SKEW)
        LDSPI 0; DB=DPX(-3)
        LDSPI 1; DB=DPX(-2)
        LDSPI 2; DB=DPX(-1)
        MOVL 2,2
        JMP TMMOV               "MOVE RESULT FROM TM TO MD
                                "CALL TMMOV(X,XMD,N)
        $END
"****** TSCUFB = SPARSE CMPLX UNSYM FWD ELIM,BACK SUB/COMMON/ = REL 1.1, OCT 79
"USING TMRAM AND MD
        $TITLE TSCUFB
        $RADIX 8
        $ENTRY TSCUFB,8.
        $EXT TSCFWD,TCVMUL,TSCBAK,MTMOV,TMMOV
"
"      ---ABSTRACT---
"GIVEN A SPARSE COMPLEX UNSYMMETRIC COEFFICIENT MATRIX
"THAT HAS BEEN FACTORED INTO LU (LOWER/UPPER TRIANGULAR) FORM, AND STORED
"IN PACKED FORM, THIS ROUTINE COMPLETES THE SOLUTION OF THE COMPLEX EQUATIONS
"BY PERFORMING THE FORWARD AND BACK SUBSTITUTION.  TMRAM IS USED AS A
"WORK AREA.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN ROUTINE:
"-----------------------------------------------------
"        SUBROUTINE TSCUFB(N,XR,XI,LR,LI,UR,UI,DR,DI,ICP,IRP,INDL,INDU)
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       ML = NUMBER OF NONZEROS IN L
"C       MU =   "     "    "      " U
"C       XR = REAL PART OF RIGHT HAND SIDE, B,  (DIMENSION N)
"C       XI = IMAG   "   "    "    "    "   "          "
"C             (SOLUTION X WILL REPLACE B IN XR AND XI)
"C       LR = REAL PART OF NONZERO VALUES OF L         (DIMENSION ML)
"C       LI = IMAG  "    "     "      "     "    "            "
"C       UR = REAL PART OF NONZERO VALUES OF U         (DIMENSION MU)
"C       UI = IMAG  "    "     "      "     "    "            "
"C       DR = REAL PART OF DIAGONAL ELEMENTS           (DIMENSION N)
"C       DI = IMAG  "    "     "      "                       "
"C       ICP= ARRAY OF COLUMN POINTERS TO LR,LI, AND INDL  (DIMENSION N+1)
"C       IRP= ARRAY OF ROW POINTERS TO UR,UI, AND INDU  (DIMENSION N+1)
"C       INDL= ARRAY OF ROW INDICES FOR NONZEROS BY ROWS (DIMENSION ML)
"C       INDU= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION MU)
"C
"        REAL LR,LI
"        DIMENSION XR(1),XI(1),LR(1),LI(1),UR(1),UI(1),DR(1),DI(1)
"        DIMENSION ICP(1),IRP(1),INDL(1),INDU(1)
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=ICP(I)
"        LAST=ICP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FACR=XR(I)
"        FACI=XI(I)
"        IF(FACR.EQ.0.AND.FACI.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=IFIRST+J-1
"                K=INDL(JJ)
"                XR(K)=XR(K)-FACR*LR(JJ)+FACI*LI(JJ)
"                XI(K)=XI(K)-FACI*LR(JJ)-FACR*LI(JJ)
"50              CONTINUE
"100     CONTINUE
"C
"C    DIAGONAL ELEMENTS * SOLUTION VECTOR
"C
"        DO 200 I=1,N
"        TEMPR=DR(I)*XR(I)-DI(I)*XI(I)
"        XI(I)=DI(I)*XR(I)+DR(I)*XI(I)
"        XR(I)=TEMPR
"200     CONTINUE
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=INDU(JJ)
"                XR(II)=XR(II)-XR(K)*UR(JJ)+XI(K)*UI(JJ)
"                XI(II)=XI(II)-XI(K)*UR(JJ)-XR(K)*UI(JJ)
"250             CONTINUE
"300     CONTINUE
"        RETURN
"        END
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE COMPLEX COEFFICIENTS FOR THE OFF-DIAGONAL
"NONZEROS IN THE LOWER TRIANGULAR MATRIX AND THEIR ROW INDICES ARE STORED
"BY COLUMNS IN INTERLEAVED FASHION IN VECTOR L.  COEFFICIENTS FOR THE OFF-
"DIAGONAL NONZEROS IN THE UPPER TRIANGULAR MATRIX AND THEIR COLUMN INDICES
"ARE STORED BY ROWS IN INTERLEAVED FASHION IN VECTOR U.  THE COMPLEX FULL VECTOR
"IS STORED IN INTERLEAVED FASHION IN VECTOR XMD.  THE COMPLEX DIAGONAL
"ELEMENTS ARE STORED IN INTERLEAVED FASHION IN THE VECTOR D.  A WORK VECTOR
"X IN TMRAM IS USED TO STORE THE RHS AND RESULTS.
"
"      ---HISTORY---
"ORIGINAL:  JAN 79  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY AND TMRAM
"SIZE:      29 + TSCFWD (44) + TCVMUL (17) + TSCBAK (44)
"               + MTMOV (6 FAST, 7 STND) + TMMOV (5) = 145 FAST, 146 STND
"SPEED:
"TSCUFB SETUP TIME:  4.17 US
"MTMOV
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.17       0.17        0.17         0.83          167 NS MEMORY
" (US):         0.33       0.33        0.33         0.83          333 NS MEMORY
"TSCFWD
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     1.17       1.17        1.17      2.17      1.33  167 NS MEMORY
" (US):         1.17       1.17        1.17   2.17-2.50    1.33  333 NS MEMORY
"TCVMUL
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     1.0        1.0         1.0          1.83          167 NS MEMORY
" (US):         1.0        1.0         1.0          1.83          333 NS MEMORY
"TSCBAK
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     1.17       1.17        1.17      2.17       3.0  167 NS MEMORY
" (US):         1.17       1.17        1.17   2.17-2.50     3.0  333 NS MEMORY
"TMMOV
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.17       0.17        0.17         0.67          167 NS MEMORY
" (US):         0.33       0.33        0.33         1.67          333 NS MEMORY
"
"THUS TOTAL EXECUTION TIME FOR N EQUATIONS WITH ML NONDIAGONAL NONZEROS IN L
"AND MU NONDIAGONAL NONZEROS IN U IS:
"       1.17ML + 1.17MU +      6.00N   + 11.83  US        167 NS MEMORY
"       1.17ML + 1.17MU + (6.67-7.33)N + 11.83  US        333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL TSCUFB(N,XMD,X,ICP,L,IRP,U,D)
"APAL CALL:     JSR TSCUFB
"SCRATCH:       SP(0-15),DA,DPX(-4 TO 3),DPY(-1 TO 3),FA,FM,MD,TM
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N      $EQU     0            "NUMBER OF EQUATIONS
   XMD    $EQU     1            "BASE ADDR (MD) OF COMPLEX WORK VECTOR
                                "  STORED WITH REALS AND IMAGS INTERLEAVED
   X      $EQU     2            "BASE ADDR (TM) OF COMPLEX WORK VECTOR
                                "  STORED WITH REALS AND IMAGS INTERLEAVED
   ICP    $EQU     3            "BASE ADDR (MD) OF POINTERS TO L
                                " POINTER IS INTEGER IN LOW MANTISSA
   L      $EQU     4            "BASE ADDR (MD) OF INFO ON COMPLEX OFF-DIAGONAL
                                "  NONZERO COEFFICIENTS IN LOWER TRIANGULAR
                                "  MATRIX, STORED BY COLUMNS AS FOLLOWS:
                                "   L       ROW INDEX OF NONZERO COEFFIC   1
                                "   L +1    REAL PART OF   '       '       '
                                "   L +2    IMAG PART '    '       '       '
                                "   L +3    ROW INDEX '    '       '       2
                                "   L +4    REAL PART '    '       '       '
                                "   L +5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " ROW INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   IRP    $EQU     5            "BASE ADDR (MD) OF POINTERS TO U
                                " POINTER IS INTEGER IN LOW MANTISSA
   U      $EQU     6            "BASE ADDR (MD) OF INFO ON COMPLEX OFF-DIAGONAL
                                "  NONZERO COEFFICIENTS IN UPPER TRIANGULAR
                                "  MATRIX, STORED BY ROWS AS FOLLOWS:
                                "   U       COL INDEX OF NONZERO COEFFIC   1
                                "   U +1    REAL PART OF   '       '       '
                                "   U +2    IMAG PART '    '       '       '
                                "   U +3    COL INDEX '    '       '       2
                                "   U +4    REAL PART '    '       '       '
                                "   U +5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   D      $EQU     7            "BASE ADDR (MD) OF COMPLEX DIAGONAL ELEMENTS
"
TSCUFB: MOV N,N; DPX(-1)<SPFN "SAVE THE INPUT PARAMETERS
        MOV XMD,17; DPX(-2)<SPFN;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV X,1; DPX(-3)<SPFN
        MOV IRP,IRP; DPX(-4)<SPFN
        MOV D,D; DPY(-1)<SPFN
        MOVL N,2
        MOV 17,0
        JSR MTMOV               "MOVE DATA TO TMRAM
                                "CALL MTMOV(XMD,X,N+N)
        LDSPI N; DB=DPX(-1)
        LDSPI 1; DB=DPX(-3)
        MOV ICP,2
        MOV L,3
        CLR 4
        JSR TSCFWD               "DO FORWARD ELIMINATION
                                 "CALL TSCFWD(N,X,ICP,L,0)
        LDSPI 0; DB=DPX(-3)     "RESTORE PARAMETERS FOR TCVMUL
        LDSPI 1; DB=DPY(-1)
        LDSPI 2; DB=DPX(-1)
        JSR TCVMUL              "DO COMPLEX MULTIPLY BY DIAGONAL ELEMENTS
                                "CALL TCVMUL(X,D,N)
        LDSPI N; DB=DPX(-1)
        LDSPI 1; DB=DPX(-3)
        LDSPI 2; DB=DPX(-4)
        MOV U,3
        JSR TSCBAK               "DO BACK SUBSTITUTION
                                 "CALL TSCBAK(N,X,IRP,U,0)
        LDSPI 0; DB=DPX(-3)
        LDSPI 1; DB=DPX(-2)
        LDSPI 2; DB=DPX(-1)
        MOVL 2,2
        JMP TMMOV               "MOVE RESULT FROM TM TO MD
                                "CALL TMMOV(X,XMD,N+N)
        $END
"****** TSCFWD = SPARSE COMPLEX MATRIX FORWARD ELIM /COMMON/ = REL 1.0, JUN 78 *
"USING TMRAM AND INTERLEAVED COMPLEX AND PACKED STORAGE
        $TITLE TSCFWD
        $RADIX 8
        $ENTRY TSCFWD,5.
"
"      ---ABSTRACT---
"PERFORMS FORWARD ELIMINATION ON A SPARSE COMPLEX LOWER TRIANGULAR SYSTEM
"OF EQUATIONS OF THE FORM LX=B, SOLVING FOR X, GIVEN FORCING VECTOR B.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN CODE:
"-----------------------------------------------------
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF NONZEROS IN L (OR U)
"C       XR = REAL PART OF RIGHT HAND SIDE, B,  (DIMENSION N)
"C       XI = IMAG   "   "    "    "    "   "          "
"C             (SOLUTION X WILL REPLACE B IN XR AND XI)
"C       LR= REAL PART OF NONZERO VALUES OF L (OR U)  (DIMENSION M)
"C       LI= IMAG  "    "     "      "     "    "            "
"C       DR = REAL PART OF DIAGONAL ELEMENTS           (DIMENSION N)
"C       DI = IMAG  "    "     "      "                       "
"C       ICP= ARRAY OF COLUMN POINTERS TO LR,LI, AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF ROW INDICES FOR NONZEROS BY COLUMNS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=ICP(I)
"        LAST=ICP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FACR=XR(I)
"        FACI=XI(I)
"        IF(FACR.EQ.0.AND.FACI.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.NE.ISKEW)GO TO 40
"C---------SPECIAL CODE FOR SKEW-SYMMETRIC COMPONENT OF NONZERO----
"                K=IND(JJ+1)
"                XR(K)=XR(K)+FACR*LR(JJ)-FACI*LI(JJ)
"                XI(K)=XI(K)+FACI*LR(JJ)+FACR*LI(JJ)
"                GO TO 50
"C-----------------------------------------------------------------
"40              XR(K)=XR(K)-FACR*LR(JJ)+FACI*LI(JJ)
"                XI(K)=XI(K)-FACI*LR(JJ)-FACR*LI(JJ)
" 50             CONTINUE
"100     CONTINUE
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE COMPLEX MATRIX COEFFICIENTS AND THEIR ROW INDEX
"ARE STORED IN INTERLEAVED FASHION IN VECTOR L.  THE COMPLEX FULL VECTOR
"IS STORED IN INTERLEAVED FASHION IN TMRAM IN VECTOR X.
"
"      ---HISTORY---
"ORIGINAL:  JUN 78  R.S. NORIN
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY AND TMRAM
"SIZE:      44 LOCATIONS
"EXECUTION      BEST     TYPICAL      WORST  SETUP/COLUMN(US) SETUP(US)
"TIME/LOOP:     1.17       1.17        1.17      2.17       1.33  167 NS MEMORY
" (US):         1.17       1.17        1.17   2.17-2.50     1.33  333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL TSCFWD(N,X,ICP,L,SKEW)
"APAL CALL:     JSR TSCFWD
"SCRATCH:       SP(0-3,7-15),DPX(0-3),DPY(0-3),FA,FM,MD,TM
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N   $EQU     0            "NUMBER OF EQUATIONS
   X    $EQU     1            "BASE ADDR IN TMRAM OF COMPLEX WORK VECTOR
                                "  STORED WITH REALS AND IMAGS INTERLEAVED
   ICP $EQU     2            "BASE ADDR (MD) OF ILOCF (POINTER TO INDEX LIST)
                                " POINTER IS INTEGER IN LOW MANTISSA
   L  $EQU     3            "BASE ADDR (MD) OF INFO ON COMPLEX NONZERO
                                "  COEFFICIENTS, STORED AS FOLLOWS:
                                "   L      ROW INDEX OF NONZERO COEFFIC   1
                                "   L+1    REAL PART OF   '       '       '
                                "   L+2    IMAG PART '    '       '       '
                                "   L+3    ROW INDEX '    '       '       2
                                "   L+4    REAL PART '    '       '       '
                                "   L+5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " ROW INDICES ARE INTEGERS IN LOW MANTISSA
                                "
  SKEW $EQU     4               "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
"TEMPORARY STORAGE:
   ROWW   $EQU     7            "2 * ROW INDEX
   LO    $EQU    10            "BASE ADDRESS - 6 FOR L
   LOFF  $EQU    11            "TEMPORARY FOR L OFFSET
   TWO    $EQU    12            "2
   THREE  $EQU    13            "3
   XCUR  $EQU     14           "POINTER TO CURRENT XR FOR COLUMN
   NZ     $EQU    15            "COUNTER FOR NONZEROS IN COLUMN
   ROW    $EQU    16            "ROW INDEX OF CURRENT NONZERO IN COLUMN
   FIRST  $EQU    17            "TEMPORARY
"DATA PADS:
"  DPX(0)   =   FACR (CURRENT XR FOR COLUMN)
"  DPY(0)   =   FACI (CURRENT XI FOR COLUMN)
"  DPX(1)   =   TEMP
"  DPY(1)   =    ' '
"
TSCFWD: LDSPI TWO; DB=2         "2
        LDSPI THREE; DB=3       "3
        SUB TWO,X;              "BACK UP XR,XI POINTER
         LDDA; DB=5             "SET DA TO TMRAM
        INC# ICP; SETMA         "GET LOCATION OF
                                "LAST ELEMENT POINTER IN COLUMN
        MOV X,XCUR              "SET POINTER TO CURRENT COLUMN XR,XI
        MOV L,LO              "COMPUTE BASE ADDR L-6
        DECMA;                  "GET LOC OF 1ST ELT PTR IN 1ST COLUMN
         SUB THREE,LO;         "
         DPY(3)<MD              "SAVE LAST ELEMENT POINTER
        SUB THREE,LO
        LDSPI NZ; DB=DPY(3)     "LAST ELEMENT POINTER
        ADD TWO,ICP; SETMA;     "GET LOC OF LAST ELT PTR IN 2ND COLUMN
         DPX(3)<MD              "SAVE 1ST ELEMENT PTR
        MOVL NZ,LOFF           "COMPUTE L OFFSET OF LAST ELT IN COLUMN
        ADD NZ,LOFF;
         BR OLOOP+1             "ENTER OUTER LOOP
"HERE IS INTRODUCTION TO INNER LOOP
INTRO:  MOV LO,L           "GET L BASE ADDRESS
        ADD LOFF,L; SETMA; "5. GET ROW INDEX FOR 1ST NONZERO IN COLUMN
         INCTMA;                "   GET CURRENT XI FOR COLUMN=FACI
         DPX(0)<TM              "   SAVE FACR
        LDSPI NZ; DB=DPY(3);    "6. RESTORE LAST PTR LOCATION
         FADD TM,ZERO           "   SEE IF FACR=0
        INCMA;                  "7. GET LR FOR 1ST NONZERO IN COLUMN
         LDSPI LOFF; DB=MD;    "   COMPUTE OFFSET FOR NEXT COLUMN
         DPY(1)<MD              "   SAVE PTR TO LAST ELT OR NEXT COLUMN
        LDSPI FIRST; DB=DPX(3)  "1. GET PTR TO 1ST ELT OF COLUMN
        FADD TM,ZERO;           "2. SEE IF FACI=0
            INCMA;              "   GET LI FOR 1ST NONZERO IN COLUMN
             LDSPI ROW; DB=MD   "   SAVE 1ST ROW INDEX
            FMUL DPX(0),MD;     "3. FACR*LR
             MOVL ROW,ROWW;     "   2 * 1ST ROW INDEX
             DPX(3)<DPY(3)      "   LAST PTR BECOMES 1ST FOR NEXT COLUMN
        SUB FIRST,NZ;           "4. GET NONZERO COUNT
         FADD;
            FMUL TM,MD;         "   FACI*LR
             DPY(3)<DPY(1);     "   SAVE LAST PTR FOR NEXT COLUMN
             BFEQ FACR0         "   BRANCH IF FACR=0
"HERE IF FACR NOT 0
        SUB THREE,L; SETMA;    "5. GET 2ND LR
            FMUL TM,MD;         "   FACI*LI
             DPY(0)<TM;         "   SAVE FACI
             BNE J1             "   BRANCH IF NONZEROS IN COLUMN
"HERE IF NO OFF-DIAGONAL NONZEROS IN COLUMN
NONZ:   MOVL LOFF,FIRST        "COMPUTE OFFSET FOR NEXT COLUMN
NONZ1:  ADD FIRST,LOFF;        "
         BR EOLOOP              "BRANCH TO END OF OUTER LOOP
J1:     MOVL LOFF,FIRST;       "6. COMPUTE OFFSET FOR NEXT COLUMN
            FMUL DPX(0),MD;     "   FACR*LI
             DPY(2)<FM;         "   SAVE FACR*LR
             BR COMM            "   BRANCH ON TO MAIN PART
"HERE BEGINS THE OUTER LOOP FOR PROCESSING A COLUMN
OLOOP:  INC ICP; SETMA;      "GET NONZERO NR FOR START OF NEXT COLUMN
         BEQ DONE               "EXIT IF ALL COLUMNS PROCESSED
        ADD TWO,XCUR; SETTMA;  "GET CURRENT XR FOR COLUMN=FACR
         BR INTRO               "BRANCH TO INTRODUCTION TO INNER LOOP
"HERE IF FACR=0; MUST TEST FACI ALSO
FACR0:  SUB THREE,L; SETMA;    "5A. GET 2ND ROW INDEX
            FMUL TM,MD;         "    FACI*LI
             DPY(0)<TM;         "    SAVE FACI
             BEQ NONZ           "    BRANCH IF NO NONZEROS IN COLUMN
        MOVL LOFF,FIRST;       "6A. COMPUTE OFFSET FOR NEXT COLUMN
            FMUL DPX(0),MD;     "    FACR*LI
             DPY(2)<FM;         "    SAVE FACR*LR
             BFEQ NONZ1         "    BRANCH IF FACI (AND FACR)=0
"HERE IF COLUMN REALLY NEEDS TO BE PROCESSED
COMM:   INCMA;                  "7. GET 2ND LR
            FMUL;               "   PUSH
             DPX(2)<FM;         "   SAVE FACI*LR
             ADD FIRST,LOFF    "   COMPUTE OFFSET FOR NEXT COLUMN
"HERE BEGINS THE REAL LOOP
LOOP:           ADD X,ROWW; SETTMA;     "1. GET XR(ROW)
                 FSUBR FM,DPY(2);       "   FACR*LR-FACI*LI
                 FMUL                   "   PUSH
            INCMA;                      "2. GET LI
             LDSPI ROW; DB=MD;          "   SAVE ROW INDEX
                FADD FM,DPX(2);         "   FACI*LR+FACR*LI
                 INCTMA                 "   GET XI(ROW)
            FMUL DPX(0),MD;             "3. FACR*LR
             MOVL ROW,ROWW;             "   2*ROW
                FSUB TM,FA              "   FORM NEW XR
            FMUL DPY(0),MD;             "4. FACI*LR
             SUB SKEW,ROW;              "   TEST FOR SKEW-SYMM ELT
                FSUB TM,FA              "   FORM NEW XI
COMM1:  SUB THREE,L; SETMA;            "5. GET ROW INDEX
            FMUL DPY(0),MD;             "   FACI*LI
             BEQ SKEWL;                 "   BRANCH IF SKEW COMPONENT
                DPY(1)<FA;              "   SAVE NEW XR
                 FADD                   "   PUSH
            FMUL DPX(0),MD;             "6. FACR*LI
             DPY(2)<FM;                 "   SAVE FACR*LR
                OUT; DECTMA; DB=DPY(1); "   NEW XR TO TMRAM
                 DPX(1)<FA;             "   SAVE NEW XI
                 DEC NZ                 "   DECREMENT COUNT
        INCMA;                          "7. GET LR
            FMUL;                       "   PUSH
             DPX(2)<FM;                 "   SAVE FACI*LR
                OUT; INCTMA; DB=DPX(1); "   NEW XI TO TMRAM
                 BNE LOOP               "   LOOP THRU ALL NONZEROS IN COLUMN
"WE'RE NOW COMPLETING THE OUTER LOOP
EOLOOP: DEC N;                       "SEE IF MORE COLUMNS
         BR OLOOP                       "BRANCH TO BEGINNING OF OUTER LOOP
DONE:   RETURN                          "EXIT WHEN ALL COLUMNS FINISHED
"HERE IF INDEX FLAGS A SKEW-SYMMETRIC ELEMENT
SKEWL:      FMUL DPX(0),MD;             "6A. FACR*LI
             DPY(2)<FM;                 "   SAVE FACR*LR
                OUT; DECTMA; DB=DPY(1); "   NEW XR TO TMRAM
                 DPX(1)<FA;             "   SAVE NEW XI
                 DEC NZ                 "   DECREMENT COUNT
        INCMA;                          "7A. GET LR
            FMUL;                       "   PUSH
             DPX(2)<FM;                 "   SAVE FACI*LR
                OUT; INCTMA; DB=DPX(1); "   NEW XI TO TMRAM
                 BEQ EOLOOP             "   BRANCH IF ALL NONZEROS IN COLUMN DON
"HERE IS BEGINNING OF LOOP WHEN SKEW ELEMENT BEING PROCESSED
                FSUBR FM,DPY(2);        "1A. FACR*LR-FACI*LI
                 FMUL                   "   PUSH
            INCMA;                      "2A. GET LI
             LDSPI ROW; DB=MD;          "    SAVE ROW INDEX
                FADD FM,DPX(2)          "    FACI*LR+FACR*LI
            FMUL DPX(0),MD;             "3A. FACR*LR
             MOVL ROW,ROWW;             "    2*ROW
                FADD DPY(1),FA          "    FORM NEW XR
            FMUL DPY(0),MD;             "4A. FACI*LR
             SUB SKEW,ROW;              "    TEST FOR SKEW-SYMM ELEMENT
                FADD DPX(1),FA;         "    FORM NEW XI
                 BR COMM1               "    BACK INTO MAIN LOOP
        $END
"****** TSCBAK = SPARSE COMPLEX BACK SUBSTITUTION /COMMON/ = REL 1.1, JAN 79 ***
"USING TMRAM AND INTERLEAVED COMPLEX AND PACKED STORAGE
        $TITLE TSCBAK
        $RADIX 8
        $ENTRY TSCBAK,5.
"
"      ---ABSTRACT---
"PERFORMS THE BACK SUBSTITUTION ON COMPLEX SIMUTANEOUS EQUATIONS UX=B, WHERE
"THE UPPER TRIANGUAR COEFFICIENT MATRIX (RESUTING FROM LU DECOMPOSITION) IS
"SPARSE.  SOLVES FOR X, GIVEN THE FORCING VECTOR B
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN CODE:
"-----------------------------------------------------
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF NONZEROS IN L (OR U)
"C       XR = REAL PART OF RIGHT HAND SIDE, B,  (DIMENSION N)
"C       XI = IMAG   "   "    "    "    "   "          "
"C             (SOLUTION X WILL REPLACE B IN XR AND XI)
"C       UR= REAL PART OF NONZERO VALUES OF L (OR U)  (DIMENSION M)
"C       UI= IMAG  "    "     "      "     "    "            "
"C       DR = REAL PART OF DIAGONAL ELEMENTS           (DIMENSION N)
"C       DI = IMAG  "    "     "      "                       "
"C       IRP= ARRAY OF ROW POINTERS TO UR,UI, AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.EQ.ISKEW)K=IND(JJ+1)
"                XR(II)=XR(II)-XR(K)*UR(JJ)+XI(K)*UI(JJ)
"                XI(II)=XI(II)-XI(K)*UR(JJ)-XR(K)*UI(JJ)
"250             CONTINUE
"300     CONTINUE
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE COMPLEX MATRIX COEFFICIENTS AND THEIR COLUMN INDEX
"ARE STORED IN INTERLEAVED FASHION IN VECTOR U.  THE COMPLEX FULL VECTOR
"IS STORED IN INTERLEAVED FASHION IN TMRAM IN VECTOR X.
"
"      ---HISTORY---
"ORIGINAL:  JUN 78  R.S. NORIN
" REVISED:  JAN 79  R.S. NORIN   CORRECTS CASE WHERE NO NONZEROS IN A ROW
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY AND TMRAM
"SIZE:      44 LOCATIONS
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     1.17       1.17        1.17      2.17       3.0  167 NS MEMORY
" (US):         1.17       1.17        1.17   2.17-2.50     3.0  333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL TSCBAK(N,X,IRP,U,SKEW)
"APAL CALL:     JSR TSCBAK
"SCRATCH:       SP(0-3,9-15),DA,DPX(0-2),DPY(0-3),FA,FM,MD,TM
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N   $EQU     0            "NUMBER OF EQUATIONS
   X    $EQU     1            "BASE ADDR IN TMRAM OF COMPLEX WORK VECTOR
                                "  STORED WITH REALS AND IMAGS INTERLEAVED
   IRP $EQU     2            "BASE ADDR (MD) OF ILOCF (POINTER TO INDEX LIST)
                                " POINTER IS INTEGER IN LOW MANTISSA
   U  $EQU     3            "BASE ADDR (MD) OF INFO ON COMPLEX NONZERO
                                "  COEFFICIENTS, STORED AS FOLLOWS:
                                "   U      COL INDEX OF NONZERO COEFFIC   1
                                "   U+1    REAL PART OF   '       '       '
                                "   U+2    IMAG PART '    '       '       '
                                "   U+3    COL INDEX '    '       '       2
                                "   U+4    REAL PART '    '       '       '
                                "   U+5    IMAG PART '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
  SKEW $EQU     4               "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
"TEMPORARY STORAGE:
   TWO    $EQU    11            "2
   THREE  $EQU    12            "3
   XX     $EQU    13            "POINTER TO CURRENT XI FOR ROW
   LAST   $EQU    14            "CURRENT (LAST) VALUE IN IRP
   NZ     $EQU    15            "COUNTER FOR NONZEROS IN ROW
   COL    $EQU    16            "COLUMN INDEX OF CURRENT NONZERO IN ROW
   TP     $EQU    17            "TEMPORARY
   COLL   $EQU    17            "2 * COLUMN INDEX
"DATA PADS:
"  DPX(0)   =   FACR (CURRENT XR FOR ROW)
"  DPY(0)   =   FACI (CURRENT XI FOR ROW)
"  DPX(1,2) =   TEMP
"  DPY(1-3) =    ' '
"
TSCBAK:  ADD N,IRP;        "POINT TO LAST ROW IN IRP
         LDDA; DB=5             "SET DA TO TMRAM
        DEC IRP; SETMA       "GET LAST NONZERO NR
        LDSPI TWO; DB=2         "2
        SUB TWO,X             "BACK UP POINTER
        MOV X,XX            "POINT TO XR(N)
        ADD N,XX
        ADD N,XX; SETTMA   "SET TMA, THO VALUE NOT USED
        LDSPI LAST; DB=MD       "SAVE LAST NONZERO NR
        LDSPI THREE; DB=3       "3
        MOV LAST,NZ             "COMPUTE OFFSET FOR PACKED DATA
        SUB THREE,NZ            "SUBTRACT 3 FROM NR NONZEROS
        MOVL NZ,TP              "AND THEN MUTIPLY BY 3
        ADD NZ,TP
        ADD TP,U
        INC XX                "ADJUST OUTPUT POINTER
        DEC IRP; SETMA       "GET NONZERO NR FOR START OF ROW
"HERE IS INTRODUCTION TO INNER LOOP
INTRO:  DECTMA;                 "GET FACI FOR ROW
         DEC N               "DECREMENT ROW COUNT
        ADD THREE,U; SETMA; "5. GET COL INDEX FOR LAST NONZERO IN ROW
         DECTMA;                "   GET FACR FOR ROW
         BEQ DONE               "   EXIT IF ALL ROWS ARE DONE
        MOV LAST,NZ;            "6. SAVE NONZERO NR FOR PREVIOUS ROW
         DPY(0)<TM              "   SAVE FACI
        INCMA;                  "7. GET UR
         LDSPI LAST; DB=MD      "   SAVE CURRENT NONZERO NR
P1:         LDSPI COL; DB=MD    "1. SAVE COL INDEX OF LAST NZ IN ROW
            INCMA;              "2. GET UI
             MOVL COL,COLL;     "   2 * COL
             DPX(0)<TM          "   SAVE FACR
            ADD# COLL,X; SETTMA; "3. GET XR
             DPX(1)<MD          "   SAVE UR
            SUB# COL,SKEW       "4. IS THIS A SKEW ELEMENT?
        SUB THREE,U; SETMA;    "5. GET NEXT COL INDEX, WORKING
                                "    BACKWARDS ALONG ROW
            DPX(2)<MD;          "    SAVE UI
             BEQ SKEW0          "    BRANCH IF SKEW ELEMENT
        SUB LAST,NZ;            "6. COMPUTE NR NONZEROS IN ROW
            FMUL TM,DPX(1);     "   XR*UR
             FADD ZERO,DPX(1);  "   SAVE UR
             INCTMA;            "   GET XI
             DPY(1)<TM;         "   SAVE XR IN CASE NEXT ELEMENT IS SKEW
             BR NEXT            "   SKIP OVER NEXT TWO INSTRUCTIONS
"HERE BEGINS THE OUTER LOOP FOR PROCESSING A ROW
OLOOP:  DEC IRP; SETMA;      "GET NONZERO NR FOR START OF ROW
         OUT; DB=DPX(0); DECTMA; "STORE NEW FACR
         BR INTRO               "CONTINUE ON INTO NEXT ROW INTRO
DONE:   RETURN                  "EXIT
"HERE IS CYCLE BEFORE BEGINNING OF INNER LOOP
NEXT:   INCMA;                  "7. GET UR
            FMUL TM,DPX(2);     "   XR*UI
             BEQ EOLOOP         "   BRANCH IF NO NONZEROS IN ROW
"HERE BEGINS THE REAL LOOP
LOOP:       LDSPI COL; DB=MD;   "1. SAVE COL INDEX
                FMUL TM,DPX(2); "   XI*UI
                FADD            "   PUSH
            INCMA;              "2. GET UI
             MOVL COL,COLL;     "   2*COL
                FMUL TM,FA;     "   XI*UR
                 FSUBR FM,DPX(0); "   FACR-XR*UR
                 DPY(3)<TM       "   SAVE XI IN CASE NEXT ELEMENT IS SKEW
COMM:       ADD# COLL,X; SETTMA; "3. GET XR
             DPX(1)<MD;         "   SAVE UR
                FSUBR FM,DPY(0); "   FACI-XR*UI
                 FMUL           "   PUSH
            SUB# COL,SKEW;      "4. IS THIS ELEMENT SKEW?
                FADD FM,FA;     "   FACR-XR*UR+XI*UI
                 FMUL;          "   PUSH
                 DPY(2)<DPY(1)  "   PASS ALONG LAST XR
        SUB THREE,U; SETMA;    "5. GET NEXT COL INDEX
            DPX(2)<MD;          "   SAVE UI
             BEQ SKEWL;         "   BRANCH IF SKEW ELEMENT
                FSUBR FM,FA     "   FACI-XR*UI-XI*UR
            FMUL TM,DPX(1);     "6. XR*UR
             FADD ZERO,DPX(1);  "   SAVE UR
             INCTMA;            "   GET XI
             DPY(1)<TM;         "   SAVE XR IN CASE NEXT ELEMENT IS SKEW
                DPX(0)<FA;      "   SAVE NEW FACR
                 DEC NZ         "   DECREMENT NONZERO COUNT
        INCMA;                  "7. GET UR
            FMUL TM,DPX(2);     "   XR*UI
                DPY(0)<FA;      "   SAVE NEW FACI
                 BNE LOOP       "   GO TO NEXT NONZERO
"WE'RE NOW COMPLETING THE OUTER LOOP
EOLOOP: OUT; DB=DPY(0); SUB TWO,XX; SETTMA; "STORE NEW FACI
         BR OLOOP               "BRANCH TO BEGINNING OF OUTER LOOP
"HERE IF IN INTRO A SKEW ELEMENT IS FOUND
SKEW0:      FMUL DPY(2),DPX(1); "6A. (LAST XR)*UR
             FADD ZERO,DPX(1);  "    SAVE UR
             INCTMA;            "    GET XI
             DPY(1)<TM          "    SAVE XR IN CASE NEXT ELEMENT IS SKEW
        INCMA;                  "7A. GET UR
            FMUL DPY(2),DPX(2)  "    (LAST XR)*UI
"HERE IS REAL LOOP WHERE SKEW ELEMENT IS BEING PROCESSED
SLOOP:      LDSPI COL; DB=MD;    "1A. SAVE COL INDEX
                FMUL DPY(3),DPX(2); "    (LAST XI)*UI
                 FADD           "    PUSH
            INCMA;              "2A. GET UI
             MOVL COL,COLL;     "    2*COL
                FMUL DPY(3),FA; "    (LAST XI)*UR
                 FSUBR FM,DPX(0); "    FACR-XR*UR
                 DPY(3)<TM;     "    SAVE XI IN CASE NEXT ELEMENT IS SKEW
                 BR COMM        "    GO ON TO MAIN INNER LOOP
"HERE IS LAST PART OF REAL LOOP WHERE SKEW ELEMENT PROCESSING STARTS
SKEWL:      FMUL DPY(2),DPX(1); "6A. (LAST XR)*UR
             FADD ZERO,DPX(1);  "    SAVE UR
             INCTMA;            "    GET XI
             DPY(1)<TM;         "    SAVE XR IN CASE NEXT ELEMENT IS SKEW
                DPX(0)<FA;      "    SAVE NEW FACR
                 DEC NZ         "    DECREMENT NONZERO COUNT
        INCMA;                  "7A. GET UR
            FMUL DPY(2),DPX(2); "    (LAST XR)*UI
                DPY(0)<FA;      "    SAVE NEW FACI
                 BNE SLOOP      "    GO TO NEXT NONZERO
        BR EOLOOP               "GO TO END OF OUTER LOOP
        $END
"****** TSRSFB = SPARSE REAL SYMM FWD ELIM BACK SUB/COMMON/ = REL 1.1, OCT 79 *
"USING TMRAM AND MD
        $TITLE TSRSFB
        $RADIX 8
        $ENTRY TSRSFB,7.
        $EXT TSRFWD,MTTMUL,TSRBAK,MTMOV,TMMOV
"
"      ---ABSTRACT---
"GIVEN A SPARSE REAL SYMMETRIC COEFFICIENT MATRIX
"THAT HAS BEEN FACTORED INTO LU (LOWER/UPPER TRIANGULAR) FORM, AND STORED
"IN PACKED FORM, THIS ROUTINE COMPLETES THE SOLUTION OF THE REAL EQUATIONS
"BY PERFORMING THE FORWARD AND BACK SUBSTITUTION.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN ROUTINE:
"-----------------------------------------------------
"        SUBROUTINE TSRSFB(N,X,UL,D,IRP,IND,ISKEW)
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF NONZEROS IN L (OR U)
"C       X = RIGHT HAND SIDE, B,  (DIMENSION N)
"C             (SOLUTION X WILL REPLACE B IN X )
"C       UL= NONZERO VALUES OF L (OR U)  (DIMENSION M)
"C       D = DIAGONAL ELEMENTS           (DIMENSION N)
"C       IRP= ARRAY OF ROW POINTERS TO UL AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"        DIMENSION X(1),UL(1),D(1),IRP(1),IND(1)
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=IRP(I)
"        LAST=IRP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FAC=X(I)
"        IF(FAC.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.NE.ISKEW)GO TO 40
"C---------SPECIAL CODE FOR SKEW-SYMMETRIC COMPONENT OF NONZERO----
"                K=IND(JJ+1)
"                X(K)=X(K)+FAC*UL(JJ)
"                GO TO 50
"C--------END OF SPECIAL SKEW CODE---
"40              X(K)=X(K)-FAC*UL(JJ)
"50              CONTINUE
"100     CONTINUE
"C
"C    DIAGONAL ELEMENTS * SOLUTION VECTOR
"C
"        DO 200 I=1,N
"        X(I)=D(I)*X(I)
"200     CONTINUE
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.EQ.ISKEW)K=IND(JJ+1)
"                X(II)=X(II)-X(K)*UL(JJ)
"250             CONTINUE
"300     CONTINUE
"        RETURN
"        END
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE REAL MATRIX COEFFICIENTS AND THEIR COLUMN INDEX
"ARE STORED IN MD IN INTERLEAVED FASHION IN VECTOR UL.  THE INPUT VECTOR IS
"STORED IN MD IN VECTOR XMD, AND THE RESULT IS STORED BACK INTO XMD.  A
"WORK VECTOR X OF LENGTH N IS NEEDED IN TMRAM.  THE REAL DIAGONAL
"ELEMENTS ARE STORED IN MD IN THE VECTOR D.
"
"      ---HISTORY---
"ORIGINAL:  JAN 79  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY AND TMRAM
"SIZE:      34 + TSRFWD (35) + MTTMUL (20) + TSRBAK (33)
"               + MTMOV (6 FAST, 7 STND) + TMMOV (5) = 133 FAST, 134 STND
"SPEED:
"TSRSFB SETUP TIME:  5.5 US
"MTMOV
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.17       0.17        0.17         0.83          167 NS MEMORY
" (US):         0.33       0.33        0.33         0.83          333 NS MEMORY
"TSRFWD
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     0.83       0.83        0.83      2.17      1.33  167 NS MEMORY
" (US):         0.83       0.83        0.83   2.17-2.50    1.33  333 NS MEMORY
"MTTMUL
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.5        0.5         0.5          2.33          167 NS MEMORY
" (US):         0.5        0.5         0.5          2.33          333 NS MEMORY
"TSRBAK
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     0.67       0.67        0.67      2.17       2.33 167 NS MEMORY
" (US):         0.67       0.67        0.67      2.33       2.33 333 NS MEMORY
"TMMOV
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.17       0.17        0.17         0.67          167 NS MEMORY
" (US):         0.33       0.33        0.33         1.67          333 NS MEMORY
"
"THUS TOTAL EXECUTION TIME FOR N EQUATIONS WITH M NONDIAGONAL NONZEROS
"IN L (OR U) IS
"           1.5M +    5.17N     + 13.0        US     167 NS MEMORY
"           1.5M + (5.67-6.00)N + 13.0        US     333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL TSRSFB(N,XMD,X,IRP,UL,SKEW,D)
"APAL CALL:     JSR TSRSFB
"SCRATCH:       SP(0-6,10-15),DPX(-4 TO 3),DPY(-2 TO 2),FA,FM,MD,TM,DA
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N      $EQU     0            "NUMBER OF EQUATIONS
   XMD    $EQU     1            "BASE ADDR (MD) FOR RHS AND RESULT
   X      $EQU     2            "BASE ADDR (TM) OF REAL WORK VECTOR
   IRP    $EQU     3            "BASE ADDR (MD) OF POINTERS TO UL
                                " POINTER IS INTEGER IN LOW MANTISSA
   UL     $EQU     4            "BASE ADDR (MD) OF INFO ON REAL NONZERO
                                "  COEFFICIENTS, STORED AS FOLLOWS:
                                "   UL      COL INDEX OF NONZERO COEFFIC   1
                                "   UL+1    VALUE OF  '       '          '
                                "   UL+2    COL INDEX '    '       '       2
                                "   UL+3    VALUE OF  '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   SKEW   $EQU     5            "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
   D      $EQU     6            "BASE ADDR (MD) OF REAL DIAGONAL ELEMENTS
"
TSRSFB: MOV N,N; DPX(-1)<SPFN   "SAVE THE INPUT PARAMETERS
        MOV XMD,17; DPX(-2)<SPFN;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV X,1; DPX(-3)<SPFN
        MOV IRP,IRP; DPX(-4)<SPFN
        MOV UL,UL; DPY(-1)<SPFN
        MOV SKEW,SKEW; DPY(-2)<SPFN
        MOV N,2
        MOV 17,0
        JSR MTMOV                       "MOVE RHS TO TMRAM
                                        "CALL MTMOV(XMD,X,N)
        LDSPI N; DB=DPX(-1)
        LDSPI 1; DB=DPX(-3)
        LDSPI 2; DB=DPX(-4)
        LDSPI 3; DB=DPY(-1)
        LDSPI 4; DB=DPY(-2)
        JSR TSRFWD               "DO FORWARD ELIMINATION
                                "CALL TSRFWD(N,X,IRP,UL,SKEW)
        LDSPI 2; DB=DPX(-3)     "RESTORE PARAMETERS FOR MTTMUL, X
        MOV D,0                 "GET D
        MOV 2,4
        LDSPI 6; DB=DPX(-1)     "GET N
        LDSPI 1; DB=1           "SET ADDRESS INCREMENT OF 1
        MOV 1,3
        MOV 1,5
        JSR MTTMUL               "DO REAL MULTIPLY BY DIAGONAL ELEMENTS
                                "CALL MTTMUL(D,1,X,1,X,1,N)
        LDSPI N; DB=DPX(-1)
        LDSPI 1; DB=DPX(-3)
        LDSPI 2; DB=DPX(-4)
        LDSPI 3; DB=DPY(-1)
        LDSPI 4; DB=DPY(-2)
        JSR TSRBAK               "DO BACK SUBSTITUTION
                                "CALL TSRBAK(N,X,IRP,UL,SKEW)
        LDSPI 0; DB=DPX(-3)
        LDSPI 1; DB=DPX(-2)
        LDSPI 2; DB=DPX(-1)
        JMP TMMOV               "MOVE RESULT FROM TM TO MD
                                "CALL TMMOV(X,XMD,N)
        $END
"****** TSRUFB = SPARSE REAL UNSYM FWD ELIM BACK SUB/COMMON/ = REL 1.1, OCT 79 *
"USING TMRAM AND MD
        $TITLE TSRUFB
        $RADIX 8
        $ENTRY TSRUFB,8.
        $EXT TSRFWD,MTTMUL,TSRBAK,MTMOV,TMMOV
"
"      ---ABSTRACT---
"GIVEN A SPARSE REAL UNSYMMETRIC COEFFICIENT MATRIX
"THAT HAS BEEN FACTORED INTO LU (LOWER/UPPER TRIANGULAR) FORM, AND STORED
"IN PACKED FORM, THIS ROUTINE COMPLETES THE SOLUTION OF THE REAL EQUATIONS
"BY PERFORMING THE FORWARD AND BACK SUBSTITUTION.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN ROUTINE:
"-----------------------------------------------------
"        SUBROUTINE TSRUFB(N,X,L,U,D,ICP,IRP,INDL,INDU)
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       ML = NUMBER OF NONZEROS IN L
"C       MU =   "     "    "      " U
"C       X = RIGHT HAND SIDE, B,  (DIMENSION N)
"C             (SOLUTION X WILL REPLACE B IN X )
"C       L = NONZERO VALUES OF L         (DIMENSION ML)
"C       U = NONZERO VALUES OF U         (DIMENSION MU)
"C       D = DIAGONAL ELEMENTS           (DIMENSION N)
"C       ICP= ARRAY OF COLUMN POINTERS TO L AND INDL  (DIMENSION N+1)
"C       IRP= ARRAY OF ROW POINTERS TO U AND INDU  (DIMENSION N+1)
"C       INDL= ARRAY OF ROW INDICES FOR NONZEROS BY ROWS (DIMENSION ML)
"C       INDU= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION MU)
"C
"        REAL L
"        DIMENSION X(1),L(1),U(1),D(1)
"        DIMENSION ICP(1),IRP(1),INDL(1),INDU(1)
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=ICP(I)
"        LAST=ICP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FAC=X(I)
"        IF(FAC.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=IFIRST+J-1
"                K=INDL(JJ)
"                X(K)=X(K)-FAC*L(JJ)
"50              CONTINUE
"100     CONTINUE
"C
"C    DIAGONAL ELEMENTS * SOLUTION VECTOR
"C
"        DO 200 I=1,N
"        X(I)=D(I)*X(I)
"200     CONTINUE
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=INDU(JJ)
"                X(II)=X(II)-X(K)*U(JJ)
"250             CONTINUE
"300     CONTINUE
"        RETURN
"        END
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE REAL COEFFICIENTS FOR THE OFF-DIAGONAL
"NONZEROS IN THE LOWER TRIANGULAR MATRIX AND THEIR ROW INDICES ARE STORED
"BY COLUMNS IN INTERLEAVED FASHION IN VECTOR L.  COEFFICIENTS FOR THE OFF-
"DIAGONAL NONZEROS IN THE UPPER TRIANGULAR MATRIX AND THEIR COLUMN INDICES
"ARE STORED BY ROWS IN INTERLEAVED FASHION IN VECTOR U.  THE INPUT VECTOR
"IS STORED IN MD IN VECTOR XMD, AND THE RESULT IS STORED BACK INTO XMD.  A
"WORK VECTOR X OF LENGTH N IS NEEDED IN TMRAM.  THE REAL DIAGONAL
"ELEMENTS ARE STORED IN THE VECTOR D.
"
"      ---HISTORY---
"ORIGINAL:  JAN 79  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY AND TMRAM
"SIZE:      33 + TSRFWD (35) + MTTMUL (20) + TSRBAK (33)
"               + MTMOV (6 FAST, 7 STND) + TMMOV (5) = 132 FAST, 133 STND
"SPEED:
"TSRUFB SETUP TIME:  5.5 US
"MTMOV
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.17       0.17        0.17         0.83          167 NS MEMORY
" (US):         0.33       0.33        0.33         0.83          333 NS MEMORY
"TSRFWD
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     0.83       0.83        0.83      2.17      1.33  167 NS MEMORY
" (US):         0.83       0.83        0.83   2.17-2.50    1.33  333 NS MEMORY
"MTTMUL
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.5        0.5         0.5          2.33          167 NS MEMORY
" (US):         0.5        0.5         0.5          2.33          333 NS MEMORY
"TSRBAK
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     0.67       0.67        0.67      2.17       2.33 167 NS MEMORY
" (US):         0.67       0.67        0.67      2.33       2.33 333 NS MEMORY
"TMMOV
"EXECUTION      BEST     TYPICAL      WORST         SETUP(US)
"TIME/LOOP:     0.17       0.17        0.17         0.67          167 NS MEMORY
" (US):         0.33       0.33        0.33         1.67          333 NS MEMORY
"
"THUS TOTAL EXECUTION TIME FOR N EQUATIONS WITH ML NONDIAGONAL NONZEROS
"IN L AND MU NONDIAGONAL NONZEROS IN U IS:
"      0.83ML + 0.67MU +    5.17N     + 13.0        US     167 NS MEMORY
"      0.83ML + 0.67MU + (5.67-6.00)N + 13.0        US     333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL TSRUFB(N,XMD,X,ICP,L,IRP,U,D)
"APAL CALL:     JSR TSRUFB
"SCRATCH:       SP(0-6,10-15),DPX(-4 TO 3),DPY(-1 TO 2),FA,FM,MD,TM,DA
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N      $EQU     0            "NUMBER OF EQUATIONS
   XMD    $EQU     1            "BASE ADDR (MD) FOR RHS AND RESULT
   X      $EQU     2            "BASE ADDR (TM) OF REAL WORK VECTOR
   ICP    $EQU     3            "BASE ADDR (MD) OF POINTERS TO L
                                " POINTER IS INTEGER IN LOW MANTISSA
   L      $EQU     4            "BASE ADDR (MD) OF INFO ON REAL OFF-DIAGONAL
                                "  NONZERO COEFFICIENTS IN UPPER TRIANGULAR
                                "  MATRIX, STORED BY COLUMNS AS FOLLOWS:
                                "   L      ROW INDEX OF NONZERO COEFFIC   1
                                "   L+1    VALUE OF  '       '          '
                                "   L+2    ROW INDEX '    '       '       2
                                "   L+3    VALUE OF  '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " ROW INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   IRP    $EQU     5            "BASE ADDR (MD) OF POINTERS TO U
                                " POINTER IS INTEGER IN LOW MANTISSA
   U      $EQU     6            "BASE ADDR (MD) OF INFO ON REAL OFF-DIAGONAL
                                "  NONZERO COEFFICIENTS IN UPPER TRIANGULAR
                                "  MATRIX, STORED BY ROWS AS FOLLOWS:
                                "   U      COL INDEX OF NONZERO COEFFIC   1
                                "   U+1    VALUE OF  '       '          '
                                "   U+2    COL INDEX '    '       '       2
                                "   U+3    VALUE OF  '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
   D      $EQU     7            "BASE ADDR (MD) OF REAL DIAGONAL ELEMENTS
"
TSRUFB: MOV N,N; DPX(-1)<SPFN   "SAVE THE INPUT PARAMETERS
        MOV XMD,17; DPX(-2)<SPFN;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV X,1; DPX(-3)<SPFN
        MOV IRP,IRP; DPX(-4)<SPFN
        MOV U,U; DPY(-1)<SPFN
        MOV N,2
        MOV 17,0
        JSR MTMOV                       "MOVE RHS TO TMRAM
                                        "CALL MTMOV(XMD,X,N)
        LDSPI N; DB=DPX(-1)
        LDSPI 1; DB=DPX(-3)
        MOV 3,2
        MOV 4,3
        CLR 4
        JSR TSRFWD               "DO FORWARD ELIMINATION
                                "CALL TSRFWD(N,X,ICP,L,0)
        LDSPI 2; DB=DPX(-3)     "RESTORE PARAMETERS FOR MTTMUL, X
        MOV D,0                 "GET D
        MOV 2,4
        LDSPI 6; DB=DPX(-1)     "GET N
        LDSPI 1; DB=1           "SET ADDRESS INCREMENT OF 1
        MOV 1,3
        MOV 1,5
        JSR MTTMUL               "DO REAL MULTIPLY BY DIAGONAL ELEMENTS
                                "CALL MTTMUL(D,1,X,1,X,1,N)
        LDSPI N; DB=DPX(-1)
        LDSPI 1; DB=DPX(-3)
        LDSPI 2; DB=DPX(-4)
        LDSPI 3; DB=DPY(-1)
        CLR 4
        JSR TSRBAK               "DO BACK SUBSTITUTION
                                "CALL TSRBAK(N,X,IRP,U,0)
        LDSPI 0; DB=DPX(-3)
        LDSPI 1; DB=DPX(-2)
        LDSPI 2; DB=DPX(-1)
        JMP TMMOV               "MOVE RESULT FROM TM TO MD
                                "CALL TMMOV(X,XMD,N)
        $END
"****** TSRFWD = SPARSE REAL MATRIX FORWARD ELIM /COMMON/ = REL 1.0, JAN 79 ***
"USING TMRAM AND INTERLEAVED REAL AND PACKED STORAGE
        $TITLE TSRFWD
        $RADIX 8
        $ENTRY TSRFWD,5.
"
"      ---ABSTRACT---
"PERFORMS FORWARD ELIMINATION ON A SPARSE REAL LOWER TRIANGULAR SYSTEM
"OF EQUATIONS OF THE FORM LX=B, SOLVING FOR X, GIVEN FORCING VECTOR B.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN CODE:
"-----------------------------------------------------
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF OFFDIAGONAL NONZEROS IN L
"C       X = RIGHT HAND SIDE, B,  (DIMENSION N)
"C             (SOLUTION X WILL REPLACE B IN X)
"C       L= NONZERO VALUES OF L  (DIMENSION M)
"C       D = DIAGONAL ELEMENTS           (DIMENSION N)
"C       ICP= ARRAY OF COLUMN POINTERS TO L AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF ROW INDICES FOR NONZEROS BY COLUMNS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"C
"C     FORWARD ELIMINATION
"C
"        DO 100 I=1,N
"        IFIRST=ICP(I)
"        LAST=ICP(I+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 100
"        FAC=X(I)
"        IF(FAC.EQ.0)GO TO 100
"                DO 50 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.NE.ISKEW)GO TO 40
"C---------SPECIAL CODE FOR SKEW-SYMMETRIC COMPONENT OF NONZERO----
"                K=IND(JJ+1)
"                X(K)=X(K)+FAC*L(JJ)
"                GO TO 50
"C--------END OF SPECIAL SKEW CODE-----
"40              X(K)=X(K)-FAC*L(JJ)
" 50             CONTINUE
"100     CONTINUE
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE REAL MATRIX COEFFICIENTS AND THEIR ROW INDEX
"ARE STORED IN INTERLEAVED FASHION IN VECTOR L.  THE REAL FULL VECTOR
"IS STORED IN TMRAM IN VECTOR X.
"
"      ---HISTORY---
"ORIGINAL:  JAN 79  R.S. NORIN
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY AND TMRAM
"SIZE:      35 LOCATIONS
"EXECUTION      BEST     TYPICAL      WORST  SETUP/COLUMN(US) SETUP(US)
"TIME/LOOP:     0.83       0.83        0.83      2.17       1.33  167 NS MEMORY
" (US):         0.83       0.83        0.83   2.17-2.50     1.33  333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL TSRFWD(N,X,ICP,L,SKEW)
"APAL CALL:     JSR TSRFWD
"SCRATCH:       SP(0-3,10-15),DPX(0-3),DPY(0-2),FA,FM,MD,TM,DA
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N   $EQU     0            "NUMBER OF EQUATIONS
   X    $EQU     1            "BASE ADDR IN TMRAM OF REAL WORK VECTOR
   ICP $EQU     2            "BASE ADDR (MD) OF POINTER TO L
                                " POINTER IS INTEGER IN LOW MANTISSA
   L  $EQU     3            "BASE ADDR (MD) OF INFO ON REAL NONZERO
                                "  COEFFICIENTS, STORED AS FOLLOWS:
                                "   L      ROW INDEX OF NONZERO COEFFIC   1
                                "   L+1    VALUE     OF   '       '       '
                                "   L+2    ROW INDEX '    '       '       2
                                "   L+3    VALUE     '    '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " ROW INDICES ARE INTEGERS IN LOW MANTISSA
                                "
  SKEW $EQU     4               "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
"TEMPORARY STORAGE:
   LO    $EQU    12            "BASE ADDRESS - 3 FOR L
   LOFF  $EQU    13            "TEMPORARY FOR L OFFSET
   C27    $EQU    14            "27.  NEEDED FOR FLOATING COUNT
   XCUR  $EQU     15           "POINTER TO CURRENT X FOR COLUMN
   NZ     $EQU    16            "COUNTER FOR NONZEROS IN COLUMN
   ROWW   $EQU    16            "TM OUTPUT POINTER
   ROW    $EQU    17            "ROW INDEX OF CURRENT NONZERO IN COLUMN
   FIRST  $EQU    17            "TEMPORARY
   TWO    $EQU    17            "2
"
TSRFWD: LDSPI TWO; DB=2         "2
        LDSPI C27; DB=27.       "27.
        DEC X;                  "BACK UP X POINTER
         LDDA; DB=5             "SET DA TO TMRAM
        INC# ICP; SETMA         "GET LOCATION OF
                                "LAST ELEMENT POINTER IN COLUMN
        MOV X,XCUR;             "SET POINTER TO CURRENT COLUMN X
         LDTMA; DB=!ONE         "GET 1.0 FOR COUNTER FROM TMROM
        MOV L,LO              "COMPUTE BASE ADDR L-3
        DECMA;                  "GET LOC OF 1ST ELT PTR IN 1ST COLUMN
         DEC LO;             "
         DPX(1)<MD              "SAVE LAST ELEMENT POINTER
        SUB TWO,LO;
         DPY(2)<TM              "SAVE 1.0
        LDSPI NZ; DB=DPX(1)     "LAST ELEMENT POINTER
        ADD TWO,ICP; SETMA;     "GET LOC OF LAST ELT PTR IN 2ND COLUMN
         DPX(3)<MD              "SAVE 1ST ELEMENT PTR
        MOVL NZ,LOFF;          "COMPUTE L OFFSET OF LAST ELT IN COLUMN
         BR OLOOP+1             "ENTER OUTER LOOP
"HERE IS INTRODUCTION TO INNER LOOP
INTRO:  MOV LO,L           "GET L BASE ADDRESS
        ADD LOFF,L; SETMA; "2. GET L FOR LAST NONZERO IN COLUMN
         DPX(0)<TM              "   SAVE FAC
        LDSPI NZ; DB=DPX(1);    "3. RESTORE LAST PTR LOCATION
         FADD TM,ZERO           "   SEE IF FAC=0
        DECMA;                  "4. GET ROW INDEX FOR LAST NONZERO IN COLUMN
         FADD;                  "   PUSH
         LDSPI LOFF; DB=MD;    "   COMPUTE OFFSET FOR NEXT COLUMN
         DPY(1)<MD              "   SAVE PTR TO LAST ELT OF NEXT COLUMN
        LDSPI FIRST; DB=DPX(3)  "5. GET PTR TO 1ST ELT OF COLUMN
        SUB FIRST,NZ;           "1. GET NONZERO COUNT
        DPX(3)<SPFN;            "   SAVE COUNT
        BFEQ FAC0;              "   BRANCH IF FAC=0
            FMUL DPX(0),MD      "   FAC*L
        DECMA;                  "2. GET NEXT L
        FADD ZERO,MDPX(3);      "   FLOAT NONZERO COUNT
         MOV C27,C27;
         BNE J1;                "   BRANCH IF NONZEROS IN COLUMN
            FMUL
"HERE IF FAC=0 OR NO NONZEROS IN COLUMN
FAC0:   DPX(3)<DPX(1);          "LAST PTR BECOMES 1ST FOR NEXT COL
         MOVL LOFF,LOFF         "COMPUTE OFFSET FOR NEXT COL
        DPX(1)<DPY(1);          "SAVE LAST PTR FOR NEXT COL
         DEC N;                 "DECREMENT COUNT
         BR OLOOP               "PROCESS NEXT COLUMN
"HERE IF PROCESSING NONZERO IN COLUMN
J1:     FADD; FMUL;             "3. PUSHERS
            LDSPI ROW; DB=MD    "   SAVE ROW INDEX
        DECMA;                  "4. GET ROW INDEX
        DPX(3)<DPX(1);          "   LAST PTR BECOMES 1ST FOR NEXT COL
            ADD X,ROW; SETTMA;  "   GET X
            FADD ZERO,FA;       "   PASS COUNT ALONG
            DPY(0)<FM           "   SAVE FAC*L
        MOVL LOFF,LOFF;         "5. COMPUTE OFFSET FOR NEXT COL
        DPX(1)<DPY(1);          "   SAVE LAST PTR FOR NEXT COL
        BR LOOP                 "   GO ON TO MAIN LOOP
"HERE BEGINS THE OUTER LOOP FOR PROCESSING A COLUMN
OLOOP:  INC ICP; SETMA;      "GET NONZERO NR FOR START OF NEXT COLUMN
         BEQ DONE               "EXIT IF ALL COLUMNS PROCESSED
        INC XCUR; SETTMA;      "GET CURRENT X FOR COLUMN=FAC
         BR INTRO               "BRANCH TO INTRODUCTION TO INNER LOOP
"HERE BEGINS THE REAL LOOP
LOOP:       FMUL DPX(0),MD;             "1. FAC*L
                FSUB TM,DPY(0);         "   X-FAC*L
                MOV ROW,ROWW            "   SAVE POINTER TO X
COMM:   DECMA;                          "2. GET L
            LDSPI ROW; DB=MD;           "   SAVE ROW INDEX
            FMUL DPX(0),DPY(2);         "    FAC*1.0 FOR SKEW PART OF LOOP
                FSUBR DPY(2),FA         "   DECREMENT COUNT
            SUB# SKEW,ROW;              "3. TEST FOR SKEW-SYMM ELT
            FMUL;
                FSUBR NC,NC;            "   WE NEED COUNT AGAIN IN FA
                DPX(2)<FA               "   SAVE NEW X
        DECMA;                          "4. GET ROW INDEX
            ADD X,ROW; SETTMA;          "   GET X
            DPY(0)<FM; FMUL;            "   SAVE FAC*L
            BEQ SKEWL                   "   BRANCH IF SKEW COMPONENT
                OUT; DB=DPX(2); SETTMA; "5. OUTPUT NEW X TO TMRAM
                MOV ROWW,ROWW;
                BFGT LOOP               "   LOOP THRU ALL NONZEROS IN COL
"WE'RE NOW COMPLETING THE OUTER LOOP
EOLOOP: DEC N;                       "SEE IF MORE COLUMNS
         BR OLOOP                       "BRANCH TO BEGINNING OF OUTER LOOP
DONE:   RETURN                          "EXIT WHEN ALL COLUMNS FINISHED
"HERE IF INDEX FLAGS A SKEW-SYMMETRIC ELEMENT
SKEWL:          OUT; DB=DPX(2); SETTMA; "5A. OUTPUT NEW X TO TMRAM
                MOV ROWW,ROWW;
                BFGT SLOOP              "   LOOP THRU ALL NONZEROS IN COL
        BR EOLOOP                       "FINISHED WITH COLUMN
SLOOP:      FMUL FM,MD;                 "1A. FAC*L
                FADD DPX(2),DPY(0);     "    X+FAC*L
                MOV ROW,ROWW;           "    SAVE POINTER TO X
                BR COMM                 "    RETURN TO MAIN PART OF LOOP
        $END
"****** TSRBAK = SPARSE REAL BACK SUBSTITUTION /COMMON/ = REL 1.0, JAN 79 *****
"USING TMRAM AND INTERLEAVED REAL AND PACKED STORAGE
        $TITLE TSRBAK
        $RADIX 8
        $ENTRY TSRBAK,5.
"
"      ---ABSTRACT---
"PERFORMS THE BACK SUBSTITUTION ON REAL SIMUTANEOUS EQUATIONS UX=B, WHERE
"THE UPPER TRIANGUAR COEFFICIENT MATRIX (RESUTING FROM LU DECOMPOSITION) IS
"SPARSE.  SOLVES FOR X, GIVEN THE FORCING VECTOR B
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN CODE:
"-----------------------------------------------------
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF NONZEROS IN U
"C       X = RIGHT HAND SIDE, B,  (DIMENSION N)
"C             (SOLUTION X WILL REPLACE B)
"C       U= NONZERO VALUES OF U  (DIMENSION M)
"C       D = DIAGONAL ELEMENTS           (DIMENSION N)
"C       IRP= ARRAY OF ROW POINTERS TO U AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION M)
"C       ISKEW= INDEX NUMBER (<=0 OR >N) WHICH FLAGS THE SKEW-SYMMETRIC
"C              COMPONENT OF THE NEXT NON-ZERO
"C
"C    BACK SUBSTITUTION
"C
"        NM1=N-1
"        DO 300 I=1,NM1
"        II=N-I
"        IFIRST=IRP(II)
"        LAST=IRP(II+1)
"        NZ=LAST-IFIRST
"        IF(NZ.EQ.0)GO TO 300
"                DO 250 J=1,NZ
"                JJ=IFIRST+J-1
"                K=IND(JJ)
"                IF(K.EQ.ISKEW)K=IND(JJ+1)
"                X(II)=X(II)-X(K)*U(JJ)
"250             CONTINUE
"300     CONTINUE
"-----------------------------------------------------
"
"IN THIS IMPLEMENTATION THE REAL MATRIX COEFFICIENTS AND THEIR COLUMN INDEX
"ARE STORED IN INTERLEAVED FASHION IN VECTOR U.  THE REAL FULL VECTOR
"IS STORED IN TMRAM IN VECTOR X.
"
"      ---HISTORY---
"ORIGINAL:  JAN 79  R.S. NORIN
"
"      ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B/190L WITH EITHER SPEED MAIN DATA MEMORY AND TMRAM
"SIZE:      33 LOCATIONS
"EXECUTION      BEST     TYPICAL      WORST  SETUP/ROW(US) SETUP(US)
"TIME/LOOP:     0.67       0.67        0.67      2.17       2.33 167 NS MEMORY
" (US):         0.67       0.67        0.67      2.33       2.33 333 NS MEMORY
"
"      ---USAGE---
"FORTRAN CALL:  CALL TSRBAK(N,X,IRP,U,SKEW)
"APAL CALL:     JSR TSRBAK
"SCRATCH:       SP(0-3,11-15),DA,DPX(0-1),DPY(0),FA,FM,MD,TM
"
"ENTER WITH FOLLOWING PARAMETERS IN S-PADS:
"   NAME        NUMBER
   N   $EQU     0            "NUMBER OF EQUATIONS
   X    $EQU     1            "BASE ADDR IN TMRAM OF REAL WORK VECTOR
   IRP $EQU     2            "BASE ADDR (MD) OF POINTERS TO U
                                " POINTER IS INTEGER IN LOW MANTISSA
   U  $EQU     3            "BASE ADDR (MD) OF INFO ON REAL NONZERO
                                "  COEFFICIENTS, STORED AS FOLLOWS:
                                "   U      COL INDEX OF NONZERO COEFFIC   1
                                "   U+1    VALUE OF       '       '       '
                                "   U+2    COL INDEX '    '       '       2
                                "   U+3    VALUE OF       '       '       '
                                "     .
                                "     .
                                "     .    ETC
                                " COL INDICES ARE INTEGERS IN LOW MANTISSA
                                "
  SKEW $EQU     4               "INDEX NUMBER (<=0 OR >N) WHICH FLAGS
                                " THE SKEW SYMMETRIC COMPONENT OF THE
                                " NEXT NON-ZERO
"TEMPORARY STORAGE:
   XX     $EQU    13            "POINTER TO CURENT XI FOR ROW
   LAST   $EQU    14            "CURENT (LAST) VALUE IN IRP
   NZ     $EQU    15            "COUNTER FOR NONZEROS IN ROW
   COL    $EQU    16            "COLUMN INDEX OF CURENT NONZERO IN ROW
   UOFF   $EQU    17            "INCREMENT FOR POINTER TO U
"
TSRBAK:  ADD N,IRP;        "POINT TO LAST ROW IN IRP
         LDDA; DB=5             "SET DA TO TMRAM
        DEC IRP; SETMA       "GET LAST NONZERO NR
        DEC X                 "BACK UP POINTER
        MOV X,XX            "POINT TO X(N)
        ADD N,XX; SETTMA   "SET TMA, THO VALUE NOT USED
        LDSPI LAST; DB=MD       "SAVE LAST NONZERO NR
        MOV LAST,NZ             "COMPUTE OFFSET FOR PACKED DATA
        DEC NZ                  "SUBTRACT 1 FROM NR NONZEROS
        MOVL NZ,NZ              "AND THEN MUTIPLY BY 2
        DEC NZ
        ADD NZ,U                   "SET POINTER TO LAST VALUE U
        CLR UOFF              "ADJUST OUTPUT POINTER
        DEC IRP; SETMA       "GET NONZERO NR FOR START OF ROW
"HERE IS INTRODUCTION TO INNER LOOP
INTRO:  DECTMA;                 "GET FAC FOR ROW
         DEC N               "DECREMENT ROW COUNT
        MOV LAST,NZ;         "SAVE NONZERO NR FOR PREVIOUS ROW
         BEQ DONE            "EXIT IF ALL ROWS ARE DONE
        SUB UOFF,U; SETMA;   "3. GET VALUE U FOR LAST NONZERO
         FADD TM,ZERO        "   PUT FAC FOR ROW INTO FA
        LDSPI LAST; DB=MD    "4. SAVE CURRENT NONZERO NR
"
        FADD;                    "1. PUSH FAC
         SUB LAST,NZ;            "   COMPUTE NR NONZEROS IN ROW
            DECMA                "   GET COL INDEX FOR LAST NZ IN ROW
        MOVL NZ,UOFF;            "2. COMPUTE OFFSET FOR NEXT ROW OF U
         BEQ EOLOOP              "   EXIT IF NO NONZEROS IN ROW
        DECMA;                   "3. GET NEXT U
            DPX(0)<MD            "   SAVE U
            LDSPI COL; DB=MD;    "4. SAVE COL INDEX
            DECMA                    "   GET COL INDEX
                ADD# X,COL; SETTMA;  "1. GET X
                DPX(1)<DPX(0)        "   PASS ON U
       DECMA;                        "3. GET NEXT U
           DPX(0)<MD                 "   SAVE U
           LDSPI COL; DB=MD;         "4. SAVE COL INDEX
               FMUL TM,DPX(1);       "   X*U
               BR LOOP               "   ON TO MAIN LOOP
"HERE BEGINS THE OUTER LOOP FOR PROCESSING A ROW
OLOOP:  OUT; DB=DPX(0); DEC XX; SETTMA; "STORE NEW FAC
         BR INTRO               "CONTINUE ON INTO NEXT ROW INTRO
DONE:   RETURN                  "EXIT
"HERE BEGINS THE REAL LOOP
LOOP:       DECMA;                      "1. GET COL INDEX
                ADD# X,COL; SETTMA;     "   GET X
                    FMUL;
                    DPY(0)<TM           "   SAVE X IN CASE NEXT ELT SKEW
                SUB SKEW,COL;           "2. IS THIS ELEMENT SKEW?
                DPX(1)<DPX(0);          "   PASS ON U
                    FMUL
        DECMA;                          "3. GET NEXT U
            DPX(0)<MD;                  "   SAVE U
                BEQ SKEWL;              "   BRANCH IF SKEW ELEMENT
                    FSUBR FM,FA;        "   FAC-X*U
                    DEC NZ              "   DECREMENT NONZERO COUNT
            LDSPI COL; DB=MD;           "4. SAVE COL INDEX
                FMUL TM,DPX(1);         "   X*U
                    FADD;
                    BNE LOOP            "   GO TO NEXT NONZERO
"WE'RE NOW COMPLETING THE OUTER LOOP
EOLOOP: DEC IRP; SETMA;              "GET NONZERO NR FOR START OF ROW
         DPX(0)<FA;                  "SAVE NEW FAC
         BR OLOOP               "BRANCH TO BEGINNING OF OUTER LOOP
"HERE IS LAST PART OF REAL LOOP WHERE SKEW ELEMENT PROCESSING STARTS
SKEWL:      LDSPI COL; DB=MD;           "4A. SAVE COL INDEX
                FMUL DPY(0),DPX(1);     "    (LAST X)*U
                    FADD;
                    BNE LOOP            "    GO TO NEXT NONZERO
        BR EOLOOP               "GO TO END OF OUTER LOOP
        $END
"****** TCVMUL = COMPLEX VECTOR MULTIPLY WITH TMRAM /COMMON/ = REL 1.1, OCT 79 *
        $TITLE TCVMUL
        $RADIX 8
        $ENTRY TCVMUL,3
"
"    ---ABSTRACT---
"MULTIPLIES A COMPLEX VECTOR IN TMRAM BY A COMPLEX VECTOR IN MD AND STORES
"THE COMPLEX RESULT BACK INTO THE SAME TMRAM LOCATIONS.
"
"ROUTINE IS EQUIVALENT TO THE FOLLOWING FORTRAN CODE:
"-----------------------------------------------------
"C
"C     PARAMETERS:
"C       N  = NUMBER OF EQUATIONS
"C       M  = NUMBER OF NONZEROS IN L (OR U)
"C       XR = REAL PART OF RIGHT HAND SIDE, B,  (DIMENSION N)
"C       XI = IMAG   "   "    "    "    "   "          "
"C             (SOLUTION X WILL REPLACE B IN XR AND XI)
"C       ULR= REAL PART OF NONZERO VALUES OF L (OR U)  (DIMENSION M)
"C       ULI= IMAG  "    "     "      "     "    "            "
"C       DR = REAL PART OF DIAGONAL ELEMENTS           (DIMENSION N)
"C       DI = IMAG  "    "     "      "                       "
"C       IRP= ARRAY OF ROW POINTERS TO ULR,ULI, AND IND  (DIMENSION N+1)
"C       IND= ARRAY OF COLUMN INDICES FOR NONZEROS BY ROWS (DIMENSION M)
"C
"C    DIAGONAL ELEMENTS * SOLUTION VECTOR
"C
"        DO 200 I=1,N
"        TEMPR=DR(I)*XR(I)-DI(I)*XI(I)
"        XI(I)=DI(I)*XR(I)+DR(I)*XI(I)
"        XR(I)=TEMPR
"200     CONTINUE
"-----------------------------------------------------
"
"FORMULA:   X(2M)=X(2M)*D(2M)-X(2M+1)*D(2M+1)
"           X(2M+1)=X(2M)*D(2M+1)+X(2M+1)*D(2M)
"                    FOR M=0 TO N-1
"
"   ---HISTORY---
"ORIGINAL:  JUN 78  R.S.NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"   ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT:  AP WITH TMRAM AND EITHER SPEED MD MEMORY
"SIZE:    17 LOCATIONS
"EXECUTION      BEST   TYPICAL    WORST      SETUP(US)
"TIME/LOOP      1.0      1.0       1.0         1.83         167 NS MEMORY
" (US):         1.0      1.0       1.0         1.83         333 NS MEMORY
"
"   ---USAGE---
"FORTRAN CALL:  CALL TCVMUL(X,D,N)
"APAL CALL:     JSR TCVMUL
"SCRATCH:       SP(0,2,14,15),DA,DPX(0),DPY(0),FA,FM,MD,TM
"
"ENTER WITH THE FOLLOWING PARAMETERS IN S-PADS:
"  NAME      NUMBER
  X   $EQU    0               "BASE ADDR (TM) OF SOURCE AND DESTINATION
                                "COMPLEX VECTOR
  D  $EQU    1               "BASE ADDR (MD) OF 2ND SOURCE COMPLEX VECTOR
  N  $EQU    2               "COMPLEX ELEMENT COUNT
"
"TEMPORARY STORAGE:
  XO  $EQU   16               "POINTER TO OUTPUT VECTOR
  TWO   $EQU   17               "2
"
TCVMUL: LDDA; DB=5              "SET DA TO TMRAM
        LDSPI TWO; DB=2         "SET 2
        MOV D,D; SETMA    "5. GET 1ST RDIAR
        MOV X,XO; SETTMA    "6. GET 1ST XR
        MOV N,N;                "IS ELEMENT COUNT = 0?
            INCTMA;             "1. GET 1ST XI
             INCMA              "   GET 1ST RDIAX
        BEQ DONE;               "EXIT IF COUNT = 0
            FMUL TM,MD;         "2. XR*RDIAR
             DPX<TM             "   SAVE XR
            FMUL TM,MD;         "3. XI*RDIAR
             SUB TWO,XO       "   BACK UP OUTPUT POINTER
            FMUL TM,MD          "4. XI*RDIAX
        INCMA;                  "5. GET 2ND RDIAR
            FMUL DPX,MD;        "   XR*RDIAX
             DPX<FM             "   SAVE XR*RDIAR
        ADD TWO,X; SETTMA;    "6. GET XR
            FMUL;               "   PUSH
             DPY<FM             "   SAVE XI*RDIAR
LOOP:       INCTMA;             "1. GET XI
             INCMA;             "   GET RDIAX
                FSUBR FM,DPX;   "   XR*RDIAR-XI*RDIAX
                 FMUL
            FMUL TM,MD;         "2. XR*RDIAR
             DPX<TM;            "   SAVE XR
                FADD FM,DPY     "   XR*RDIAX+XI*RDIAR
            FMUL TM,MD;         "3. XI*RDIAR
                DPY<FA;         "   SAVE NEW XR
                 FADD           "   PUSH
            FMUL TM,MD;         "4. XI*RDIAX
                OUT; DB=DPY;    "   STORE NEW XR
                 ADD TWO,XO; SETTMA;
                 DPY<FA         "   SAVE NEW XI
        INCMA;                  "5. GET RDIAR
            FMUL DPX,MD;        "   XR*RDIAX
             DPX<FM;            "   SAVE XR*RDIAR
                OUT; DB=DPY; INCTMA; "   STORE NEW XI
                 DEC N       "   DECREMENT COUNT
        ADD TWO,X; SETTMA;    "6. GET XR
            FMUL;               "   PUSH
             DPY<FM;            "   SAVE XI*RDIAR
                BNE LOOP        "   CONTINUE UNTIL COUNT=0
DONE:   RETURN                  "EXIT
        $END
$ENDLIB
 