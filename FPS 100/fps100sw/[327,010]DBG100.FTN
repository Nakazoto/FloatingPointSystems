C+++    DBG100
C****** DBG100 = FPS100 DEBUGGER = REL.  1.00 , 04/20/79 ******
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APDBUG WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 17:52:45
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
C
C****** DBG100 = MAINLINE FOR AP DEBUGGER = REL.  1.00 , 04/20/79
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C                    DBG100 OVERLAY STRUCTURE                   *
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C THE FOLLOWING DESCRIBES AN OVERLAY STRUCTURE THAT ONCE WORKED
C FOR THIS PROGRAM.  IF OVERLAYING IS NEEDED IT SHOULD BE TRIED
C FIRST.  WHAT WE GIVE HERE ARE THE SEPARATE OVERLAYS, ANYTHING
C NOT SPECIFICALLY LISTED CAN BE ASSUMED TO BE IN THE ROOT SEGMENT.
C WE WILL DESCRIBE OVERLAYS BY SEPARATING MODULES THAT CAN BE OVERLAYED
C BY COMMAS AND MODULES THAT MUST RESIDE TOGETHER BY SPACES, FOR
C EXAMPLE IF SUBROUTINE A AND SUBROUTINE B DO NOT CALL EACH OTHER
C THEN THE OVERLAY WOULD BE REPRESENTED LIKE THIS:
C
C A,B
C
C NOW IF SUBROUTINE A CALLS SUBROUTINE B BUT NIETHER CALL SUBROUTINE
C C THEN WE WOULD REPRESENT THE OVERLAY LIKE THIS:
C
C A B,C
C
C THIS MEANS THAT A AND B TOGETHER OVERLAY C.  FOR A MORE REVEALING
C EXAMPLE SUPPOSE THAT WE HAVE PROGRAM MAIN THAT CALLS SUBROUTINE A
C WICH CALLS SUBROUTINE B.  SUPPOSE MAIN ALSO CALLS SUBROUTINE C AND
C SUPPOSE FURTHER THAT THERE IS A SUBROUTINE D THAT IS CALLED BY C
C AND A SUBROUTINE E CALLED BY MAIN.  WE DECIDE TO OVERLAY A AND B
C AGAINST C AND OVERLAY D AGAINST E THEN WE WOULD REPRESENT THIS
C OVERLAY AS THIS:
C
C A B,C
C
C D,E
C
C THERE WILL ALWAYS BE A BLANK (C ONLY) LINE BETWEEN OVERLAYS, IF
C AN OVERLAY TAKES UP MORE THAN ONE LINE THEN THE LAST CHARACTER ON
C THE LINE WILL BE EITHER A BLANK OR A COMMA. FOR EXAMPLE CONSIDER THE
C FIRST EXAMPLE IF IT WERE WRITTEN ON MORE THAT ONE LINE FOLLOWING THAT
C CONVENTION THEN WE MIGHT WRITE IT AS:
C
C A B,
C C
C
C OR LIKE THIS:
C
C A
C B,C
C
C IT SHOULD BE CLEAR THEN WHAT THE OVERLAYS BELOW MEAN
C
C""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
C APFILL,TCBEXM
C
C GETFPN GETSYM GETINT APDIN,APEXAM APDEP WRTST2 DEPST2
C
C SUBBRK,SUBRUN,SUBTRS,SUBEXM,SUBYAN
C
C RDLIN,WRTLIN
C
C IMAPS,OMAPS  (IF YOU HAVE ASCII UTILITIES THESE WILL NOT EXIST)
C
C DFTOS,STODF
C
C EXTST,EXTCS,INSSS,FTOA,INCODE,STOFI,SRCST,EXTSL,INSCS,ATOF,
C ITOS,EXTVT,RMVCS,EXTSS,RPLCS
C
C""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
C
C                    END OF OVERLAY STRUCTURE
C
C""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
C
C
C-------DECLARATIONS:
C
C-------LOCAL STORAGE
C
C    STATE VARIABLES
C                                                                       DBGCOM
       COMMON/GLOP/ DEVADR,LOC                                          DBGCOM
       COMMON TEMP,BUFFER,TOKEN,RADIX,IERR,OFFSET,BPPTR,REG,BPTBL,      DBGCOM
     *  HALT,IPROC,ISTEP,BRKLOC,BRKTYP,EBREAK,OPEN,                     DBGCOM
     *  ENAMNF,BLOPEN,EMNOPN,BLTYPE,BLWDTH,BLSTRT,BLOP,BLSTOP,          DBGCOM
     *  EENADR,NAME,LUN,FP,ETOMNY,ECMDNF,EBPTBG,BPTSIZ,                 DBGCOM
     *  LSPACE,STR1,FIE,TYPEL,WIDTH,TCBOPN,BASE,ENOPN                   DBGCOM
        INTEGER RADIX,FP,FIE,OFFSET,OPEN,IPROC,ISTEP,LUNMAP             DBGCOM
        INTEGER BRKTYP,BRKLOC,TYPEL,WIDTH,LOC,LUN                       DBGCOM
        INTEGER BLOP,BLOPEN,BLTYPE,BLWDTH                               DBGCOM
        INTEGER BASE,TCBOPN                                             DBGCOM
        REAL BLSTRT,BLSTOP                                              DBGCOM
C                                                                       DBGCOM
C                                                                       DBGCOM
C    TEMPORARY STORAGE                                                  DBGCOM
        INTEGER TEMP,BUFFER(81),TOKEN(81),STR1(81),IERR,I,J,REG(4)      DBGCOM
        INTEGER K,NAME(81)                                              DBGCOM
C   MULTIPLE BREAKPOINT TABLE                                           DBGCOM
        INTEGER BPTBL(10,5)                                             DBGCOM
C FUNCTIONS:                                                            DBGCOM
        INTEGER SRCST,INFILE,GETINT,EXTVT,IPFIX,APDIN,RMVTOK,RDLIN      DBGCOM
        INTEGER EXTSL,APDOUT,IAND16,IOR16,ILSH16                        DBGCOM
        REAL PFLOAT                                                     DBGCOM
C                                                                       DBGCOM
C-------DEFINED CONSTANTS                                               DBGCOM
C                                                                       DBGCOM
        INTEGER LSPACE,LPOINT,LEOF                                      DBGCOM
        INTEGER BPTSIZ,BPPTR,HALT(4)                                    DBGCOM
        INTEGER DEVADR(8)                                               DBGCOM
        INTEGER EFILNF,EEOF  ,ENUMBD,ERDXBD,EENADR,ECMDNF,ENOPN ,       DBGCOM
     1          EMNOPN,EIO   ,ENAMNF,EBREAK,ECMLNE,ETOMNY,ENRANG        DBGCOM
        INTEGER EBPTBG                                                  DBGCOM
C                                                                       DBGCOM
C-------MESSAGES
C
C                                                                       STARTPRE
C-------FPS100 REGISTER AND MEMORY MNEMONIC TABLE.
      INTEGER APRMPT(42),CNTOPN(28),APRUN(39),PROMPT(2),COMNDS(28),
     XMCMDS(6),OPENS(267),PSFLDS(167),ERRORS(361)
C STRNG APRMPT "ENTER WHICH AP TO USE, #1 IS THE FIRST AP"
      DATA APRMPT(2)/'E '/,APRMPT(3)/'N '/,APRMPT(4)/'T '/
      DATA APRMPT(5)/'E '/,APRMPT(6)/'R '/,APRMPT(7)/'  '/
      DATA APRMPT(8)/'W '/,APRMPT(9)/'H '/,APRMPT(10)/'I '/
      DATA APRMPT(11)/'C '/,APRMPT(12)/'H '/,APRMPT(13)/'  '/
      DATA APRMPT(14)/'A '/,APRMPT(15)/'P '/,APRMPT(16)/'  '/
      DATA APRMPT(17)/'T '/,APRMPT(18)/'O '/,APRMPT(19)/'  '/
      DATA APRMPT(20)/'U '/,APRMPT(21)/'S '/,APRMPT(22)/'E '/
      DATA APRMPT(23)/', '/,APRMPT(24)/'  '/,APRMPT(25)/'# '/
      DATA APRMPT(26)/'1 '/,APRMPT(27)/'  '/,APRMPT(28)/'I '/
      DATA APRMPT(29)/'S '/,APRMPT(30)/'  '/,APRMPT(31)/'T '/
      DATA APRMPT(32)/'H '/,APRMPT(33)/'E '/,APRMPT(34)/'  '/
      DATA APRMPT(35)/'F '/,APRMPT(36)/'I '/,APRMPT(37)/'R '/
      DATA APRMPT(38)/'S '/,APRMPT(39)/'T '/,APRMPT(40)/'  '/
      DATA APRMPT(41)/'A '/,APRMPT(42)/'P '/
      DATA APRMPT(1)/41/
C STRNG CNTOPN "REQUESTED AP NOT AVAILABLE?"
      DATA CNTOPN(2)/'R '/,CNTOPN(3)/'E '/,CNTOPN(4)/'Q '/
      DATA CNTOPN(5)/'U '/,CNTOPN(6)/'E '/,CNTOPN(7)/'S '/
      DATA CNTOPN(8)/'T '/,CNTOPN(9)/'E '/,CNTOPN(10)/'D '/
      DATA CNTOPN(11)/'  '/,CNTOPN(12)/'A '/,CNTOPN(13)/'P '/
      DATA CNTOPN(14)/'  '/,CNTOPN(15)/'N '/,CNTOPN(16)/'O '/
      DATA CNTOPN(17)/'T '/,CNTOPN(18)/'  '/,CNTOPN(19)/'A '/
      DATA CNTOPN(20)/'V '/,CNTOPN(21)/'A '/,CNTOPN(22)/'I '/
      DATA CNTOPN(23)/'L '/,CNTOPN(24)/'A '/,CNTOPN(25)/'B '/
      DATA CNTOPN(26)/'L '/,CNTOPN(27)/'E '/,CNTOPN(28)/'? '/
      DATA CNTOPN(1)/27/
C STRNG APRUN "THE AP IS RUNNING, TYPE  I  TO STOP IT"
      DATA APRUN(2)/'T '/,APRUN(3)/'H '/,APRUN(4)/'E '/,APRUN(5)/'  '/
      DATA APRUN(6)/'A '/,APRUN(7)/'P '/,APRUN(8)/'  '/,APRUN(9)/'I '/
      DATA APRUN(10)/'S '/,APRUN(11)/'  '/,APRUN(12)/'R '/
      DATA APRUN(13)/'U '/,APRUN(14)/'N '/,APRUN(15)/'N '/
      DATA APRUN(16)/'I '/,APRUN(17)/'N '/,APRUN(18)/'G '/
      DATA APRUN(19)/', '/,APRUN(20)/'  '/,APRUN(21)/'T '/
      DATA APRUN(22)/'Y '/,APRUN(23)/'P '/,APRUN(24)/'E '/
      DATA APRUN(25)/'  '/,APRUN(26)/'  '/,APRUN(27)/'I '/
      DATA APRUN(28)/'  '/,APRUN(29)/'  '/,APRUN(30)/'T '/
      DATA APRUN(31)/'O '/,APRUN(32)/'  '/,APRUN(33)/'S '/
      DATA APRUN(34)/'T '/,APRUN(35)/'O '/,APRUN(36)/'P '/
      DATA APRUN(37)/'  '/,APRUN(38)/'I '/,APRUN(39)/'T '/
      DATA APRUN(1)/38/
C STRNG PROMPT "*"
      DATA PROMPT(2)/'* '/
      DATA PROMPT(1)/1/
C TABLE 1,0,COMNDS,"R"
      DATA COMNDS(2)/1/,COMNDS(3)/0/
      DATA COMNDS(4)/'R '/
C TABLE 1,0,COMNDS,"Q"
      DATA COMNDS(5)/'Q '/
C TABLE 1,0,COMNDS,"B"
      DATA COMNDS(6)/'B '/
C TABLE 1,0,COMNDS,"D"
      DATA COMNDS(7)/'D '/
C TABLE 1,0,COMNDS,"S"
      DATA COMNDS(8)/'S '/
C TABLE 1,0,COMNDS,"F"
      DATA COMNDS(9)/'F '/
C TABLE 1,0,COMNDS,"V"
      DATA COMNDS(10)/'V '/
C TABLE 1,0,COMNDS,"L"
      DATA COMNDS(11)/'L '/
C TABLE 1,0,COMNDS,"E"
      DATA COMNDS(12)/'E '/
C TABLE 1,0,COMNDS,"."
      DATA COMNDS(13)/'. '/
C TABLE 1,0,COMNDS,"+"
      DATA COMNDS(14)/'+ '/
C TABLE 1,0,COMNDS,"-"
      DATA COMNDS(15)/'- '/
C TABLE 1,0,COMNDS,"I"
      DATA COMNDS(16)/'I '/
C TABLE 1,0,COMNDS,"C"
      DATA COMNDS(17)/'C '/
C TABLE 1,0,COMNDS,"P"
      DATA COMNDS(18)/'P '/
C TABLE 1,0,COMNDS,"Z"
      DATA COMNDS(19)/'Z '/
C TABLE 1,0,COMNDS,"N"
      DATA COMNDS(20)/'N '/
C TABLE 1,0,COMNDS,"Y"
      DATA COMNDS(21)/'Y '/
C TABLE 1,0,COMNDS,"W"
      DATA COMNDS(22)/'W '/
C TABLE 1,0,COMNDS,"O"
      DATA COMNDS(23)/'O '/
C TABLE 1,0,COMNDS,"X"
      DATA COMNDS(24)/'X '/
C TABLE 1,0,COMNDS,"J"
      DATA COMNDS(25)/'J '/
C TABLE 1,0,COMNDS,"G"
      DATA COMNDS(26)/'G '/
C TABLE 1,0,COMNDS,"U"
      DATA COMNDS(27)/'U '/
C TABLE 1,0,COMNDS,"M"
      DATA COMNDS(28)/'M '/
      DATA COMNDS(1)/25/
C TABLE 1,0,MCMDS,"S"
      DATA MCMDS(2)/1/,MCMDS(3)/0/
      DATA MCMDS(4)/'S '/
C TABLE 1,0,MCMDS,"C"
      DATA MCMDS(5)/'C '/
C TABLE 1,0,MCMDS,"D"
      DATA MCMDS(6)/'D '/
      DATA MCMDS(1)/28/
C TABLE 4,2,OPENS,"PSA" 0 1
      DATA OPENS(2)/4/,OPENS(3)/2/
      DATA OPENS(4)/'P '/,OPENS(5)/'S '/,OPENS(6)/'A '/,OPENS(7)/'  '/
      DATA OPENS(8)/0/,OPENS(9)/1/
C TABLE 4,2,OPENS,"SPD" 0 1
      DATA OPENS(10)/'S '/,OPENS(11)/'P '/,OPENS(12)/'D '/
      DATA OPENS(13)/'  '/
      DATA OPENS(14)/0/,OPENS(15)/1/
C TABLE 4,2,OPENS,"MA" 0 1
      DATA OPENS(16)/'M '/,OPENS(17)/'A '/,OPENS(18)/'  '/
      DATA OPENS(19)/'  '/
      DATA OPENS(20)/0/,OPENS(21)/1/
C TABLE 4,2,OPENS,"TMA" 0 1
      DATA OPENS(22)/'T '/,OPENS(23)/'M '/,OPENS(24)/'A '/
      DATA OPENS(25)/'  '/
      DATA OPENS(26)/0/,OPENS(27)/1/
C TABLE 4,2,OPENS,"DPA" 0 1
      DATA OPENS(28)/'D '/,OPENS(29)/'P '/,OPENS(30)/'A '/
      DATA OPENS(31)/'  '/
      DATA OPENS(32)/0/,OPENS(33)/1/
C TABLE 4,2,OPENS,"SP" 1 1
      DATA OPENS(34)/'S '/,OPENS(35)/'P '/,OPENS(36)/'  '/
      DATA OPENS(37)/'  '/
      DATA OPENS(38)/1/,OPENS(39)/1/
C TABLE 4,2,OPENS,"STAT" 0 1
      DATA OPENS(40)/'S '/,OPENS(41)/'T '/,OPENS(42)/'A '/
      DATA OPENS(43)/'T '/
      DATA OPENS(44)/0/,OPENS(45)/1/
C TABLE 4,2,OPENS,"DA" 0 1
      DATA OPENS(46)/'D '/,OPENS(47)/'A '/,OPENS(48)/'  '/
      DATA OPENS(49)/'  '/
      DATA OPENS(50)/0/,OPENS(51)/1/
C TABLE 4,2,OPENS,"PS" 1 4
      DATA OPENS(52)/'P '/,OPENS(53)/'S '/,OPENS(54)/'  '/
      DATA OPENS(55)/'  '/
      DATA OPENS(56)/1/,OPENS(57)/4/
C TABLE 4,2,OPENS,"IO" 1 3
      DATA OPENS(58)/'I '/,OPENS(59)/'O '/,OPENS(60)/'  '/
      DATA OPENS(61)/'  '/
      DATA OPENS(62)/1/,OPENS(63)/3/
C TABLE 4,2,OPENS," " 0 0
      DATA OPENS(64)/'  '/,OPENS(65)/'  '/,OPENS(66)/'  '/
      DATA OPENS(67)/'  '/
      DATA OPENS(68)/0/,OPENS(69)/0/
C TABLE 4,2,OPENS,"DPX" 1 3
      DATA OPENS(70)/'D '/,OPENS(71)/'P '/,OPENS(72)/'X '/
      DATA OPENS(73)/'  '/
      DATA OPENS(74)/1/,OPENS(75)/3/
C TABLE 4,2,OPENS,"DPY" 1 3
      DATA OPENS(76)/'D '/,OPENS(77)/'P '/,OPENS(78)/'Y '/
      DATA OPENS(79)/'  '/
      DATA OPENS(80)/1/,OPENS(81)/3/
C TABLE 4,2,OPENS,"MD" 1 3
      DATA OPENS(82)/'M '/,OPENS(83)/'D '/,OPENS(84)/'  '/
      DATA OPENS(85)/'  '/
      DATA OPENS(86)/1/,OPENS(87)/3/
C TABLE 4,2,OPENS,"SPFN" 0 1
      DATA OPENS(88)/'S '/,OPENS(89)/'P '/,OPENS(90)/'F '/
      DATA OPENS(91)/'N '/
      DATA OPENS(92)/0/,OPENS(93)/1/
C TABLE 4,2,OPENS,"TM" 1 3
      DATA OPENS(94)/'T '/,OPENS(95)/'M '/,OPENS(96)/'  '/
      DATA OPENS(97)/'  '/
      DATA OPENS(98)/1/,OPENS(99)/3/
C TABLE 4,2,OPENS,"SWR" 0 1
      DATA OPENS(100)/'S '/,OPENS(101)/'W '/,OPENS(102)/'R '/
      DATA OPENS(103)/'  '/
      DATA OPENS(104)/0/,OPENS(105)/1/
C TABLE 4,2,OPENS,"FN" 0 1
      DATA OPENS(106)/'F '/,OPENS(107)/'N '/,OPENS(108)/'  '/
      DATA OPENS(109)/'  '/
      DATA OPENS(110)/0/,OPENS(111)/1/
C TABLE 4,2,OPENS,"LITE" 0 1
      DATA OPENS(112)/'L '/,OPENS(113)/'I '/,OPENS(114)/'T '/
      DATA OPENS(115)/'E '/
      DATA OPENS(116)/0/,OPENS(117)/1/
C TABLE 4,2,OPENS,"APMA" 0 1
      DATA OPENS(118)/'A '/,OPENS(119)/'P '/,OPENS(120)/'M '/
      DATA OPENS(121)/'A '/
      DATA OPENS(122)/0/,OPENS(123)/1/
C TABLE 4,2,OPENS,"HMA" 0 1
      DATA OPENS(124)/'H '/,OPENS(125)/'M '/,OPENS(126)/'A '/
      DATA OPENS(127)/'  '/
      DATA OPENS(128)/0/,OPENS(129)/1/
C TABLE 4,2,OPENS,"WC" 0 1
      DATA OPENS(130)/'W '/,OPENS(131)/'C '/,OPENS(132)/'  '/
      DATA OPENS(133)/'  '/
      DATA OPENS(134)/0/,OPENS(135)/1/
C TABLE 4,2,OPENS,"CTL" 0 1
      DATA OPENS(136)/'C '/,OPENS(137)/'T '/,OPENS(138)/'L '/
      DATA OPENS(139)/'  '/
      DATA OPENS(140)/0/,OPENS(141)/1/
C TABLE 4,2,OPENS,"FMTH" 0 1
      DATA OPENS(142)/'F '/,OPENS(143)/'M '/,OPENS(144)/'T '/
      DATA OPENS(145)/'H '/
      DATA OPENS(146)/0/,OPENS(147)/1/
C TABLE 4,2,OPENS,"FMTL" 0 1
      DATA OPENS(148)/'F '/,OPENS(149)/'M '/,OPENS(150)/'T '/
      DATA OPENS(151)/'L '/
      DATA OPENS(152)/0/,OPENS(153)/1/
C TABLE 4,2,OPENS,"IFRS" 0 1
      DATA OPENS(154)/'I '/,OPENS(155)/'F '/,OPENS(156)/'R '/
      DATA OPENS(157)/'S '/
      DATA OPENS(158)/0/,OPENS(159)/1/
C TABLE 4,2,OPENS,"IFST" 0 1
      DATA OPENS(160)/'I '/,OPENS(161)/'F '/,OPENS(162)/'S '/
      DATA OPENS(163)/'T '/
      DATA OPENS(164)/0/,OPENS(165)/1/
C TABLE 4,2,OPENS,"MASK" 0 1
      DATA OPENS(166)/'M '/,OPENS(167)/'A '/,OPENS(168)/'S '/
      DATA OPENS(169)/'K '/
      DATA OPENS(170)/0/,OPENS(171)/1/
C TABLE 4,2,OPENS,"APME" 0 1
      DATA OPENS(172)/'A '/,OPENS(173)/'P '/,OPENS(174)/'M '/
      DATA OPENS(175)/'E '/
      DATA OPENS(176)/0/,OPENS(177)/1/
C TABLE 4,2,OPENS,"MAE" 0 1
      DATA OPENS(178)/'M '/,OPENS(179)/'A '/,OPENS(180)/'E '/
      DATA OPENS(181)/'  '/
      DATA OPENS(182)/0/,OPENS(183)/1/
C TABLE 4,2,OPENS,"CCTR" 2 1
      DATA OPENS(184)/'C '/,OPENS(185)/'C '/,OPENS(186)/'T '/
      DATA OPENS(187)/'R '/
      DATA OPENS(188)/2/,OPENS(189)/1/
C TABLE 4,2,OPENS,"CCST" 2 1
      DATA OPENS(190)/'C '/,OPENS(191)/'C '/,OPENS(192)/'S '/
      DATA OPENS(193)/'T '/
      DATA OPENS(194)/2/,OPENS(195)/1/
C TABLE 4,2,OPENS,"CCTL" 2 1
      DATA OPENS(196)/'C '/,OPENS(197)/'C '/,OPENS(198)/'T '/
      DATA OPENS(199)/'L '/
      DATA OPENS(200)/2/,OPENS(201)/1/
C TABLE 4,2,OPENS,"IMSK" 2 1
      DATA OPENS(202)/'I '/,OPENS(203)/'M '/,OPENS(204)/'S '/
      DATA OPENS(205)/'K '/
      DATA OPENS(206)/2/,OPENS(207)/1/
C TABLE 4,2,OPENS," " 0 0
      DATA OPENS(208)/'  '/,OPENS(209)/'  '/,OPENS(210)/'  '/
      DATA OPENS(211)/'  '/
      DATA OPENS(212)/0/,OPENS(213)/0/
C TABLE 4,2,OPENS," " 0 0
      DATA OPENS(214)/'  '/,OPENS(215)/'  '/,OPENS(216)/'  '/
      DATA OPENS(217)/'  '/
      DATA OPENS(218)/0/,OPENS(219)/0/
C TABLE 4,2,OPENS,"ST3" 2 1
      DATA OPENS(220)/'S '/,OPENS(221)/'T '/,OPENS(222)/'3 '/
      DATA OPENS(223)/'  '/
      DATA OPENS(224)/2/,OPENS(225)/1/
C TABLE 4,2,OPENS,"ST2" 2 1
      DATA OPENS(226)/'S '/,OPENS(227)/'T '/,OPENS(228)/'2 '/
      DATA OPENS(229)/'  '/
      DATA OPENS(230)/2/,OPENS(231)/1/
C TABLE 4,2,OPENS,"SMA" 0 1
      DATA OPENS(232)/'S '/,OPENS(233)/'M '/,OPENS(234)/'A '/
      DATA OPENS(235)/'  '/
      DATA OPENS(236)/0/,OPENS(237)/1/
C TABLE 4,2,OPENS,"MDR" 0 3
      DATA OPENS(238)/'M '/,OPENS(239)/'D '/,OPENS(240)/'R '/
      DATA OPENS(241)/'  '/
      DATA OPENS(242)/0/,OPENS(243)/3/
C TABLE 4,2,OPENS,"TMR" 0 3
      DATA OPENS(244)/'T '/,OPENS(245)/'M '/,OPENS(246)/'R '/
      DATA OPENS(247)/'  '/
      DATA OPENS(248)/0/,OPENS(249)/3/
C TABLE 4,2,OPENS,"TCB" 3 1
      DATA OPENS(250)/'T '/,OPENS(251)/'C '/,OPENS(252)/'B '/
      DATA OPENS(253)/'  '/
      DATA OPENS(254)/3/,OPENS(255)/1/
C TABLE 4,2,OPENS,"DPXA" 1 3
      DATA OPENS(256)/'D '/,OPENS(257)/'P '/,OPENS(258)/'X '/
      DATA OPENS(259)/'A '/
      DATA OPENS(260)/1/,OPENS(261)/3/
C TABLE 4,2,OPENS,"DPYA" 1 3
      DATA OPENS(262)/'D '/,OPENS(263)/'P '/,OPENS(264)/'Y '/
      DATA OPENS(265)/'A '/
      DATA OPENS(266)/1/,OPENS(267)/3/
      DATA OPENS(1)/72/
C TABLE 4,0,PSFLDS,"B"
      DATA PSFLDS(2)/4/,PSFLDS(3)/0/
      DATA PSFLDS(4)/'B '/,PSFLDS(5)/'  '/,PSFLDS(6)/'  '/
      DATA PSFLDS(7)/'  '/
C TABLE 4,0,PSFLDS,"SOP"
      DATA PSFLDS(8)/'S '/,PSFLDS(9)/'O '/,PSFLDS(10)/'P '/
      DATA PSFLDS(11)/'  '/
C TABLE 4,0,PSFLDS,"SH"
      DATA PSFLDS(12)/'S '/,PSFLDS(13)/'H '/,PSFLDS(14)/'  '/
      DATA PSFLDS(15)/'  '/
C TABLE 4,0,PSFLDS,"SPS"
      DATA PSFLDS(16)/'S '/,PSFLDS(17)/'P '/,PSFLDS(18)/'S '/
      DATA PSFLDS(19)/'  '/
C TABLE 4,0,PSFLDS,"SPD"
      DATA PSFLDS(20)/'S '/,PSFLDS(21)/'P '/,PSFLDS(22)/'D '/
      DATA PSFLDS(23)/'  '/
C TABLE 4,0,PSFLDS,"FADD"
      DATA PSFLDS(24)/'F '/,PSFLDS(25)/'A '/,PSFLDS(26)/'D '/
      DATA PSFLDS(27)/'D '/
C TABLE 4,0,PSFLDS,"A1"
      DATA PSFLDS(28)/'A '/,PSFLDS(29)/'1 '/,PSFLDS(30)/'  '/
      DATA PSFLDS(31)/'  '/
C TABLE 4,0,PSFLDS,"A2"
      DATA PSFLDS(32)/'A '/,PSFLDS(33)/'2 '/,PSFLDS(34)/'  '/
      DATA PSFLDS(35)/'  '/
C TABLE 4,0,PSFLDS,"COND"
      DATA PSFLDS(36)/'C '/,PSFLDS(37)/'O '/,PSFLDS(38)/'N '/
      DATA PSFLDS(39)/'D '/
C TABLE 4,0,PSFLDS,"DISP"
      DATA PSFLDS(40)/'D '/,PSFLDS(41)/'I '/,PSFLDS(42)/'S '/
      DATA PSFLDS(43)/'P '/
C TABLE 4,0,PSFLDS,"DPX"
      DATA PSFLDS(44)/'D '/,PSFLDS(45)/'P '/,PSFLDS(46)/'X '/
      DATA PSFLDS(47)/'  '/
C TABLE 4,0,PSFLDS,"DPY"
      DATA PSFLDS(48)/'D '/,PSFLDS(49)/'P '/,PSFLDS(50)/'Y '/
      DATA PSFLDS(51)/'  '/
C TABLE 4,0,PSFLDS,"DPBS"
      DATA PSFLDS(52)/'D '/,PSFLDS(53)/'P '/,PSFLDS(54)/'B '/
      DATA PSFLDS(55)/'S '/
C TABLE 4,0,PSFLDS,"XR"
      DATA PSFLDS(56)/'X '/,PSFLDS(57)/'R '/,PSFLDS(58)/'  '/
      DATA PSFLDS(59)/'  '/
C TABLE 4,0,PSFLDS,"YR"
      DATA PSFLDS(60)/'Y '/,PSFLDS(61)/'R '/,PSFLDS(62)/'  '/
      DATA PSFLDS(63)/'  '/
C TABLE 4,0,PSFLDS,"XW"
      DATA PSFLDS(64)/'X '/,PSFLDS(65)/'W '/,PSFLDS(66)/'  '/
      DATA PSFLDS(67)/'  '/
C TABLE 4,0,PSFLDS,"YW"
      DATA PSFLDS(68)/'Y '/,PSFLDS(69)/'W '/,PSFLDS(70)/'  '/
      DATA PSFLDS(71)/'  '/
C TABLE 4,0,PSFLDS,"FM"
      DATA PSFLDS(72)/'F '/,PSFLDS(73)/'M '/,PSFLDS(74)/'  '/
      DATA PSFLDS(75)/'  '/
C TABLE 4,0,PSFLDS,"M1"
      DATA PSFLDS(76)/'M '/,PSFLDS(77)/'1 '/,PSFLDS(78)/'  '/
      DATA PSFLDS(79)/'  '/
C TABLE 4,0,PSFLDS,"M2"
      DATA PSFLDS(80)/'M '/,PSFLDS(81)/'2 '/,PSFLDS(82)/'  '/
      DATA PSFLDS(83)/'  '/
C TABLE 4,0,PSFLDS,"MI"
      DATA PSFLDS(84)/'M '/,PSFLDS(85)/'I '/,PSFLDS(86)/'  '/
      DATA PSFLDS(87)/'  '/
C TABLE 4,0,PSFLDS,"MA"
      DATA PSFLDS(88)/'M '/,PSFLDS(89)/'A '/,PSFLDS(90)/'  '/
      DATA PSFLDS(91)/'  '/
C TABLE 4,0,PSFLDS,"DPA"
      DATA PSFLDS(92)/'D '/,PSFLDS(93)/'P '/,PSFLDS(94)/'A '/
      DATA PSFLDS(95)/'  '/
C TABLE 4,0,PSFLDS,"TMA"
      DATA PSFLDS(96)/'T '/,PSFLDS(97)/'M '/,PSFLDS(98)/'A '/
      DATA PSFLDS(99)/'  '/
C TABLE 4,0,PSFLDS,"SOP1"
      DATA PSFLDS(100)/'S '/,PSFLDS(101)/'O '/,PSFLDS(102)/'P '/
      DATA PSFLDS(103)/'1 '/
C TABLE 4,0,PSFLDS,"SPEC"
      DATA PSFLDS(104)/'S '/,PSFLDS(105)/'P '/,PSFLDS(106)/'E '/
      DATA PSFLDS(107)/'C '/
C TABLE 4,0,PSFLDS,"STST"
      DATA PSFLDS(108)/'S '/,PSFLDS(109)/'T '/,PSFLDS(110)/'S '/
      DATA PSFLDS(111)/'T '/
C TABLE 4,0,PSFLDS,"HPNL"
      DATA PSFLDS(112)/'H '/,PSFLDS(113)/'P '/,PSFLDS(114)/'N '/
      DATA PSFLDS(115)/'L '/
C TABLE 4,0,PSFLDS,"SPSA"
      DATA PSFLDS(116)/'S '/,PSFLDS(117)/'P '/,PSFLDS(118)/'S '/
      DATA PSFLDS(119)/'A '/
C TABLE 4,0,PSFLDS,"PSEV"
      DATA PSFLDS(120)/'P '/,PSFLDS(121)/'S '/,PSFLDS(122)/'E '/
      DATA PSFLDS(123)/'V '/
C TABLE 4,0,PSFLDS,"PSOD"
      DATA PSFLDS(124)/'P '/,PSFLDS(125)/'S '/,PSFLDS(126)/'O '/
      DATA PSFLDS(127)/'D '/
C TABLE 4,0,PSFLDS,"PS"
      DATA PSFLDS(128)/'P '/,PSFLDS(129)/'S '/,PSFLDS(130)/'  '/
      DATA PSFLDS(131)/'  '/
C TABLE 4,0,PSFLDS,"SEXT"
      DATA PSFLDS(132)/'S '/,PSFLDS(133)/'E '/,PSFLDS(134)/'X '/
      DATA PSFLDS(135)/'T '/
C TABLE 4,0,PSFLDS,"FAD1"
      DATA PSFLDS(136)/'F '/,PSFLDS(137)/'A '/,PSFLDS(138)/'D '/
      DATA PSFLDS(139)/'1 '/
C TABLE 4,0,PSFLDS,"IO"
      DATA PSFLDS(140)/'I '/,PSFLDS(141)/'O '/,PSFLDS(142)/'  '/
      DATA PSFLDS(143)/'  '/
C TABLE 4,0,PSFLDS,"LREG"
      DATA PSFLDS(144)/'L '/,PSFLDS(145)/'R '/,PSFLDS(146)/'E '/
      DATA PSFLDS(147)/'G '/
C TABLE 4,0,PSFLDS,"RREG"
      DATA PSFLDS(148)/'R '/,PSFLDS(149)/'R '/,PSFLDS(150)/'E '/
      DATA PSFLDS(151)/'G '/
C TABLE 4,0,PSFLDS,"IOUT"
      DATA PSFLDS(152)/'I '/,PSFLDS(153)/'O '/,PSFLDS(154)/'U '/
      DATA PSFLDS(155)/'T '/
C TABLE 4,0,PSFLDS,"SNSE"
      DATA PSFLDS(156)/'S '/,PSFLDS(157)/'N '/,PSFLDS(158)/'S '/
      DATA PSFLDS(159)/'E '/
C TABLE 4,0,PSFLDS,"FLAG"
      DATA PSFLDS(160)/'F '/,PSFLDS(161)/'L '/,PSFLDS(162)/'A '/
      DATA PSFLDS(163)/'G '/
C TABLE 4,0,PSFLDS,"CONT"
      DATA PSFLDS(164)/'C '/,PSFLDS(165)/'O '/,PSFLDS(166)/'N '/
      DATA PSFLDS(167)/'T '/
      DATA PSFLDS(1)/113/
C LIST ERRORS "FILE NOT FOUND OR UNAVAILABLE?: "
      DATA ERRORS(3)/'F '/,ERRORS(4)/'I '/,ERRORS(5)/'L '/
      DATA ERRORS(6)/'E '/,ERRORS(7)/'  '/,ERRORS(8)/'N '/
      DATA ERRORS(9)/'O '/,ERRORS(10)/'T '/,ERRORS(11)/'  '/
      DATA ERRORS(12)/'F '/,ERRORS(13)/'O '/,ERRORS(14)/'U '/
      DATA ERRORS(15)/'N '/,ERRORS(16)/'D '/,ERRORS(17)/'  '/
      DATA ERRORS(18)/'O '/,ERRORS(19)/'R '/,ERRORS(20)/'  '/
      DATA ERRORS(21)/'U '/,ERRORS(22)/'N '/,ERRORS(23)/'A '/
      DATA ERRORS(24)/'V '/,ERRORS(25)/'A '/,ERRORS(26)/'I '/
      DATA ERRORS(27)/'L '/,ERRORS(28)/'A '/,ERRORS(29)/'B '/
      DATA ERRORS(30)/'L '/,ERRORS(31)/'E '/,ERRORS(32)/'? '/
      DATA ERRORS(33)/': '/,ERRORS(34)/'  '/
      DATA ERRORS(2)/32/
C     "UNEXPECTED END OF FILE?"
      DATA ERRORS(36)/'U '/,ERRORS(37)/'N '/,ERRORS(38)/'E '/
      DATA ERRORS(39)/'X '/,ERRORS(40)/'P '/,ERRORS(41)/'E '/
      DATA ERRORS(42)/'C '/,ERRORS(43)/'T '/,ERRORS(44)/'E '/
      DATA ERRORS(45)/'D '/,ERRORS(46)/'  '/,ERRORS(47)/'E '/
      DATA ERRORS(48)/'N '/,ERRORS(49)/'D '/,ERRORS(50)/'  '/
      DATA ERRORS(51)/'O '/,ERRORS(52)/'F '/,ERRORS(53)/'  '/
      DATA ERRORS(54)/'F '/,ERRORS(55)/'I '/,ERRORS(56)/'L '/
      DATA ERRORS(57)/'E '/,ERRORS(58)/'? '/
      DATA ERRORS(35)/23/
C     "BAD NUMBER?: "
      DATA ERRORS(60)/'B '/,ERRORS(61)/'A '/,ERRORS(62)/'D '/
      DATA ERRORS(63)/'  '/,ERRORS(64)/'N '/,ERRORS(65)/'U '/
      DATA ERRORS(66)/'M '/,ERRORS(67)/'B '/,ERRORS(68)/'E '/
      DATA ERRORS(69)/'R '/,ERRORS(70)/'? '/,ERRORS(71)/': '/
      DATA ERRORS(72)/'  '/
      DATA ERRORS(59)/13/
C     "BAD RADIX?: "
      DATA ERRORS(74)/'B '/,ERRORS(75)/'A '/,ERRORS(76)/'D '/
      DATA ERRORS(77)/'  '/,ERRORS(78)/'R '/,ERRORS(79)/'A '/
      DATA ERRORS(80)/'D '/,ERRORS(81)/'I '/,ERRORS(82)/'X '/
      DATA ERRORS(83)/'? '/,ERRORS(84)/': '/,ERRORS(85)/'  '/
      DATA ERRORS(73)/12/
C     "STARTING ADDRESS GREATER THAN ENDING ADDRESS?"
      DATA ERRORS(87)/'S '/,ERRORS(88)/'T '/,ERRORS(89)/'A '/
      DATA ERRORS(90)/'R '/,ERRORS(91)/'T '/,ERRORS(92)/'I '/
      DATA ERRORS(93)/'N '/,ERRORS(94)/'G '/,ERRORS(95)/'  '/
      DATA ERRORS(96)/'A '/,ERRORS(97)/'D '/,ERRORS(98)/'D '/
      DATA ERRORS(99)/'R '/,ERRORS(100)/'E '/,ERRORS(101)/'S '/
      DATA ERRORS(102)/'S '/,ERRORS(103)/'  '/,ERRORS(104)/'G '/
      DATA ERRORS(105)/'R '/,ERRORS(106)/'E '/,ERRORS(107)/'A '/
      DATA ERRORS(108)/'T '/,ERRORS(109)/'E '/,ERRORS(110)/'R '/
      DATA ERRORS(111)/'  '/,ERRORS(112)/'T '/,ERRORS(113)/'H '/
      DATA ERRORS(114)/'A '/,ERRORS(115)/'N '/,ERRORS(116)/'  '/
      DATA ERRORS(117)/'E '/,ERRORS(118)/'N '/,ERRORS(119)/'D '/
      DATA ERRORS(120)/'I '/,ERRORS(121)/'N '/,ERRORS(122)/'G '/
      DATA ERRORS(123)/'  '/,ERRORS(124)/'A '/,ERRORS(125)/'D '/
      DATA ERRORS(126)/'D '/,ERRORS(127)/'R '/,ERRORS(128)/'E '/
      DATA ERRORS(129)/'S '/,ERRORS(130)/'S '/,ERRORS(131)/'? '/
      DATA ERRORS(86)/45/
C     "COMMAND NOT FOUND?: "
      DATA ERRORS(133)/'C '/,ERRORS(134)/'O '/,ERRORS(135)/'M '/
      DATA ERRORS(136)/'M '/,ERRORS(137)/'A '/,ERRORS(138)/'N '/
      DATA ERRORS(139)/'D '/,ERRORS(140)/'  '/,ERRORS(141)/'N '/
      DATA ERRORS(142)/'O '/,ERRORS(143)/'T '/,ERRORS(144)/'  '/
      DATA ERRORS(145)/'F '/,ERRORS(146)/'O '/,ERRORS(147)/'U '/
      DATA ERRORS(148)/'N '/,ERRORS(149)/'D '/,ERRORS(150)/'? '/
      DATA ERRORS(151)/': '/,ERRORS(152)/'  '/
      DATA ERRORS(132)/20/
C     "NOTHING OPEN?"
      DATA ERRORS(154)/'N '/,ERRORS(155)/'O '/,ERRORS(156)/'T '/
      DATA ERRORS(157)/'H '/,ERRORS(158)/'I '/,ERRORS(159)/'N '/
      DATA ERRORS(160)/'G '/,ERRORS(161)/'  '/,ERRORS(162)/'O '/
      DATA ERRORS(163)/'P '/,ERRORS(164)/'E '/,ERRORS(165)/'N '/
      DATA ERRORS(166)/'? '/
      DATA ERRORS(153)/13/
C     "A MEMORY NOT OPEN?"
      DATA ERRORS(168)/'A '/,ERRORS(169)/'  '/,ERRORS(170)/'M '/
      DATA ERRORS(171)/'E '/,ERRORS(172)/'M '/,ERRORS(173)/'O '/
      DATA ERRORS(174)/'R '/,ERRORS(175)/'Y '/,ERRORS(176)/'  '/
      DATA ERRORS(177)/'N '/,ERRORS(178)/'O '/,ERRORS(179)/'T '/
      DATA ERRORS(180)/'  '/,ERRORS(181)/'O '/,ERRORS(182)/'P '/
      DATA ERRORS(183)/'E '/,ERRORS(184)/'N '/,ERRORS(185)/'? '/
      DATA ERRORS(167)/18/
C     "I/O ERROR?"
      DATA ERRORS(187)/'I '/,ERRORS(188)/'/ '/,ERRORS(189)/'O '/
      DATA ERRORS(190)/'  '/,ERRORS(191)/'E '/,ERRORS(192)/'R '/
      DATA ERRORS(193)/'R '/,ERRORS(194)/'O '/,ERRORS(195)/'R '/
      DATA ERRORS(196)/'? '/
      DATA ERRORS(186)/10/
C     "NAME NOT FOUND?: "
      DATA ERRORS(198)/'N '/,ERRORS(199)/'A '/,ERRORS(200)/'M '/
      DATA ERRORS(201)/'E '/,ERRORS(202)/'  '/,ERRORS(203)/'N '/
      DATA ERRORS(204)/'O '/,ERRORS(205)/'T '/,ERRORS(206)/'  '/
      DATA ERRORS(207)/'F '/,ERRORS(208)/'O '/,ERRORS(209)/'U '/
      DATA ERRORS(210)/'N '/,ERRORS(211)/'D '/,ERRORS(212)/'? '/
      DATA ERRORS(213)/': '/,ERRORS(214)/'  '/
      DATA ERRORS(197)/17/
C     "APDBUG - USER REQUESTED BREAK!"
      DATA ERRORS(216)/'A '/,ERRORS(217)/'P '/,ERRORS(218)/'D '/
      DATA ERRORS(219)/'B '/,ERRORS(220)/'U '/,ERRORS(221)/'G '/
      DATA ERRORS(222)/'  '/,ERRORS(223)/'- '/,ERRORS(224)/'  '/
      DATA ERRORS(225)/'U '/,ERRORS(226)/'S '/,ERRORS(227)/'E '/
      DATA ERRORS(228)/'R '/,ERRORS(229)/'  '/,ERRORS(230)/'R '/
      DATA ERRORS(231)/'E '/,ERRORS(232)/'Q '/,ERRORS(233)/'U '/
      DATA ERRORS(234)/'E '/,ERRORS(235)/'S '/,ERRORS(236)/'T '/
      DATA ERRORS(237)/'E '/,ERRORS(238)/'D '/,ERRORS(239)/'  '/
      DATA ERRORS(240)/'B '/,ERRORS(241)/'R '/,ERRORS(242)/'E '/
      DATA ERRORS(243)/'A '/,ERRORS(244)/'K '/,ERRORS(245)/'! '/
      DATA ERRORS(215)/30/
C     "TOO MANY ARGUMENTS?: "
      DATA ERRORS(247)/'T '/,ERRORS(248)/'O '/,ERRORS(249)/'O '/
      DATA ERRORS(250)/'  '/,ERRORS(251)/'M '/,ERRORS(252)/'A '/
      DATA ERRORS(253)/'N '/,ERRORS(254)/'Y '/,ERRORS(255)/'  '/
      DATA ERRORS(256)/'A '/,ERRORS(257)/'R '/,ERRORS(258)/'G '/
      DATA ERRORS(259)/'U '/,ERRORS(260)/'M '/,ERRORS(261)/'E '/
      DATA ERRORS(262)/'N '/,ERRORS(263)/'T '/,ERRORS(264)/'S '/
      DATA ERRORS(265)/'? '/,ERRORS(266)/': '/,ERRORS(267)/'  '/
      DATA ERRORS(246)/21/
C     "DATA FILE LONGER THAN COUNT?"
      DATA ERRORS(269)/'D '/,ERRORS(270)/'A '/,ERRORS(271)/'T '/
      DATA ERRORS(272)/'A '/,ERRORS(273)/'  '/,ERRORS(274)/'F '/
      DATA ERRORS(275)/'I '/,ERRORS(276)/'L '/,ERRORS(277)/'E '/
      DATA ERRORS(278)/'  '/,ERRORS(279)/'L '/,ERRORS(280)/'O '/
      DATA ERRORS(281)/'N '/,ERRORS(282)/'G '/,ERRORS(283)/'E '/
      DATA ERRORS(284)/'R '/,ERRORS(285)/'  '/,ERRORS(286)/'T '/
      DATA ERRORS(287)/'H '/,ERRORS(288)/'A '/,ERRORS(289)/'N '/
      DATA ERRORS(290)/'  '/,ERRORS(291)/'C '/,ERRORS(292)/'O '/
      DATA ERRORS(293)/'U '/,ERRORS(294)/'N '/,ERRORS(295)/'T '/
      DATA ERRORS(296)/'? '/
      DATA ERRORS(268)/28/
C     "OUTPUT OVERFLOW OR UNDERFLOW?"
      DATA ERRORS(298)/'O '/,ERRORS(299)/'U '/,ERRORS(300)/'T '/
      DATA ERRORS(301)/'P '/,ERRORS(302)/'U '/,ERRORS(303)/'T '/
      DATA ERRORS(304)/'  '/,ERRORS(305)/'O '/,ERRORS(306)/'V '/
      DATA ERRORS(307)/'E '/,ERRORS(308)/'R '/,ERRORS(309)/'F '/
      DATA ERRORS(310)/'L '/,ERRORS(311)/'O '/,ERRORS(312)/'W '/
      DATA ERRORS(313)/'  '/,ERRORS(314)/'O '/,ERRORS(315)/'R '/
      DATA ERRORS(316)/'  '/,ERRORS(317)/'U '/,ERRORS(318)/'N '/
      DATA ERRORS(319)/'D '/,ERRORS(320)/'E '/,ERRORS(321)/'R '/
      DATA ERRORS(322)/'F '/,ERRORS(323)/'L '/,ERRORS(324)/'O '/
      DATA ERRORS(325)/'W '/,ERRORS(326)/'? '/
      DATA ERRORS(297)/29/
C     "MULTIPLE BREAKPOINT TABLE IS FULL!"
      DATA ERRORS(328)/'M '/,ERRORS(329)/'U '/,ERRORS(330)/'L '/
      DATA ERRORS(331)/'T '/,ERRORS(332)/'I '/,ERRORS(333)/'P '/
      DATA ERRORS(334)/'L '/,ERRORS(335)/'E '/,ERRORS(336)/'  '/
      DATA ERRORS(337)/'B '/,ERRORS(338)/'R '/,ERRORS(339)/'E '/
      DATA ERRORS(340)/'A '/,ERRORS(341)/'K '/,ERRORS(342)/'P '/
      DATA ERRORS(343)/'O '/,ERRORS(344)/'I '/,ERRORS(345)/'N '/
      DATA ERRORS(346)/'T '/,ERRORS(347)/'  '/,ERRORS(348)/'T '/
      DATA ERRORS(349)/'A '/,ERRORS(350)/'B '/,ERRORS(351)/'L '/
      DATA ERRORS(352)/'E '/,ERRORS(353)/'  '/,ERRORS(354)/'I '/
      DATA ERRORS(355)/'S '/,ERRORS(356)/'  '/,ERRORS(357)/'F '/
      DATA ERRORS(358)/'U '/,ERRORS(359)/'L '/,ERRORS(360)/'L '/
      DATA ERRORS(361)/'! '/
      DATA ERRORS(327)/34/,ERRORS(1)/15/
C                                                                       ENDPRE
C
C-------LOCAL DATA INITIALIZATION
C
        DATA    EFILNF,EEOF  ,ENUMBD,ERDXBD,EENADR,ECMDNF,ENOPN /
     1               1,     2,     3,     4,     5,     6,     7/
        DATA    EMNOPN,EIO   ,ENAMNF,EBREAK,ECMLNE,ETOMNY,ENRANG/
     1               8,     9,    10,    11,    12,    13,    14/
        DATA EBPTBG/
     1           15/
C
        DATA    LSPACE,LPOINT,LEOF/8224,8238,8285/
C
C   MULTIPLE BREAKPOINT INITIALIZATION
C
        DATA BPPTR,BPTSIZ,HALT(1),HALT(2),HALT(3),HALT(4)/
     1           0,10,     3,  -4096,      0,      0/
C
C-------I/O DEVICE ADDRESSES FOR &AP REGISTERS
C
C            RTCCTR         RTCCST
        DATA DEVADR(1)/248/,DEVADR(2)/249/
C            RTCCTL         IMASK
        DATA DEVADR(3)/250/,DEVADR(4)/251/
C            NOT USED       NOT USED
        DATA DEVADR(5)/252/,DEVADR(6)/253/
C            APSTAT3        APSTAT2
        DATA DEVADR(7)/254/,DEVADR(8)/255/
C
C
C-------DEFAULT SETTINGS OF STATE VARIABLES
C
        DATA FP    ,FIE   ,OFFSET,OPEN  ,IPROC ,ISTEP ,BRKTYP,BRKLOC/
     1            1,     0,     0,     0,     1,  8192,     0,     0/
        DATA LUN   / 2/
C
C-------THE DEFAULT INTEGER RADIX IS SET TO 8 FOR OCTAL, IT MAY BE CHANGED
C       TO WHATEVER IS THE HOST SYSTEM DEFAULT.
C
        DATA RADIX / 8/
C
C-------DEFINE THE CURRENTLY OPEN TCB ELEMENT AND THE TCB BASE ADDRESS
C
        DATA TCBOPN,BASE/0,0/
C
C-------IF ANY LUN MAPPING IS DONE BY INFILE, LUNMAP SHOULD BE SET SO
C       THAT WHEN ADDED TO THE INFILE LUN, FORTRAN READ/WRITES CAN BE
C       DONE.
C
        DATA LUNMAP /7/
C
C
C
C-------INITIALIZE
C
C    EMPTY COMMAND STRING
        CALL RMVCS(BUFFER,1,-1)
C    OPEN THE TTY
        I=INFILE(3,0,-1)
C    STOP IF CAN'T OPEN THE TTY
        IF (I.NE.0) CALL EXIT
C    GREET THE USER
        WRITE(5,9999)
9999    FORMAT(' DGB100 REL.  1.00 , 04/20/79')
        GO TO 10
C
C    CAN'T OPEN REQUESTED AP
9       CALL WRTLIN(CNTOPN,-1,80)
C
C    PROMPT FOR AP NUMBER
10      CALL WRTLIN(APRMPT,-1,80)
C    GET THE AP # TO DEBUG
        TEMP=GETINT(BUFFER,TOKEN,10,-1,IERR)
        IF (TOKEN(2).EQ.8280) GO TO 4300
        IF (IERR.NE.0) GO TO 9
        CALL APASGN(TEMP,1,I)
C    SEE IF REALLY ASSIGNED
        IF (I.NE.TEMP) GO TO 9
C     PLACE HOST AP DRIVER IN NON-SUPERVISOR MODE.
        CALL APSUPV(0)
C    SHOW USER STATE OF AP BY DISPLAYING APSTAT2.
        I=38
        GO TO 1810
C
C
C-------COMMAND LOOP, GET A NEW COMMAND AND GO DO IT
C
C    IF THE BUFFER STILL HAS STUFF IN IT FROM THE LAST COMMAND, THEN AN ERROR
1000    IERR=ECMLNE
        IF (RMVTOK(TOKEN,80,BUFFER,10).NE.0) GO TO 9000
C    SEE IF THE AP IS RUNNING, IF SO TELL THE USER
        CALL APEXAM(TEMP,18,0)
        IF (NEGCHK(TEMP).NE.1) CALL WRTLIN(APRUN,-1,80)
C    PUT OUT THE PROMPT
        CALL WRTLIN(PROMPT,-1,80)
C    GET COMMAND
        CALL GETSYM(BUFFER,TOKEN,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
C    LOOK UP COMMAND
        IERR=ECMDNF
        I=SRCST(COMNDS,1,-1,TOKEN,-1)
        IF (I.EQ.0) GO TO 9000
        IP1=0
C    BRANCH ON THE TYPE OF COMMAND USER TYPED.
C              R    Q    B    D    S    F    V    L    E    .
        GO TO (1100,1200,1300,1400,1500,1600,1700,1750,1800,1900,
     1         2000,2100,2200,2300,1105,5000,4000,5000,5000,4100,
     2         4300,4400,4500,4600,8000),I
C              +    -    I    C    P    Z    N    Y    W    O
C              X    J    G    U    M
C
C----------------------------------------------------------------------
C------- IN THE MAINLINE DRIVER TWO VARIABLES ARE USED FOR A SPECIAL
C------- PURPOSE.  THEY ARE IP1 AND IP2.  IP1 IS USED TO SIMULATE ENTRY
C------- POINTS IN A DBG100 SUBROUTINE.  IP2 IS USED TO SIMULATE
C------- ALTERNATE RETURN LABELS IN THE MAINLINE.
C----------------------------------------------------------------------
C
C
C-------RUN: 'R'
C
C    GET P.S. ADDRESS
1100      CONTINUE
          CALL SUBRUN(IP1,IP2,OPENS,PSFLDS)
          IP2=IP2+1
          GOTO(1000,9000,8999,1900),IP2
1105      CONTINUE
          IP1=1
          GOTO 1100
1112      CONTINUE
          IP1=2
          GOTO 1100
C
C-------PROCESS THE BASIC COMMANDS 'Q', 'B', 'D', 'S', 'F', 'V', 'L'
C
1200      CONTINUE
          CALL SUBTRS(IP1,IP2,OPENS,ERRORS)
          IP2=IP2+1
          GOTO(9000,1000),IP2
1300      CONTINUE
          IP1=1
          GOTO 1200
1400      CONTINUE
          IP1=2
          GOTO 1200
1500      CONTINUE
          IP1=3
          GOTO 1200
1600      CONTINUE
          IP1=4
          GOTO 1200
1700      CONTINUE
          IP1=5
          GOTO 1200
1750      CONTINUE
          IP1=6
          GOTO 1200
C
C-----EXAMINE: 'E'
C
1800      CONTINUE
          CALL SUBEXM(IP1,IP2,OPENS,PSFLDS)
          IP2=IP2+1
          GOTO (9000,8999,1000),IP2
1810      CONTINUE
          IP1=1
          GOTO 1800
1820      CONTINUE
          IP1=2
          GOTO 1800
1900      CONTINUE
          IP1=3
          GOTO 1800
2000      CONTINUE
          IP1=4
          GOTO 1800
2100      CONTINUE
          IP1=5
          GOTO 1800
C
C-------RESET THE AP (INITIALIZE): 'I'
C
C    SET APSTAT2 TO USER MODE AND DISPLAY IT.
C    THEN PROCESS MULTPLE BREAKPOINT SUBSTITUTION IF NECESSARY.
2200    CALL APRSET
        CALL DEPST2(0)
        OPEN=38
        LOC=255
        TYPEL=2
        WIDTH=1
        J=1
        GOTO 1112
C
C-------CHANGE CURRENT OPEN LOCATION: 'C'
C
2300    IERR=ENOPN
        IF (OPEN.EQ.0) GO TO 8999
C    SEE IF WE ARE CHANGING A TCB ELEMENT
        IF (TYPEL.NE.3) GO TO 2310
        CALL TCBEXM(5,BUFFER,TOKEN,-1,REG,WIDTH,TYPEL,
     1        LOC,TCBOPN,BASE,RADIX,FP,FIE,OFFSET,IERR)
        IF (IERR.NE.0) GO TO 8999
        GO TO 1000
C
C       INPUT A VALUE
2310    IERR=APDIN(REG,LOC,WIDTH,RADIX,FP,FIE,PSFLDS,-1,BUFFER,TOKEN)
        IF (IERR.NE.0) GO TO 9000
C
C       IF CHANGING PSA, ADD OFFSET TO NEW VALUE
        IF (OPEN.EQ.1) REG(1)=REG(1)+OFFSET
C
C    PUT THE NEW DATA INTO THE AP HARDWARE
        CALL APDEP(REG,OPEN,LOC)
        GOTO 1000
C
C-------SET RADIX:    'N'
C
4000    TEMP=GETINT(BUFFER,TOKEN,10,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        IERR=ERDXBD
        IF (TEMP.NE.8.AND.TEMP.NE.10.AND.TEMP.NE.16) GO TO 9000
        RADIX=TEMP
        GO TO 1000
C
C-------SET THE P.S. OFFSET
C
4100    TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        OFFSET=TEMP
        GO TO 1000
C
C-------EXIT: 'X'
C
4300    CALL APRLSE
        I=INFILE(4,0,-1)
        CALL EXIT
C
C-------JUMP TO THE PIOP DEBUGGER
C
4400    CONTINUE
C
C-------------------------------------------------------------
C
C       IF THE PIOP IS INSTALLED, THEN UNCOMMENT THE NEXT LINE
C
C       CALL PPDBUG
C
C-------------------------------------------------------------
        GO TO 1000
C
C-------GET DATA FROM A APLOAD LOAD MODULE 'G'
C
C    GET THE FILE NAME AND ASSIGN IT
4500    CALL GETSYM(BUFFER,TOKEN,-1,IERR)
        I=EXTSS (TOKEN,1,NAME,-1)
        IF (IERR.NE.0) GO TO 9000
        LUN=2
C    AN ACTION CODE OF 33 IS ACTUALLY 32 + 1, WHICH MEANS OPEN AN
C    UNFORMATTED DISK FILE.
        IERR=INFILE(33,TOKEN,LUN)
        IF (IERR) 4511,4520,4512
C    I/O ERROR
4511    IERR=EIO
        GOTO 4520
C    FILE NAME NOT FOUND
4512    IERR=EFILNF
C
4520    IF (IERR.NE.0) GOTO 9000
C    CALL APFILL TO LOAD THE LOAD MODULE IN THE AP.
        CALL APFILL(LUN+LUNMAP)
C    UNASSIGN THE FILE
        GOTO 5901
C
C-------SETTING MODE:  'U'
C
4600    CONTINUE
C    CHANGE THE CURRENT OPEN LOCATION TO APSTAT2 (ADDRESS 377 OCTAL).
        OPEN=38
        LOC=255
        TYPEL=2
        WIDTH=1
C    GET L, M, AND N PARAMETERS. THEY MUST BE 0 OR 1.
C    SET UP NEW VALUE OF CURRENT STATE APSTAT2 (BITS 3-5)
C    MASK=L*10000 + M*4000 + N*2000   (NUMBERS OCTAL)
        I=0
        DO 4610 J = 0, 2
           TEMP = GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
           IF (IERR.NE.0) GO TO 9000
           IERR=ENUMBD
           IF (TEMP.NE.0.AND.TEMP.NE.1) GO TO 8999
           I=I+TEMP*4096/2**J
4610    CONTINUE
C    PUT MASK INTO APSTAT2.  BUT OLD CONTENTS OF BITS(3-5)
C    MUST GO INTO BITS(0-1).
        CALL DEPST2(I)
        GO TO 1820
C
C
C-------YANK DATA FROM A FILE: 'Y'
C-------WRITE DATA TO A FILE: 'W'
C-------ZERO OUT A MEMORY: 'Z'
C
5901    CONTINUE
        IP1=2
        GOTO 5000
5900    CONTINUE
        IP1=1
5000    CONTINUE
        IP2=I
        CALL SUBYAN(IP1,IP2,OPENS)
        IP2=IP2+1
        GOTO(9000,8999,7000,6100,1000),IP2
C    REMEMBER OPERATION
C
C-------WRITE OUT DATA
C
C    PUT OUT COUNT IN DECIMAL WITH A POINT
6100    CALL ITOS(IPFIX(BLSTOP-BLSTRT+1.0),STR1,80,10)
        CALL INSCS(STR1,-1,LPOINT)
        CALL WRTLIN(STR1,LUN,80)
C
        IERR=EBREAK
C
6105    CALL TERM(TEMP)
        IF (TEMP.NE.0) GO TO 5901
        TEMP=IPFIX(BLSTRT)
        CALL APEXAM(REG,BLOPEN,TEMP)
        IERR=APDOUT(REG,BLOPEN,TEMP,BLWDTH,BLTYPE,RADIX,FP,FIE,
     1              OFFSET,OPENS,PSFLDS,LUN,0)
        IF (IERR.NE.0) GO TO 5901
        BLSTRT=BLSTRT+1.0
        IF (BLSTRT.LE.BLSTOP) GO TO 6105
C
        GO TO 5900
C
C-------ZERO OUT A MEMORY
C
7000    DO 7005 I=1,4
           REG(I)=0
7005    CONTINUE
C
        IERR=EBREAK
C
7050    CALL TERM(TEMP)
        IF (TEMP.NE.0) GO TO 8999
        CALL APDEP(REG,BLOPEN,IPFIX(BLSTRT))
        BLSTRT=BLSTRT+1.0
        IF (BLSTRT.LE.BLSTOP) GO TO 7050
C
        GO TO 1000
C
8000      CONTINUE
          CALL SUBBRK(IP1,IP2,MCMDS)
          IP2=IP2+1
          GOTO(9000,1000),IP2
C
C-------ERROR PRINTOUTS
C
C    'TOKEN' CONTAINS EITHER THE BAD USER INPUT OR NULL STRING
C
C    USE THIS ENTRY TO CLEAR 'TOKEN' FIRST
8999    CALL RMVCS(TOKEN,1,-1)
C    LOOK UP ERROR MESSAGE
9000    I=EXTSL(ERRORS,IERR,STR1,80)
C    APPEND 'TOKEN' WHICH CONTAINS THE BAD INPUT
        CALL INSSS(STR1,-1,TOKEN,-1)
        CALL WRTLIN(STR1,-1,80)
C    EMPTY COMMAND BUFFER
        CALL RMVCS(BUFFER,1,-1)
        GO TO 1000
        END
C+++    SUBEXM
C****** SUBEXM = EXAMINE FOR DBG100 = REL.  1.00 , 04/20/79
       SUBROUTINE SUBEXM(IP1,IP2,OPENS,PSFLDS)
       INTEGER OPENS(999),PSFLDS(999)
C
C       THIS ROUTINE PARSES AND EXECUTES THE EXAMINE DEBUGGER COMMAND.
C       THE FORMAT OF THE COMMAND IS:
C              E <MEMORY OR REGISTER> <LOCATION>
C
C       CALL:
C              IP1 - ENTRY POINT TO THIS ROUTINE.
C              IP2 - ALTERNATE RETURN POINT TO CALLING ROUTINE.
C              OPENS - TABLE OF OPENABLE REGISTERS AND MEMORIES IN .
C              PSFLDS - PS FIELDS TABLE.
C
C       RETURN:
C              IP2 - 0 ERROR RETURN WITH VALUE IN ERROR MESSAGE.
C                  - 1 ERROR RETURN WITH JUST MESSAGE.
C                  - 2 NORMAL RETURN
C
C
C                                                                       DBGCOM
       COMMON/GLOP/ DEVADR,LOC                                          DBGCOM
       COMMON TEMP,BUFFER,TOKEN,RADIX,IERR,OFFSET,BPPTR,REG,BPTBL,      DBGCOM
     *  HALT,IPROC,ISTEP,BRKLOC,BRKTYP,EBREAK,OPEN,                     DBGCOM
     *  ENAMNF,BLOPEN,EMNOPN,BLTYPE,BLWDTH,BLSTRT,BLOP,BLSTOP,          DBGCOM
     *  EENADR,NAME,LUN,FP,ETOMNY,ECMDNF,EBPTBG,BPTSIZ,                 DBGCOM
     *  LSPACE,STR1,FIE,TYPEL,WIDTH,TCBOPN,BASE,ENOPN                   DBGCOM
        INTEGER RADIX,FP,FIE,OFFSET,OPEN,IPROC,ISTEP,LUNMAP             DBGCOM
        INTEGER BRKTYP,BRKLOC,TYPEL,WIDTH,LOC,LUN                       DBGCOM
        INTEGER BLOP,BLOPEN,BLTYPE,BLWDTH                               DBGCOM
        INTEGER BASE,TCBOPN                                             DBGCOM
        REAL BLSTRT,BLSTOP                                              DBGCOM
C                                                                       DBGCOM
C                                                                       DBGCOM
C    TEMPORARY STORAGE                                                  DBGCOM
        INTEGER TEMP,BUFFER(81),TOKEN(81),STR1(81),IERR,I,J,REG(4)      DBGCOM
        INTEGER K,NAME(81)                                              DBGCOM
C   MULTIPLE BREAKPOINT TABLE                                           DBGCOM
        INTEGER BPTBL(10,5)                                             DBGCOM
C FUNCTIONS:                                                            DBGCOM
        INTEGER SRCST,INFILE,GETINT,EXTVT,IPFIX,APDIN,RMVTOK,RDLIN      DBGCOM
        INTEGER EXTSL,APDOUT,IAND16,IOR16,ILSH16                        DBGCOM
        REAL PFLOAT                                                     DBGCOM
C                                                                       DBGCOM
C-------DEFINED CONSTANTS                                               DBGCOM
C                                                                       DBGCOM
        INTEGER LSPACE,LPOINT,LEOF                                      DBGCOM
        INTEGER BPTSIZ,BPPTR,HALT(4)                                    DBGCOM
        INTEGER DEVADR(8)                                               DBGCOM
        INTEGER EFILNF,EEOF  ,ENUMBD,ERDXBD,EENADR,ECMDNF,ENOPN ,       DBGCOM
     1          EMNOPN,EIO   ,ENAMNF,EBREAK,ECMLNE,ETOMNY,ENRANG        DBGCOM
        INTEGER EBPTBG                                                  DBGCOM
C                                                                       DBGCOM
C
C       DEFINE LOCATION OF DPX, DPY, DPXA, AND DPYA IN THE
C       TABLE OF OPENABLE REGISTERS (OPENS).
        INTEGER DPX,DPY,DPXA,DPYA
        DATA DPX,DPY,DPXA,DPYA / 12, 13, 43, 44 /
C
C-----EXAMINE: 'E'
C
C    BRANCH ON ENTRY POINT.
       IP1=IP1+1
       GOTO(1800,1810,1820,1900,2000,2100),IP1
1810   CONTINUE
       I=38
       GOTO 1811
C    GET MEMORY OR REGISTER MNEMONIC AND LOOK IT UP.
1800   OPEN=0
       CALL GETSYM(BUFFER,TOKEN,-1,IERR)
       IF (IERR.NE.0) GO TO 9000
       IERR=ENAMNF
       I=SRCST(OPENS,1,-1,TOKEN,-1)
       IF (I.EQ.0) GO TO 9000
C    SET WIDTH(# OF 16-BIT PIECES) AND TYPE
C    (0=REGISTER, 1=MEMORY, 2=REGISTER W/ADDRESS,
C     3=TCB ELEMENT)
1811    TYPEL=EXTVT(OPENS,I,1,TYPEL,1)
        WIDTH=EXTVT(OPENS,I,2,WIDTH,1)
C    BRANCH ON TYPE OF REFERENCE
        K=TYPEL+1
        GO TO (1819,1817,1816,1819),K
C    REGISTER HAS I/O DEVICE ADDRESS GET ADDRESS.
1816    LOC=DEVADR(I-30)
        GO TO 1819
C    MEMORY, GET LOCATION
1817    TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        LOC=TEMP
C    IF EXAMINING P.S. ADD OFFSET
        IF (I.EQ.9) LOC=LOC+OFFSET
C
1819    OPEN=I
        J=1
C    IF EXAMINING DPX OR DPY RELATIVE TO DPA ADD DPA TO THE LOCATION.
        IF (OPEN.NE.DPX.AND.OPEN.NE.DPY) GO TO 1820
        CALL APEXAM (REG,5,0)
        LOC=LOC + REG(1)
C     EXAMINE THE AP HARDWARE
C    MAP ABSOLUTE DPX AND DPY INTO RELATIVE.
1820    CONTINUE
        IF (OPEN.EQ.DPXA) OPEN=DPX
        IF (OPEN.EQ.DPYA) OPEN=DPY
        IF (TYPEL.EQ.3) GO TO 1850
        CALL APEXAM(REG,OPEN,LOC)
C
C    WRITE OUT THE RESULTS
        TOKEN(1)=0
        IERR=APDOUT(REG,OPEN,LOC,WIDTH,TYPEL,RADIX,FP,FIE,OFFSET,
     1              OPENS,PSFLDS,-1,TOKEN)
        IF (IERR.NE.0) GO TO 8999
C    IF APSTAT2 EXAMINED, INTERPRET BITS 3 THRU 5.
        IF (OPEN.EQ.38) CALL WRTST2(REG(1))
        GO TO 1000
C
C-------EXAMINE A TCB ELEMENT
C
1850    CALL TCBEXM(J,BUFFER,TOKEN,-1,REG,WIDTH,TYPEL,
     1        LOC,TCBOPN,BASE,RADIX,FP,FIE,OFFSET,IERR)
        IF (IERR.NE.0) GO TO 8999
        GO TO 1000
C
C-------RE-EXAMINE CURRENT LOCATION: '.'
C
C    SEE IF ANYTHING OPEN
1900    IERR=ENOPN
        J=2
        IF (OPEN.EQ.0) GO TO 8999
        GO TO 1820
C
C-------INCREMENT LOCATION: '+'
C
C       CAN'T INCREMENT UNLESS A MEMORY IS OPEN
2000    IERR=EMNOPN
        J=3
        IF (OPEN.EQ.0.OR.TYPEL.NE.1.AND.TYPEL.NE.3) GO TO 8999
        LOC=IADD16(LOC,1)
        GO TO 1820
C
C-------DECREMENT LOCATION: '-'
C
C       CAN'T DECREMENT UNLESS A MEMORY IS OPEN
2100    IERR=EMNOPN
        J=4
        IF (OPEN.EQ.0.OR.TYPEL.NE.1.AND.TYPEL.NE.3) GO TO 8999
        LOC=ISUB16(LOC,1)
        GO TO 1820
9000       CONTINUE
       IP2=0
       RETURN
8999       CONTINUE
       IP2=1
       RETURN
1000       CONTINUE
       IP2=2
       RETURN
       END
C+++    SUBBRK
C****** SUBBRK = MULTIPLE BREAKPTS = REL.  1.00 , 04/20/79
       SUBROUTINE SUBBRK(IP1,IP2,MCMDS)
       INTEGER MCMDS(999)
C
C       THIS ROUTINE PARSES AND EXECUTES THE MULTIPLE BREAKPOINT
C       COMMAND IN THE DEBUGGER.   ITS POSSIBLE FORMS ARE:
C             M S <LOC>     SET A PS BREAKPOINT
C             M D <LOC>     DELETE A PS BREAKPOINT
C             M C           CLEAR ALL PS BREAKPOINTS
C
C       CALL:
C            IP1 - ENTRY POINT TO START EXECUTION IN THIS ROUTINE.
C            IP2 - ALTERNATE RETURN POINT TO CALLING ROUTINE.
C            MCMDS - SUBCOMMANDS (S, D, AND C) TABLE.
C
C       RETURN:
C            IP2 - 0 IF ERRORS OCCURRED, 1 IF ALL OKAY.
C
C
C
C                                                                       DBGCOM
       COMMON/GLOP/ DEVADR,LOC                                          DBGCOM
       COMMON TEMP,BUFFER,TOKEN,RADIX,IERR,OFFSET,BPPTR,REG,BPTBL,      DBGCOM
     *  HALT,IPROC,ISTEP,BRKLOC,BRKTYP,EBREAK,OPEN,                     DBGCOM
     *  ENAMNF,BLOPEN,EMNOPN,BLTYPE,BLWDTH,BLSTRT,BLOP,BLSTOP,          DBGCOM
     *  EENADR,NAME,LUN,FP,ETOMNY,ECMDNF,EBPTBG,BPTSIZ,                 DBGCOM
     *  LSPACE,STR1,FIE,TYPEL,WIDTH,TCBOPN,BASE,ENOPN                   DBGCOM
        INTEGER RADIX,FP,FIE,OFFSET,OPEN,IPROC,ISTEP,LUNMAP             DBGCOM
        INTEGER BRKTYP,BRKLOC,TYPEL,WIDTH,LOC,LUN                       DBGCOM
        INTEGER BLOP,BLOPEN,BLTYPE,BLWDTH                               DBGCOM
        INTEGER BASE,TCBOPN                                             DBGCOM
        REAL BLSTRT,BLSTOP                                              DBGCOM
C                                                                       DBGCOM
C                                                                       DBGCOM
C    TEMPORARY STORAGE                                                  DBGCOM
        INTEGER TEMP,BUFFER(81),TOKEN(81),STR1(81),IERR,I,J,REG(4)      DBGCOM
        INTEGER K,NAME(81)                                              DBGCOM
C   MULTIPLE BREAKPOINT TABLE                                           DBGCOM
        INTEGER BPTBL(10,5)                                             DBGCOM
C FUNCTIONS:                                                            DBGCOM
        INTEGER SRCST,INFILE,GETINT,EXTVT,IPFIX,APDIN,RMVTOK,RDLIN      DBGCOM
        INTEGER EXTSL,APDOUT,IAND16,IOR16,ILSH16                        DBGCOM
        REAL PFLOAT                                                     DBGCOM
C                                                                       DBGCOM
C-------DEFINED CONSTANTS                                               DBGCOM
C                                                                       DBGCOM
        INTEGER LSPACE,LPOINT,LEOF                                      DBGCOM
        INTEGER BPTSIZ,BPPTR,HALT(4)                                    DBGCOM
        INTEGER DEVADR(8)                                               DBGCOM
        INTEGER EFILNF,EEOF  ,ENUMBD,ERDXBD,EENADR,ECMDNF,ENOPN ,       DBGCOM
     1          EMNOPN,EIO   ,ENAMNF,EBREAK,ECMLNE,ETOMNY,ENRANG        DBGCOM
        INTEGER EBPTBG                                                  DBGCOM
C                                                                       DBGCOM
C
C-------MULTIPLE BREAKPOINTS 'M'
C
C    GET SUBCOMMAND 'S', 'C', OR 'D'
        CALL GETSYM(BUFFER,TOKEN,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
C    LOOK UP NAME
        IERR=ECMDNF
        I=SRCST(MCMDS,1,-1,TOKEN,-1)
        IF (I.EQ.0) GO TO 9000
C
C    BRANCH ON TYPE OF SUBCOMMAND.
C              S    C    D
        GO TO (8100,8200,8300),I
C
C------- SET A BREAKPOINT 'S'
C
C    GET PS LOCATION
8100    TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        TEMP=TEMP+OFFSET
C    SCAN BREAKPOINT TABLE FOR ADDRESS
        IF (BPPTR.EQ.0) GO TO 8120
        DO 8110 I=1,BPPTR
           IF (BPTBL(I,1).EQ.TEMP) GO TO 1000
8110    CONTINUE
C    ADDRESS NOT IN TABLE.  ADD IT.
8120    IERR=EBPTBG
        IF (BPPTR.EQ.BPTSIZ) GO TO 9000
        BPPTR=BPPTR+1
        BPTBL(BPPTR,1)=TEMP
        CALL APEXAM(REG,9,TEMP)
        BPTBL(BPPTR,2)=REG(1)
        BPTBL(BPPTR,3)=REG(2)
        BPTBL(BPPTR,4)=REG(3)
        BPTBL(BPPTR,5)=REG(4)
        GO TO 1000
C
C------- CLEAR ALL BREAKPOINTS 'C'
C
8200    BPPTR=0
        GO TO 1000
C
C------- DELETE A BREAKPOINT 'D'
C
C    GET LOCATION
8300    TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        TEMP=TEMP+OFFSET
C    SCAN BREAKPOINT TABLE FOR ADDRESS
        IF (BPPTR.EQ.0) GO TO 1000
        DO 8310 I=1,BPPTR
           IF (BPTBL(I,1).EQ.TEMP) GO TO 8320
8310    CONTINUE
        GO TO 1000
C    CLOSE UP TABLE
8320    BPPTR=BPPTR-1
        DO 8330 J=I,BPPTR
           DO 8330 K=1,5
              BPTBL(J,K)=BPTBL(J+1,K)
8330    CONTINUE
        GO TO 1000
9000   CONTINUE
       IP2=0
       RETURN
1000   CONTINUE
       IP2=1
       RETURN
       END
C+++    SUBTRS
C****** SUBTRS = FUNCTIONS FOR DBG100 = REL.  1.00 , 04/20/79
       SUBROUTINE SUBTRS(IP1,IP2,OPENS,ERRORS)
       INTEGER OPENS(999),ERRORS(999)
C
C       THIS ROUTINE PARSES AND EXECUTES THE FOLLOWING COMMANDS.
C                Q <VALUE>
C                B <MEMORY> <LOCATION>
C                D
C                S <VALUE>
C                F < 1 OR 0 >
C                V < 1 OR 0 >
C                L
C
C       CALL:
C               IP1 - ENTRY POINT TO THIS ROUTINE.
C               IP2 - ALTERNATE RETURN POINT TO THE CALLING ROUTINE.
C               OPENS - TABLE OF OPENABLE REGISTERS AND MEMORIES.
C               ERRORS - ERROR MESSAGE TABLE FROM MAINLINE.
C
C       RETURN:
C               IP2 - 0 ERROR RETURN
C                     1 NORMAL RETURN
C
C
C                                                                       DBGCOM
       COMMON/GLOP/ DEVADR,LOC                                          DBGCOM
       COMMON TEMP,BUFFER,TOKEN,RADIX,IERR,OFFSET,BPPTR,REG,BPTBL,      DBGCOM
     *  HALT,IPROC,ISTEP,BRKLOC,BRKTYP,EBREAK,OPEN,                     DBGCOM
     *  ENAMNF,BLOPEN,EMNOPN,BLTYPE,BLWDTH,BLSTRT,BLOP,BLSTOP,          DBGCOM
     *  EENADR,NAME,LUN,FP,ETOMNY,ECMDNF,EBPTBG,BPTSIZ,                 DBGCOM
     *  LSPACE,STR1,FIE,TYPEL,WIDTH,TCBOPN,BASE,ENOPN                   DBGCOM
        INTEGER RADIX,FP,FIE,OFFSET,OPEN,IPROC,ISTEP,LUNMAP             DBGCOM
        INTEGER BRKTYP,BRKLOC,TYPEL,WIDTH,LOC,LUN                       DBGCOM
        INTEGER BLOP,BLOPEN,BLTYPE,BLWDTH                               DBGCOM
        INTEGER BASE,TCBOPN                                             DBGCOM
        REAL BLSTRT,BLSTOP                                              DBGCOM
C                                                                       DBGCOM
C                                                                       DBGCOM
C    TEMPORARY STORAGE                                                  DBGCOM
        INTEGER TEMP,BUFFER(81),TOKEN(81),STR1(81),IERR,I,J,REG(4)      DBGCOM
        INTEGER K,NAME(81)                                              DBGCOM
C   MULTIPLE BREAKPOINT TABLE                                           DBGCOM
        INTEGER BPTBL(10,5)                                             DBGCOM
C FUNCTIONS:                                                            DBGCOM
        INTEGER SRCST,INFILE,GETINT,EXTVT,IPFIX,APDIN,RMVTOK,RDLIN      DBGCOM
        INTEGER EXTSL,APDOUT,IAND16,IOR16,ILSH16                        DBGCOM
        REAL PFLOAT                                                     DBGCOM
C                                                                       DBGCOM
C-------DEFINED CONSTANTS                                               DBGCOM
C                                                                       DBGCOM
        INTEGER LSPACE,LPOINT,LEOF                                      DBGCOM
        INTEGER BPTSIZ,BPPTR,HALT(4)                                    DBGCOM
        INTEGER DEVADR(8)                                               DBGCOM
        INTEGER EFILNF,EEOF  ,ENUMBD,ERDXBD,EENADR,ECMDNF,ENOPN ,       DBGCOM
     1          EMNOPN,EIO   ,ENAMNF,EBREAK,ECMLNE,ETOMNY,ENRANG        DBGCOM
        INTEGER EBPTBG                                                  DBGCOM
C                                                                       DBGCOM
C
C    BRANCH ON ENTRY POINT.
       IP1=IP1+1
       GOTO(1200,1300,1400,1500,1600,1700,1750),IP1
C
C-------SET BREAKPOINT COUNTER: 'Q'
C
C    GET COUNT
1200    TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        IPROC=TEMP
        IF (IPROC.LE.0) IPROC=1
        GO TO 1000
C
C-------SET BREAKPOINT: 'B'
C
1300    BRKTYP=0
        BRKLOC=0
C    GET MEMORY TO BREAK ON
        CALL GETSYM(BUFFER,TOKEN,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
C    LOOK UP NAME
        IERR=ENAMNF
        I=SRCST(OPENS,1,-1,TOKEN,-1)
C    THE USER TYPED IN 'PS', 'TM', OR 'MD'
C    BUT WE MUST SET 'PSA','TMA', OR 'MA' PLUS BREAK
        J=0
        IF (I.EQ.9) J=256
        IF (I.EQ.14) J=258
        IF (I.EQ.16) J=259
        IF (J.EQ.0) GO TO 9000
C    GET ADDRESS
        TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        BRKLOC=TEMP
        BRKTYP=J
C    ADD OFFSET IF P.S.
        IF (BRKTYP.EQ.256) BRKLOC=BRKLOC+OFFSET
        IPROC=1
        GO TO 1000
C
C-------DELETE BREAKPOINTS: 'D'
C
1400    BRKTYP=0
        BRKLOC=0
        IPROC=1
        GO TO 1000
C
C-------STEP FLAG:  'S'
C
C       SET 'ISTEP' TO 4096 TO STEP EXECUTION IF THE USER INPUTS A NON-ZERO,
C         ELSE SET 'STEP' TO 8192 TO CONTINUE EXECUTION
1500    TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        ISTEP=8192
        IF (TEMP.NE.0) ISTEP=4096
        IPROC=1
        GO TO 1000
C
C-------F.P. INPUT/OUTPUT FLAG: 'F'
C
1600    TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        FP=TEMP
        IF (FP.NE.0) FP=1
        GO TO 1000
C
C-------P.S. FIELD VALUE I/O FLAG: 'V'
C
1700    TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        FIE=TEMP
        IF (FIE.NE.0) FIE=1
        GO TO 1000
C
C-------LIST BREAKPOINT: 'L'
C
1750    IF (BRKTYP.EQ.0) GO TO 1760
        TEMP=BRKLOC
C    IF BREAKPOINT IS IN PS SUBTRACT OFFSET FOR TYPEOUT
        IF (BRKTYP.EQ.256) TEMP=TEMP-OFFSET
        IF (BRKTYP.EQ.256) I=1
        IF (BRKTYP.EQ.259) I=16
        IF (BRKTYP.EQ.258) I=14
C    GET NAME
        I=EXTST(OPENS,I,STR1,4)
C    CONVERT LOCATION AND OUTPUT
        CALL INSCS(STR1,6,LSPACE)
        CALL PUTINT(STR1,7,TEMP,RADIX)
        CALL WRTLIN(STR1,-1,80)
C    LIST BREAKPOINT TABLE
1760    IF (BPPTR.EQ.0) GO TO 1000
        I=EXTSL(ERRORS,EBPTBG,STR1,25)
        CALL WRTLIN(STR1,-1,80)
        I=EXTST(OPENS,1,STR1,4)
        CALL INSCS(STR1,6,LSPACE)
        DO 1770 I=1,BPPTR
           CALL PUTINT(STR1,7,BPTBL(I,1)-OFFSET,RADIX)
           CALL WRTLIN(STR1,-1,80)
1770    CONTINUE
        GO TO 1000
9000       CONTINUE
       IP2=0
       RETURN
1000       CONTINUE
       IP2=1
       RETURN
       END
C+++    SUBRUN
C****** SUBRUN = RUN FOR DBG100 = REL.  1.00 , 04/20/79
       SUBROUTINE SUBRUN(IP1,IP2,OPENS,PSFLDS)
       INTEGER OPENS(999),PSFLDS(999)
C
C       THIS ROUTINE PARSES AND EXECUTES THE DEBUGGER RUN COMMAND.
C       THE FORM OF THE COMMAND IS:
C              R <LOCATION>
C
C       CALL:
C              IP1 - ENTRY POINT TO THIS ROUTINE.
C              IP2 - ALTERNATE RETURN POINT TO CALLING ROUTINE.
C              OPENS - LIST OF OPENABLE REGISTERS AND MEMORIES.
C              PSFLDS - PS WORD FIELDS.
C
C       RETURN:
C              IP2 - 0 NORMAL RETURN BUT NO REGISTER OR MEMORY IS
C                      OPEN TO DISPLAY.
C                    1 ERROR IN LOCATION PARAMETER OF COMMAND.
C                    2 USER REQUESTED BREAK.
C                    3 NORMAL RETURN TO DISPLAY CURRENTLY OPEN
C                      REGISTER OR MEMORY.
C
C
C                                                                       DBGCOM
       COMMON/GLOP/ DEVADR,LOC                                          DBGCOM
       COMMON TEMP,BUFFER,TOKEN,RADIX,IERR,OFFSET,BPPTR,REG,BPTBL,      DBGCOM
     *  HALT,IPROC,ISTEP,BRKLOC,BRKTYP,EBREAK,OPEN,                     DBGCOM
     *  ENAMNF,BLOPEN,EMNOPN,BLTYPE,BLWDTH,BLSTRT,BLOP,BLSTOP,          DBGCOM
     *  EENADR,NAME,LUN,FP,ETOMNY,ECMDNF,EBPTBG,BPTSIZ,                 DBGCOM
     *  LSPACE,STR1,FIE,TYPEL,WIDTH,TCBOPN,BASE,ENOPN                   DBGCOM
        INTEGER RADIX,FP,FIE,OFFSET,OPEN,IPROC,ISTEP,LUNMAP             DBGCOM
        INTEGER BRKTYP,BRKLOC,TYPEL,WIDTH,LOC,LUN                       DBGCOM
        INTEGER BLOP,BLOPEN,BLTYPE,BLWDTH                               DBGCOM
        INTEGER BASE,TCBOPN                                             DBGCOM
        REAL BLSTRT,BLSTOP                                              DBGCOM
C                                                                       DBGCOM
C                                                                       DBGCOM
C    TEMPORARY STORAGE                                                  DBGCOM
        INTEGER TEMP,BUFFER(81),TOKEN(81),STR1(81),IERR,I,J,REG(4)      DBGCOM
        INTEGER K,NAME(81)                                              DBGCOM
C   MULTIPLE BREAKPOINT TABLE                                           DBGCOM
        INTEGER BPTBL(10,5)                                             DBGCOM
C FUNCTIONS:                                                            DBGCOM
        INTEGER SRCST,INFILE,GETINT,EXTVT,IPFIX,APDIN,RMVTOK,RDLIN      DBGCOM
        INTEGER EXTSL,APDOUT,IAND16,IOR16,ILSH16                        DBGCOM
        REAL PFLOAT                                                     DBGCOM
C                                                                       DBGCOM
C-------DEFINED CONSTANTS                                               DBGCOM
C                                                                       DBGCOM
        INTEGER LSPACE,LPOINT,LEOF                                      DBGCOM
        INTEGER BPTSIZ,BPPTR,HALT(4)                                    DBGCOM
        INTEGER DEVADR(8)                                               DBGCOM
        INTEGER EFILNF,EEOF  ,ENUMBD,ERDXBD,EENADR,ECMDNF,ENOPN ,       DBGCOM
     1          EMNOPN,EIO   ,ENAMNF,EBREAK,ECMLNE,ETOMNY,ENRANG        DBGCOM
        INTEGER EBPTBG                                                  DBGCOM
C                                                                       DBGCOM
C
C    BRANCH ON ENTRY POINT.
       IP2=0
       IP1=IP1+1
       GOTO (1100,1105,1112),IP1
C
C-------RUN: 'R'
C
C    GET P.S. ADDRESS
1100   TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
       IF(IERR .EQ. 0) GOTO 1101
       IP2=1
       RETURN
1101   CONTINUE
C    ADD OFFSET TO RUN ADDRESS
       TEMP=TEMP+OFFSET
C    RUN --- TEMP TO PSA
       CALL APDEP(TEMP,1,0)
C    SET MULTIPLE BREAKPOINTS BY REPLACING INSTRUCTIONS WITH HALTS.
1105   IF (BPPTR.EQ.0) GO TO 1107
       DO 1106 I=1,BPPTR
          CALL APEXAM(REG,9,BPTBL(I,1))
          BPTBL(I,2)=REG(1)
          BPTBL(I,3)=REG(2)
          BPTBL(I,4)=REG(3)
          BPTBL(I,5)=REG(4)
          CALL APDEP(HALT,9,BPTBL(I,1))
1106   CONTINUE
C    PROCEED --- BRKLOC TO SWR, BRKTYP + ISTEP TO FN
1107   DO 1111 I=1,IPROC
          CALL APDEP(BRKLOC,17,0)
          CALL APDEP(ISTEP+BRKTYP,18,0)
C    LOOK FOR USER BREAK
1108      CALL TERM(TEMP)
          IF (TEMP.EQ.0) GO TO 1109
C
C    USER REQUESTED BREAK
          IERR=EBREAK
          IP2=2
          RETURN
C
C    SEE IF STILL RUNNING
1109      CALL APEXAM (TEMP,18,0)
          IF (NEGCHK(TEMP).EQ.0) GO TO 1108
C    THE AP HAS STOPPED.  GET THE PSA OF THE LAST EXECUTED INSTRUCTION.
          CALL APEXAM(REG,1,0)
          TEMP=REG(1)-1
C    IF A MULTIPLE BREAKPOINT HAS OCCURRED IT IS NOT UNDER THE CONTROL
C    OF THE DEBUGGER 'Q' COMMAND SO DON'T CONTINUE RUNNING AP.
          IF (BPPTR.EQ.0) GO TO 1111
          DO 1110 J=1,BPPTR
             IF (TEMP.EQ.BPTBL(J,1)) GO TO 1112
1110      CONTINUE
          J=0
1111   CONTINUE
C
C    PLACE INSTRUCTIONS AT BREAKPOINT LOCATIONS BACK IN PS.
1112   IF (BPPTR.EQ.0) GO TO 1120
       DO 1116 I=1,BPPTR
          REG(1)=BPTBL(I,2)
          REG(2)=BPTBL(I,3)
          REG(3)=BPTBL(I,4)
          REG(4)=BPTBL(I,5)
          CALL APDEP(REG,9,BPTBL(I,1))
1116   CONTINUE
C    IF WE STOPPED AT A MULTIPLE BREAKPOINT BACKUP ONE INSTRUCTION
C    AND EXECUTE THE REAL INSTRUCTION INSTEAD OF A HALT.
       IF (J.EQ.0) GO TO 1120
       CALL APDEP(TEMP,1,0)
       CALL APDEP(4096,18,0)
C
C    WHEN WE COME BACK, TYPE OUT PSA AND THE CONTENTS OF THE CURRENTLY OPEN
C    REGISTER.   MUST ALSO GET PS(PSA) DISASSEMBLED.
C
1120   CALL APEXAM(TEMP,1,0)
       TOKEN(1)=0
       I=APDOUT(TEMP,1,0,1,0,RADIX,0,0,OFFSET,OPENS,PSFLDS,-1,TOKEN)
       IF(OPEN .EQ. 0) RETURN
       IP2=3
       RETURN
       END
C+++ SUBYAN
C****** SUBYAN = YANK FOR DBG100 = REL.  1.00 , 04/20/79
       SUBROUTINE SUBYAN(IP1,IP2,OPENS)
       INTEGER OPENS(999)
C
C       THIS ROUTINE PARSES AND EXECUTES THE DEBUGGER COMMANDS YANK,
C       WRITE, AND ZERO.  THE FORMS OF THE COMMANDS ARE:
C              Y <MEMORY> <START LOCATION> <FILE NAME>
C              W <MEMORY> <START LOCATION> <END LOCATION> <FILE NAME>
C              Z <MEMORY> <START LOCATION> <END LOCATION>
C
C       CALL:
C              IP1 - ENTRY POINT TO THIS ROUTINE.
C              IP2 - ALTERNATE RETURN POINT TO CALLING ROUTINE.
C              OPENS - LIST OF OPENABLE REGISTERS AND MEMORIES.
C
C       RETURN:
C              IP2 - 0 ERROR RETURN WITH NOTHING ADDED TO MESSAGE.
C                    1 ERROR RETURN WITH STRING ADDED TO MESSAGE.
C                    2 RETURN TO ZERO OUT MEMORY.
C                    3 RETURN TO WRITE OUT MEMORY.
C                    4 NORMAL RETURN.
C
C
C                                                                       DBGCOM
       COMMON/GLOP/ DEVADR,LOC                                          DBGCOM
       COMMON TEMP,BUFFER,TOKEN,RADIX,IERR,OFFSET,BPPTR,REG,BPTBL,      DBGCOM
     *  HALT,IPROC,ISTEP,BRKLOC,BRKTYP,EBREAK,OPEN,                     DBGCOM
     *  ENAMNF,BLOPEN,EMNOPN,BLTYPE,BLWDTH,BLSTRT,BLOP,BLSTOP,          DBGCOM
     *  EENADR,NAME,LUN,FP,ETOMNY,ECMDNF,EBPTBG,BPTSIZ,                 DBGCOM
     *  LSPACE,STR1,FIE,TYPEL,WIDTH,TCBOPN,BASE,ENOPN                   DBGCOM
        INTEGER RADIX,FP,FIE,OFFSET,OPEN,IPROC,ISTEP,LUNMAP             DBGCOM
        INTEGER BRKTYP,BRKLOC,TYPEL,WIDTH,LOC,LUN                       DBGCOM
        INTEGER BLOP,BLOPEN,BLTYPE,BLWDTH                               DBGCOM
        INTEGER BASE,TCBOPN                                             DBGCOM
        REAL BLSTRT,BLSTOP                                              DBGCOM
C                                                                       DBGCOM
C                                                                       DBGCOM
C    TEMPORARY STORAGE                                                  DBGCOM
        INTEGER TEMP,BUFFER(81),TOKEN(81),STR1(81),IERR,I,J,REG(4)      DBGCOM
        INTEGER K,NAME(81)                                              DBGCOM
C   MULTIPLE BREAKPOINT TABLE                                           DBGCOM
        INTEGER BPTBL(10,5)                                             DBGCOM
C FUNCTIONS:                                                            DBGCOM
        INTEGER SRCST,INFILE,GETINT,EXTVT,IPFIX,APDIN,RMVTOK,RDLIN      DBGCOM
        INTEGER EXTSL,APDOUT,IAND16,IOR16,ILSH16                        DBGCOM
        REAL PFLOAT                                                     DBGCOM
C                                                                       DBGCOM
C-------DEFINED CONSTANTS                                               DBGCOM
C                                                                       DBGCOM
        INTEGER LSPACE,LPOINT,LEOF                                      DBGCOM
        INTEGER BPTSIZ,BPPTR,HALT(4)                                    DBGCOM
        INTEGER DEVADR(8)                                               DBGCOM
        INTEGER EFILNF,EEOF  ,ENUMBD,ERDXBD,EENADR,ECMDNF,ENOPN ,       DBGCOM
     1          EMNOPN,EIO   ,ENAMNF,EBREAK,ECMLNE,ETOMNY,ENRANG        DBGCOM
        INTEGER EBPTBG                                                  DBGCOM
C                                                                       DBGCOM
C
C-------YANK DATA FROM A FILE: 'Y'
C       WRITE DATA TO A FILE: 'W'
C       ZERO OUT A MEMORY: 'Z'
C
C    REMEMBER OPERATION
        I=IP2
        IP2=0
        IP1=IP1+1
        GOTO(5000,5900,5901),IP1
5000    BLOP=I
C    SEE WHICH MEMORY TO OPEN FOR BLOCK TRANSFER
        CALL GETSYM(BUFFER,TOKEN,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        IERR=ENAMNF
        BLOPEN=SRCST(OPENS,1,-1,TOKEN,-1)
C    ERROR IF NOT FOUND
        IF (BLOPEN.EQ.0) GO TO 9000
C    MUST BE A MEMORY
        IERR=EMNOPN
        IF (EXTVT(OPENS,BLOPEN,1,BLTYPE,1) .NE.1) GO TO 9000
        BLWDTH=EXTVT(OPENS,BLOPEN,2,BLWDTH,1)
C    GET STARTING LOC
        TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        BLSTRT=PFLOAT(TEMP)
C    ADD OFFSET IF PS
        IF (BLOPEN.EQ.9) BLSTRT=BLSTRT+PFLOAT(OFFSET)
C    DON'T GET ENDING LOC IF A YANK
        IF (BLOP.EQ.18) GO TO 5020
C
        TEMP=GETINT(BUFFER,TOKEN,RADIX,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
        BLSTOP=PFLOAT(TEMP)
        IF (BLOPEN.EQ.9) BLSTOP=BLSTOP+PFLOAT(OFFSET)
C    ENDING MUST BE HIGHER THAN STARTING
        IERR=EENADR
        IF (BLSTOP.LT.BLSTRT) GO TO 8999
C
C       IF 'Z' DON'T OPEN A FILE
        IF (BLOP.EQ.16) GO TO 7000
C
C-------OPEN A FILE
C
5020    CALL GETSYM(BUFFER,TOKEN,-1,IERR)
        IF (IERR.NE.0) GO TO 9000
C    COPY NAME
        I=EXTSS(TOKEN,1,NAME,-1)
C    OPEN FOR EITHER READ OR WRITE ONLY
        LUN=2
        IERR=INFILE(BLOP-17,NAME,LUN)
        IF (IERR) 5021,5025,5022
C
C    I/O ERROR
5021    IERR=EIO
        GO TO 5025
C    FILE NAME NOT FOUND
5022    IERR=EFILNF
C
5025    IF (IERR.NE.0) GO TO 9000
C
        IF (BLOP.EQ.19) GO TO 6100
C
C-------YANK
C
C    GET ENDING ADDRESS = COUNT+BLSTRT
        BLSTOP=PFLOAT(GETINT(BUFFER,TOKEN,10,LUN,IERR)) + BLSTRT - 1.0
        IF (IERR.NE.0) GO TO 5901
C
C-------INPUT LOOP
C
5300    IERR=APDIN(REG,0,BLWDTH,RADIX,FP,0,0,LUN,BUFFER,TOKEN)
        IF (IERR.NE.0) GO TO 5901
        CALL APDEP(REG,BLOPEN,IPFIX(BLSTRT))
        BLSTRT=BLSTRT+1.0
        IF (BLSTRT.LE.BLSTOP) GO TO 5300
C
C    SEE IF AT END-OF-FILE, IF NOT, THEN TOO MANY DATA ELEMENTS
        IERR=0
        CALL GETSYM(BUFFER,TOKEN,LUN,I)
        IF (I.NE.LEOF) IERR=ETOMNY
        GO TO 5900
C
C-------HERE WE RELEASE THE FILE WE HAVE BEEN USING
C
C    CLEAR IERR
5900    IERR=0
C
5901    CONTINUE
        I=INFILE(4,NAME,LUN)
        IF (I.EQ.-1) IERR=EIO
        IF (IERR.NE.0) GO TO 8999
        GOTO 1000
9000    RETURN
8999    CONTINUE
        IP2=1
        RETURN
7000    CONTINUE
        IP2=2
        RETURN
6100    CONTINUE
        IP2=3
        RETURN
1000    CONTINUE
        IP2=4
        RETURN
        END
C+++    APDIN
C****** APDIN = AP DEBUG INPUT = REL.  1.00 , 04/20/79 ******
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APDBUG WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:00:58
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        INTEGER FUNCTION APDIN(REG,LOC,WIDTH,RADIX,FP,FIE,PSFLDS,LUN,
     1                         BUFFER,TOKEN)
        INTEGER REG(4),LOC,WIDTH,RADIX,FP,FIE,PSFLDS(9999),LUN,
     1                         BUFFER(9999),TOKEN(9999)
C
C       PROVIDES INPUT FROM THE USER FOR THE FPS100 DEBUGGER.
C       RETURNS 0 IF THE INPUT WAS OK, ELSE THE ERROR CODE
C       WORKS IN THREE FORMATS AND THREE WORD WIDTHS:
C
C       1. <=16 BIT WORD:   1-INTEGER
C       2.   38 BIT WORD:   3-INTEGERS,  OR   FLOATING POINT
C       3.   64 BIT WORD:   4-INTEGERS,  OR   OP-CODE FIELDS
C
C       PARAMETERS:
C       REG     DATA FROM THE USER, LEFT JUSTIFIED IN 16-BIT PIECES.
C                       IT'S SIZE DEPENDS ON 'WIDTH':
C                               WIDTH    SIZE
C                               1       1 LOCATION INTEGER ARRAY OR VARIABLE
C                               3       3 LOCATION INTEGER ARRAY
C                               4       4 LOCATION INTEGER ARRAY
C       LOC     ADDRESS OF LOCATION TO BE INPUT  (USED ONLY IF 'WIDTH' IS 4 AND
C                       'FIE' IS 1)
C       WIDTH   WIDTH OF DATA IN # OF 16-BIT PIECES, 1, 3, OR 4
C       RADIX   RADIX FOR INTEGERS, 8, 10, OR 16
C       FP      FLOATING POINT FLAG (USED ONLY IF 'WIDTH' IS 3)
C                       1 MEANS INPUT IN FLOATING POINT
C                       0 MEANS INPUT IN INTEGER
C       FIE     P.S. FIELD FLAG (USED ONLY IF 'WIDTH' IS 4)
C                       1 MEANS INPUT IN P.S. FIELDS
C                       0 MEANS INPUT IN INTEGER
C       PSFLDS  TABLE OF P.S. FIELDS NAMES (ONLY USED IF 'WIDTH' IS 4 AND 'FIE'
C                       IS 1)
C       LUN     INPUT LOGICAL UNIT NUMBER
C       BUFFER  INPUT BUFFER STRING
C       TOKEN   INPUT TOKEN STRING
C
C-------DECLARATIONS
C
C    LOCAL VARIABLES
        INTEGER I,TEMP
C    FUNCTIONS USED
        INTEGER GETINT,SRCST
        DOUBLE PRECISION GETFPN
C    DEFINED CONSTANTS
        INTEGER ENAMNF
        DATA    ENAMNF/10/
C
C
C       SEE IF INTEGER, OR OTHER FORMAT
        IF (FP.EQ.1.AND.WIDTH.EQ.3) GO TO 2000
        IF (FIE.EQ.1.AND.WIDTH.EQ.4) GO TO 3000
C
C-------INTEGER FORMAT
C
        DO 1100 I=1,WIDTH
        REG(I)=GETINT(BUFFER,TOKEN,RADIX,LUN,APDIN)
        IF (APDIN.NE.0) RETURN
1100    CONTINUE
        RETURN
C
C-------FLOATING POINT FORMAT
C
2000    CALL FTOA(GETFPN(BUFFER,TOKEN,LUN,APDIN),REG)
        RETURN
C
C-------PROGRAM WORD FIELD FORMAT
C
C            GET EXISTING P.S. WORD
C            GET DESIRED FIELD NAME
C            GET NEW VALUE FOR THAT FIELD
C            MERGE TOGETHER WITH OLD VALUE
3000    CALL APEXAM(REG,9,LOC)
        CALL GETSYM(BUFFER,TOKEN,LUN,APDIN)
        IF (APDIN.NE.0) RETURN
        I=SRCST(PSFLDS,1,-1,TOKEN,-1)
        IF (I.EQ.0) GO TO 9000
        TEMP=GETINT(BUFFER,TOKEN,RADIX,LUN,APDIN)
        IF (APDIN.NE.0) RETURN
        CALL INCODE(TEMP,I,REG)
        RETURN
C
C       ERROR RETURN, NAME NOT FOUND
C
9000    APDIN=ENAMNF
        RETURN
        END
C+++    APDOUT
C****** APDOUT = AP DEBUG OUTPUT = REL.  1.00 , 04/20/79 ******
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APDBUG WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:01:47
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        INTEGER FUNCTION APDOUT(REG,OPEN,LOC,WIDTH,TYPEL,RADIX,FP,FIE,
     1                    OFFSET,OPENS,PSFLDS,LUN,SCODE)
        INTEGER REG(4),OPEN,LOC,WIDTH,TYPEL,RADIX,FP,FIE,OFFSET,
     1          OPENS(9999),PSFLDS(9999),LUN,SCODE(9999)
C
C       HANDLES OUTPUT TO THE USER OF THE FPS100 DEBUG.
C       RETURNS '0' IF THE OUTPUT WAS OK, OTHERWISE THE ERROR CODE.
C
C       PARAMETERS:
C       REG     DATA FROM THE AP FRONT PANEL, LEFT JUSTIFIED IN 16-BIT PIECES.
C                       IT'S SIZE DEPENDS ON 'WIDTH':
C                               WIDTH    SIZE
C                               1       1 LOCATION INTEGER ARRAY OR VARIABLE
C                               3       3 LOCATION INTEGER ARRAY
C                               4       4 LOCATION INTEGER ARRAY
C       OPEN    NUMBER OF OPEN REGISTER OR MEMORY, CORRESPONDS TO 'APEXAM'
C                       NUMBERING
C       LOC     MEMORY ADDRESS DATA IS FROM (USED ONLY IF A 'TYPE' IS 1)
C       WIDTH   WIDTH OF DATA IN # OF 16-BIT PIECES (1,3,OR 4)
C       TYPEL    TYPE OF LOCATION (0=REGISTER, 1=MEMORY,
C                2=REGISTER WITH ADDRESS IN LOC FIELD,
C                3=TCB REFERENCE)
C       RADIX   RADIX FOR INTEGERS (8,10,OR 16)
C       FP      FLOATING POINT FLAG (USED ONLY IF 'WIDTH' IS 3)
C                       1 MEANS OUTPUT IN FLOATING POINT
C                       0 MEANS OUTPUT IN INTEGER
C       FIE     P.S. FIELD FLAG (USED ONLY IF 'WIDTH' IS 4)
C                       1 MEANS OUTPUT IN P.S. FIELDS
C                       0 MEANS OUTPUT IN INTEGER
C       OFFSET  OFFSET FOR P.S. RELATED TYPELUN (PS OR PSA)
C       OPENS   TABLE OF REGISTER NAMES
C       PSFLDS  TABLE OF P.S. FIELD NAMES (USED ONLY IF 'WIDTH' IS 4
C                       AND 'FIE' IS 1)
C       LUN     OUTPUT LOGICAL UNTI NUMBER
C       SCODE   A STRING TO BE ADDED TO THE END OF THE OUTPUT USUALLY
C               USED ONLY W/ PS AND PSA OUTPUT.
C
C-------DECLARATIONS
C
C    LOCAL STORAGE
        INTEGER I,BUFF(141),POS,NAMBUF(14),FV(26),J,J1,TEMBUF(5),TEMP
C    FUNCTIONS USED
        INTEGER EXTST
        DOUBLE PRECISION ATOF
C    DEFINED CONSTANTS
        INTEGER LSPACE,LZERO,LDBLQO,ENRANG
        DATA    LSPACE,LZERO,LDBLQO,ENRANG/8224,8240,8226,14/
C
C   CLEAR ERROR RETURN
        APDOUT=0
C    CLEAR OUTPUT STRINGS
        CALL RMVCS(BUFF,1,-1)
C
C    GET NAME
        J=4
        IF (TYPEL.EQ.3) J=6
        I=EXTST(OPENS,OPEN,NAMBUF,J)
C    PUT COMMENT CHARACTER IN FRONT IF A DUMP (I.E. WRITING TO LUN > 0)
        IF (LUN.GT.0) CALL INSCS(NAMBUF,1,LDBLQO)
        IF (LUN.EQ.-1) CALL INSCS(NAMBUF,1,LSPACE)
C    CONVERT LOCATION IF A MEMORY, ELSE FILL WITH BLANKS
        J=TYPEL+1
        GO TO (300,200,300,300),J
C
C    FOR P.S. SUBTRACT OFFSET FOR TYPELUN OF LOCATION
200     J=LOC
        IF (OPEN.EQ.9) J=J-OFFSET
        CALL INSCS(NAMBUF,7,LSPACE)
        CALL PUTINT(NAMBUF,8,J,RADIX)
        GO TO 1000
C
C   A REGISTER, FILL WITH BLANKS
300     CALL INSCS(NAMBUF,13,LSPACE)
C
C    SEE IF INTEGER, OR OTHER FORMAT
1000    IF (FP.EQ.1.AND.WIDTH.EQ.3) GO TO 2000
        IF (FIE.EQ.1.AND.WIDTH.EQ.4) GO TO 3000
C
C-------INTEGER FORMAT
C
C    IF ITS PSA, SUBTRACT OFFSET FOR TYEPLUN
        IF (OPEN.EQ.1) REG(1)=REG(1)-OFFSET
C
C    CONVERT DATA
        POS=1
        DO 1100 I=1,WIDTH
        CALL PUTINT(BUFF,POS,REG(I),RADIX)
        CALL INSCS(BUFF,POS+6,LSPACE)
1100    POS=POS+8
C    ADD NAME AND LOCATION
1200    CONTINUE
        CALL INSSS (BUFF,POS,NAMBUF,13)
        CALL INSSS (BUFF,LENS(BUFF)+3,SCODE,-1)
        CALL WRTLIN(BUFF,LUN,80)
        RETURN
C
C-------FLOATING POINT OUTPUT
C
2000    CALL DFTOS(ATOF(REG,APDOUT),BUFF,3,17,10)
        IF (APDOUT.NE.0) APDOUT=ENRANG
        POS=19
        GO TO 1200
C
C-------PROGRAM WORD FIELD OUTPUT
C
C    DECODE THE FIELDS
3000    CALL SPLIT (REG,FV)
C   PUT LUN NAME AND LOCATION ON FIRST LINE
        CALL WRTLIN(NAMBUF,LUN,80)
C   NOW PUT LUN FOUR LINES OF THE P.S. FIELDS
        DO 3100 I=1,19,6
        CALL RMVCS(BUFF,1,-1)
        POS=5
        J1=I+5
        DO 3050 J=I,J1
        TEMP=EXTST(PSFLDS,J,TEMBUF,4)
        CALL INSSS(BUFF,POS,TEMBUF,4)
        CALL INSCS(BUFF,POS+4,LSPACE)
        CALL RPLIS(BUFF,POS+5,FV(J),2,RADIX,LZERO)
3050    POS=POS+11
C
3100    CALL WRTLIN(BUFF,LUN,80)
C
        RETURN
        END
C+++    GETINT
C****** GETINT = GET SIGNED INTEGER = REL.  1.00 , 04/20/79 ******
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APDBUG WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:02:34
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        INTEGER FUNCTION GETINT(BUFFER,TOKEN,RADIX,LUN,IERR)
        INTEGER BUFFER(9999),TOKEN(9999),RADIX,LUN,IERR
C
C       GET A SIGNED INTEGER FROM STRING 'BUFFER' IN RADIX 'RADIX'.
C       IF 'BUFFER' IS EMPTY, READ A LINE FROM LOGICAL UNIT 'LUN'.
C       SET 'IERR' TO 0 IF OK, ELSE THE PROPER ERROR CODE.
C       'GETINT' RETURNS THE VALUE OF THE SIGNED INTEGER, 'TOKEN' RETURNS THE
C       STRING.  ON ERROR, 'GETINT' RETURNS 0.
C
C-------LOCAL DECLARATIONS
C
C    VARIABLES
        INTEGER I,ISGN,TRADIX,TEMP(81),L
        REAL RVAL
C    FUNCTIONS
        INTEGER IPFIX,EXTSS,EXTCS,LENS
        REAL STOFI
C    DEFINED CONSTANTS
        INTEGER LPLUS,LMINUS,LPOINT,ENUMBD
        DATA    LPLUS,LMINUS,LPOINT,ENUMBD/8235,8237,8238,3/
C
C
C    GET THE NUMBER
        CALL GETSYM(BUFFER,TOKEN,LUN,IERR)
        IF (IERR.NE.0) RETURN
C    COPY NUMBER INTO TEMPORARY
        I=EXTSS(TOKEN,1,TEMP,-1)
        TRADIX=RADIX
        ISGN=0
C    IF LAST CHARACTER OF NUMBER IS POINT, THEN SET RADIX TO 10
        L=LENS(TEMP)
        IF (EXTCS(TEMP,L,I).NE.LPOINT) GO TO 200
C
        TRADIX=10
        CALL RMVCS(TEMP,L,1)
C
C    LOOK FOR SIGN AS FIRST CHARACTER
200     I=EXTCS(TEMP,1,I)
        IF (I.NE.LPLUS.AND.I.NE.LMINUS) GO TO 300
C
C    IGNORE '+', REMEMBER '-'
        CALL RMVCS(TEMP,1,1)
        IF (I.EQ.LMINUS) ISGN=1
C
C    CONVERT THE NUMBER
300     RVAL=STOFI(TEMP,TRADIX)
C    STOFI SIGNALS AN ERROR WITH A -1.0
        IF (RVAL.LT.0.0) GO TO 1000
C    NEGATE IF FOUND A MINUS SIGN
        IF (ISGN.EQ.1) RVAL=-RVAL
        GETINT=IPFIX(RVAL)
        RETURN
C
C       ERROR
C
1000    IERR=ENUMBD
        GETINT=0
        RETURN
        END
C+++    GETFPN
C****** GETFPN = GET A FLOATING POINT NUMBER = REL.  1.00 , 04/20/79 ***
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APDBUG WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:03:20
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        DOUBLE PRECISION FUNCTION GETFPN(BUFFER,TOKEN,LUN,IERR)
        INTEGER BUFFER(9999),TOKEN(9999),LUN,IERR
C
C       GET A DOUBLE PRECISION NUMBER FROM STRING 'BUFFER'.  IF 'BUFFER' IS
C       EMPTY THEN READ A LINE FROM LOGICAL UNIT 'LUN'.  SET 'IERR' TO 0 IF
C       OK, ELSE THE ERROR CODE FOR A BAD NUMBER.  'GETFPN' RETURNS THE DOUBLE
C       PRECISION VALUE, AND RETURNS 0.0 IF AN ERROR.  RETURN THE NUMBER AS A
C       STRING IN 'TOKEN'.
C
C-------LOCAL DEFINITIONS
C
C    LOCAL STORAGE
C    FUNCTIONS USED
        DOUBLE PRECISION STODF
C    DEFINED CONSTANTS
        INTEGER ENUMBD
        DATA ENUMBD/3/
C
C    GET THE NUMBER
        CALL GETSYM(BUFFER,TOKEN,LUN,IERR)
        IF (IERR.NE.0) RETURN
C
C    NOW CONVERT
        GETFPN=STODF(TOKEN,IERR)
        IF (IERR.EQ.0) RETURN
        IERR=ENUMBD
        RETURN
        END
C+++    GETSYM
C****** GETSYM = GET SYMBOL = REL.  1.00 , 04/20/79 ******
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APDBUG WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:04:04
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE GETSYM(BUFFER,TOKEN,LUN,IERR)
        INTEGER BUFFER(9999),TOKEN(9999),LUN,IERR
C
C       GET THE NEXT SYMBOL FROM 'BUFFER'.  A SYMBOL IS A STRING OF NON-
C       BLANK CHARACTERS, OPTIONALLY PRECEEDED BY BLANKS, AND DELIMITED BY
C       A BLANK.  IF 'BUFFER' IS EMPTY OR CONTAINS ONLY BLANKS, READ THE NEXT
C       LINE IN FROM LOGICAL UNIT 'LUN'.  THE SYMBOL IS RETURNED IN 'TOKEN'.
C       IERR IS SET TO 0 IF OK, ELSE THE ERROR CODE FOR EITHER 'I/O' ERROR
C       OR 'END-OF-FILE'.
C
C-------LOCAL DECLARATIONS
C
        INTEGER I,TEMP(81)
C    FUNCTIONS USED
        INTEGER TYPC,EXTCS,RMVTFF,RMVTOK
C    DEFINED CONSTANTS
        INTEGER LEOF,LDBLQO,EIO,EEOF
        DATA    LEOF,LDBLQO,EIO,EEOF/8285,8226,9,2/
C
        IERR=0
C
C    GET FIRST TOKEN ON THE FIRST NON BLANK LINE
100     I=RMVTFF(TOKEN,80,BUFFER,10,LUN,80)
        IF (I.EQ.-3.OR.I.EQ.LEOF) GO TO 10000
C    IF A COMMENT, IGNORE REST OF LINE AND GET FIRST TOKEN FROM
C    ANOTHER LINE
        IF (I.NE.LDBLQO) GO TO 200
C
        CALL RMVCS(BUFFER,1,-1)
        GO TO 100
C
C   APPEND ANY OTHER TOKENS ON THE LINE UNTIL THE DELIMITER IS A BLANK
200     IF (TYPC(EXTCS(BUFFER,1,I),10).EQ.0) RETURN
        IF (TYPC(EXTCS(BUFFER,1,I),10).EQ.8224) RETURN
C    GET NEXT TOKEN FROM LINE
        I=RMVTOK(TEMP,80,BUFFER,10)
        IF (I.EQ.-3) GO TO 10000
C   IF A COMMENT, CLEAR REST OF LINE
        IF (I.NE.LDBLQO) GO TO 300
C
        CALL RMVCS(BUFFER,1,-1)
        RETURN
C
C    OTHERWISE APPEND THE NEW TOKEN TO THE END AND GET ANOTHER
300     CALL INSSS(TOKEN,-1,TEMP,-1)
        GO TO 200
C
C    ERROR
10000   IF (I.EQ.-3) IERR=EIO
        IF (I.EQ.LEOF) IERR=EEOF
        RETURN
        END
C+++    PUTINT
C****** PUTINT = PUT AN INTEGER INTO A LINE = REL.  1.00 , 04/20/79 ****
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APDBUG WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:04:49
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE PUTINT(BUFFER,POS,VALUE,RADIX)
        INTEGER BUFFER(9999),POS,VALUE,RADIX
C
C       CONVERT INTEGER 'VALUE' INTO A 6 CHARACTER STRING RIGHT JUSTIFIED ZERO
C       FILLED STRING AND INSERT IT INTO STRING 'STR' AT POSITION 'POS'.
C       IF 'RADIX' IS 10,  BLANK FILL THE 1ST, AND IF 'RADIX' IS 16, THE 1ST
C       TWO POSITIONS OF THE INSERTED STRING WITH BLANKS
C
C-------LOCAL DEFINITIONS
C
C    LOCAL VARIABLES
        INTEGER I
C    FUNCTIONS USED
        INTEGER INSCS
C    DEFINED CONSTANTS
        INTEGER LSPACE,LZERO
        DATA    LSPACE,LZERO/8224,8240/
C
        CALL RPLIS(BUFFER,POS,VALUE,6,RADIX,LZERO)
        IF (RADIX.GE.10) I=RPLCS(BUFFER,POS,LSPACE)
        IF (RADIX.EQ.16) I=RPLCS(BUFFER,POS+1,LSPACE)
        RETURN
        END
C+++    APFILL
C****** APFILL = LOAD MODULE LOADER = REL.  1.00 , 04/20/79 ******
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APDBUG WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:05:31
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE APFILL (LUN)
        INTEGER LUN
C
C       THIS ROUTINE LOADS AN AP LOAD MODULE CREATED BY APLOAD INTO THE AP.
C
C       *************************************************************
C
C       I N S T A L L A T I O N   I N S T R U C T I O N S
C
C       SET FPPAK AND PAKFAC FOR THE HOST AS DESCRIBED UNDER VARIABLES
C       BELOW.
C
C       SET THE ABUF DIMENTION SIZE IN THE INTEGER STMT.
C       TO THE IBUF SIZE DIVIDED BY FPFAK.
C
C       **************************************************************
C
C       CALL:
C
C       LUN    = LOGICAL UNIT ASSIGNED TO THE LOAD MODULE FILE
C
C       VARIABLES:
C
C       PGCRNT = THE CURRENTLY SELECTED MD PAGE (0-16)
C       FPPAK  = THE NUMBER OF HOST WORDS PER HOST FLOATING PT. NUMBER
C       PAKFAC = THE NUMBER OF 16 BIT INTEGERS PER HOST WORD ( 1 OR 2 )
C       IBUF() = GENERAL INPUT BUFFER - THIS MUST BE AT LEAST AS
C                BIG AS THE BUFFER() IN APLOAD.
C       ABUF() = EQUIVALENCED TO IBUF() - FOR HOST F.P.N.'S
C       BUFSIZ = THE NUMBER OF WORDS IN IBUF()
C       LMBUF  = BUFFER FOR READING HEADER RECORDS
C       TYPEL   = THE TYPE OF HEADER READ:  0=INTEGER VALUES (CODE OR
C                OVERLAY MAP), 1=DATA BLOCK VALUES, 2=N.I., 3=END RECORD.
C       ADDR   = THE AP DESTINATION ADDRESS OF AN ITEM OR THE START ADDRESS
C                OF A BLOCK OF ITEMS
C       PG     = THE MD PAGE DESTINATION OF A VALUE(S)
C       CNT    = THE NUMBER OF RECORDS IN A BLOCK OR THE HOST WORD SIZE OF
C                A BLOCK
C       DEST   = THE DESTINATION OF A CODE BLOCK: 0=PS, 1=MD
C       VALTYP = VALUE TYPE SPECIFIER: 1=INTEGER (16), 2=HOST F.P.N.
C       REPCNT = REPETITION COUNT (USED W/ DATA BLOCK VALUES)
C
C       ROUTINES-APEX:  APPUT, LOADPS, OAPME
C
        INTEGER LMBUF(8),I,TYPEL,ADDR,PG,CNT,K,KK,L,VALTYP,DEST
        INTEGER REPCNT,IBUF(200),PGCRNT,J,PAKFAC,FPPAK,BUFSIZ
C
        REAL ABUF(100),VAL(2),FPN
C
C-------DECLARE THE STATE VARIABLES USED BY THE BOOTSTRAP LOADER.
C
        INTEGER SUPER, START, BOOT
        COMMON /SYSTEM/ SUPER, START, BOOT
        INTEGER PSSIZ
C
C
        EQUIVALENCE (ABUF(1),IBUF(1))
        EQUIVALENCE (LMBUF(5),VAL(1))
C
        COMMON /APLDCM/ IPAV(33),NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS(33),
     *                  LMT(10,3),LMTE
        INTEGER IPAV,NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS,LMT,LMTE
C
C------- INITIALIZE
C
        DATA FPPAK,PAKFAC,BUFSIZ/2,1,200/
C
C       SELECT MD PAGE ZERO.  INITIALLY LOAD THE BOOTSTRAP IN LOW MEMORY.
C
        CALL OAPME (0)
        PGCRNT=0
        CALL SIZEPS (PSSIZ)
        START=0
        CALL LOADBT
C
C       GET A HEADER RECORD, GET THE TYPE, RECORD COUNT, LOAD ADDRESS,
C       AND PAGE DESTINATION.
C
100     CONTINUE
        CALL APWD
        READ (LUN,END=500) (LMBUF(I),I=1,8)
        TYPEL=LMBUF(1)+1
        CNT=LMBUF(2)
        ADDR=LMBUF(3)
        PG=LMBUF(4)
        DEST=LMBUF(5)
C
C       PROCESS:  INTEGER VALUES (CODE OR OV MAP), DATA BLOCK VALUES, N.I.,
C                 AND END BLOCK
C
        IF (TYPEL .LT. 0 .OR. TYPEL .GT. 4) GOTO 90000
        GOTO (1000,2000,600,500),TYPEL
C
C------- END RECORD FOUND - RETURN
C
500     CONTINUE
        IF (LMBUF(2).EQ.0) GO TO 100
        CALL OMASK (15)
        RETURN
C
C------- INFO RECORD PROCESSING
C
C       MUST SET PPAAD, PPASZ AND LMID IN THE RUN TIME INFO COMMON
C       AREA (/APLDCM/)
C
600     IPPAAD=LMBUF(2)
        IPPAND=LMBUF(3)
        IDLM=LMBUF(4)
        IF (LMBUF(5).EQ.0) GO TO 100
        CALL APPUT(LMBUF(5),1,2,1)
        GOTO 100
C
C------- INTEGER VALUE PROCESSING (CODE OR OVERLAY MAP VALUES)
C
C       IF DEST .NE. 0 WE MUST SELECT AN MD PG FOR THE MD TRANSFER.
C       IF PG=PGCRNT THEN DO NOTHING, ELSE SELECT PAGE PG.  IF
C       DEST=0 THEN TRANSFER IS TO PS.
C
1000    CONTINUE
        IF (CNT.EQ.0) GO TO 100
        IF (DEST .EQ. 0) GOTO 1100
C
        IF (PG .EQ. PGCRNT) GOTO 1100
        CALL OAPME (PG)
        PGCRNT=PG
C
C       READ THE BUFFER OF VALUES (MAX OF BUFSIZ AT A TIME)
C
1100    K=MIN0 (CNT,BUFSIZ)
        CALL APWD
        DO 1200 J=1,K,8
           L=MIN0(J+7,K)
           READ (LUN) (IBUF(I),I=J,L)
1200    CONTINUE
        IF (DEST .NE. 0) GOTO 1400
C
C       MOVE VALUES (CODE) TO PS.  MOVE THE BOOTSTRAP INTO HIGH MEMORY IF
C       IT IS ABOUT TO BE CLOBBERED.
C
        IF (ADDR.GT.16) GO TO 1300
        START=PSSIZ-16
        CALL APWAIT
        CALL LOADBT
1300    CONTINUE
        CALL LOADPS (IBUF,ADDR,(K*PAKFAC)/4)
        ADDR=ADDR+(K*PAKFAC)/4
        GOTO 1440
C
C       MOVE VALUES (CODE OR OVERLAY MAP) TO MD;  32 BITS OF HOST
C       PER MD WORD.
C
1400    CALL APPUT (IBUF,ADDR,(K*PAKFAC)/2,0)
        ADDR=ADDR+(K*PAKFAC)/2
C
C       SEE IF THERE ARE MORE VALUES
C
1440    IF (K .EQ. CNT) GOTO 100
        CNT=CNT-K
        GOTO 1100
C
C------- DATA BLOCK VALUE PROCESSING
C
C       SELECT THE REQUESTED MD PAGE (PG) IF ITS DIFFERENT FROM PGCRNT.
C
2000    IF (PG .EQ. PGCRNT) GOTO 2020
        CALL OAPME (PG)
        PGCRNT=PG
C
C       GET DATA BLOCK VALUES (1 PER RECORD) AND PLACE THEM IN MD.
C       GET THE TYPE OF VALUE (0=16 BIT INTEGER, 1=F.P.), AND DESTINATION
C       ADDRESS.
C
2020    DO 3500 J=1,CNT
        CALL APWD
        READ (LUN) (LMBUF(I),I=1,8)
        VALTYP=LMBUF(1)
        ADDR=LMBUF(3)
C
C       IF REPETITION COUNT (LMBUF(2)) .GT. 1 PROCESS SEPERATE
C
        IF (LMBUF(2) .GT. 1) GOTO 2600
C
C       PROCESS VALUES:  INTEGER, REAL, COMPLEX, TRIPLE
C
        GOTO (2100,2150,2200,2300),VALTYP
C
C       INTEGER VALUE
C
2100    CONTINUE
        CALL APPUT (LMBUF(5),ADDR,1,1)
        GOTO 3500
C
C       REAL VALUE
C
2150    CALL APPUT (VAL(1),ADDR,1,2)
        GOTO 3500
C
C       COMPLEX VALUE
C
2200    CONTINUE
        CALL APPUT (VAL(1),ADDR,2,2)
        GO TO 3500
C
C       A TRIPLE VALUE.
C
2300    CONTINUE
        CALL APPUT (LMBUF(6),ADDR,1,0)
        GO TO 3500
C
C       PROCESS VALUE WITH A REPETITION COUNT.  MAKE 'REPCNT' COPIES OF VALUE
C       IN THE IBUF(),  (EQUIVALENCED TO ABUF()).
C
C       PROCESS BY VALTYP:  1=INTEGER, 2=REAL, 3=COMPLEX, 4=TRIPLE
C
2600    REPCNT=LMBUF(2)
        GOTO (2700,2800,2900,3000),VALTYP
C
C       INTEGER VALUE WITH REPETITION COUNT
C
2700    K=MIN0 (BUFSIZ,REPCNT)
        DO 2750 I=1,K
2750    IBUF(I)=LMBUF(5)
        CALL APPUT(IBUF,ADDR,K,1)
        IF (K .EQ. REPCNT) GOTO 3500
        REPCNT=REPCNT-K
        ADDR=ADDR+K
        GOTO 2700
C
C       REAL VALUE WITH REPETITION COUNT
C
2800    K=MIN0(BUFSIZ/FPPAK,REPCNT)
        DO 2850 I=1,K
2850    ABUF(I)=VAL(1)
        CALL APPUT (ABUF,ADDR,K,2)
        IF (REPCNT .EQ. K) GOTO 3500
        REPCNT=REPCNT-K
        ADDR=ADDR+K
        GOTO 2800
C
C       COMPLEX WITH REPETITION COUNT
C
2900    CONTINUE
        K=MIN0(BUFSIZ/FPPAK,REPCNT*2)
        DO 2920 I=1,K,2
           ABUF(I)=VAL(1)
           ABUF(I+1)=VAL(2)
2920    CONTINUE
        CALL APPUT (ABUF,ADDR,K,2)
        IF (REPCNT*2 .EQ. K) GO TO 3500
        REPCNT=REPCNT - K/2
        ADDR=ADDR+K
        GO TO 2900
C
C    32 BIT TRANSFER WITH REPETITION COUNT
C
3000    CONTINUE
        L=3-PAKFAC
        K=MIN0(BUFSIZ/L,REPCNT)
        KK=K*L
        DO 2950 I=1,KK,L
        IBUF(I)=LMBUF(6)
        IBUF(I+1)=LMBUF(7)
2950    CONTINUE
        CALL APPUT(IBUF,ADDR,K,0)
        IF (K.EQ.REPCNT) GO TO 3500
        REPCNT=REPCNT-K
        ADDR=ADDR+K
        GO TO 3000
C
C       BOTTOM OF THE DATA BLOCK RECORD LOOP
C
3500    CONTINUE
        GOTO 100
C
C       ERROR - BAD LOAD MODULE
C
C#      DO TTY I/O HERE
90000   CONTINUE
        CALL APSTOP (10)
        RETURN
        END
C+++    TCBEXM
C****** TCBEXM = FPS100  TCB EXAMINE = REL.  1.00 , 04/20/79 ***********
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APDBUG WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:06:28
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE TCBEXM(CODE,BUFFER,TOKEN,LUN,REG,WIDTH,TYPEL,
     1              LOC,TCBOPN,BASE,RADIX,FP,FIE,OFFSET,IERR)
        INTEGER CODE,BUFFER(9999),TOKEN(9999),LUN,REG(4),WIDTH,
     1          TYPEL,LOC,TCBOPN,BASE,RADIX,FP,FIE,OFFSET,IERR
C
C       HANDLES A LOGICAL EXAM AND CHANGE OF A TCB ELEMENT. IT IS
C       LOGICAL BECAUSE A TCB IS A LIST STRUCTURE RESIDING IN MD
C       MEMORY.  THIS ROUTINE MAPS A TCB REFERENCE INTO THE PROPER
C       MD LOCATION.
C
C       PARAMETERS:
C       CODE     A NUMBER FROM 1 TO 5.
C                  1 = EXAMINE A TCB ELEMENT SPECIFIED BY USER
C                  2 = '.' RE-EXAMINE THE PREVIOUS TCB ELEMENT
C                  3 = '+' EXAMINE THE NEXT TCB ELEMENT
C                  4 = '-' EXAMINE THE PREVIOUS TCB ELEMENT
C                  5 = CHANGE THE CURRENT TCB ELEMENT
C       BUFFER  DATA AREA TO HOLD USER INPUT
C       TOKEN   TOKEN EXTRACTED FROM USER INPUT
C       LUN     INPUT/OUTPUT LOGICAL UNIT NUMBER
C       REG     DATA FROM THE AP FRONT PANEL, LEFT JUSTIFIED IN 16-BIT PIECES.
C                       IT'S SIZE DEPENDS ON 'WIDTH':
C                               WIDTH    SIZE
C                               1       1 LOCATION INTEGER ARRAY OR VARIABLE
C                               3       3 LOCATION INTEGER ARRAY
C                               4       4 LOCATION INTEGER ARRAY
C       WIDTH   WIDTH OF DATA IN # OF 16-BIT PIECES (1,3,OR 4)
C       TYPEL    TYPE OF LOCATION (0=REGISTER, 1=MEMORY,
C               2=REGISTER WITH ADDRESS IN LOC FIELD)
C       LOC     MEMORY ADDRESS DATA IS FROM
C       TCBOPN  POINTER TO CURRENTLY OPEN TCB ELEMENT
C       BASE    BASE ADDRESS OF CURRENT TCB
C       RADIX   RADIX FOR INTEGERS (8,10,OR 16)
C       FP      FLOATING POINT FLAG (USED ONLY IF 'WIDTH' IS 3)
C                       1 MEANS OUTPUT IN FLOATING POINT
C                       0 MEANS OUTPUT IN INTEGER
C       FIE     P.S. FIELD FLAG (USED ONLY IF 'WIDTH' IS 4)
C                       1 MEANS OUTPUT IN P.S. FIELDS
C                       0 MEANS OUTPUT IN INTEGER
C       OFFSET  OFFSET FOR P.S. RELATED TYPELUN (PS OR PSA)
C       IERR    RETURN ERROR CODE
C
C-------LOCAL DECLARATIONS
C
        INTEGER TBLSIZ,ENAMNF,I,J,K
C
C-------FUNCTIONS USED
C
        INTEGER SRCST,EXTVT,APDOUT,APDIN
C
C-------INITIALIZATION
C
C-------TABLES
C
C       TCB DEFINITION
C       EACH ENTRY CONSISTS OF 3 PARTS
C         1. TCB ELEMENT MNEMONIC
C         2. OFFSET FROM BASE IN MD MEMORY
C         3. WIDTH OF ELEMENT IN 16 BIT WORDS
C       ORDER:  BY OCCURRANCE IN MD MEMORY
C
C                                                                       STARTPRE
      INTEGER TCBTBL(451)
C TABLE 6,2,TCBTBL,"BASE" -1 1
      DATA TCBTBL(2)/6/,TCBTBL(3)/2/
      DATA TCBTBL(4)/'B '/,TCBTBL(5)/'A '/,TCBTBL(6)/'S '/
      DATA TCBTBL(7)/'E '/,TCBTBL(8)/'  '/,TCBTBL(9)/'  '/
      DATA TCBTBL(10)/-1/,TCBTBL(11)/1/
C TABLE 6,2,TCBTBL,"HEADER" 0 1
      DATA TCBTBL(12)/'H '/,TCBTBL(13)/'E '/,TCBTBL(14)/'A '/
      DATA TCBTBL(15)/'D '/,TCBTBL(16)/'E '/,TCBTBL(17)/'R '/
      DATA TCBTBL(18)/0/,TCBTBL(19)/1/
C TABLE 6,2,TCBTBL,"RLINK" 0 1
      DATA TCBTBL(20)/'R '/,TCBTBL(21)/'L '/,TCBTBL(22)/'I '/
      DATA TCBTBL(23)/'N '/,TCBTBL(24)/'K '/,TCBTBL(25)/'  '/
      DATA TCBTBL(26)/0/,TCBTBL(27)/1/
C TABLE 6,2,TCBTBL,"LLINK" 1 1
      DATA TCBTBL(28)/'L '/,TCBTBL(29)/'L '/,TCBTBL(30)/'I '/
      DATA TCBTBL(31)/'N '/,TCBTBL(32)/'K '/,TCBTBL(33)/'  '/
      DATA TCBTBL(34)/1/,TCBTBL(35)/1/
C TABLE 6,2,TCBTBL,"RPRI" 2 1
      DATA TCBTBL(36)/'R '/,TCBTBL(37)/'P '/,TCBTBL(38)/'R '/
      DATA TCBTBL(39)/'I '/,TCBTBL(40)/'  '/,TCBTBL(41)/'  '/
      DATA TCBTBL(42)/2/,TCBTBL(43)/1/
C TABLE 6,2,TCBTBL,"TYPE" 3 3
      DATA TCBTBL(44)/'T '/,TCBTBL(45)/'Y '/,TCBTBL(46)/'P '/
      DATA TCBTBL(47)/'E '/,TCBTBL(48)/'  '/,TCBTBL(49)/'  '/
      DATA TCBTBL(50)/3/,TCBTBL(51)/3/
C TABLE 6,2,TCBTBL,"LENGTH" 4 1
      DATA TCBTBL(52)/'L '/,TCBTBL(53)/'E '/,TCBTBL(54)/'N '/
      DATA TCBTBL(55)/'G '/,TCBTBL(56)/'T '/,TCBTBL(57)/'H '/
      DATA TCBTBL(58)/4/,TCBTBL(59)/1/
C TABLE 6,2,TCBTBL,"ANSKEY" 5 1
      DATA TCBTBL(60)/'A '/,TCBTBL(61)/'N '/,TCBTBL(62)/'S '/
      DATA TCBTBL(63)/'K '/,TCBTBL(64)/'E '/,TCBTBL(65)/'Y '/
      DATA TCBTBL(66)/5/,TCBTBL(67)/1/
C TABLE 6,2,TCBTBL,"HDREND" 5 1
      DATA TCBTBL(68)/'H '/,TCBTBL(69)/'D '/,TCBTBL(70)/'R '/
      DATA TCBTBL(71)/'E '/,TCBTBL(72)/'N '/,TCBTBL(73)/'D '/
      DATA TCBTBL(74)/5/,TCBTBL(75)/1/
C TABLE 6,2,TCBTBL,"MISC" 6 3
      DATA TCBTBL(76)/'M '/,TCBTBL(77)/'I '/,TCBTBL(78)/'S '/
      DATA TCBTBL(79)/'C '/,TCBTBL(80)/'  '/,TCBTBL(81)/'  '/
      DATA TCBTBL(82)/6/,TCBTBL(83)/3/
C TABLE 6,2,TCBTBL,"TASKID" 6 1
      DATA TCBTBL(84)/'T '/,TCBTBL(85)/'A '/,TCBTBL(86)/'S '/
      DATA TCBTBL(87)/'K '/,TCBTBL(88)/'I '/,TCBTBL(89)/'D '/
      DATA TCBTBL(90)/6/,TCBTBL(91)/1/
C TABLE 6,2,TCBTBL,"OVLPTR" 7 1
      DATA TCBTBL(92)/'O '/,TCBTBL(93)/'V '/,TCBTBL(94)/'L '/
      DATA TCBTBL(95)/'P '/,TCBTBL(96)/'T '/,TCBTBL(97)/'R '/
      DATA TCBTBL(98)/7/,TCBTBL(99)/1/
C TABLE 6,2,TCBTBL,"OVLCNT" 8 1
      DATA TCBTBL(100)/'O '/,TCBTBL(101)/'V '/,TCBTBL(102)/'L '/
      DATA TCBTBL(103)/'C '/,TCBTBL(104)/'N '/,TCBTBL(105)/'T '/
      DATA TCBTBL(106)/8/,TCBTBL(107)/1/
C TABLE 6,2,TCBTBL,"DPRI" 9 1
      DATA TCBTBL(108)/'D '/,TCBTBL(109)/'P '/,TCBTBL(110)/'R '/
      DATA TCBTBL(111)/'I '/,TCBTBL(112)/'  '/,TCBTBL(113)/'  '/
      DATA TCBTBL(114)/9/,TCBTBL(115)/1/
C TABLE 6,2,TCBTBL,"STATUS" 10 1
      DATA TCBTBL(116)/'S '/,TCBTBL(117)/'T '/,TCBTBL(118)/'A '/
      DATA TCBTBL(119)/'T '/,TCBTBL(120)/'U '/,TCBTBL(121)/'S '/
      DATA TCBTBL(122)/10/,TCBTBL(123)/1/
C TABLE 6,2,TCBTBL,"LSTMSG" 11 1
      DATA TCBTBL(124)/'L '/,TCBTBL(125)/'S '/,TCBTBL(126)/'T '/
      DATA TCBTBL(127)/'M '/,TCBTBL(128)/'S '/,TCBTBL(129)/'G '/
      DATA TCBTBL(130)/11/,TCBTBL(131)/1/
C TABLE 6,2,TCBTBL,"RCLOCK" 12 1
      DATA TCBTBL(132)/'R '/,TCBTBL(133)/'C '/,TCBTBL(134)/'L '/
      DATA TCBTBL(135)/'O '/,TCBTBL(136)/'C '/,TCBTBL(137)/'K '/
      DATA TCBTBL(138)/12/,TCBTBL(139)/1/
C TABLE 6,2,TCBTBL,"LCLOCK" 13 1
      DATA TCBTBL(140)/'L '/,TCBTBL(141)/'C '/,TCBTBL(142)/'L '/
      DATA TCBTBL(143)/'O '/,TCBTBL(144)/'C '/,TCBTBL(145)/'K '/
      DATA TCBTBL(146)/13/,TCBTBL(147)/1/
C TABLE 6,2,TCBTBL,"ICLOCK" 14 1
      DATA TCBTBL(148)/'I '/,TCBTBL(149)/'C '/,TCBTBL(150)/'L '/
      DATA TCBTBL(151)/'O '/,TCBTBL(152)/'C '/,TCBTBL(153)/'K '/
      DATA TCBTBL(154)/14/,TCBTBL(155)/1/
C TABLE 6,2,TCBTBL,"TADDR" 15 1
      DATA TCBTBL(156)/'T '/,TCBTBL(157)/'A '/,TCBTBL(158)/'D '/
      DATA TCBTBL(159)/'D '/,TCBTBL(160)/'R '/,TCBTBL(161)/'  '/
      DATA TCBTBL(162)/15/,TCBTBL(163)/1/
C TABLE 6,2,TCBTBL,"FIFO" 16 3
      DATA TCBTBL(164)/'F '/,TCBTBL(165)/'I '/,TCBTBL(166)/'F '/
      DATA TCBTBL(167)/'O '/,TCBTBL(168)/'  '/,TCBTBL(169)/'  '/
      DATA TCBTBL(170)/16/,TCBTBL(171)/3/
C TABLE 6,2,TCBTBL,"DPBS" 19 3
      DATA TCBTBL(172)/'D '/,TCBTBL(173)/'P '/,TCBTBL(174)/'B '/
      DATA TCBTBL(175)/'S '/,TCBTBL(176)/'  '/,TCBTBL(177)/'  '/
      DATA TCBTBL(178)/19/,TCBTBL(179)/3/
C TABLE 6,2,TCBTBL,"DPXW" 20 3
      DATA TCBTBL(180)/'D '/,TCBTBL(181)/'P '/,TCBTBL(182)/'X '/
      DATA TCBTBL(183)/'W '/,TCBTBL(184)/'  '/,TCBTBL(185)/'  '/
      DATA TCBTBL(186)/20/,TCBTBL(187)/3/
C TABLE 6,2,TCBTBL,"STAT1" 21 1
      DATA TCBTBL(188)/'S '/,TCBTBL(189)/'T '/,TCBTBL(190)/'A '/
      DATA TCBTBL(191)/'T '/,TCBTBL(192)/'1 '/,TCBTBL(193)/'  '/
      DATA TCBTBL(194)/21/,TCBTBL(195)/1/
C TABLE 6,2,TCBTBL,"DPX0" 22 3
      DATA TCBTBL(196)/'D '/,TCBTBL(197)/'P '/,TCBTBL(198)/'X '/
      DATA TCBTBL(199)/'0 '/,TCBTBL(200)/'  '/,TCBTBL(201)/'  '/
      DATA TCBTBL(202)/22/,TCBTBL(203)/3/
C TABLE 6,2,TCBTBL,"DPX1" 23 3
      DATA TCBTBL(204)/'D '/,TCBTBL(205)/'P '/,TCBTBL(206)/'X '/
      DATA TCBTBL(207)/'1 '/,TCBTBL(208)/'  '/,TCBTBL(209)/'  '/
      DATA TCBTBL(210)/23/,TCBTBL(211)/3/
C TABLE 6,2,TCBTBL,"DPX2" 24 3
      DATA TCBTBL(212)/'D '/,TCBTBL(213)/'P '/,TCBTBL(214)/'X '/
      DATA TCBTBL(215)/'2 '/,TCBTBL(216)/'  '/,TCBTBL(217)/'  '/
      DATA TCBTBL(218)/24/,TCBTBL(219)/3/
C TABLE 6,2,TCBTBL,"DPX3" 25 3
      DATA TCBTBL(220)/'D '/,TCBTBL(221)/'P '/,TCBTBL(222)/'X '/
      DATA TCBTBL(223)/'3 '/,TCBTBL(224)/'  '/,TCBTBL(225)/'  '/
      DATA TCBTBL(226)/25/,TCBTBL(227)/3/
C TABLE 6,2,TCBTBL,"DA" 26 1
      DATA TCBTBL(228)/'D '/,TCBTBL(229)/'A '/,TCBTBL(230)/'  '/
      DATA TCBTBL(231)/'  '/,TCBTBL(232)/'  '/,TCBTBL(233)/'  '/
      DATA TCBTBL(234)/26/,TCBTBL(235)/1/
C TABLE 6,2,TCBTBL,"SPD" 27 1
      DATA TCBTBL(236)/'S '/,TCBTBL(237)/'P '/,TCBTBL(238)/'D '/
      DATA TCBTBL(239)/'  '/,TCBTBL(240)/'  '/,TCBTBL(241)/'  '/
      DATA TCBTBL(242)/27/,TCBTBL(243)/1/
C TABLE 6,2,TCBTBL,"SPAD0" 28 1
      DATA TCBTBL(244)/'S '/,TCBTBL(245)/'P '/,TCBTBL(246)/'A '/
      DATA TCBTBL(247)/'D '/,TCBTBL(248)/'0 '/,TCBTBL(249)/'  '/
      DATA TCBTBL(250)/28/,TCBTBL(251)/1/
C TABLE 6,2,TCBTBL,"SPFUNC" 29 1
      DATA TCBTBL(252)/'S '/,TCBTBL(253)/'P '/,TCBTBL(254)/'F '/
      DATA TCBTBL(255)/'U '/,TCBTBL(256)/'N '/,TCBTBL(257)/'C '/
      DATA TCBTBL(258)/29/,TCBTBL(259)/1/
C TABLE 6,2,TCBTBL,"SPAD1" 30 1
      DATA TCBTBL(260)/'S '/,TCBTBL(261)/'P '/,TCBTBL(262)/'A '/
      DATA TCBTBL(263)/'D '/,TCBTBL(264)/'1 '/,TCBTBL(265)/'  '/
      DATA TCBTBL(266)/30/,TCBTBL(267)/1/
C TABLE 6,2,TCBTBL,"SPAD2" 31 1
      DATA TCBTBL(268)/'S '/,TCBTBL(269)/'P '/,TCBTBL(270)/'A '/
      DATA TCBTBL(271)/'D '/,TCBTBL(272)/'2 '/,TCBTBL(273)/'  '/
      DATA TCBTBL(274)/31/,TCBTBL(275)/1/
C TABLE 6,2,TCBTBL,"SPAD3" 32 1
      DATA TCBTBL(276)/'S '/,TCBTBL(277)/'P '/,TCBTBL(278)/'A '/
      DATA TCBTBL(279)/'D '/,TCBTBL(280)/'3 '/,TCBTBL(281)/'  '/
      DATA TCBTBL(282)/32/,TCBTBL(283)/1/
C TABLE 6,2,TCBTBL,"SPAD4" 33 1
      DATA TCBTBL(284)/'S '/,TCBTBL(285)/'P '/,TCBTBL(286)/'A '/
      DATA TCBTBL(287)/'D '/,TCBTBL(288)/'4 '/,TCBTBL(289)/'  '/
      DATA TCBTBL(290)/33/,TCBTBL(291)/1/
C TABLE 6,2,TCBTBL,"SPAD5" 34 1
      DATA TCBTBL(292)/'S '/,TCBTBL(293)/'P '/,TCBTBL(294)/'A '/
      DATA TCBTBL(295)/'D '/,TCBTBL(296)/'5 '/,TCBTBL(297)/'  '/
      DATA TCBTBL(298)/34/,TCBTBL(299)/1/
C TABLE 6,2,TCBTBL,"SPAD6" 35 1
      DATA TCBTBL(300)/'S '/,TCBTBL(301)/'P '/,TCBTBL(302)/'A '/
      DATA TCBTBL(303)/'D '/,TCBTBL(304)/'6 '/,TCBTBL(305)/'  '/
      DATA TCBTBL(306)/35/,TCBTBL(307)/1/
C TABLE 6,2,TCBTBL,"SPAD7" 36 1
      DATA TCBTBL(308)/'S '/,TCBTBL(309)/'P '/,TCBTBL(310)/'A '/
      DATA TCBTBL(311)/'D '/,TCBTBL(312)/'7 '/,TCBTBL(313)/'  '/
      DATA TCBTBL(314)/36/,TCBTBL(315)/1/
C TABLE 6,2,TCBTBL,"STAT2" 37 1
      DATA TCBTBL(316)/'S '/,TCBTBL(317)/'T '/,TCBTBL(318)/'A '/
      DATA TCBTBL(319)/'T '/,TCBTBL(320)/'2 '/,TCBTBL(321)/'  '/
      DATA TCBTBL(322)/37/,TCBTBL(323)/1/
C TABLE 6,2,TCBTBL,"TMAREG" 38 1
      DATA TCBTBL(324)/'T '/,TCBTBL(325)/'M '/,TCBTBL(326)/'A '/
      DATA TCBTBL(327)/'R '/,TCBTBL(328)/'E '/,TCBTBL(329)/'G '/
      DATA TCBTBL(330)/38/,TCBTBL(331)/1/
C TABLE 6,2,TCBTBL,"TMREG" 39 3
      DATA TCBTBL(332)/'T '/,TCBTBL(333)/'M '/,TCBTBL(334)/'R '/
      DATA TCBTBL(335)/'E '/,TCBTBL(336)/'G '/,TCBTBL(337)/'  '/
      DATA TCBTBL(338)/39/,TCBTBL(339)/3/
C TABLE 6,2,TCBTBL,"FFT" 40 3
      DATA TCBTBL(340)/'F '/,TCBTBL(341)/'F '/,TCBTBL(342)/'T '/
      DATA TCBTBL(343)/'  '/,TCBTBL(344)/'  '/,TCBTBL(345)/'  '/
      DATA TCBTBL(346)/40/,TCBTBL(347)/3/
C TABLE 6,2,TCBTBL,"MAREG" 41 1
      DATA TCBTBL(348)/'M '/,TCBTBL(349)/'A '/,TCBTBL(350)/'R '/
      DATA TCBTBL(351)/'E '/,TCBTBL(352)/'G '/,TCBTBL(353)/'  '/
      DATA TCBTBL(354)/41/,TCBTBL(355)/1/
C TABLE 6,2,TCBTBL,"STAT3" 42 1
      DATA TCBTBL(356)/'S '/,TCBTBL(357)/'T '/,TCBTBL(358)/'A '/
      DATA TCBTBL(359)/'T '/,TCBTBL(360)/'3 '/,TCBTBL(361)/'  '/
      DATA TCBTBL(362)/42/,TCBTBL(363)/1/
C TABLE 6,2,TCBTBL,"SRS" 43 1
      DATA TCBTBL(364)/'S '/,TCBTBL(365)/'R '/,TCBTBL(366)/'S '/
      DATA TCBTBL(367)/'  '/,TCBTBL(368)/'  '/,TCBTBL(369)/'  '/
      DATA TCBTBL(370)/43/,TCBTBL(371)/1/
C TABLE 6,2,TCBTBL,"MINTCB" 58 1
      DATA TCBTBL(372)/'M '/,TCBTBL(373)/'I '/,TCBTBL(374)/'N '/
      DATA TCBTBL(375)/'T '/,TCBTBL(376)/'C '/,TCBTBL(377)/'B '/
      DATA TCBTBL(378)/58/,TCBTBL(379)/1/
C TABLE 6,2,TCBTBL,"SPAD8" 59 1
      DATA TCBTBL(380)/'S '/,TCBTBL(381)/'P '/,TCBTBL(382)/'A '/
      DATA TCBTBL(383)/'D '/,TCBTBL(384)/'8 '/,TCBTBL(385)/'  '/
      DATA TCBTBL(386)/59/,TCBTBL(387)/1/
C TABLE 6,2,TCBTBL,"DPYW" 67 3
      DATA TCBTBL(388)/'D '/,TCBTBL(389)/'P '/,TCBTBL(390)/'Y '/
      DATA TCBTBL(391)/'W '/,TCBTBL(392)/'  '/,TCBTBL(393)/'  '/
      DATA TCBTBL(394)/67/,TCBTBL(395)/3/
C TABLE 6,2,TCBTBL,"DPY0" 68 3
      DATA TCBTBL(396)/'D '/,TCBTBL(397)/'P '/,TCBTBL(398)/'Y '/
      DATA TCBTBL(399)/'0 '/,TCBTBL(400)/'  '/,TCBTBL(401)/'  '/
      DATA TCBTBL(402)/68/,TCBTBL(403)/3/
C TABLE 6,2,TCBTBL,"DPAD" 72 3
      DATA TCBTBL(404)/'D '/,TCBTBL(405)/'P '/,TCBTBL(406)/'A '/
      DATA TCBTBL(407)/'D '/,TCBTBL(408)/'  '/,TCBTBL(409)/'  '/
      DATA TCBTBL(410)/72/,TCBTBL(411)/3/
C TABLE 6,2,TCBTBL,"DPA" 128 1
      DATA TCBTBL(412)/'D '/,TCBTBL(413)/'P '/,TCBTBL(414)/'A '/
      DATA TCBTBL(415)/'  '/,TCBTBL(416)/'  '/,TCBTBL(417)/'  '/
      DATA TCBTBL(418)/128/,TCBTBL(419)/1/
C TABLE 6,2,TCBTBL,"FLADD" 129 3
      DATA TCBTBL(420)/'F '/,TCBTBL(421)/'L '/,TCBTBL(422)/'A '/
      DATA TCBTBL(423)/'D '/,TCBTBL(424)/'D '/,TCBTBL(425)/'  '/
      DATA TCBTBL(426)/129/,TCBTBL(427)/3/
C TABLE 6,2,TCBTBL,"FLMUL" 134 3
      DATA TCBTBL(428)/'F '/,TCBTBL(429)/'L '/,TCBTBL(430)/'M '/
      DATA TCBTBL(431)/'U '/,TCBTBL(432)/'L '/,TCBTBL(433)/'  '/
      DATA TCBTBL(434)/134/,TCBTBL(435)/3/
C TABLE 6,2,TCBTBL,"FLAGS" 140 3
      DATA TCBTBL(436)/'F '/,TCBTBL(437)/'L '/,TCBTBL(438)/'A '/
      DATA TCBTBL(439)/'G '/,TCBTBL(440)/'S '/,TCBTBL(441)/'  '/
      DATA TCBTBL(442)/140/,TCBTBL(443)/3/
C TABLE 6,2,TCBTBL,"MAXTCB" 143 1
      DATA TCBTBL(444)/'M '/,TCBTBL(445)/'A '/,TCBTBL(446)/'X '/
      DATA TCBTBL(447)/'T '/,TCBTBL(448)/'C '/,TCBTBL(449)/'B '/
      DATA TCBTBL(450)/143/,TCBTBL(451)/1/
      DATA TCBTBL(1)/56/
C                                                                       ENDPRE
C
      DATA TBLSIZ,ENAMNF/56,10/
C
C-------BRANCH ON VALUE PASSED IN CODE
C
        GO TO (1000,5000,3000,4000,6000),CODE
C
C-------ASK USER WHAT TCB LOCATION TO EXAMINE AND FIND OUT WHERE
C       IT STARTS IN MD.
C
1000    TCBOPN=0
        CALL GETSYM(BUFFER,TOKEN,LUN,IERR)
        IF (IERR.NE.0) RETURN
        IERR=ENAMNF
        I=SRCST(TCBTBL,1,-1,TOKEN,-1)
        IF (I.EQ.0) RETURN
        LOC=EXTVT(TCBTBL,I,1,LOC,1)
        LOC=IADD16(LOC,BASE)
1010    WIDTH=EXTVT(TCBTBL,I,2,WIDTH,1)
        TCBOPN=I
        GO TO 5000
C
C-------'+' EXAMINE NEXT LOCATION
C
C    LOCATE NEXT OPENABLE TCB ELEMENT.
3000    IF (TCBOPN.EQ.TBLSIZ) GO TO 3100
        K=EXTVT(TCBTBL,TCBOPN,1,K,1)
        DO 3010 I=TCBOPN,TBLSIZ
        J=EXTVT(TCBTBL,I,1,J,1)
        IF (J.NE.K) GO TO 3020
3010    CONTINUE
        GO TO 5000
C    SEE IF BY INCREMENTING LOCATION WE OPENED A NEW TCB ELEMENT.
3020    K=ISUB16(LOC,BASE)
        IF (K.EQ.J) GO TO 1010
        GO TO 5000
C    WE CAN'T GO BEYOND END OF TCB TABLE.
3100    LOC=ISUB16(LOC,1)
        GO TO 5000
C
C-------'-' EXAMINE PREVIOUS LOCATION
C
C    GET PREVIOUS OPENABLE TCB ELEMENT.
4000    IF (TCBOPN.LT.4) GO TO 4100
        K=EXTVT(TCBTBL,TCBOPN,1,K,1)
        I=TCBOPN
4010    I=I-1
        IF (I.EQ.1) GO TO 5000
        J=EXTVT(TCBTBL,I,1,J,1)
        IF (J.NE.K) GO TO 4020
        GO TO 4010
C    SEE IF WE DECREMENTED SO THAT A NEW TCB ELEMENT IS OPEN.
4020    J=ISUB16(LOC,BASE)
        IF (K.GT.J) GO TO 1010
        GO TO 5000
C    WE CAN'T GO BEYOND BEGINNING OF TCB TABLE.
4100    LOC=IADD16(LOC,1)
        GO TO 5000
C
C-------EXAMINE DESIRED TCB ENTRY.
C
C    IF IT IS THE BASE ADDRESS OF THE TCB TRAP IT.
5000    IF (TCBOPN.EQ.1) REG(3)=BASE
        IF (TCBOPN.NE.1) CALL APEXAM(REG,14,LOC)
        IF (WIDTH.EQ.1) REG(1)=REG(3)
C
C-------NOW DISPLAY THE RESULT
C
        TOKEN(1)=0
        I=APDOUT(REG,TCBOPN,LOC,WIDTH,TYPEL,RADIX,FP,FIE,OFFSET,
     1           TCBTBL,TCBTBL,LUN,TOKEN)
        IERR=0
        RETURN
C
C
C
C-------CHANGE THE VALUE OF A TCB ENTRY
C
C    IF NO TCB ELEMENT IS OPEN THEN RETURN
6000    IF (TCBOPN.EQ.0) RETURN
C    ACCEPT NEW VALUE FROM USER
        IERR=APDIN(REG,LOC,WIDTH,RADIX,FP,FIE,TCBTBL,LUN,BUFFER,TOKEN)
        IF (IERR.NE.0) RETURN
C    DEPOSIT NEW VALUE INTO TCB ENTRY, IF A CHANGE TO THE TCB
C    BASE ADDRESS IS DESIRED CHANGE PROGRAM VALUE
        IF (TCBOPN.NE.1) GO TO 6010
        BASE=REG(1)
        RETURN
6010    IF (WIDTH.EQ.3) GO TO 6020
        REG(3)=REG(1)
        REG(1)=0
6020    CALL APDEP(REG,14,LOC)
        IERR=0
        RETURN
        END
C+++    WRTST2
C****** WRTST2 = WRITE TO APSTAT2 = REL.  1.00 , 04/20/79 ******
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APDBUG WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:07:31
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE WRTST2(STAT2)
        INTEGER STAT2
C
C       EXAMINE THE APSTAT2 REGISTER ON THE AP AND INTERPRET BITS 3 THRU 5
C       INTO ENGLISH MESSAGES INDICATING THEIR SETTING.
C
C-------LOCAL DEFINITIONS
C
C    LOCAL VARIABLES
        INTEGER I,J,K,STR1(81)
C    FUNCTIONS USED
        INTEGER EXTSL,ILSH16,NEGCHK,WRTLIN
C
C-------MESSAGES
C
C                                                                       STARTPRE
      INTEGER MESSAG(102)
C LIST MESSAG "USER MODE"
      DATA MESSAG(3)/'U '/,MESSAG(4)/'S '/,MESSAG(5)/'E '/
      DATA MESSAG(6)/'R '/,MESSAG(7)/'  '/,MESSAG(8)/'M '/
      DATA MESSAG(9)/'O '/,MESSAG(10)/'D '/,MESSAG(11)/'E '/
      DATA MESSAG(2)/9/
C     "SUPERVISOR MODE"
      DATA MESSAG(13)/'S '/,MESSAG(14)/'U '/,MESSAG(15)/'P '/
      DATA MESSAG(16)/'E '/,MESSAG(17)/'R '/,MESSAG(18)/'V '/
      DATA MESSAG(19)/'I '/,MESSAG(20)/'S '/,MESSAG(21)/'O '/
      DATA MESSAG(22)/'R '/,MESSAG(23)/'  '/,MESSAG(24)/'M '/
      DATA MESSAG(25)/'O '/,MESSAG(26)/'D '/,MESSAG(27)/'E '/
      DATA MESSAG(12)/15/
C     "INHIBIT INTERRUPT"
      DATA MESSAG(29)/'I '/,MESSAG(30)/'N '/,MESSAG(31)/'H '/
      DATA MESSAG(32)/'I '/,MESSAG(33)/'B '/,MESSAG(34)/'I '/
      DATA MESSAG(35)/'T '/,MESSAG(36)/'  '/,MESSAG(37)/'I '/
      DATA MESSAG(38)/'N '/,MESSAG(39)/'T '/,MESSAG(40)/'E '/
      DATA MESSAG(41)/'R '/,MESSAG(42)/'R '/,MESSAG(43)/'U '/
      DATA MESSAG(44)/'P '/,MESSAG(45)/'T '/
      DATA MESSAG(28)/17/
C     "ENABLE INTERRUPT"
      DATA MESSAG(47)/'E '/,MESSAG(48)/'N '/,MESSAG(49)/'A '/
      DATA MESSAG(50)/'B '/,MESSAG(51)/'L '/,MESSAG(52)/'E '/
      DATA MESSAG(53)/'  '/,MESSAG(54)/'I '/,MESSAG(55)/'N '/
      DATA MESSAG(56)/'T '/,MESSAG(57)/'E '/,MESSAG(58)/'R '/
      DATA MESSAG(59)/'R '/,MESSAG(60)/'U '/,MESSAG(61)/'P '/
      DATA MESSAG(62)/'T '/
      DATA MESSAG(46)/16/
C     "USER MA REGISTER"
      DATA MESSAG(64)/'U '/,MESSAG(65)/'S '/,MESSAG(66)/'E '/
      DATA MESSAG(67)/'R '/,MESSAG(68)/'  '/,MESSAG(69)/'M '/
      DATA MESSAG(70)/'A '/,MESSAG(71)/'  '/,MESSAG(72)/'R '/
      DATA MESSAG(73)/'E '/,MESSAG(74)/'G '/,MESSAG(75)/'I '/
      DATA MESSAG(76)/'S '/,MESSAG(77)/'T '/,MESSAG(78)/'E '/
      DATA MESSAG(79)/'R '/
      DATA MESSAG(63)/16/
C     "SUPERVISOR MA REGISTER"
      DATA MESSAG(81)/'S '/,MESSAG(82)/'U '/,MESSAG(83)/'P '/
      DATA MESSAG(84)/'E '/,MESSAG(85)/'R '/,MESSAG(86)/'V '/
      DATA MESSAG(87)/'I '/,MESSAG(88)/'S '/,MESSAG(89)/'O '/
      DATA MESSAG(90)/'R '/,MESSAG(91)/'  '/,MESSAG(92)/'M '/
      DATA MESSAG(93)/'A '/,MESSAG(94)/'  '/,MESSAG(95)/'R '/
      DATA MESSAG(96)/'E '/,MESSAG(97)/'G '/,MESSAG(98)/'I '/
      DATA MESSAG(99)/'S '/,MESSAG(100)/'T '/,MESSAG(101)/'E '/
      DATA MESSAG(102)/'R '/
      DATA MESSAG(80)/22/,MESSAG(1)/6/
C                                                                       ENDPRE
C
C
C    EXAMINE BITS 3 THRU 5 AND INTERPRET USING MESSAGE LIST.
C
        I=ILSH16(STAT2,3)
        DO 10 J=1,3
        K=NEGCHK(I)+J+J-1
        K=EXTSL(MESSAG,K,STR1,80)
        CALL WRTLIN(STR1,-1,80)
        I=ILSH16(I,1)
10      CONTINUE
C
        RETURN
        END
C+++    DEPST2
C****** DEPST2 = DEPOSIT INTO APSTAT2 = REL.  1.00 , 04/20/79 ******
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APDBUG WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:09:33
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE DEPST2(MASK)
        INTEGER MASK
C
C       FIRST, SHIFT BITS 3-5 OF APSTAT2 INTO BITS 0-2 TO SAVE OLD
C       CONTENTS OF MODE, INTERRUPT, AND MA SETTING.  THEN TAKE
C       THE MASK AND PLACE IT INTO BITS 3-5.
C
C-------LOCAL DEFINITIONS
C
C    LOCAL VARIABLES
        INTEGER I,REG(4)
C    FUNCTIONS USED
        INTEGER IAND16,ILSH16,IOR16
C
C
C    READ APSTAT2 AND PUT INTO TEMP.
        CALL APEXAM(REG,38,255)
C    MASK OUT CURRENT STATE (BITS 3-5) AND PUT INTO PREVIOUS
C    STATE (BITS 0-2) OF MASK I.
C    MASK = MASK OR ((STAT2 AND 16000)*10)  (NUMBERS OCTAL)
        MASK=IOR16(MASK,ILSH16(IAND16(REG(1),7168),3))
C    ZERO OUT CURRENT & PREVIOUS STATE OF APSTAT2
C    STAT2=STAT2 AND 1777   (NUMBERS OCTAL)
        REG(1)=IAND16(REG(1),1023)
C    PLACE MASK BITS INTO STAT2.
C    STAT2=STAT2 OR MASK
        REG(1)=IOR16(REG(1),MASK)
C    DEPOSIT RESULT INTO REGISTER APSTAT2.
        CALL APDEP(REG,38,255)
C    RETURN TO CALLING ROUTINE
        RETURN
        END
