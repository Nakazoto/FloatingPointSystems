$LIB
"****** BABSRC = BASIC MATH LIBRARY (PART 2) /FAST/ = REL 3.3, AUG 80 *****
"
"====================  CONDITIONAL ASSEMBLY SWITCHES  ==================
"
"    XADC   DETERMINES WHETHER ASSEMBLY WILL INCLUDE BOTH ADC AND UDC
"              ENTRY POINTS, OR ONLY UDC ENTRY POINTS
"           XADC $EQU 1    ASSEMBLE BOTH ADC AND UDC ENTRY POINTS (DEFAULT)
"           XADC $EQU 0    ASSEMBLE ONLY UDC ENTRY POINTS
"
"           TO CHANGE FROM THE DEFAULT (ADC AND UDC) TO UDC ONLY ASSEMBLY,
"           GLOBALLY EDIT THIS FILE TO CHANGE ALL OCCURRENCES (1 PER
"           ROUTINE) OF
"               XADC $EQU 1      TO     XADC $EQU 0
"
"
"=====================================================================
"
"    ---HISTORY---
"REV 3.3 AND 2A.3:  AUG 80
"       1. FIXED A PERIODIC BUG, AND CASE OF N=1 IN VUP16.
"       2. RFFTSC AND CFFTSC MODIFIED TO HANDLE N=32768.
"       3. (REV 3.3 ONLY) CORRECTED THE ADC LINKAGE IN THE FOLLOWING ROUTINES:
"              VSMAFX
"              VFLT32
"              VFIX32
"              VUP16
"              VUPS16
"              VPK16
"              VUP8
"              VUPS8
"              VPK8
"              MVML4
"              VSUM
"              DAREAD
"              XDAREA
"              DAWRIT
"
"REV 3.2 AND 2A.2:  MAR 80
"       1. (REV 3.2 ONLY) THE STATEMENT   $RADIX 8   HAS BEEN ADDED TO ALL
"             ROUTINES SO THAT THEY WIILL ASSEMBLE PROPERLY EVEN IF FOR SOME
"             REASON THE ASSEMBLER DEFAULT RADIX HAS BEEN CHANGED TO 10 OR 16.
"       2. THE FUNCTIONALITY OF THE FOLLOWING ROUTINES IS CHANGED BACK
"          TO THAT WHICH EXISTED PRIOR TO LIBRARY RELEASES 3.1 (SEP 79)
"          OR 2.3 (MAY 79).  FOR THESE ROUTINES THE STATUS INFORMATION
"          (E.G. SCALING FACTOR, SINGULARITY CONDITION, ETC.) IS RETURNED
"          ONLY IN SP(15), AND NOT IN AN MD LOCATION.
"               VSCALE
"               VSCSCL
"               MATINV
"               SOLVEQ
"               DAREAD
"       3. THE FOLLOWING NEW ROUTINES ARE ADDED TO RETAIN THE FUNCTIONALITY
"          OF VERSIONS 3.1 (SEP 79), 2A.1 (SEP 79), AND 2.3 (MAY 79) OF THE
"          ROUTINES VSCALE, VSCSCL, MATINV, SOLVEQ, AND DAREAD, RESPECTIVELY.
"          IN THE NEW ROUTINES, THE STATUS INFORMATION IS RETURNED INTO MD
"          AS AN INTEGER IN LOW MANTISSA, AS WELL AS IN SP(15).
"               XVSCAL
"               XVSCSC
"               XMATIN
"               XSOLVE
"               XDAREA
"
"REV 3.1 AND 2A.1:  SEP 79
"       1. FIXES BUGS IN THE FOLLOWING ROUTINES:
"              VPK16
"              VUPS8
"              VFLT
"       2. CORRECTS ALL ROUTINES SO THAT THEY DO NOTHING IF ELEMENT COUNT
"          IS ZERO.
"       3. DELETES THE FOLLOWING ROUTINES:
"              RFFT2D   -- MOVED TO IMAGE PROCESSING LIBRARY
"              CFFT2D   -- MOVED TO IMAGE PROCESSING LIBRARY
"              WIENER   -- MOVED TO SIGNAL PROCESSING LIBRARY
"       4. CHANGES CALLING SEQUENCE FOR THE FOLLOWING ROUTINES TO ADD
"          PARAMETER WHICH SPECIFIES MD ADDRESS TO RETURN STATUS INFORMATION
"          WHICH IS ALSO RETURNED IN SP(15):
"              VSCALE
"              VSCSCL
"              SOLVEQ
"              MATINV
"              DAREAD
"       5. ADDS PARAMETER TO CONV FOR ADC ENTRY ONLY TO SPECIFY TRACE LENGTH.
"
"REV 2.3:  MAY 79
"       1.  THE FOLLOWING ROUTINES HAVE BEEN TAKEN OUT OF UTLSRC AND ADDED
"           TO THE END OF BABSRC:
"               SETC5
"               RDC5
"               DAREAD
"               DAWRIT
"               MDCOM
"       2.  THE FOLLOWING ROUTINES HAVE BEEN DELETED:
"               RFFT2D
"               CFFT2D
"       3.  BUGS HAVE BEEN FIXED IN THE FOLLOWING ROUTINES:
"               VPK16
"               VUPS8
"       4.  THE FOLLOWING ROUTINES HAVE BEEN MODIFIED SUCH THAT DATA STORED
"           IN SP(15) IS ALSO STORED IN MD:
"               VSCALE
"               VSCSCL
"               SOLVEQ
"               MATINV
"               DAREAD
"REV 3.0:  MAR 79
"       1. ADDS ENTRY POINTS FOR AP FORTRAN.
"       2. MINOR MODS TO THE FOLLOWING ROUTINES FOR APAL3 COMPATIBILITY:
"            CFFT
"            CFFTB
"      3. ADDS THE FOLLOWING ROUTINES (MOVED FROM UTLSRC)
"            SETC5
"            RDC5
"            DAREAD
"            DAWRIT
"            MDCOM
"REV 2.2:  SEP 78
"       1. SPLITS BASIC LIBRARY INTO 3 PARTS:
"               BAASRC --  COMPLEX VECTOR OPERATIONS
"                          BASIC VECTOR OPERATIONS
"                          VECTOR-TO-SCALAR OPERATIONS
"
"               BABSRC --  VECTOR COMPARISON OPERATIONS
"                          DATA FORMATING OPERATIONS
"                          MATRIX ROUTINES
"                          FFT ROUTINES
"                          AUXILIARY ROUTINES
"
"               UTLSRC --  APAL-CALLABLE UTILITY ROUTINES
"
"       2. ADDS THE FOLLOWING NEW ROUTINES:
"               LVGT   --  LOGICAL VECTOR GREATER THAN
"               LVGE   --  LOGICAL VECTOR GREATER OR EQUAL
"               LVEQ   --  LOGICAL VECTOR EQUAL
"               LVNE   --  LOGICAL VECTOR NOT EQUAL
"               LVNOT  --  LOGICAL VECTOR NOT
"               VLMERG --  VECTOR LOGICAL MERGE
"               VSMAFX --  VECTOR SCALAR MULTIPLY, ADD AND FIX
"               RFFT2D --  REAL 2D FFT
"               CFFT2D --  COMPLEX 2D FFT
"
"       3. INCLUDES FASTER VERSIONS OF THE FOLLOWING ROUTINES:
"               VFLT   --   0.5 US  VS  0.7 US
"
"       4. FIXES PROBLEMS WHEN EXECUTING WITH N>32767 IN THE
"          FOLLOWING ROUTINES:
"               VMAX
"               VMIN
"               VFIX
"               VFLT32
"               VUP16
"               VUPS16
"               SOLVEQ
"
"       5. FIXES BUGS IN THE FOLLOWING ROUTINES:
"               VUP8
"               VUPS8
"
"
"-----NOTE: FOR THE HISTORY OF REV 2.1 AND EARLIER REFER TO THE HISTORY
"           SECTION OF BAASRC.
"
"=====================================================================
"
"
"
"****** VMAX = VECTOR MAXIMUM /FAST/ = REL 3.1, SEP 79 *****
       $TITLE VMAX
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY VMAX, 7                          "USER-DIRECTED-CALL ENTRY
       $EXT SPUFLT
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE: 14 + SPUFLT (8) = 22 WORDS
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN     ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"THIS TAKES THE MAXIMUM OF EACH CORRESPONDING  PAIR OF ELEMENTS
"FROM TWO VECTORS (A AND B), AND OUTPUTS THE MAXIMUMS INTO
"VECTOR C.
"      C(M*K) = MAX(A(M*I), B(M*J))
       "FOR M = 0 TO N - 1
"LOOP CONTROL IS DONE IN THE FLOATING ADDER.  A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"S-PAD PARAMETERS:
        A $EQU 0                       "VECTOR A ORIGIN
       I $EQU 1                        "VECTOR A INCREMENT
       B $EQU 2                        "VECTOR B ORIGIN
       J $EQU 3                        "VECTOR B INCREMENT
       C $EQU 4                        "VECTOR C ORIGIN
       K $EQU 5                        "VECTOR C INCREMENT
       N $EQU 6                        "VECTOR LENGTH
       NM $EQU 17
"DATA-PAD PARAMETERS:
       NN $EQU 1                       "FLOATED VECTOR LENGTH
"SCRATCH:
"          S-PADS: 0,2,4,17
"              DPX:ALL.     DPY:  ALL. DPA IS ALTERED
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVMAX,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVMAX: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VMAX:  MOV N,NM                         "MOVE VECTOR LENGTH TO S-PAD(NM) AND
       JSR SPUFLT                        "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                   MOV A,A;SETMA       "FETCH A(0)
                   MOV B,B;SETMA       "FETCH B(0)
                   SUB K,C
                ADD I,A;SETMA;         "FETCH A(1)
                   DPX<MD              "SAVE A(0)
               ADD J,B;SETMA;          "FETCH B(1)
                   DPY<MD;             "SAVE B(0)
                   FSUB DPX,MD         "A(0) - B(0)
                   FSUBR TM,DPX(NN);   "DECREMENT COUNT BY 1
                   INCDPA
"
"
LOOP:  ADD I,A;SETMA;                  "1. FETCH A(M)
           DPX<MD;                     "SAVE A(M+1)
           FSUBR NC,NC                 "DECREMENT COUNTER (IT'S IN FA)
       ADD J,B;SETMA;                  "FETCH B(M)
           DPY<MD;                     "SAVE B(M+1)
           FSUB DPX,MD;                "A(M+1) - B(M+1)
               BFGT ITSA               "BRANCH IF A(M+2)>B(M+2)
"B.GE.A, SO STORE IT
ITSB:          FSUBR TM,FA;            "DECREMENT COUNTER FOR TESTING
               ADD K,C;SETMA;MI<DPY(-1); "C(M+3)<B(M+3)
                INCDPA;BFGT LOOP       "DO NEXT ONE
"
"DONE, RETURN
DONE:   RETURN                  "EXIT
"
"A.GT.B
ITSA:          FSUBR TM,FA;            "DECREMENT COUNTER FOR TESTING
               ADD K,C;SETMA;MI<DPX(-1); "C(M+3)<A(M+3)
               INCDPA; BFGT LOOP       "DO NEXT ONE
"
"DONE, RETURN
       RETURN
       $END
"****** VMIN = VECTOR MINIMUM /FAST/ = REL 3.1, SEP 79 *****
       $TITLE VMIN
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY VMIN, 7                          "USER-DIRECTED-CALL ENTRY
       $EXT SPUFLT
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE: 14 + SPUFLT (8) = 22 WORDS
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN     ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"THIS TAKES THE MINIMUM OF EACH CORRESPONDING  PAIR OF ELEMENTS
"FROM TWO VECTORS (A AND B), AND OUTPUTS THE MINIMUMS INTO
"VECTOR C.
"      C(M*K) = MIN(A(M*I), B(M*J))
       "FOR M = 0 TO N - 1
"LOOP CONTROL IS DONE IN THE FLOATING ADDER.  A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"S-PAD PARAMETERS:
        A $EQU 0                       "VECTOR A ORIGIN
       I $EQU 1                        "VECTOR A INCREMENT
       B $EQU 2                        "VECTOR B ORIGIN
       J $EQU 3                        "VECTOR B INCREMENT
       C $EQU 4                        "VECTOR C ORIGIN
       K $EQU 5                        "VECTOR C INCREMENT
       N $EQU 6                        "VECTOR LENGTH
       NM $EQU 17
"DATA-PAD PARAMETERS:
       NN $EQU 1                       "FLOATED VECTOR LENGTH
"SCRATCH:
"          S-PADS: 0,2,4,17
"              DPX:ALL.     DPY:  ALL. DPA IS ALTERED
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVMIN,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVMIN: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VMIN:  MOV N,NM                         "MOVE VECTOR LENGTH TO S-PAD(NM) AND
       JSR SPUFLT                        "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                   MOV A,A;SETMA       "FETCH A(0)
                   MOV B,B;SETMA       "FETCH B(0)
                   SUB K,C
                ADD I,A;SETMA;         "FETCH A(1)
                   DPX<MD              "SAVE A(0)
               ADD J,B;SETMA;          "FETCH B(1)
                   DPY<MD;             "SAVE B(0)
                   FSUBR DPX,MD        "B(0) - A(0)
                   FSUBR TM,DPX(NN);   "DECREMENT COUNT BY 1
                   INCDPA
"
"
LOOP:  ADD I,A;SETMA;                  "1. FETCH A(M)
           DPX<MD;                     "SAVE A(M+1)
           FSUBR NC,NC                 "DECREMENT COUNTER (IT'S IN FA)
       ADD J,B;SETMA;                  "FETCH B(M)
           DPY<MD;                     "SAVE B(M+1)
           FSUBR DPX,MD;               "B(M+1) - A(M+1)
               BFGT ITSA               "BRANCH IF A(M+2).LE.B(M+2)
"B.LT.A, SO STORE IT
ITSB:          FSUBR TM,FA;            "DECREMENT COUNTER FOR TESTING
               ADD K,C;SETMA;MI<DPY(-1); "C(M+3)=B(M+3)
                INCDPA;BFGT LOOP       "DO NEXT ONE
"
"DONE, RETURN
DONE:   RETURN                  "EXIT
"
"A.LT.B
ITSA:          FSUBR TM,FA;            "DECREMENT COUNTER FOR TESTING
               ADD K,C;SETMA;MI<DPX(-1); "C(M+3)=A(M+3)
               INCDPA; BFGT LOOP       "DO NEXT ONE
"
"DONE, RETURN
       RETURN
       $END
"****** LVGT = LOGICAL VECTOR GREATER THAN /FAST/ = REL 3.1, SEP 79 *****
"
"
        $TITLE LVGT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY LVGT,7                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"
"       THIS ALGORITHM DOES    C(mK) = 1.0  IF  A(mI)>B(mJ)
"                              C(mK) = 0.0  IF  A(mI)=<B(mJ)
"WHERE A, B, AND C ARE VECTORS WHOSE DIMENSION IS GIVEN BY N.
"       --------STATISTICS--------
"       LANGUAGE:   AP-120B ASSEMBLER
"       EQUIPMENT:  AP-120B WITH FAST MEMORY
"       SIZE:       15 + SPUFLT (8) = 23 WORDS
"       SPEED:      BEST     (2.50 + 0.50*N) USEC
"                   TYPICAL  (2.83 + 0.83*N) USEC
"                   WORST    (3.33 + 1.00*N) USEC
"
"    --- HISTORY ---
"ORIGINAL:  JUL 78  D. DAVIS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       --------SCRATCH--------
"       SP(0,2,4),  DPX(0),  DPY(0),  DPX(1)
"
"
        A $EQU 0
        I $EQU 1
        B $EQU 2
        J $EQU 3
        C $EQU 4
        K $EQU 5
        N $EQU 6
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FLGT,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FLGT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LVGT:   MOV N,17
        JSR SPUFLT                       "FLOAT COUNTER
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV A,A;SETMA                   "1. FETCH A(1)
        MOV B,B;SETMA                   "2. FETCH B(1)
        ADD I,A;SETMA                   "1. FETCH A(2)
        ADD J,B;SETMA;                  "2. FETCH B(2)
                DPX<MD                  "1. STORE A(1)
        ADD I,A;SETMA;                  "1. FETCH A(3)
                DPY<MD                  "2. STORE B(1)
        ADD J,B;SETMA;                  "2. FETCH B(3)
                DPX<MD;FSUB DPX,DPY     "1. STORE A(2),  A(1)-B(1)
        SUB K,C;
                DPY<MD;                 "2. STORE B(2)
                        FSUBR TM,DPX(1) "3. DECREMENT COUNTER
LOOP:   ADD I,A;SETMA;                  "1. FETCH A(M+3)
                DPX<MD;                 "STORE A(M+2)
                        FSUB DPX,DPY    "A(M+1)-B(M+1)
        ADD J,B;SETMA;                  "2. FETCH B(M+3)
                DPY<MD;                 "STORE B(M+3)
                                BFGT C1  "BRANCH TO C1 IF A(M)>B(M)
                        FSUBR TM,FA;    "3. DECREMENT COUNTER
                                ADD K,C;SETMA;MI<ZERO;BFGT LOOP
                                        "STORE 0.0 IN C(M), BRANCH TO LOOP
DONE:   RETURN                  "EXIT
C1:                     FSUBR TM,FA;    "3. DECREMENT COUNTER
                                ADD K,C;SETMA;MI<TM;BFGT LOOP
                                        "STORE 1.0 IN C(M), BRANCH TO LOOP
        RETURN
        $END
"****** LVGE = LOGICAL VECTOR GREATER OR EQUAL /FAST/ = REL 3.1, SEP 79 *****
"
"
        $TITLE LVGE
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY LVGE,7                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"
"       THIS ALGORITHM DOES    C(mK) = 1.0  IF  A(mI)=>B(mJ)
"                              C(mK) = 0.0  IF  A(mI)<B(mJ)
"WHERE A, B, AND C ARE VECTORS WHOSE DIMENSION IS GIVEN BY N.
"       --------STATISTICS--------
"       LANGUAGE:   AP-120B ASSEMBLER
"       EQUIPMENT:  AP-120B WITH FAST MEMORY
"       SIZE:       15 + SPUFLT (8) = 23 WORDS
"       SPEED:      BEST     (2.50 + 0.50*N) USEC
"                   TYPICAL  (2.83 + 0.83*N) USEC
"                   WORST    (3.33 + 1.00*N) USEC
"
"    --- HISTORY ---
"ORIGINAL:  JUL 78  D. DAVIS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       --------SCRATCH--------
"       SP(0,2,4),  DPX(0),  DPY(0),  DPX(1)
"
"
        A $EQU 0
        I $EQU 1
        B $EQU 2
        J $EQU 3
        C $EQU 4
        K $EQU 5
        N $EQU 6
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FLGE,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FLGE: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LVGE:   MOV N,17
        JSR SPUFLT                       "FLOAT COUNTER
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV A,A;SETMA                   "1. FETCH A(1)
        MOV B,B;SETMA                   "2. FETCH B(1)
        ADD I,A;SETMA                   "1. FETCH A(2)
        ADD J,B;SETMA;                  "2. FETCH B(2)
                DPX<MD                  "1. STORE A(1)
        ADD I,A;SETMA;                  "1. FETCH A(3)
                DPY<MD                  "2. STORE B(1)
        ADD J,B;SETMA;                  "2. FETCH B(3)
                DPX<MD;FSUB DPX,DPY     "1. STORE A(2),  A(1)-B(1)
        SUB K,C;
                DPY<MD;                 "2. STORE B(2)
                        FSUBR TM,DPX(1) "3. DECREMENT COUNTER
LOOP:   ADD I,A;SETMA;                  "1. FETCH A(M+3)
                DPX<MD;                 "STORE A(M+2)
                        FSUB DPX,DPY    "A(M+1)-B(M+1)
        ADD J,B;SETMA;                  "2. FETCH B(M+3)
                DPY<MD;                 "STORE B(M+3)
                                BFGE C1  "BRANCH TO C1 IF A(M)=>B(M)
                        FSUBR TM,FA;    "3. DECREMENT COUNTER
                                ADD K,C;SETMA;MI<ZERO;BFGT LOOP
                                        "STORE 0.0 IN C(M), BRANCH TO LOOP
DONE:   RETURN                  "EXIT
C1:                     FSUBR TM,FA;    "3. DECREMENT COUNTER
                                ADD K,C;SETMA;MI<TM;BFGT LOOP
                                        "STORE 1.0 IN C(M), BRANCH TO LOOP
        RETURN
        $END
"****** LVEQ = LOGICAL VECTOR EQUAL /FAST/ = REL 3.1, SEP 79 *****
"
"
        $TITLE LVEQ
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY LVEQ,7                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"
"       THIS ALGORITHM DOES    C(mK) = 1.0  IF  A(mI)=B(mJ)
"                              C(mK) = 0.0  IF  A(mI)not=B(mJ)
"WHERE A, B, AND C ARE VECTORS WHOSE DIMENSION IS GIVEN BY N.
"       --------STATISTICS--------
"       LANGUAGE:   AP-120B ASSEMBLER
"       EQUIPMENT:  AP-120B WITH FAST MEMORY
"       SIZE:       15 + SPUFLT (8) = 23 WORDS
"       SPEED:      BEST     (2.50 + 0.50*N) USEC
"                   TYPICAL  (2.83 + 0.83*N) USEC
"                   WORST    (3.33 + 1.00*N) USEC
"
"    --- HISTORY ---
"ORIGINAL:  JUL 78  D. DAVIS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       --------SCRATCH--------
"       SP(0,2,4),  DPX(0),  DPY(0),  DPX(1)
"
"
        A $EQU 0
        I $EQU 1
        B $EQU 2
        J $EQU 3
        C $EQU 4
        K $EQU 5
        N $EQU 6
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FLEQ,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FLEQ: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LVEQ:   MOV N,17
        JSR SPUFLT                       "FLOAT COUNTER
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV A,A;SETMA                   "1. FETCH A(1)
        MOV B,B;SETMA                   "2. FETCH B(1)
        ADD I,A;SETMA                   "1. FETCH A(2)
        ADD J,B;SETMA;                  "2. FETCH B(2)
                DPX<MD                  "1. STORE A(1)
        ADD I,A;SETMA;                  "1. FETCH A(3)
                DPY<MD                  "2. STORE B(1)
        ADD J,B;SETMA;                  "2. FETCH B(3)
                DPX<MD;FSUB DPX,DPY     "1. STORE A(2),  A(1)-B(1)
        SUB K,C;
                DPY<MD;                 "2. STORE B(2)
                        FSUBR TM,DPX(1) "3. DECREMENT COUNTER
LOOP:   ADD I,A;SETMA;                  "1. FETCH A(M+3)
                DPX<MD;                 "STORE A(M+2)
                        FSUB DPX,DPY    "A(M+1)-B(M+1)
        ADD J,B;SETMA;                  "2. FETCH B(M+3)
                DPY<MD;                 "STORE B(M+3)
                                BFEQ C1  "BRANCH TO C1 IF A(M)=B(M)
                        FSUBR TM,FA;    "3. DECREMENT COUNTER
                                ADD K,C;SETMA;MI<ZERO;BFGT LOOP
                                        "STORE 0.0 IN C(M), BRANCH TO LOOP
DONE:   RETURN                  "EXIT
C1:                     FSUBR TM,FA;    "3. DECREMENT COUNTER
                                ADD K,C;SETMA;MI<TM;BFGT LOOP
                                        "STORE 1.0 IN C(M), BRANCH TO LOOP
        RETURN
        $END
"****** LVNE = LOGICAL VECTOR NOT EQUAL /FAST/ = REL 3.1, SEP 79 *****
"
"
        $TITLE LVNE
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY LVNE,7                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"
"       THIS ALGORITHM DOES    C(mK) = 1.0  IF  A(mI)not=B(mJ)
"                              C(mK) = 0.0  IF  A(mI)=B(mJ)
"WHERE A, B, AND C ARE VECTORS WHOSE DIMENSION IS GIVEN BY N.
"       --------STATISTICS--------
"       LANGUAGE:   AP-120B ASSEMBLER
"       EQUIPMENT:  AP-120B WITH FAST MEMORY
"       SIZE:       15 + SPUFLT (8) = 23 WORDS
"       SPEED:      BEST     (2.50 + 0.50*N) USEC
"                   TYPICAL  (2.83 + 0.83*N) USEC
"                   WORST    (3.33 + 1.00*N) USEC
"
"    --- HISTORY ---
"ORIGINAL:  JUL 78  D. DAVIS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       --------SCRATCH--------
"       SP(0,2,4),  DPX(0),  DPY(0),  DPX(1)
"
"
        A $EQU 0
        I $EQU 1
        B $EQU 2
        J $EQU 3
        C $EQU 4
        K $EQU 5
        N $EQU 6
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FLNE,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FLNE: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LVNE:   MOV N,17
        JSR SPUFLT                       "FLOAT COUNTER
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV A,A;SETMA                   "1. FETCH A(1)
        MOV B,B;SETMA                   "2. FETCH B(1)
        ADD I,A;SETMA                   "1. FETCH A(2)
        ADD J,B;SETMA;                  "2. FETCH B(2)
                DPX<MD                  "1. STORE A(1)
        ADD I,A;SETMA;                  "1. FETCH A(3)
                DPY<MD                  "2. STORE B(1)
        ADD J,B;SETMA;                  "2. FETCH B(3)
                DPX<MD;FSUB DPX,DPY     "1. STORE A(2),  A(1)-B(1)
        SUB K,C;
                DPY<MD;                 "2. STORE B(2)
                        FSUBR TM,DPX(1) "3. DECREMENT COUNTER
LOOP:   ADD I,A;SETMA;                  "1. FETCH A(M+3)
                DPX<MD;                 "STORE A(M+2)
                        FSUB DPX,DPY    "A(M+1)-B(M+1)
        ADD J,B;SETMA;                  "2. FETCH B(M+3)
                DPY<MD;                 "STORE B(M+3)
                                BFNE C1  "BRANCH TO C1 IF A(M)not=B(M)
                        FSUBR TM,FA;    "3. DECREMENT COUNTER
                                ADD K,C;SETMA;MI<ZERO;BFGT LOOP
                                        "STORE 0.0 IN C(M), BRANCH TO LOOP
DONE:   RETURN                  "EXIT
C1:                     FSUBR TM,FA;    "3. DECREMENT COUNTER
                                ADD K,C;SETMA;MI<TM;BFGT LOOP
                                        "STORE 1.0 IN C(M), BRANCH TO LOOP
        RETURN
        $END
"****** LVNOT = LOGICAL VECTOR NOT  /FAST/ = REL 3.1, SEP 79 *****
"
"
        $TITLE LVNOT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY LVNOT,5                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"
"       THIS ALGORITHM DOES    C(mK) = 1.0  IF  A(mI)=0.0
"                              C(mK) = 0.0  IF  A(mI)not=0.0
"WHERE A  AND C ARE VECTORS WHOSE DIMENSION IS GIVEN BY N.
"       --------STATISTICS--------
"       LANGUAGE:   AP-120B ASSEMBLER
"       EQUIPMENT:  AP-120B WITH FAST MEMORY
"       SIZE:       13 + SPUFLT (8) = 21 WORDS
"       SPEED:      BEST     (2.33 + 0.33*N) USEC
"                   TYPICAL  (2.33 + 0.50*N) USEC
"                   WORST    (2.83 + 0.66*N) USEC
"
"    --- HISTORY ---
"ORIGINAL:  JUL 78  D. DAVIS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       --------SCRATCH--------
"       SP(0,2),  DPX(1)
"
"
        A $EQU 0
        I $EQU 1
        C $EQU 2
        K $EQU 3
        N $EQU 4
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FLNO,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FLNO: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LVNOT:  MOV N,17
        JSR SPUFLT
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV A,A;SETMA
        SUB K,C
        ADD I,A;SETMA
                FADD ZERO,MD
        ADD I,A;SETMA;
                        FSUBR TM,DPX(1)
                FADD ZERO,MD
LOOP:   ADD I,A;SETMA;
                        FSUBR TM,FA;
                                BFEQ C1
                FADD ZERO,MD;
                                ADD K,C;SETMA;MI<ZERO;BFGT LOOP
DONE:   RETURN                  "EXIT
C1:             FADD ZERO,MD;
                                ADD K,C;SETMA;MI<TM;BFGT LOOP
        RETURN
        $END
"****** VLMERG = VECTOR LOGICAL MERGE /FAST/ = REL 3.1, SEP 79 *****
"
"
        $TITLE VLMERG
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VLMERG,9.                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"
"       THIS ALGORITHM DOES    D(mL) = A(mI)  IF  C(mK)not=0.0
"                              D(mL) = B(mJ)  IF  C(mK)=0.0
"WHERE A, B, C, AND D ARE VECTORS WHOSE DIMENSION IS GIVEN BY N.
"       --------STATISTICS--------
"       LANGUAGE:   AP-120B ASSEMBLER
"       EQUIPMENT:  AP-120B WITH FAST MEMORY
"       SIZE:       15 + SPUFLT (8) = 23 WORDS
"       SPEED:      BEST     (2.33 + 0.66*N) USEC
"                   TYPICAL  (2.33 + 0.83*N) USEC
"                   WORST    (2.33 + 1.33*N) USEC
"
"    --- HISTORY ---
"ORIGINAL:  JUL 78  D. DAVIS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       --------SCRATCH--------
"       SP(0,2,4,6),  DPX(0),  DPY(0),  DPX(1)
"
"
        A $EQU 0
        I $EQU 1
        B $EQU 2
        J $EQU 3
        C $EQU 4
        K $EQU 5
        D $EQU 6
        L $EQU 7
        N $EQU 10
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FLMG,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  652
        $PARAM  9., P1(#2,#11)/R/IP, P2/I/IP,
                    P3(#4,#11)/R/IP, P4/I/IP,
                    P5(#6,#11)/R/IP, P6/I/IP,
                    P7(#10,#11)/R/OP, P8/I/IP,
                    P9/I/IP
FLMG: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VLMERG: MOV N,17
        JSR SPUFLT
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV C,C;SETMA                           "3. FETCH C(1)
        FADD ZERO,DPX(1)                        "PREPARE COUNTER
                SUB I,A
                MOV B,B;SETMA;FADD ZERO,MD      "2. FETCH B(1)
                                                "PREPARE C(1) FOR BRANCH
        ADD K,C;SETMA                           "3. FETCH C(2)
                SUB L,D
LOOP:           ADD I,A;SETMA;                  "1. FETCH A(M)
                        FSUBR TM,FA;DPY<MD      "DEC COUNT, STORE B(M+1) TEMP.
                ADD J,B;SETMA;FADD ZERO,MD      "2. FETCH B(M+1),
                                                "PREPARE C(M+2) FOR BRANCH
        ADD K,C;SETMA;                          "3. FETCH C(M+2)
                        BFEQ C1                 "BRANCH TO C1 IF C(M)=0.0
                        ADD L,D;SETMA;MI<DB;DB=MD;BFGT LOOP
                                                "4. STORE A(M) IN D(M)
DONE:   RETURN                  "EXIT
C1:                     ADD L,D;SETMA;MI<DPY;BFGT LOOP
                                                "4. STORE B(M) IN D(M)
        RETURN
        $END
"
"****** VMAXMG = VECTOR MAX MAGNITUDE OF TWO VECTORS /COMMON/= REL 3.1, SEP 79 *
"       FOR EITHER MEMORY
        $TITLE VMAXMG
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VMAXMG,7                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"FORMS VECTOR C AS THE MAXIMUM MAGNITUDE OF EACH PAIR OF ELEMENTS
"OF TWO VECTORS A AND B.
"
"FORMULA:  C(MK) = MAX ( ABS(A(MI)), ABS(B(MJ)) ) FOR M=0 TO N-1
"
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 14 LOCATIONS
"EXECUTION     BEST      TYPICAL     WORST           SETUP(US)
"TIME/LOOP:    0.67 (B)    0.83       1.00             1.83       167 NS MEMORY
" (US)         1.00 (B)    1.33       1.50             2.17       333 NS MEMORY
"       COLUMNS/LOOP: 3
"SUBROUTINES USED: NONE
"
"     ---HISTORY---
"ORIGINAL: DEC 75, S. CAMLEY
"REV 2.1:  JUL 77, R.S. NORIN ---- CHANGED BASIC DEFINITION FROM
"                          C(MK) = A(MI)     IF ABS(A(MI))>= B(MJ)
"                                = (SIGN OF A(MI))*B(MJ) IF ABS(A(MI))<B(MJ)
"                  TO
"                          C(MK) = MAX( ABS(A(MI)), ABS(B(MJ)) )
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN: CALL VMAXMG(A,I,B,J,C,K,N)
"APAL:    JSR VMAXMG
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "BASE ADDRESS OF SOURCE VECTOR
     J  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF B
     C  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR
     K  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  6                 "NUMBER OF ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4,6),DPX(0,1),DPY(0,1),FA,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVMGAX,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVMGAX: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VMAXMG: MOV A,A; SETMA          "GET A(0)
        MOV B,B; SETMA          "GET B(0)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        SUB K,C;                "BACK UP THE OUTPUT POINTER
          FABS MD;              "ABS(A(0))
          BEQ DONE              "EXIT IF COUNT = 0
S2:     ADD I,A; SETMA;         "1. GET A(1)
            FABS MD             "   ABS(B(0))
        ADD J,B; SETMA;         "2. GET B(1)
            FADD;
            DPX<FA              "   SAVE ABS(A(0))
            FSUB DPX,FA;        "3. TEST ABS(A(0)) - ABS(B(0))
            DPX(1)<FA           "   SAVE ABS(B(0))
        FABS MD                 "4. ABS(A(1))
"HERE START FULL LOOP
LOOP:   ADD I,A; SETMA;         "1. GET A(M+2)
            FABS MD;            "   ABS(B(M+1))
                DPY<DPX         "SAVE ABS(A(M))
        ADD J,B; SETMA;         "2. GET B(M)
            FADD;
            DPX<FA;             "   SAVE ABS(A(M+1))
                DPY(1)<DPX(1);  "   SAVE ABS(B(M))
                BFGE AGTB       "   BRANCH IF ABS(A(M))>ABS(B(M))
"HERE IF ABS(A)<ABS(B)
            FSUB DPX,FA;        "3. TEST ABS(A(M+1)) - ABS(B(M+1))
            DPX(1)<FA;          "   SAVE ABS(B(M+1))
                DPY<DPY(1);     "   GET ABS(B(M)) FOR ANSWER
                DEC N;          "   DECREMENT COUNT
                BR COMM         "   PROCEED TO REST OF LOOP
"HERE IF ABS(A)>ABS(B)
AGTB:     FSUB DPX,FA;          "3. TEST ABS(A(M+1)) - ABS(B(M+1))
            DPX(1)<FA;          "   SAVE ABS(B(M+1))
                DEC N           "   DECREMENT COUNT
"COMMON CYCLE
COMM:   FABS MD;                 "4. ABS(A(M+2))
                ADD K,C; SETMA;MI<DPY; "   STORE RESULT
                BNE LOOP        "   CONTINUE UNTIL
DONE:   RETURN                  "DONE
        $END
"****** VMINMG = VECTOR MIN MAGNITUDE OF TWO VECTORS /COMMON/= REL 3.1, SEP 79
"       FOR EITHER MEMORY
        $TITLE VMINMG
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VMINMG,7                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"FORMS VECTOR C AS THE MINIMUM MAGNITUDE OF EACH PAIR OF ELEMENTS
"OF TWO VECTORS A AND B.
"
"FORMULA:  C(MK) = MIN ( ABS(A(MI)), ABS(B(MJ)) ) FOR M=0 TO N-1
"
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 14 LOCATIONS
"EXECUTION     BEST      TYPICAL     WORST           SETUP(US)
"TIME/LOOP:    0.67 (B)    0.83       1.00             1.83       167 NS MEMORY
" (US)         1.00 (B)    1.33       1.50             2.17       333 NS MEMORY
"       COLUMNS/LOOP: 3
"SUBROUTINES USED: NONE
"
"     ---HISTORY---
"ORIGINAL: DEC 75, S. CAMLEY
"REV 2.1:  JUL 77, R.S. NORIN ---- CHANGED BASIC DEFINITION FROM
"                          C(MK) = A(MI)     IF ABS(A(MI))<= B(MJ)
"                                = (SIGN OF A(MI))*B(MJ) IF ABS(A(MI))>B(MJ)
"                  TO
"                          C(MK) = MIN( ABS(A(MI)), ABS(B(MJ)) )
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN: CALL VMINMG(A,I,B,J,C,K,N)
"APAL:    JSR VMINMG
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "BASE ADDRESS OF SOURCE VECTOR
     J  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF B
     C  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR
     K  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  6                 "NUMBER OF ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4,6),DPX(0,1),DPY(0,1),FA,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVMGIN,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVMGIN: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VMINMG: MOV A,A; SETMA          "GET A(0)
        MOV B,B; SETMA          "GET B(0)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        SUB K,C;                "BACK UP THE OUTPUT POINTER
          FABS MD;              "ABS(A(0))
          BEQ DONE              "EXIT IF COUNT = 0
S2:     ADD I,A; SETMA;         "1. GET A(1)
            FABS MD             "   ABS(B(0))
        ADD J,B; SETMA;         "2. GET B(1)
            FADD;
            DPX<FA              "   SAVE ABS(A(0))
            FSUB DPX,FA;        "3. TEST ABS(A(0)) - ABS(B(0))
            DPX(1)<FA           "   SAVE ABS(B(0))
        FABS MD                 "4. ABS(A(1))
"HERE START FULL LOOP
LOOP:   ADD I,A; SETMA;         "1. GET A(M+2)
            FABS MD;            "   ABS(B(M+1))
                DPY<DPX         "SAVE ABS(A(M))
        ADD J,B; SETMA;         "2. GET B(M)
            FADD;
            DPX<FA;             "   SAVE ABS(A(M+1))
                DPY(1)<DPX(1);  "   SAVE ABS(B(M))
                BFGE AGTB       "   BRANCH IF ABS(A(M))>ABS(B(M))
"HERE IF ABS(A)<ABS(B)
            FSUB DPX,FA;        "3. TEST ABS(A(M+1)) - ABS(B(M+1))
            DPX(1)<FA;          "   SAVE ABS(B(M+1))
                DEC N;          "   DECREMENT COUNT
                BR COMM         "   PROCEED TO REST OF LOOP
"HERE IF ABS(A)>ABS(B)
AGTB:     FSUB DPX,FA;          "3. TEST ABS(A(M+1)) - ABS(B(M+1))
            DPX(1)<FA;          "   SAVE ABS(B(M+1))
                DPY<DPY(1);     "   GET ABS(B(M)) FOR ANSWER
                DEC N           "   DECREMENT COUNT
"COMMON CYCLE
COMM:   FABS MD;                 "4. ABS(A(M+2))
                ADD K,C; SETMA;MI<DPY; "   STORE RESULT
                BNE LOOP        "   CONTINUE UNTIL
DONE:   RETURN                  "DONE
        $END
"****** VCLIP = VECTOR CLIP /COMMON/ = REL 3.1, SEP 79 *****
"       FOR EITHER MEMORY
        $TITLE VCLIP
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VCLIP,7                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"PERFORMS A DOUBLE CLIP OF A VECTOR, RESTRICTING IT
"BETWEEN A RANGE OF VALUES B AND C.
"
"FORMULA:  D(ML) = B      IF A(MI)<B
"                = A(MI)  IF B<=A(MI)<=C
"                = C      IF A(MI)>C
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 16 LOCATIONS
"SPEED: BEST (FAST): 3N  (A,D SAME; I,L EVEN)
"          (STANDARD): 5N
"     TYPICAL (FAST): 3N
"         (STANDARD): 5N
"      WORST  (FAST): 4N
"         (STANDARD): 6N
"       COLUMNS/LOOP: 3
"SUBROUTINES USED: NONE
"
"    --- HISTORY ---
"ORIGINAL:  APR 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN: CALL VCLIP(A,I,B,C,D,L,N)
"APAL:    JSR VCLIP
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "ADDRESS OF SMALLER SCALAR
     C  $EQU  3                 "ADDRESS OF LARGER SCALAR
     D  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR
     L  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF D
     N  $EQU  6                 "NUMBER OF ELEMENTS IN D
"
"SCRATCH:  SP(0,4,6),DPX(0,1),DPY(0),FA,FM,MD,TM
"TABLE MEMORY ADDRESS:
   ONE $EQU !ONE                 "1.0
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVCLIP,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  142
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3/R/IP, P4/R/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVCLIP: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VCLIP: MOV B,B;SETMA           "GET SMALLER SCALAR
        MOV C,C; SETMA          "GET LARGER SCALAR
        LDTMA; DB=ONE           "GET 1.0 FROM TM
        MOV A,A; SETMA;         "GET A(0)
            DPX<MD              "SAVE B
        DPY<MD;                 "SAVE C
          MOV N,N               "IS ELEMENT COUNT = 0?
        SUB L,D;                "BACK UP POINTER
          BEQ DONE              "EXIT IF COUNT = 0
S2:     ADD I,A;SETMA;          "1. GET A(1)
            FSUBR DPX,MD;       "   TEST A(0)-B
            FMUL TM,MD          "   SAVE A(0) IN FM
            FSUB DPY,MD;        "2. TEST C-A(0)
            FMUL                "   PUSH
            FADD; FMUL          "3. PUSH
LOOP:   ADD I,A;SETMA;          "1. GET A(M+2)
            FSUBR DPX,MD;       "   A(M+1)-B
            FMUL TM,MD;         "   SAVE A(M+1) IN FM
                DPX(1)<FM;      "   SAVE A(M)
                BFGE AGTB       "   BRANCH IF A(MI)>=B
"HERE IF A(MI)<B
            FSUB DPY,MD;        "2. C-A(M+1)
            FMUL;               "   PUSH
                DPX(1)<DPX;     "   SAVE B
                DEC N           "   DECREMENT COUNTER
COMM:       FADD; FMUL;         "3. PUSHERS
                ADD L,D; SETMA; MI<DPX(1); "STORE D(L)
                BNE LOOP        "   CONTINUE THE LOOP
        BR DONE                 "EXIT IF DONE
"HERE IF A(MI)>B
AGTB:       FSUB DPY,MD;        "2. C-A(M+1)
            FMUL;               "   PUSH
                DEC N;          "   DECREMENT COUNTER
                BFGE COMM       "   BRANCH IF B<=A(MI)<=C
"HERE IF A(MI)>C
            FADD; FMUL;         "3. PUSHERS
                ADD L,D; SETMA; MI<DPY; "STORE D(L)=C
                BNE LOOP        "   CONTINUE THE LOOP
DONE:   RETURN  "EXIT
        $END
"****** VICLIP = VECTOR INVERTED CLIP /COMMON/ = REL 3.1, SEP 79 *****
"       FOR EITHER MEMORY
        $TITLE VICLIP
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VICLIP,7                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"PERFORMS AN INVERTED DOUBLE CLIP OF A VECTOR, RESTRICTING IT
"TO VALUES OUTSIDE THE RANGE OF VALUES B AND C.
"
"FORMULA:  D(ML) = A(MI)  IF A(MI)<B
"                = B      IF B<=A(MI)<0
"                = C      IF 0<=A(MI)<C
"                = A(MI)  IF A(MI)>C  FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 19 LOCATIONS
"EXECUTION     BEST      TYPICAL     WORST           SETUP(US)
"TIME/LOOP:    0.67        0.67       0.67             2.0        167 NS MEMORY
" (US)         0.83        0.83       1.00             2.0        333 NS MEMORY
"       COLUMNS/LOOP: 3
"SUBROUTINES USED: NONE
"
"    --- HISTORY ---
"ORIGINAL:  JUL 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN: CALL VICLIP(A,I,B,C,D,L,N)
"APAL:    JSR VICLIP
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "ADDRESS OF SMALLER SCALAR
     C  $EQU  3                 "ADDRESS OF LARGER SCALAR
     D  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR
     L  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF D
     N  $EQU  6                 "NUMBER OF ELEMENTS IN D
"
"SCRATCH:  SP(0,4,6),DPX(0,1),DPY(0),FA,FM,MD,TM
"TABLE MEMORY ADDRESS:
   ONE $EQU !ONE                 "1.0
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVICLP,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  142
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3/R/IP, P4/R/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVICLP: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VICLIP: MOV B,B;SETMA           "GET SMALLER SCALAR
        MOV C,C; SETMA          "GET LARGER SCALAR
        LDTMA; DB=ONE           "GET 1.0 FROM TM
        MOV A,A; SETMA;         "GET A(0)
            DPX<MD              "SAVE B
        DPY<MD;                 "SAVE C
          MOV N,N               "IS ELEMENT COUNT = 0?
        SUB L,D;                "BACK UP POINTER
          BEQ DONE              "EXIT IF COUNT = 0
S2:     ADD I,A;SETMA;          "1. GET A(1)
            FADD ZERO,MD        "TEST SIGN OF A(0)
            FSUB DPX,MD         "TEST B-A(0)
            FSUB DPY,FA;        "TEST C-A(0)
            FMUL TM,FA          "SAVE A(0) IN FM
"BEGIN THE REAL 4 CYCLE LOOP
LOOP:           FMUL; FADD;     "1. PUSH
                BFGE APOS       "   BRANCH IF A(M)>=0
"HERE IF A<0
        ADD I,A; SETMA;         "2. GET A(M+2)
            FADD ZERO,MD;       "   TEST A(M+1)
                FMUL;           "   PUSH
                BFGE ALTB       "BRANCH IF A<=B
"HERE IF B<A<0
            FSUB DPX,MD;        "3. TEST B-A(MI)
                DPX(1)<DPX;     "   SAVE B FOR ANSWER
                DEC N;          "   DECREMENT COUNT
                BR COMM4        "PROCEED
"HERE IF A<B
ALTB:       FSUB DPX,MD;        "3. TEST B-A(MI)
                DPX(1)<FM;      "   SAVE A FOR ANSWER
                DEC N;          "   DECREMENT COUNT
                BR COMM4        "PROCEED
"HERE IF A>0
APOS:   ADD I,A; SETMA;         "2. GET A(M+2)
            FADD ZERO,MD;       "   TEST A(M+1)
                FMUL            "   PUSH
            FSUB DPX,MD;        "3. TEST B-A(M+1)
                DPX(1)<FM;      "   SAVE A FOR ANSWER
                DEC N;          "   DECREMENT COUNTER
                BFGE ALTC       "   BRANCH IF 0<=A<C
"HERE EXCEPT IF 0<=A<C
COMM4:      FSUB DPY,FA;        "4. TEST C-A(MI)
            FMUL TM,FA;         "   SAVE A(M+1) IN FM
                ADD L,D;SETMA;MI<DPX(1); "   STORE D(M)
                BNE LOOP        "   CONTINUE LOOPING UNTIL
DONE:   RETURN  "DONE. THEN EXIT
"HERE IF O<=A<C
ALTC:       FSUB DPY,FA;        "4. TEST C-A(M+1)
            FMUL TM,FA;         "   SAVE A(M+1) IN FM
                ADD L,D; SETMA;MI<DPY; "   STORE D(M)=C
                BNE LOOP        "   CONTINUE LOOPING UNTIL
"EXIT
        BR DONE                 "DONE.
        $END
"****** VLIM = VECTOR LIMIT /COMMON/ = REL 3.1, SEP 79 *****
"       FOR EITHER MEMORY
        $TITLE VLIM
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VLIM,7                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"PERFORMS A LIMIT REPLACEMENT WHERE THE DESTINATION IS SET TO
"A C IF THE SOURCE VECTOR IS GREATER THAN A SECOND SCALAR B,
"AND -C IF THE SOURCE IS LESS THAN B.
"
"FORMULA:  D(ML) = -C      IF A(MI)<B
"                = C      IF A(MI)>=B
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 14 LOCATIONS
"SPEED: BEST (FAST): 3N  (A,D SAME; I,L EVEN)
"          (STANDARD): 5N
"     TYPICAL (FAST): 3N
"         (STANDARD): 5N
"      WORST  (FAST): 4N
"         (STANDARD): 6N
"       COLUMNS/LOOP: 3
"SUBROUTINES USED: NONE
"
"    --- HISTORY ---
"ORIGINAL:  APR 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN: CALL VLIM(A,I,B,C,D,L,N)
"APAL:    JSR VLIM
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "ADDRESS OF SCALAR TO COMPARE WITH SOURCE
     C  $EQU  3                 "ADDRESS OF SCALAR TO SET INTO DESTINATION
     D  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR
     L  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF D
     N  $EQU  6                 "NUMBER OF ELEMENTS IN D
"
"SCRATCH:  SP(0,4,6),DPX(0,1),DPY(0),FA,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVLIM,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  142
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3/R/IP, P4/R/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVLIM: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VLIM:   MOV C,C; SETMA          "GET SCALAR FOR DESTINATION
        MOV B,B; SETMA          "GET SCALAR FOR SOURCE
        SUB L,D                 "BACK UP POINTER
S1:     MOV A,A; SETMA;         "GET A(0)
            DPX<MD;             "SAVE C
            FSUB ZERO,MD        "FORM -C
        DPY<MD;                 "SAVE B
          MOV N,N;              "IS ELEMENT COUNT = 0?
            FADD                "PUSH
S2:     ADD I,A; SETMA;         "GET A(1)
        BEQ DONE;               "EXIT IF COUNT = 0
            DPX(1)<FA           "SAVE -C
            FSUBR DPY,MD        "A(0)-B
            FADD                "PUSH
LOOP:   ADD I,A; SETMA;         "1. GET A(M+2)
            FSUBR DPY,MD        "   A(M+1)-B
                DEC N;          "2. DECREMENT COUNT
                BFGE AGTB       "   BRANCH IF A>=B
"HERE IF A(MI)<B
            FADD;               "3. PUSH
                ADD L,D;SETMA;MI<DPX(1); "   STORE D(M)=-C
                BNE LOOP        "   CONTINUE THE LOOP
        BR DONE                "EXIT IF DONE
"HERE IF A(MI)>=B
AGTB:       FADD;               "3. PUSH
                ADD L,D;SETMA;MI<DPX; "   STORE D(M)=C
                BNE LOOP        "   CONTINUE THE LOOP
DONE:   RETURN                 "EXIT
        $END
"***** VFIX = VECTOR FIX  /FAST/ = REL 3.1, SEP 79 *****
       $TITLE VFIX
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY VFIX,5                          "USER-DIRECTED-CALL ENTRY
       $EXT SPUFLT
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE:  10  + SPUFLT (8) = 18 WORDS
"
"       ---HISTORY---
"ORIGINAL:  SEP 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN      ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN      HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"VECTOR FIX
"CONVERTS THE FLOATING POINT ELEMENTS OF VECTOR A TO INTEGERS
"IN VECTOR C.
"LOOP CONTROL IS DONE IN THE FLOATING ADDER.  A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT ONE IS CALLED FROM TABLE MEMORY
"AND IS THE DECREMENT FOR LOOP CONTROL.
"S-PAD NAMES:
"        NAME          REGISTER             PURPOSE
"
       A $EQU 0                        "BASE ADDRESS OF VECTOR A
       I $EQU 1                        "INCREMENT OF VECTOR A
       C $EQU 2                        "BASE ADDRESS FOR VECTOR C
       K $EQU 3                        "INCREMENT FOR VECTOR C
       N $EQU 4                        "ELEMENT COUNT
       NM $EQU 17
"DATA PAD PARAMETERS:
       NN $EQU 1                       "FLOATED VECTOR LENGTH
"SCRTCH      S-PADS:  0,2,4,17.    DPX: 1.
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVFIX,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/I/OP, P4/I/IP,
                    P5/I/IP
FVFIX: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VFIX:  MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
               MOV A,A;SETMA           "FETCH A(0)
               FSUBR TM,DPX(NN)        "INITIALIZE COUNTER
               SUB K,C                 "BACK UP C POINTER
           ADD I,A;SETMA;              "FETCH A(1)
               FSUBR TM,FA             "DECREMENT COUNTER
               FIX MD                  "FIX A(0)
LOOP:  ADD I,A;SETMA;                  "FETCH A(M)
           FSUBR TM,FA                 "DECREMENT COUNTER
           FIX MD;                     "FIX A(M+1)
               ADD K,C;SETMA;MI<FA;    "C(M+2) < FIXED A(M+2)
               BFGT LOOP
DONE:   RETURN                  "EXIT
       $END
"
"****** VFLT = VECTOR FLOAT /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VFLT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VFLT, 5                          "USER-DIRECTED-CALL ENTRY
"VECTOR FLOAT
"
"               --- ABSTRACT ---
"FLOATS A VECTOR OF INTEGERS (28-BITS WIDTH MAX)
"
"               --- STATISTICS ---
"LANGUAGE:      AP-120B ASSEMBLER (APAL)
"EQUIPMENT:     AP-120B, 1 CYCLE MD
"STORAGE:       PS - 15.
"               MD - FOR VECTORS
"               TM - !ONE
"               DPX (0,1) (SCRATCH)
"               DPY (0)
"               SP(0,2,4,15) (SCRATCH)
"SPEED:  BEST & TYPICAL (1.67 + 0.5(N) )USEC
"        WORST (1.67 + 0.67(N) )USEC
"                   ---HISTORY---
"ORIGINAL:      A.E. CHARLESWORTH   OCT.75
"                CHANGED $ENTRY   FEB.76
"REVISION:      D. DAVIS      REVISED FOR FAST MEMORY  JUL.78
"REVISED:       R.S. NORIN  JUL 79    CORRECTED FOR CASE WHERE I NOT EQUAL K
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"               --- USEAGE ---
"SAMPLE CALL:   JSR VFLT
"ARGUEMENTS - SPAD:
"       0       A       BASE ADDRESS OF VECTOR A
"       1       I       INCREMENT FOR A
"       2       C       BASE ADDRESS  VECTOR C
"       3       K       INCREMENT FOR C
"       4       N       NUMBER OF ELEMENTS IN C
"
"
"                  --- ALGORITHM ---
"1.     INPUT: 2'S COMPLEMENT INTEGERS IN THE MANTISSA PORTION OF
"         MAIN DATA MEMORY WORDS
"2.     FLOATING IS DONE BY ADDING THE INTEGERS TO 0.0, THE ADDER
"         WILL NORMALIZE THE ANSWERS.  THE "MDPX" FLOATING ADD OPERAND
"         IN THE INSTRUCTIONS CAUSES THE MANTISSA FROM
"         DPX(0)  (I.E. OUR INTEGER) TO BE COMBINED WITH SPFN AS THE
"         EXPONENT TO GIVE A FLOATING POINT NUMBER (ALTHOUGH
"         UN-NORMALIZED) TO ADD TO 0.0.  27 IS THE PROPER EXPONENT
"         VALUE SINCE 27 LEFT SHIFTS WILL NORMALIZE AN INTEGER 1 (A 1
"         IN THE LSB) INTO A NORMALIZED FRACTION OF 0.5
"       S-PAD MNEMONICS:
        A $EQU 0
        I $EQU 1
        C $EQU 2
        K $EQU 3
        N $EQU 4
        C27 $EQU 15
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVFLT,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/I/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVFLT : LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VFLT:   LDSPI C27;  DB=27.                      "LOAD 27. INTO SP(15)
        MOV A,A;  SETMA                         "2. FETCH A(1)
        LDTMA;  DB=!ONE;  SUB K,C               "FETCH ONE FROM TABLE
        ADD I,A;  SETMA                         "2. FETCH A(2)
                DPY<MD                          "2. STORE A(1) TEMP.
        MOV N,N;  DPX(1)<SPFN                   "MOVE N FROM SP TO DPX(1)
                FADD ZERO, MDPX(1);  MOV C27,C27;   "FLOAT COUNT N
                        DPX<DPY;                "1. SHIFT FROM DPY(1) TO DPX(1)
          BEQ DONE              "EXIT IF COUNT = 0
        ADD I,A;  SETMA;                        "2. FETCH A(2)
                FADD;  DPY<MD                   "2. STORE A(2) TEMP.
                        FSUBR TM,FA             "2. DECREMENT COUNT
LOOP:                        DPX<DPY;           "1. SHIFT FROM DPY(M+1) TO DPX(M
                                FADD ZERO,MDPX;  MOV C27,C27  "1. FLOAT A(M)
        ADD I,A;  SETMA;                        "2. FETCH A(M+3)
                DPY<MD;                         "2. STORE A(M+2) TEMP.
                        FSUBR TM,FA             "2. DECREMENT COUNT
                                ADD K,C;  SETMA;  MI<FA;  BFGT LOOP
                                                "3. STORE C(M), BRANCH TO LOOP
DONE:   RETURN
        $END
"**** VSMAFX = VECTOR SCALAR MULTIPLY, ADD AND FIX /FAST/ = REL 3.1, AUG 80 ****
        $TITLE VSMAFX
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSMAFX,7                          "USER-DIRECTED-CALL ENTRY
"
"---ABSTRACT---
"D(MK) = FIX (A(MI)*B + C)
"
"---STATISTICS---
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH FAST MEMORY
"SIZE: 14
"EXECUTION      BEST    TYPICAL WORST   SETUP (WORST)
"TIME/LOOP:     3 (A)      4      4      13
"(IN CYCLES)
"SUBROUTINES USED: NONE
"AUTHOR:    H. WILLIAMS
"DATE:      DEC 77
"
"REV 3.1:  AUG 80  R. GELLER TO CORRECT PROGRAM LINKAGE
"---USAGE---
"FORTRAN: CALL VSMAFX(A,I,B,C,D,K,N)
"APAL:    JSR VSMAFX
"S-PAD PARAMETERS:
        A = 0           "INPUT VECTOR
        I = 1           "A ADDRESS INCREMENT
        B = 2           "INPUT SCALAR
        C = 3           "INPUT SCALAR
        D = 4           "DESTINATION VECTOR BASE ADDRESS
        K = 5           "D ADDRESS INCREMENT
        N = 6           "ELEMENT COUNT
"
"---SCRATCH---
"SP(0,4,6),DPX(0,1),DPY,FA,FM,MD
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSMFX,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  142
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3/R/IP, P4/R/IP,
                    P5(#6,#7)/I/OP, P6/I/IP,
                    P7/I/IP
FVSMFX: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSMAFX: MOV B,B; SETMA                          "1.
        MOV A,A; SETMA                          "2.
        MOV C,C; SETMA                          "3.
        DPX<MD; SUB K,D                         "4. DPX=B; D(-1)
        ADD I,A; SETMA;                         "5. A(1)
            FMUL DPX,MD                         "   A(0)*B
        DPY<MD;                                 "6. DPY=C
            FMUL
            FMUL                                "7.
        ADD I,A; SETMA;                         "8. A(2)
            FMUL DPX,MD;                        "   A(1)*B
                FADD FM,DPY                     "   A(0)*B+C
        MOV N,N;                                "9. TEST IN NEXT INSTR.
            FMUL;                               "
                FADD
        BEQ DONE;                               "10. TEST FOR N=0
            FMUL;                               "
                FIX FA                          "   FIX (A(0)*B+C)
LOOP:   ADD I,A; SETMA;                         "1. A(M+3)
            FMUL DPX,MD;                        "   A(M+2)*B
                FADD FM,DPY                     "   A(M+1)*B+C
            FMUL;                               "2.
                FADD;
                    DPX(1)<FA; DEC N            "    SAVE FA
            FMUL;                               "3.
                FIX FA;                         "   FIX (A(M+1)*B+C)
                    ADD K,D; SETMA; MI<DPX(1);  "   STORE D(M)
                    BNE LOOP
DONE:   RETURN
        $END
"
"****** VSEFLT = VECTOR SIGN EXTEND AND FLOAT /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE VSEFLT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSEFLT,5                          "USER-DIRECTED-CALL ENTRY
"
"     --- ABSTRACT ---
"ROUTINE TAKES 16-BIT INTEGERS IN MD WHICH HAVE NOT BEEN SIGN EXTENDED
"(SUCH AS INPUT DATA FROM AN IOP16), SIGN EXTENDS THE MANTISSA TO 28 BITS,
"AND THEN FLOATS THE DATA TO STANDARD 38-BIT FORMAT.
"
"FORMULA:  C(MK) = FLOAT (SIGN EXTEND (A(MI)) )  FOR M=0 TO N-1
"
"
"     --- HISTORY ---
"ORIGINAL:  DEC 77  J. THROOP, R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"     --- STATISTICS ---
"LANGUAGE:  APAL
"EQUIPMENT:  AP120B WITH EITHER SPEED MD MEMORY
"SIZE:       15
"EXECUTION     BEST      TYPICAL       WORST        SETUP(US)
"TIME/LOOP:    0.83        0.83         0.83         1.67        167 NS MEMORY
" (US)         0.83        0.83         1.0          1.67        333 NS MEMORY
"
"     --- USAGE ---
"FORTRAN CALL:  CALL VSEFLT(A,I,C,K,N)
"APAL CALL:     JSR VSEFLT
"SCRATCH:       SP(0,2,4,14,15),DPX(0),DPY(0,1),FA,MD,TM
"
"ENTER WITH FOLLOWING S-PAD PARAMETERS:
"  NAME       NUMBER
      A   $EQU 0                "BASE ADDRESS OF SOURCE VECTOR OF INTEGERS
      I   $EQU 1                "ADDRESS INCREMENT OF A
      C   $EQU 2                "BASE ADDRESS OF DESTINATION VECTOR
      K   $EQU 3                "ADDRESS INCREMENT OF C
      N   $EQU 4                "ELEMENT COUNT
"LOCAL STORAGE:
        EY $EQU 16
        C27 $EQU 17
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSEFL,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/I/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVSEFL: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSEFLT: LDSPI C27; DB=27.       "GET EXPONENT FOR FLOAT
        MOV N,N; DPX<SPFN       "FLOAT ELEMENT COUNT
        FADD ZERO,MDPX; MOV C27,C27;
          BEQ DONE              "EXIT IF COUNT = 0
        FADD;                   "PUSH
         MOV A,A; SETMA         "GET A(0)
        DPY(1)<FA;              "SAVE COUNT
         LDTMA; DB=!ONE;        "GET 1.0 FROM TM
         SUB K,C                "BACK UP ELEMENT COUNT
        ADD I,A; SETMA          "FETCH A(1)
        LDSPI EY; DB=MD         "SAVE A(0)
        MOV EY,EY; DPX<SPFN     "EXTEND SIGN OF A(0)
        FADD ZERO,MDPX; MOV C27,C27 "FLOAT A(0)
LOOP:       LDSPI EY; DB=MD             "1. SAVE A(M+1)
        ADD I,A; SETMA;                 "2. GET A(M+2)
                FSUBR TM,DPY(1)         "   DECREMENT COUNT
            MOV EY,EY; DPX<SPFN;        "3. EXTEND SIGN OF A(M+1)
                FADD;                   "   PUSH
                DPY<FA                  "   SAVE RESULT
            FADD ZERO,MDPX; MOV C27,C27; "4. FLOAT A(M+1)
                DPY(1)<FA               "   SAVE COUNT
                ADD K,C; SETMA; MI<DPY; "5. STORE C(M)
                BFGT LOOP               "   LOOP UNTIL COUNT=0
DONE:   RETURN                  "EXIT
        $END
"****** VSHFX = VECTOR SHIFT AND FIX /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE VSHFX
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSHFX, 6                          "USER-DIRECTED-CALL ENTRY
"                  --- ABSTRACT ---
"SHIFTS (MULTIPLIES BY A POWER OF 2) AND FIXES
"                  --- STATISTICS ---
"EQUIPMENT:        AP-120B
"LANGUAGE:         AP-120B ASSEMBLER
"SIZE:             10. LOCATIONS
"SPEED:            2 MEMORY CYCLES PER POINT
"SCRATCH:          S-PAD:  0,2,4,6
"
"    --- HISTORY ---
"ORIGINAL:  SEP 76  A.E. CHARLESWORTH
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                  --- USEAGE ---
"S-PAD PARAMETERS:
        A $EQU 0        "BASE ADDRESS OF A
        I $EQU 1        "INCREMENT FOR A
        C $EQU 2        "BASE ADDRESS OF C
        K $EQU 3        "INCREMENT FOR C
        N $EQU 4        "ELEMENT COUNT FOR C
        SHFT $EQU 5     "SHIFT (POWER OF 2 MULTIPLY) DESIRED BEFORE FIXING
                        "  + IS LEFT SHIFT, - IS RIGHT SHIFT
                        "  I.E. -2 WILL SHIFT RIGHT 2 (DIVIDE BY 4)
                        "  BEFORE DOING A FIX (RIGHT JUSTIFY
                        "  IN 28 BITS)
"SCRATCH S-PAD:
        T $EQU 6
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSHFX,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  72
        $PARAM  6 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/I/OP, P4/I/IP,
                    P5/I/IP, P6/I/IP
FVSHFX: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSHFX:  MOV A,A; SETMA          "FETCH FIRST A
        MOV N,N                 "IS ELEMENT COUNT = 0?
        LDSPI T; DB=28.;
          BEQ DONE              "EXIT IF COUNT = 0
        SUB SHFT,T              "THIS IS THE FSCALE VALUE
        SUB K,C
SLOOP:  MOV T,T; FSCLT MD       "FIX INTEGER
        ADD I,A; SETMA; FADD    "FETCH NEXT A
        DEC N
        MI<FA; ADD K,C; SETMA;  "STORE C
          BNE SLOOP
DONE:   RETURN                  "EXIT
        $END
"****** VSCALE = VECTOR SCALE (POWER 2) AND FIX /COMMON/ = REL 3.2, MAR 80 **
        $TITLE VSCALE
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSCALE, 7                          "USER-DIRECTED-CALL ENTRY
"VECTOR SCALE
"                  --- ABSTRACT ---
"SCALES (RIGHT SHIFTS) EVERY ELEMENT IN THE VECTOR BY
"       THE AMOUNT NECESSARY TO MAKE 'B' FIT INTO THE
"       SPECIFIED INTEGER BIT WIDTH (FROM 2-28 BITS WIDE)
"                  --- STATISTICS ---
"EQUIPMENT:        AP-120B WITH EITHER MEMORY
"LANGUAGE:         AP-120B ASSEMBLER
"SIZE:             14. LOCATIONS
"SPEED:            2 MEMORY CYCLES PER POINT
"SCRATCH:          S-PAD:  0,3,5,7,10  (OCTAL)
"    --- HISTORY ---
"ORIGINAL:  SEP 76  A.E. CHARLESWORTH
"REV 3, APR 77  -  CHANGED VALUE RETURNED IN S-PAD 15 TO
"                  M=WIDTH-E-1  WHERE B(0)=FRAC*2**E.
"                  AFTER TRANSFERRING FIXED DATA TO HOST
"                  AS 16-BIT INTEGERS, ORIGINAL VALUES
"                  CAN BE RECOVERED BY MULTIPLYING BY 2**(-M).
"REVISED:  APR 79  W.H.INSKEEP--STORES M IN MD(IEXP) AS WELL AS S-PAD 15.
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2: MAR 80  R.S. NORIN   FUNCTIONALITY RETURNED TO THAT
"                                        PRIOR TO APR 79 REVISION.  I.E.,
"                                        SCALING EXPONENT RETURNED ONLY
"                                        IN SP(15).
"                                        THE ROUTINE XVSCAL PRESERVES THE
"                                        APR 79- FEB 80 FUNCTIONALITY. I.E.,
"                                        WHERE THE SCALING EXPONENT IS ALSO
"                                        STORED INTO MD.
"
"                  --- USEAGE ---
"S-PAD PARAMETERS:
        A $EQU 0        "BASE ADDRESS OF A
        I $EQU 1        "INCREMENT FOR A
        B $EQU 2        "ADDRESS OF B(0)
        C $EQU 3        "BASE ADDRESS OF C
        K $EQU 4        "INCREMENT FOR C
        N $EQU 5        "ELEMENT COUNT FOR C
        WIDTH $EQU 6    "WIDTH OF DESIRED INTEGERS: 2-28
"                       "NOTE:  THIS COUNT INCLUDES THE SIGN BIT
"SCALES THE VECTOR APPROPRIATELY SO AS TO MAKE 'B' FIT
"       IN THE SPECIFIED INTEGER SIZE
"THE RESULT VECTOR HAS THE 2'S COMPLEMENT INTEGERS IN THE MANTISSA,
"       AND EXPONENT PARTS SET TO THE APPROPRIATE EXPONENT CONSIDERING
"       THE INTEGERS AS UN-NORMALIZED FRACTIONS OF A FLOATING POINT
"       NUMBER
"AN EXAMPLE:
"WE WANT TO SCALE A VECTOR INTO 12 BIT INTEGERS, THEN:
"       WIDTH = 12.    (BIGGEST VALUE IS +2047 OR -2048 IN 12 BITS)
"'B' HAS A VALUE OF 12.0  =  0.75 * 2 **4 ,
"       THIS GIVES A SCALE FACTOR OF 2**(12-4-1)=2**7=128.
"     ALL NUMBERS IN THE VECTOR WILL BE SHIFTED RIGHT UNTIL
"     THEIR EXPONENTS ALL EQUAL 28-WIDTH+E=20.
"SO:    12.0 = 0.75*2**4 WILL BE SHIFTED 20.-4 = 16. PLACES RIGHT, SO
"       ITS FRACTION OF 600000000 (OCTAL, CONSIDERED AS AN INTEGER) WILL
"         BECOME THE INTEGER 3000 OCTAL, OR 1536.
"       NUMBERS SMALLER THAN 12.0, WHICH AS WE REMEMBER WAS THE MAXIMUM,
"         WILL BE SHIFTED CORRESPONDINGLY TO LIE IN THE RANGE OF
"         +2047 TO -2048
"                  --- ALGORITHM ---
"1.     THE PROPER SCALE FACTOR IS:  M=WIDTH-E-1  WHERE B(0)=FRAC*2**E.
"ALL THE NUMBERS IN THE VECTOR WILL HAVE THEIR EXPONENT PARTS
"SET TO 28-WIDTH+E.
"NOTE: IN THIS DISCUSSION THE FACT THAT ALL EXPONENTS ARE BIASED BY 512.
"       HAS BEEN OMITTED SO AS NOT TO OBSCURE THE ISSUE.
"       THE RELEVANT S-PAD INSTRUCTIONS DEALING WITH EXPONENTS ALL
"         REMOVE THE BIAS WHEN GOING INTO S-PAD, AND ADD IT WHEN GOING
"         TO THE DATA PAD BUS, SO THINGS CAN BE CONSIDERED IGNORING THE
"         BIAS.
"SCRATCH S-PAD REGISTERS:
        T $EQU 7
        MAX $EQU 17
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSCLE,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  162
        $PARAM  7 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3/R/IP,
                    P4(#5,#6)/I/OP, P5/I/IP,
                    P6/I/IP, P7/I/IP
FVSCLE: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSCALE: MOV B,B; SETMA          "FETCH B
        MOV N,N                 "IS ELEMENT COUNT = 0?
        LDSPI T; DB=29.;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        SUB K,C
        LDSPE MAX; DB=MD        "GET EXPONENT OF B
        MOV A,A; SETMA          "FETCH FIRST A
        SUB WIDTH,MAX
        ADD MAX,T               "THIS IS THE FSCALE VALUE
SLOOP:  MOV T,T; FSCLT MD       "FIX INTEGER
        ADD I,A; SETMA; FADD    "FETCH NEXT A
        DEC N
        MI<FA; ADD K,C; SETMA;  "STORE C
          BNE SLOOP
        RETURN; COM MAX                    "SET EXPONENT OF SCALE FACTOR
        $END
"****** VSCSCL = VECTOR SCAN, SCALE (POWER 2) AND FIX /COMMO= REL 3.2, MAR 80 **
        $TITLE VSCSCL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSCSCL, 6                          "USER-DIRECTED-CALL ENTRY
        $ENTRY VSCL                          "USER-DIRECTED-CALL ENTRY
"VECTOR SCAN AND SCALE
"                  --- ABSTRACT ---
"SCANS A VECTOR FOR THE ELEMENT WITH THE LARGEST EXPONENT,
"       AND THEN SCALES (RIGHT SHIFTS) EVERY ELEMENT IN THE VECTOR BY
"       THE AMOUNT NECESSARY TO MAKE THE LARGEST ELEMENT FIT INTO THE
"       SPECIFIED INTEGER BIT WIDTH (FROM 2-28 BITS WIDE)
"                  --- STATISTICS ---
"EQUIPMENT:        AP-120B WITH EITHER MEMORY
"LANGUAGE:         AP-120B ASSEMBLER
"SIZE:             21. LOCATIONS
"SPEED:            SCANNING:  0.67 US PER POINT
"                  SCALING: 2 MEMORY CYCLES PER POINT
"SCRATCH:  SP: 0,2,4,12.-15.
"    --- HISTORY ---
"ORIGINAL:  JUN 75  A.E. CHARLESWORTH
"REV 3, APR 77  -  CHANGED VALUE RETURNED IN S-PAD 15 TO
"                  M=WIDTH-E-1 WHERE MAX(ABS(A(MI)))=FRAC*2**E.
"                  FIXED DATA CAN BE TRANSFERRED TO HOST AS 16-BIT
"                  INTEGERS AND THEN MULTIPLIED BY 2**(-M) TO
"                  RECOVER ORIGINAL VALUES.
"
"REVISED:  APR 79  W.H.INSKEEP--STORES M IN MD(IEXP) AS WELL AS IN S-PAD 15.
"
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2: MAR 80  R.S. NORIN   FUNCTIONALITY RETURNED TO THAT
"                                        PRIOR TO APR 79 REVISION.  I.E.,
"                                        SCALING EXPONENT RETURNED ONLY
"                                        IN SP(15).
"                                        THE ROUTINE XVSCSC PRESERVES THE
"                                        APR 79- FEB 80 FUNCTIONALITY. I.E.,
"                                        WHERE THE SCALING EXPONENT IS ALSO
"                                        STORED INTO MD.
"
"
"                  --- USEAGE ---
"S-PAD PARAMETERS:
        A $EQU 0        "BASE ADDRESS OF A
        I $EQU 1        "INCREMENT FOR A
        C $EQU 2        "BASE ADDRESS OF C
        K $EQU 3        "INCREMENT FOR C
        N $EQU 4        "ELEMENT COUNT FOR C
        WIDTH $EQU 5    "WIDTH OF DESIRED INTEGERS: 2-28
"                       "NOTE:  THIS COUNT INCLUDES THE SIGN BIT
"ENTRY POINT "VSCSCL" BOTH SCANS FOR THE LARGEST NUMBER AND THEN SCALES
"       THE VECTOR APPROPRIATELY SO AS TO MAKE THE LARGEST ELEMENT FIT
"       IN THE SPECIFIED INTEGER SIZE
"ENTRY "VSCL" SCALES THE VECTOR USING THE CONTENTS OF S-PAD REGISTER 15.
"       AS THE MAXIMUM EXPONENT SIZE TO BE SCALED TO FIT IN THE
"       SPECIFIED INTEGER WIDTH
"THE RESULT VECTOR HAS THE 2'S COMPLEMENT INTEGERS IN THE MANTISSA,
"       AND EXPONENT PARTS SET TO THE APPROPRIATE EXPONENT CONSIDERING
"       THE INTEGERS AS UN-NORMALIZED FRACTIONS OF A FLOATING POINT
"       NUMBER
"AN EXAMPLE:
"WE WANT TO SCALE A VECTOR INTO 12 BIT INTEGERS, THEN:
"       WIDTH = 12.    (BIGGEST VALUE IS +2047 OR -2048 IN 12 BITS)
"LET US SAY THAT THE LARGEST VALUE IN THE VECTOR IS 12.0 = 0.75*2**4,
"       THEN THE SCAN WOULD FIND THAT E = 4
"       THIS GIVES A SCALE FACTOR OF 2**(12-4-1)=2**7=128.
"ALL NUMBERS IN THE VECTOR WILL BE SHIFTED RIGHT UNTIL
"THEIR EXPONENTS ALL EQUAL 28-WIDTH+E=20.
"SO:    12.0 = 0.75*2**4 WILL BE SHIFTED 20.-4 = 16. PLACES RIGHT, SO
"       ITS FRACTION OF 600000000 (OCTAL, CONSIDERED AS AN INTEGER) WILL
"         BECOME THE INTEGER 3000 OCTAL, OR 1536.
"       NUMBERS SMALLER THAN 12.0, WHICH AS WE REMEMBER WAS THE MAXIMUM,
"         WILL BE SHIFTED CORRESPONDINGLY TO LIE IN THE RANGE OF
"         +2047 TO -2048
"                  --- ALGORITHM ---
"1.     THE EXPONENTS ARE COMPARED BY LOADING THEM INTO S-PAD
"2.     THE PROPER SCALE FACTOR IS:  M=WIDTH-E-1
"                              WHERE MAX(ABS(A(MI)))=FRAC*2**E.
"ALL THE NUMBERS IN THE VECTOR WILL HAVE THEIR EXPONENT PARTS
"SET TO 28-WIDTH+E.
"NOTE: IN THIS DISCUSSION THE FACT THAT ALL EXPONENTS ARE BIASED BY 512.
"       HAS BEEN OMITTED SO AS NOT TO OBSCURE THE ISSUE.
"       THE RELEVANT S-PAD INSTRUCTIONS DEALING WITH EXPONENTS ALL
"         REMOVE THE BIAS WHEN GOING INTO S-PAD, AND ADD IT WHEN GOING
"         TO THE DATA PAD BUS, SO THINGS CAN BE CONSIDERED IGNORING THE
"         BIAS.
"SCRATCH S-PAD REGISTERS:
        PTR $EQU 14
        T $EQU 15
        CTR $EQU 16
        MAX $EQU 17     "THIS CONTAINS THE LARGEST EXPONENT FOUND
"FIRST FIND THE LARGEST EXPONENT
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSNSL,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  72
        $PARAM  6 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/I/OP, P4/I/IP,
                    P5/I/IP, P6/I/IP
FVSNSL: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSCSCL: MOV A,PTR; SETMA        "FETCH FIRST A
        MOV N,N                 "IS ELEMENT COUNT = 0?
        LDSPI MAX; DB=-1000;    "SMALLEST EXPONENT POSSIBLE
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV N,CTR
MLOOP:  LDSPE T; DB=MD;         "EXPONENT TO S-PAD
          BEQ VSCL              "  BRANCH IF DONE
ML1:    ADD I,PTR; SETMA                "FETCH NEXT A
        SUB# T,MAX              "COMPARE
        DEC CTR; BGE MLOOP      "BRANCH IF NOT LARGER
        MOV T,MAX;              "REPLACE MAX
          BEQ VSCL              "  SEE IF DONE
        LDSPE T; DB=MD;         "EXPONENT TO S-PAD
          BR ML1
"NOW SCALE EVERYTHING
VSCL: LDSPI T; DB=29.
           SUB WIDTH,MAX
       MOV A,A; SETMA          "FETCH FIRST A
        ADD MAX,T               "THIS IS THE FSCALE VALUE
        SUB K,C
SLOOP:  MOV T,T; FSCLT MD       "FIX INTEGER
        ADD I,A; SETMA; FADD    "FETCH NEXT A
       DEC N
        MI<FA; ADD K,C; SETMA;  "STORE C
          BNE SLOOP
        RETURN; COM MAX                   "SET EXPONENT OF SCALE FACTOR
        $END
"****** XVSCAL = VECTOR SCALE (POWER 2) AND FIX /COMMON/ = REL 3.0, MAR 80
        $TITLE XVSCAL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY XVSCAL, 10                          "USER-DIRECTED-CALL ENTRY
"VECTOR SCALE
"                  --- ABSTRACT ---
"SCALES (RIGHT SHIFTS) EVERY ELEMENT IN THE VECTOR BY
"       THE AMOUNT NECESSARY TO MAKE 'B' FIT INTO THE
"       SPECIFIED INTEGER BIT WIDTH (FROM 2-28 BITS WIDE)
"                  --- STATISTICS ---
"EQUIPMENT:        AP-120B WITH EITHER MEMORY
"LANGUAGE:         AP-120B ASSEMBLER
"SIZE:             15. LOCATIONS
"SPEED:            2 MEMORY CYCLES PER POINT
"SCRATCH:          S-PAD:  0,3,5,7,10,17  (OCTAL)
"                  D-PAD:  DPX(DPA)
"
"    --- HISTORY ---
"ORIGINAL:  MAR 80  R.S. NORIN    THIS ROUTINE ADDED TO PRESERVE THE
"                                 FUNCTIONALITY OF THE ROUTINE VSCALE
"                                 DURING THE APR 79 - FEB 80 PERIOD.
"                                 SCALING EXPONENT IS STORED AS INTEGER
"                                 IN MD ADDR IEXP.
"
"                  --- USEAGE ---
"S-PAD PARAMETERS:
        A $EQU 0        "BASE ADDRESS OF A
        I $EQU 1        "INCREMENT FOR A
        B $EQU 2        "ADDRESS OF B(0)
        C $EQU 3        "BASE ADDRESS OF C
        K $EQU 4        "INCREMENT FOR C
        N $EQU 5        "ELEMENT COUNT FOR C
        WIDTH $EQU 6    "WIDTH OF DESIRED INTEGERS: 2-28
"                       "NOTE:  THIS COUNT INCLUDES THE SIGN BIT
        IEXP $EQU 7     "MD ADDRESS TO STORE M
"SCALES THE VECTOR APPROPRIATELY SO AS TO MAKE 'B' FIT
"       IN THE SPECIFIED INTEGER SIZE
"THE RESULT VECTOR HAS THE 2'S COMPLEMENT INTEGERS IN THE MANTISSA,
"       AND EXPONENT PARTS SET TO THE APPROPRIATE EXPONENT CONSIDERING
"       THE INTEGERS AS UN-NORMALIZED FRACTIONS OF A FLOATING POINT
"       NUMBER
"AN EXAMPLE:
"WE WANT TO SCALE A VECTOR INTO 12 BIT INTEGERS, THEN:
"       WIDTH = 12.    (BIGGEST VALUE IS +2047 OR -2048 IN 12 BITS)
"'B' HAS A VALUE OF 12.0  =  0.75 * 2 **4 ,
"       THIS GIVES A SCALE FACTOR OF 2**(12-4-1)=2**7=128.
"     ALL NUMBERS IN THE VECTOR WILL BE SHIFTED RIGHT UNTIL
"     THEIR EXPONENTS ALL EQUAL 28-WIDTH+E=20.
"SO:    12.0 = 0.75*2**4 WILL BE SHIFTED 20.-4 = 16. PLACES RIGHT, SO
"       ITS FRACTION OF 600000000 (OCTAL, CONSIDERED AS AN INTEGER) WILL
"         BECOME THE INTEGER 3000 OCTAL, OR 1536.
"       NUMBERS SMALLER THAN 12.0, WHICH AS WE REMEMBER WAS THE MAXIMUM,
"         WILL BE SHIFTED CORRESPONDINGLY TO LIE IN THE RANGE OF
"         +2047 TO -2048
"                  --- ALGORITHM ---
"1.     THE PROPER SCALE FACTOR IS:  M=WIDTH-E-1  WHERE B(0)=FRAC*2**E.
"ALL THE NUMBERS IN THE VECTOR WILL HAVE THEIR EXPONENT PARTS
"SET TO 28-WIDTH+E.
"NOTE: IN THIS DISCUSSION THE FACT THAT ALL EXPONENTS ARE BIASED BY 512.
"       HAS BEEN OMITTED SO AS NOT TO OBSCURE THE ISSUE.
"       THE RELEVANT S-PAD INSTRUCTIONS DEALING WITH EXPONENTS ALL
"         REMOVE THE BIAS WHEN GOING INTO S-PAD, AND ADD IT WHEN GOING
"         TO THE DATA PAD BUS, SO THINGS CAN BE CONSIDERED IGNORING THE
"         BIAS.
"SCRATCH S-PAD REGISTERS:
        T $EQU 10
        MAX $EQU 17
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FXVSCL,10                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  162
        $PARAM  10 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3/R/IP,
                    P4(#5,#6)/I/OP, P5/I/IP,
                        P6/I/IP, P7/I/IP, P10/I/OP
FXVSCL: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
XVSCAL: MOV B,B; SETMA          "FETCH B
        MOV N,N                 "IS ELEMENT COUNT = 0?
        LDSPI T; DB=29.;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        SUB K,C
        LDSPE MAX; DB=MD        "GET EXPONENT OF B
        MOV A,A; SETMA          "FETCH FIRST A
        SUB WIDTH,MAX
        ADD MAX,T               "THIS IS THE FSCALE VALUE
SLOOP:  MOV T,T; FSCLT MD       "FIX INTEGER
        ADD I,A; SETMA; FADD    "FETCH NEXT A
        DEC N
        MI<FA; ADD K,C; SETMA;  "STORE C
          BNE SLOOP
        COM MAX; DPX<SPFN                  "SET EXPONENT OF SCALE FACTOR
        MOV IEXP,IEXP; SETMA; MI<DPX;       "STORE M
          RETURN
        $END
"****** XVSCSC = VECTOR SCAN, SCALE (POWER 2) AND FIX /COMMO= REL 3.0, MAR 80
        $TITLE XVSCSC
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY XVSCSC, 7                          "USER-DIRECTED-CALL ENTRY
        $ENTRY XVSCL                          "USER-DIRECTED-CALL ENTRY
"VECTOR SCAN AND SCALE
"                  --- ABSTRACT ---
"SCANS A VECTOR FOR THE ELEMENT WITH THE LARGEST EXPONENT,
"       AND THEN SCALES (RIGHT SHIFTS) EVERY ELEMENT IN THE VECTOR BY
"       THE AMOUNT NECESSARY TO MAKE THE LARGEST ELEMENT FIT INTO THE
"       SPECIFIED INTEGER BIT WIDTH (FROM 2-28 BITS WIDE)
"                  --- STATISTICS ---
"EQUIPMENT:        AP-120B WITH EITHER MEMORY
"LANGUAGE:         AP-120B ASSEMBLER
"SIZE:             22. LOCATIONS
"SPEED:            SCANNING:  0.67 US PER POINT
"                  SCALING: 2 MEMORY CYCLES PER POINT
"SCRATCH:  SP: 0,2,4,12.-15.
"
"    --- HISTORY ---
"ORIGINAL:  MAR 80  R.S. NORIN    THIS ROUTINE ADDED TO PRESERVE THE
"                                 FUNCTIONALITY OF THE ROUTINE VSCSCL
"                                 DURING THE APR 79 - FEB 80 PERIOD.
"                                 SCALING EXPONENT IS STORED AS INTEGER
"                                 IN MD ADDR IEXP.
"
"                  --- USEAGE ---
"S-PAD PARAMETERS:
        A $EQU 0        "BASE ADDRESS OF A
        I $EQU 1        "INCREMENT FOR A
        C $EQU 2        "BASE ADDRESS OF C
        K $EQU 3        "INCREMENT FOR C
        N $EQU 4        "ELEMENT COUNT FOR C
        WIDTH $EQU 5    "WIDTH OF DESIRED INTEGERS: 2-28
        IEXP  $EQU 6    "ADDRESS TO STORE M
"                       "NOTE:  THIS COUNT INCLUDES THE SIGN BIT
"ENTRY POINT "XVSCSC" BOTH SCANS FOR THE LARGEST NUMBER AND THEN SCALES
"       THE VECTOR APPROPRIATELY SO AS TO MAKE THE LARGEST ELEMENT FIT
"       IN THE SPECIFIED INTEGER SIZE
"ENTRY "XVSCL" SCALES THE VECTOR USING THE CONTENTS OF S-PAD REGISTER 15.
"       AS THE MAXIMUM EXPONENT SIZE TO BE SCALED TO FIT IN THE
"       SPECIFIED INTEGER WIDTH
"THE RESULT VECTOR HAS THE 2'S COMPLEMENT INTEGERS IN THE MANTISSA,
"       AND EXPONENT PARTS SET TO THE APPROPRIATE EXPONENT CONSIDERING
"       THE INTEGERS AS UN-NORMALIZED FRACTIONS OF A FLOATING POINT
"       NUMBER
"AN EXAMPLE:
"WE WANT TO SCALE A VECTOR INTO 12 BIT INTEGERS, THEN:
"       WIDTH = 12.    (BIGGEST VALUE IS +2047 OR -2048 IN 12 BITS)
"LET US SAY THAT THE LARGEST VALUE IN THE VECTOR IS 12.0 = 0.75*2**4,
"       THEN THE SCAN WOULD FIND THAT E = 4
"       THIS GIVES A SCALE FACTOR OF 2**(12-4-1)=2**7=128.
"ALL NUMBERS IN THE VECTOR WILL BE SHIFTED RIGHT UNTIL
"THEIR EXPONENTS ALL EQUAL 28-WIDTH+E=20.
"SO:    12.0 = 0.75*2**4 WILL BE SHIFTED 20.-4 = 16. PLACES RIGHT, SO
"       ITS FRACTION OF 600000000 (OCTAL, CONSIDERED AS AN INTEGER) WILL
"         BECOME THE INTEGER 3000 OCTAL, OR 1536.
"       NUMBERS SMALLER THAN 12.0, WHICH AS WE REMEMBER WAS THE MAXIMUM,
"         WILL BE SHIFTED CORRESPONDINGLY TO LIE IN THE RANGE OF
"         +2047 TO -2048
"                  --- ALGORITHM ---
"1.     THE EXPONENTS ARE COMPARED BY LOADING THEM INTO S-PAD
"2.     THE PROPER SCALE FACTOR IS:  M=WIDTH-E-1
"                              WHERE MAX(ABS(A(MI)))=FRAC*2**E.
"ALL THE NUMBERS IN THE VECTOR WILL HAVE THEIR EXPONENT PARTS
"SET TO 28-WIDTH+E.
"NOTE: IN THIS DISCUSSION THE FACT THAT ALL EXPONENTS ARE BIASED BY 512.
"       HAS BEEN OMITTED SO AS NOT TO OBSCURE THE ISSUE.
"       THE RELEVANT S-PAD INSTRUCTIONS DEALING WITH EXPONENTS ALL
"         REMOVE THE BIAS WHEN GOING INTO S-PAD, AND ADD IT WHEN GOING
"         TO THE DATA PAD BUS, SO THINGS CAN BE CONSIDERED IGNORING THE
"         BIAS.
"SCRATCH S-PAD REGISTERS:
        PTR $EQU 14
        T $EQU 15
        CTR $EQU 16
        MAX $EQU 17     "THIS CONTAINS THE LARGEST EXPONENT FOUND
"FIRST FIND THE LARGEST EXPONENT
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FXVSNS,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  72
        $PARAM  7 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/I/OP, P4/I/IP,
                    P5/I/IP, P6/I/IP, P7/I/OP
FXVSNS: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
XVSCSC: MOV A,PTR; SETMA        "FETCH FIRST A
        MOV N,N                 "IS ELEMENT COUNT = 0?
        LDSPI MAX; DB=-1000;    "SMALLEST EXPONENT POSSIBLE
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV N,CTR
MLOOP:  LDSPE T; DB=MD;         "EXPONENT TO S-PAD
          BEQ XVSCL              "  BRANCH IF DONE
ML1:    ADD I,PTR; SETMA                "FETCH NEXT A
        SUB# T,MAX              "COMPARE
        DEC CTR; BGE MLOOP      "BRANCH IF NOT LARGER
        MOV T,MAX;              "REPLACE MAX
          BEQ XVSCL              "  SEE IF DONE
        LDSPE T; DB=MD;         "EXPONENT TO S-PAD
          BR ML1
"NOW SCALE EVERYTHING
XVSCL: LDSPI T; DB=29.
           SUB WIDTH,MAX
       MOV A,A; SETMA          "FETCH FIRST A
        ADD MAX,T               "THIS IS THE FSCALE VALUE
        SUB K,C
SLOOP:  MOV T,T; FSCLT MD       "FIX INTEGER
        ADD I,A; SETMA; FADD    "FETCH NEXT A
       DEC N
        MI<FA; ADD K,C; SETMA;  "STORE C
          BNE SLOOP
        COM MAX; DPX<SPFN                 "SET EXPONENT OF SCALE FACTOR
        MOV IEXP,IEXP; SETMA; MI<DPX;     "STORE M
          RETURN
        $END
"****** VFLT32 = VECTOR 32-BIT INTEGER FLOAT /COMMON/ = REL 3.2, AUG 80 *****
        $TITLE VFLT32
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VFLT32,5                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "FLOATS A 32 BIT TWOS COMPLEMENT INTEGER WHICH IS RIGHT JUSTIFIED
        "IN MD.  BITS ARE NUMBERED FROM RIGHT TO LEFT WITH THE LEAST
        "SIGNIFICANT BIT 0 HAVING A NUMERICAL VALUE OF 2**0 = 1.
        "THE USUAL MANTISSA SIGN BIT, BIT 27, HAS A VALUE OF
        "2**27 = 134217728.  THE SIGN BIT OF THE 32 BIT INTEGER IS BIT 31
        "WITH A VALUE -2**31 = -2147483648.  THE 32 BIT INTEGER
        "A(31)A(30) .. . . . A(1)A(0) WHERE EACH A(I) HAS A VALUE OF
        "ONE OR ZERO IS EVALUATED BY CALCULATING
        "-A(31)*2**31 + A(30)*2**30 +  . . . + A(1)*2 + A(0).
        "THIS WORKS OUT AS FOLLOWS:  IF A(31) = 1, ADD -2**31.
        "FLOAT A(30)A(29)A(28) WITH AN EXPONENT OF 54.
        "IF A(27) = 1, ADD 2**27. FLOAT A(26)A(25) . . . A(0) WITH
        "AN EXPONENT OF 27.  ADD THE CONTRIBUTIONS.
        "FOR SMALL NEGATIVE NUMBERS THIS PROCEDURE CAUSES UNDERFLOW,.
        "THUS IF A(31)A(30)A(29)A(28) = 17(OCTAL), WE MERELY FLOAT
        "A(27)A(26() .. . . . A(0) WITH AN EXPONENT OF 27.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER
        "EQUIPMENT:     AP-120B WITH STANDARD OR FAST MEMORY
        "SIZE:          61 + SPUFLT (8) = 69 WORDS
        "SPEED:         1.67 MICROSECONDS PER POINT
"
"     ---HISTORY---
"ORIGINAL:  APR 77  J. THROOP
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80  R. GELLER      CORRECT ADC LINKAGE
"
        "NAMES FOR S PAD
        A $EQU 0                        "SOURCE VECTOR ADDRESS
        I $EQU 1                        "SOURCE VECTOR INCREMENT
        C $EQU 2                        "DESTINATION VECTOR ADDRESS
        K $EQU 3                        "DESTINATION VECTOR INCREMENT
        N $EQU 4                        "VECTOR LENGTH
        EX $EQU 17
        E33 $EQU 16
        E67 $EQU 12
        EXB $EQU 15
        E10 $EQU 13
        E7 $EQU 11
        NM $EQU 17                      "TEMP STORAGE FOR VECTOR LENGTH
        "NAMES FOR DPX AND DPY
        TE $EQU 2
        NN $EQU 1
        SAVE $EQU -3
        C28 $EQU -1
        T4 $EQU 3
        NSB $EQU -4
        MXNEG $EQU -2
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVFL32,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/I/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVFL32: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VFLT32: MOV N,NM                        "FLOAT VECTOR LENGTH SO FLOATING ADDER C
        JSR SPUFLT                       "BE USED FOR LOOP CONTROL. TM = ONE.  D
        RPSF FC28; DPY(C28)<DB          "= 2**27 = 134217728
        RPSF MSKX; DPY(MXNEG)<DB                "-2**31 = -2147483648
        RPSF MNSB; DPY(NSB)<DB          "MASK FOR LOW 27 BITS OF MANTISSA
        LDSPI E33; DB=33                "EXPONENT TO FLOAT MANTISSA
        LDSPI E67; DB=67                "=54., EXPONENT TO FLOAT BITS IN EXPONEN
        LDSPI EXB; DB=1000              "AP BIAS FOR EXPONENT
        LDSPI E10; DB=10                "MASK FOR BIT 31 OF INTEGER
        LDSPI E7; DB=7          "MASK FOR BITS 28-29-30 OF INTEGER
        MOV A,A; SETMA                  "FETCH A(0)
        DPX(MXNEG)<DPY(MXNEG);
          MOV N,N               "IS ELEMENT COUNT = 0?
        SUB K,C;                "BACK UP C POINTER
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        LDSPE EX; DB=MD;                 "GET EXP BITS
        DPX<MD                          "SAVE A(0)
        ADD EXB,EX                      "ADD BIAS
        AND# E10,EX                     "TEST TO SEE IF A(0) < 0
        BEQ SKPA;                       "BRANCH IF A(0) > 0
        AND E7,EX; DPX(TE)<SPFN                 " EXP,BITS TO DPX(TE)
        FADD ZERO,MDPX; MOV E33,E33             "FLOAT MANTISSA BITS
        DPX(T4)<DPY(MXNEG); BR BTEN
SKPA:   FADD ZERO,MDPX; MOV E33,E33
        DPX(T4)<ZERO; BR SKPB
BTEN:   SUB E7,EX;                      "TO SEE IF ALL EXP BITS SET
        FADD; BR ONE
ONE:    ADD I,A; SETMA;                 "FETCH A(I)
                BNE SKPC;                       "BRANCH IF NOT A NEG NUMBER > -2
                DPY(SAVE)<FA                    "SAVE FLOATED MANTISSA BITS OF A
                BFGE PSN;               "BRANCH IF SIGN BIT NOT SET
                FADD ZERO,MDPX(TE); MOV E67,E67 "FLOAT EXP BITS OF A(I-1)
                DPX(T4)<ZERO;
                BR FOUR
FOUR:   LDSPE EX; DB=MD;                        "GET EXP BITS OF A(I)
        DPX<MD                  "SAVE A(I)
        ADD EXB,EX;                     "ADD BIAS
                FADD ZERO,DPY(SAVE)             "TO PUSH MANTISSA BITS THROUGH P
SIX:    AND# E10,EX;                    "TO SEE IF A(I) < 0
                FSUBR TM,DPX(NN)                "DECREMENT COUNTER
SEVEN:  BEQ SKP;                        "BRANCH IF A(I) > 0
        AND E7,EX; DPX(TE)<SPFN;                "EXP BITS OF A(I) TO DPX
                FADD DPX(T4),FA
        FADD ZERO,MDPX; MOV E33,E33;            "FLOAT MANTISSA BITS OF A(I)
                DPX(NN)<FA
NINE:   DPX(T4)<DPY(MXNEG);
                ADD K,C; SETMA; MI<FA;           "STORE ANS
                BFGT TEN
STOP:                   RETURN
SKPC:   FADD ZERO,MDPX(TE); MOV E67,E67;
                DPX(T4)<DPY(MXNEG);
                DPY(SAVE)<FA; BFGE PSNP
                FAND DPY(NSB),MDPX; MOV E33,E33;
                BR SKPD
SKPB:   FADD; BR SKP10
TEN:   SUB E7,EX;                      "TO SEE IF A(I) IS NEG > -2**31
        FADD;
        BR ONE
PSN:            FAND DPY(NSB),MDPX; MOV E33,E33        "GET MANT BITS OF A(I-1)
        LDSPE EX; DB=MD;
        DPX<MD;
                DPY<FA;
                FADD
        ADD EXB,EX;
                DPX(T4)<DPX(MXNEG);
                FADD DPY,FA;
                BR SIX
SKP:    FADD ZERO,MDPX; MOV E33,E33;
                DPX(NN)<FA; BR SK8
PSNP:   FAND DPY(NSB),MDPX; MOV E33,E33
        LDSPE EX; DB=MD;
        DPX<MD;
                FADD ZERO,FA
        ADD EXB,EX;
                FADD DPX(T4),FA
TSIX:   AND# E10,EX;
                DPX(T4)<FA; FSUBR TM,DPX(NN)
                BEQ SKP; AND E7,EX; DPX(TE)<SPFN;
                FADD DPX(T4),FA
        FADD ZERO,MDPX; MOV E33,E33;
                DPX(NN)<FA; BR NINE
SK8:    DPX(T4)<ZERO;
                ADD K,C; SETMA; MI<FA;   "STORE AND
                BFEQ STOP
NEXT1:  FADD; BR SKP10
SKPD:   LDSPE EX; DB=MD;
        DPX<MD; FADD DPY(C28),FA; BR SFIVE
SKP10:  ADD I,A; SETMA
SKP1:           FADD ZERO,MDPX(TE); MOV E67,E67;        "2. FLOAT EXP BITS
                DPY(SAVE)<FA;
                BFGE PSNP
                FAND DPY(NSB),MDPX; MOV E33,E33
        LDSPE EX; DB=MD;
        DPX<MD;
                FADD DPY(C28),FA
SFIVE:  ADD EXB,EX;
                FADD DPX(T4),FA;
                BR TSIX
FC28:   $FP 134217728.
MSKX:   $VAL 0,41,174000,0
MNSB:   $VAL 0,41,133777,177777
        $END
"****** VFIX32 = VECTOR 32-BIT INTEGER FIX /COMMON/ = REL 3.2, AUG 80 *****
"   FOR EITHER MEMORY
"
        $TITLE VFIX32
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VFIX32,5                          "USER-DIRECTED-CALL ENTRY
"
"                               --- ABSTRACT ---
"FIXES A VECTOR OF FLOATING POINT NUMBERS INTO 32-BIT WIDE
"   2'S COMPLEMENT INTEGERS RIGHT JUSTIFIED IN 38-BIT MEMORY WORDS
"
"                               --- STATISTICS ---
"EQUIPMENT:     AP-120B WITH EITHER SPEED MAIN MEMORY
"SIZE:          34. WORDS
"SPEED:         1.17 US/POINT
"
"    --- HISTORY ---
"ORIGINAL:  OCT 76  A.E. CHARLESWORTH
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80  R. GELLER      CORRECT ADC LINKAGE
"
"
"
"                               --- USEAGE ---
"S-PAD PARAMETERS:
"       NAME   NUMBER            PURPOSE
        A $EQU 0                "BASE ADDRESS OF A
        I $EQU 1                "INCREMENT FOR A
        C $EQU 2                "BASE ADDRESS OF C
        K $EQU 3                "INCREMENT FOR C
        N $EQU 4                "ELEMENT COUNT
"
"SCRATCH:  S-PAD: 0,2,4,16,17
"          DPX:   0,1,2 (REL TO DPA)
"          DPY:   0,1,2 (REL TO DPA)
"
"                               --- ALGORITHM ---
"
"FLOATING POINT ARGUEMENT:
"
"    EXPONENT    SIGN   FRACTION
"                                1         2
"    0123456789  0      123456789012345678901234567
"
"TARGET 32-BIT INTEGER:
"           3                 2         1
"          1098  7      654321098765432109876543210
"
"THE BITS THAT END UP IN 28-31, 27, AND 0-26 MUST BE EXTRACTED
"SEPARATELY FROM THE INPUT MANTISSA AND PLACED INTO THE EXPONENT,
"SIGN BIT, AND FRACTION OF THE WORD:
"       1. GET BITS 0-26 (GOES INTO THE FRACTION)
"       2. GET BIT 27 (GOES INTO THE SIGN BIT)
"       3. GET BITS 28-31 (GOES INTO THE EXPONENT)
"       4. OR RESULT 'SIGN' BIT INTO 'FRACTION' BITS
"       5. FSCALE 'EXPONENT' RESULT BITS TO RIGHT SIDE OF FRACTION
"       6. FIX COMBINED 'SIGN' AND 'MANTISSA' BITS TO RIGHT SIDE OF FRACTION
"       7. FIX ORIGINAL INPUT FLOATING POINT NUMBER TO SEE IF IT WAS
"            LESS THAN 0.5 ABSOLUTE VALUE
"       8. GET FIXED EXPONENT BITS INTO S-PAD
"       9. PUT COMBINED MANTISSA BITS INTO DPY
"      10. PUT EXPONENT BITS INTO DPY FROM S-PAD WITH 'WRTEX'
"11. IF INPUT F.P.N WAS <0.5 FORCE ANSWER TO ZERO
"
"
"OTHER S-PAD NAMES:
"       LOCAL S-PADS:
        N56 $EQU 16             "HOLDS 56
        E $EQU 17               "HOLD EXPONENT PART
"
"DATA PAD X:
                                 "1034,4000,0
        M2831 $EQU 0             "MASK TO EXTRACT BITS 28-31
        TE $EQU 1                "TEMP FOR EXPONENT BITS
                                 "1033,4000,0
        B27 $EQU 2               "BIT 27 (ON)
"
"DATA PAD Y:
                                 "1033,3777,177777
        M026 $EQU 0              "MASK TO EXTRACT BITS 0-26
                                 "1034,2000,0
        M27 $EQU 1               "MASK TO EXTRACT BIT 27
        ANS $EQU 2               "PLACE TO PACK ANSWER
"
"
"INTIIALIZE MASKS . . .
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVFX32,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/I/OP, P4/I/IP,
                    P5/I/IP
FVFX32: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VFIX32: RPSF C026; DPY(M026)<DB
        RPSF C27; DPY(M27)<DB
        RPSF C2831; DPX(M2831)<DB
        RPSF CB27; DPX(B27)<DB
"
"FIRST LOOP OF INITIALIZATION . . .
        MOV A,A; SETMA                          "2. FETCH A(0)
        LDSPI N56; DB=56.                       "3. FSCALE CONSTANT
        SUB K,C                                 "4.
        FAND DPY(M27),MD;                       "5. EXTRACT BIT 27
          MOV N,N               "IS ELEMENT COUNT = 0?
        FAND DPX(M2831),MD;                     "6. EXTRACT BITS 28-31
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        FAND DPY(M026),MD                       "7. EXTRACT BITS 0-26
"
"SECOND LOOP OF INITIALIZATION . . .
                BFEQ NOTON2;                    "1. BRANCH IF BIT 27 WAS NOT ON
                FSCALE FA; MOV N56,N56          "RIGHT JUSTIFY BITS 28-31
WASON2: ADD I,A; SETMA;                         "2. FETCH NEXT A
                FOR DPX(B27),FA; BR COMM2       "OR BIT 27 INTO BITS 0-26
NOTON2: ADD I,A; SETMA;                         "2. FETCH NEXT A
                FOR ZERO,FA                     "OR BIT 27 INTO BITS 0-26
COMM2:          FIX MD;                         "3. TEST FOR ABS(A).LT.0.5)
                DPX(TE)<FA                      "SAVE BITS 28-31
                FIX FA;                         "4. RIGHT JUSTIFY BITS 0-27
                LDSPI E; DB=DPX(TE)             "BITS 28-31 TO S-PAD
        FAND DPY(M27),MD;                       "5. EXTRACT BIT 27
                MOV E,E; DPX(TE)<SPFN           "BITS 28-31 TO EXPONENT
        FAND DPX(M2831),MD;                     "6. EXTRACT BITS 28-31
                DPY(ANS)<FA;                    "SAVE RIGHT JUSTIFIED BITS 0-27
                BFNE NOTZ2                      "BRANCH IF ANSWER ISN'T ZERO
ISZ2:   FAND DPY(M026),MD;                      "7. EXTRACT BITS 0-26
                DPY(ANS)<ZERO;                  "FORCE A ZERO ANSWER
                BR LOOP
NOTZ2:  FAND DPY(M026),MD;                      "7. EXTRACT BITS 0-26
                DPY(ANS)<DPX(TE); WRTEXP         "PACK TOGETHER
"
"AND NOW FINALLY, THE LOOP . . .
LOOP:           BFEQ NOTON;                     "1. BRANCH IF BIT 27 WAS NOT ON
                FSCALE FA; MOV N56,N56          "RIGHT JUSTIFY BITS 28-31
WASON:  ADD I,A; SETMA;                         "2. FETCH NEXT A
                FOR DPX(B27),FA; BR COMM        "OR BIT 27 INTO BITS 0-26
NOTON:  ADD I,A; SETMA;                         "2. FETCH NEXT A
                FOR ZERO,FA                     "OR BIT 27 INTO BITS 0-26
COMM:           FIX MD;                         "3. TEST FOR ABS(A).LT.0.5)
                DPX(TE)<FA;                     "SAVE BITS 28-31
                        DEC N
                FIX FA;                         "4. RIGHT JUSTIFY BITS 0-27
                LDSPI E; DB=DPX(TE);            "BITS 28-31 TO S-PAD
                        BEQ DONE                "BRANCH OUT WHEN N DOWN TO ZERO
        FAND DPY(M27),MD;                       "5. EXTRACT BIT 27
                MOV E,E; DPX(TE)<SPFN           "BITS 28-31 TO EXPONENT
        FAND DPX(M2831),MD;                     "6. EXTRACT BITS 28-31
                DPY(ANS)<FA;                    "SAVE RIGHT JUSTIFIED BITS 0-27
                BFNE NOTZ;                      "BRANCH IF ANSWER ISN'T ZERO
                        MI<DPY(ANS);            "STORE C
                        ADD K,C; SETMA
ISZ:    FAND DPY(M026),MD;                      "7. EXTRACT BITS 0-26
                DPY(ANS)<ZERO;                  "FORCE A ZERO ANSWER
                BR LOOP
NOTZ:   FAND DPY(M026),MD;                      "7. EXTRACT BITS 0-26
                DPY(ANS)<DPX(TE); WRTEXP;        "PACK TOGETHER EXPONENT
                BR LOOP                         "AND MANTISSA
"
"
DONE:   MI<DPY(ANS); ADD K,C; SETMA;            "STORE LAST C
        RETURN
"
"
"MASKS . . .
"
C27:   $VAL 0,41,142000,0        "134217728.0           1034,2000,0
C2831: $VAL 0,41,144000,0        "-268435456.0          1034,4000,0
C026:  $VAL 0,41,133777,177777   "134217727.0           1033,3777,177777
CB27:  $VAL 0,41,134000,0        "-134217728.0          1033,4000,0
        $END
"****** VUP16 = VECTOR 16-BIT BYTE UNPACK /COMMON/ = REL 3.2, AUG 80 *****
        $TITLE VUP16
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VUP16,5          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "TWO SIXTEEN BIT BYTES ARE UNPACKED FROM A SINGLE WORD OF
        "A SOURCE VECTOR A TO GIVE TWO FLOATING POINT WORDS IN A
        "DESTINATION VECTOR C.  IF BITS OF AN AP WORD ARE NUMBERED
        "0 TO 37 FROM LEFT TO RIGHT, THE BYTES ARE UNPACKED
        "       A(I)  6 TO 21  >  C(J)
        "       A(I) 22 TO 37  >  C(J+K)
        "THE DATA IS ASSUMED TO BE POSITIVE INTEGERS
        "FROM ZERO TO 65535.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER(APAL)
        "EQUIPMENT:     AP-120B WITH STANDRD OR FAST MEMORY
        "SIZE:          56 + SPUFLT (8) = 64 INSTRUCTIONS
        "SPEED:         .88 MICROSECONDS PER BYTE
"
"     ---HISTORY---
"ORIGINAL:  MAR 77  J. THROOP
" REVISED:  DEC 77  J. THROOP      FIXED SOME MINOR PROBLEMS
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REVISED:  AUG 80  T.E. SKINNER,  FIXED PERIODIC BUG - TAR #2135,
"                   R. GELLER      CLEANED-UP CODE FOR READABILITY,
"                                  PROVIDE PROPER HANDLING FOR CASE OF N=1
"                                  (PREVIOUSLY BEHAVED AS THOU N=2),
"                                  AND CORRECTED ADC LINKAGE
"
        "NAMES FOR S PAD
        A    $EQU  0                      "SOURCE VECTOR ADDRESS
        I    $EQU  1                      "SOURCE VECTOR INCREMENT
        C    $EQU  2                      "DESTINATION VECTOR ADDRESS
        K    $EQU  3                      "DESTITNATION VECTOR INCREMENT
        N    $EQU  4                      "SOURCE VECTOR LENGTH
        NM   $EQU 17
        EX   $EQU 17
        E47  $EQU 16
        E13  $EQU 15
        EXB  $EQU 14
        K3   $EQU 13
        E33  $EQU 12
        "NAMES FOR DPX
        TE   $EQU -1
        CB   $EQU -2
        NN   $EQU  1
        TA   $EQU  2
        "NAMES FOR DPY
        M4   $EQU -1
        B1   $EQU  1
"       TA   $EQU  2
        B0   $EQU  3
        M2   $EQU -2
        TMN  $EQU -3
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVU16,5                     "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/I/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVU16: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VUP16:  MOV N,NM
        JSR SPUFLT                        "DPX(1)=N., TM=1.
        DPX(CB)<ZERO;
          BFNE .+2                        "TEST FOR N=0
ZDONE:  RETURN                            "RETURN IF N=0
        RPSF MSK4; DPY(M4)<DB
        RPSF MSK2; DPY(M2)<DB
        LDSPI EXB; DB=1000
        LDSPI E33; DB=33
        LDSPI E47; DB=47
        LDSPI E13; DB=13
        MOV K,K3
        ADD K,K3
        ADD K,K3
        MOV A,A; SETMA                    "FETCH A(0)
        SUB K,C
        SUB K,C
        RPSF M2048; DPY(TMN)<DB
        LDSPE EX; DB=MD;                  "GET EXP BITS OF A(0)
          DPX<MD                          "STORE A(0)
        ADD EXB,EX                        "ADD BIAS TO EXP BITS OF A(0)
        MOV EX,EX; DPX(TE)<SPFN           "EXB BITS OF A(0) TO DPX(TE)
        FADD ZERO,MDPX(TE); MOV E47,E47   "FLOAT EXP BITS OF A(0)
        FADD ZERO,MDPX; MOV E33,E33       "TEST SB OF A(0)
        FAND DPY(M4),MDPX; MOV E13,E13;   "FLOAT MANTISSA BITS OF A(0)
          DPX(TE)<FA                      "SAVE FLOATED EXP BITS OF A(0)
        ADD I,A; SETMA;                   "FETCH A(1)
          FADD
        FAND DPY(M2),MDPX; MOV E33,E33;   "FLOAT LMN OF A(0)
          DPX(TA)<FA;                     "SAVE FLOATED MANT BITS OF A
          BFGE PSN1                       "BRANCH IF A(0) WAS POSITIVE
        FOR DPY(TMN),DPX(TA)              "FOR IN 4096.
        LDSPE EX; DB=MD;                  "GET EXP BITS OF A(1)
          DPX<MD;                         "SAVE A(1)
          FADD DPX(CB),FA                 "ADD BIAS TO BYTE0
        ADD EXB,EX;                       "ADD BIAS TO EXP BITS OF A(1)
         FOR DPX(TE),FA;                  "FOR IN FLOATED EXP BITS OF A(0)
         BR ENTA
PSN1:   DPY(TA)<DPX(TA);
          FADD
        LDSPE EX; DB=MD;                  "GET EXP BITS OF A(1)
          DPX<MD;                         "SAVE A(1)
          FADD DPX(CB),FA                 "ADD BIAS TO BYTE0 OF A(0)
        ADD EXB,EX;                       "ADD BIAS TO EXP BITS OF A(1)
          FOR DPX(TE),DPY(TA)             "FOR IN FLOATED EXP BITS OF A(0)
ENTA:   MOV EX,EX; DPX(TE)<SPFN;          "EXP BITS OF A(1) TO DPX(TE)
          DPY(B0)<FA;                     "SAVE BYTE0 OF A(0)
          FSUBR TM,DPX(NN)                "DECREMENT COUNTER
        FADD ZERO,MDPX(TE); MOV E47,E47;  "FLOAT EXP BITS OF A(1)
          DPY(B1)<FA                      "SAVE BYTE1 FROM A(0)
        FADD ZERO,MDPX; MOV E33,E33;      "TO TEST SIGN OF A(1)
          DPX(NN)<FA                      "SAVE COUNTER
        ADD K3,C; SETMA; MI<DPY(B0);      "STORE BYTE0 OF A(0)
          BFEQ NEQONE                     "TEST FOR N=1
        FAND DPY(M4),MDPX; MOV E13,E13;   "FLOAT MANTISSA BITS OF A(1)
          DPX(TE)<FA                      "SAVE FLOATED EXP BIT OF A(1)
LOOP:   ADD I,A;SETMA;                    "FETCH A(I)
          FADD DPX(CB),DPY(B1)            "ADD BIAS TO BYTE1 OF A(I-2)
        FAND DPY(M2),MDPX; MOV E33,E33;   "FLOAT BYTE0 OF A(I-1)
          DPX(TA)<FA;                     "SAVE
          BFGE PSN
        FOR DPY(TMN),DPX(TA);             "COMBE SB + MB OF A(I-1)
          SUB K,C; SETMA; MI<FA           "STORE BYTE1 OF A(I-2)
        LDSPE EX; DB=MD;                  "GET EXP BITS OF A(I)
          DPX<MD;                         "SAVE A(I)
          FADD DPX(CB),FA                 "ADD BIAS TO BYTE0 OF A(I-1)
        ADD EXB,EX;                       "ADD EXP BIAS TO EXP BITS OF A(I)
          FOR DPX(TE),FA                  "COMBINE FLOATED EXP BITS OF A(I-1)
ENT:    MOV EX,EX; DPX(TE)<SPFN;          "EX BITS OF A(I) TO DPX(TE)
          DPY(B0)<FA                      "SAVE BYTE0 OF A(I-1)
        FSUBR TM,DPX(NN);                 "DECREMENT COUNTER
          ADD K3,C;SETMA;MI<DPY(B0)       "STORE BYTE0 OF A(I-1)
        FADD ZERO,MDPX(TE); MOV E47,E47;  "FLOAT EXP BITS OF A(I)
          DPY(B1)<FA                      "SAVE BYTE1 OF A(I-1)
        FADD ZERO,MDPX; MOV E33,E33;
          DPX(NN)<FA                      "STORE COUNTER
        FAND DPY(M4),MDPX; MOV E13,E13;   "TO GET MANTISSA BITS
          DPX(TE)<FA;                     "SAVE FLOATED EXP BITS OF A(I)
          BFGT LOOP
        RETURN; SUB K,C; SETMA; MI<DPY(B1)
NEQONE: FADD DPX(CB),DPY(B1)              "CASE OF N=1
        FADD
        SUB K,C; SETMA; MI<FA;
          RETURN
PSN:    DPY(TA)<DPX(TA);
          FADD;
          SUB K,C; SETMA; MI<FA           "STORE BYTE1 OF A(I-2)
        LDSPE EX; DB=MD;
          DPX<MD;
          FADD DPX(CB),FA
        ADD EXB,EX;
          FOR DPX(TE),DPY(TA);
          BR ENT
CFB:    $FP -32768.
MSK4:   $VAL 0,40,133777,0
MSK2:   $VAL 0,41,130000,177777
M2048:  $FP 2048.
        $END
"****** VUPS16 = VECTOR 16-BIT SIGNED BYTE UNPACK /COMMON/= REL 3.2, AUG 80 ***
        $TITLE VUPS16
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VUPS16,5                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "TWO SIXTEEN BIT TWOS COMPLEMENT BYTES ARE UNPACKED
        "FROM A SINGLE WORD OF SOURCE VECTOR A AND STORED IN TWO WORDS
        "OF DESTINATION VECTOR C.  IF BITS OF AN AP WORD ARE NUMBERED
        "FROM 0 TO 37 FROM LEFT TO RIGHT, THE BYTES ARE UNPACKED
        "       A(I)  6 TO 21  >  C(J)
        "       A(I) 22 TO 37  >  C(J + K).
        "BYTES ARE UNPACKED FROM LEFT TO RIGHT.
        "BYTES RANGE IN VALUE FROM -32768 TO +32767.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER(APAL)
        "EQUIPMENT:     AP-120B WITH STANDARD OR FAST MEMORY
        "SIZE:          51 + SPUFLT (8) = 59 INSTRUCTIONS
        "SPEED:         1.25 MICROSECONDS PER BYTE
"
"     ---HISTORY---
"ORIGINAL:  MAR 77  J. THROOP
" REVISED:  DEC 77  J. THROOP      FIXED SOME MINOR PROBLEMS
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80  R. GELLER      CORRECT ADC LINKAGE
"
        "NAMES FOR S PAD
        A $EQU 0                        "SOURCE VECTOR ADDRESS
        I $EQU 1                        "SOURCE VECTOR INCREMENT
        C $EQU 2                        "DESTINATION VECTOR ADDRESS
        K $EQU 3                        "DESTINATION VECTOR INCREMENT
        N $EQU 4                        "SOURCE VECTOR LENGTH
        NM $EQU 17
        EX $EQU 17
        EXB $EQU 16
        ET $EQU 15
        EBITS $EQU 14
        ENEG $EQU 13
        E47 $EQU 12
        E13 $EQU 11
        E33 $EQU 10
        EY $EQU 7
        K3 $EQU 6
        "NAMES FOR DPY
        MSKM $EQU -1
        TMN $EQU -2
        "NAMES FOR DPX
        TE $EQU 2
        C0 $EQU 1
        C1 $EQU 3
        NN $EQU 1
        T $EQU -4
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVUS16,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/I/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVUS16: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VUPS16:  MOV N,NM
        JSR SPUFLT
        DPY(NN)<DPX(NN);
          BFNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        RPSF MSKMT; DPY(MSKM)<DB
        RPSF MSKN; DPY(TMN)<DB
        LDSPI E33; DB=33
        LDSPE EXB; DB=1000
        LDSPI ET; DB=10
        LDSPI EBITS; DB=7
        LDSPI ENEG; DB=177770
        LDSPI E47; DB=47
        LDSPI E13; DB=13
        MOV K,K3
        ADD K,K3
        ADD K,K3
        MOV A,A; SETMA                  "FETCH A0
        SUB K,C
        SUB K,C
        LDSPE EX; DB=MD;                "EXP BITS OF B1 TO S PAD
        DPX<MD
        ADD EXB,EX                      "ADD BIAS TO EX
        AND# ET,EX                      "TO SEE IF A NEGATIVE NUMBER
        AND EBITS,EX;                   "TO GET SIGNIFICANT BITS OF EX
        BEQ PSE1                        "BRQNCH IF POSITIVE
        OR ENEG,EX                      "IF NEGATIVE, THEN SIGN EXTEND
PSE1:   LDSPI EY; DB=DPX                        "B0 TO SPAD
        MOV EY,EY; DPX(T)<SPFN          "B0 BACK TO DPX WITH SIGH EXTENDED
        FADD ZERO,MDPX(T); MOV E33,E33          "FLOAT B0
        MOV EX,EX; DPX(TE)<SPFN;
        FADD
        FADD ZERO,MDPX; MOV E33,E33;
        DPX(C0)<FA                      "SAVE BYTE0
        FADD ZERO,MDPX(TE); MOV E47,E47;        "FLOAT EX BITS OF B1
        BR LOOP
PSN:            ADD K3,C; SETMA; MI<DPX(C0);
                FADD;
                DPX(TE)<FA
                FADD ZERO,FA;
                BR ENTB
LOOP:   ADD I,A; SETMA                  "FETCH A
                BFGE PSN;                       "BRANCH IF SIGN BIT NOT SET
                FAND DPY(MSKM),MDPX; MOV E13,E13        "FLOAT MANTISSA BITS OF
        ADD K3,C; SETMA; MI<DPX(C0);              "STORE BYTE0
                FADD;
                DPX(TE)<FA                      "SAVE FLOATED EXP BITS OF B1
                FOR DPY(TMN),FA                 "SIGN BIT WAS SET SO,PUT IN 2048
ENTB:   LDSPE EX; DB=MD;                        "EXP BITS OF B1 TO EXP
        DPX<MD;                 "SAVE A
                FADD
        ADD EXB,EX;                     "ADD BIAS TO EX BITS OF B1
                FOR DPX(TE),FA          "COMBINE FLOATED MANTISSA
                                "WITH FLOATED EXP BITS OF B1
        AND# ET,EX;                     "TO SEE IF B1 IS A NEGATIVE NUMBER
                FADD
        AND EBITS,EX;                           "TO GET SIGNIFICQNT BITS OF B1 E
        BEQ PSE;                                "BRANCH IF B1 POS
                DPX(C1)<FA                      "STORE BYTE1
        OR ENEG,EX                      "SIGN EXTEND B1
ENTA:   LDSPI EY; DB=DPX;                       "B0 TO S PAD
                FSUBR TM,DPY(NN)                "DECREMENT COUNTER
        MOV EY,EY; DPX(T)<SPFN;                 "BO BACK TO DOX WITH SIGN EXTEND
                FADD
        FADD ZERO,MDPX(T); MOV E33,E33;         "FLOAT B0
                DPY(NN)<FA                      "SAVE COUNTER
        MOV EX,EX; DPX(TE)<SPFN;                "EX BITS TO DPX SO THEY WILL FLO
        FADD ZERO,MDPX;                 "TO SEE IF SIGN BIT WAS SET IN B1
        BFGT NEXT                       "BRANCH IF NOT DONE
                SUB K,C; SETMA; MI<DPX(C1);             "PUT OUT LAST BYTE1
                RETURN                  "FINISHED
NEXT:   DPX(C0)<FA;                     "SAVE BYTE0
                SUB K,C; SETMA; MI<DPX(C1)              "STORE BYTE1
        FADD ZERO,MDPX(TE); MOV E47,E47;        "FLOAT EXP BITS OF B1
        BR LOOP
PSE:    BR ENTA
MSKMT:  $VAL 0,40,133777,0
MSKN:   $VAL 0,40,142000,0
        $END
"****** VPK16 = VECTOR 16-BIT BYTE PACK /COMMON/ = REL 3.2, AUG 80 *****
        $TITLE VPK16
        $RADIX 8
        XADC    $EQU 1
        $ENTRY VPK16,5
        "TWO WORDS FROM A SOURCE VECTOR ARE PACKED AS SIXTEEN BIT
        "BYTES IN A SINGLE WORD OF THE DESTINATION VECTOR.
        "IF THE SOURCE NUMBES ARE REGARDED AS TWOS COMPLEMENT
        "NUMBERS, THEN VALUES FROM -32768 TO 32767 ARE PACKED.
        "IF THE SOURCE NUMBERS ARE REGARDED AS POSITIVE INTEGERS,
        "THEN VALUES FROM ZERO TO 65535 ARE PACKED.
        "IF BITS OF AN AP WORD ARE NUMBERED 0 TO 37 FROM LEFT TO RIGHT
        "THE BYTES ARE PACKED
        "       A(M)    >  C(J)   6 TO 21
        "       A(M+I)  >  C(J)  22 TO 37
        "BYTES ARE PACKED FROM LEFT TO RIGHT.
        "VPK16 DOES NOT CHECK FOR NUMBERS OUT OF RANGE.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER(APAL)
        "EQUIPMENT:     AP-120B WITH STANDARD OR FAST MEMORY
        "SIZE:          52 LOCATIONS
        "SPEED:         1. MICROSECONDS PER BYTE
        "                       7. MICROSECONDS SETUP
        " --- HISTORY ---
        "ORIGINAL: MAR 1977 J THROOP
        "        : FEB 1979 P PINCUS  FIXED SOME BUGS TO ALLOW NEGATIVE NUMBERS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80  R. GELLER      CORRECT ADC LINKAGE
        "                               IN UPPER BYTE CORRECTLY
        "NAMES FOR S PAD
        A $EQU 0                        "SOURCE VECTOR ADDRESS
        I $EQU 1                        "SOURCE VECTOR INCREMENT
        C $EQU 2                        "DESTINATION VECTOR ADDRSS
        K $EQU 3                        "DESTINATION VECTOR INCREMENT
        N $EQU 4                        "VECTOR LENGTH
        EX $EQU 17
        EXB $EQU 16
        E17 $EQU 15
        E14 $EQU 14
        I3 $EQU 13
        CL $EQU 12
        E15 $EQU 11
        "NAMES FOR DPX
        ANS $EQU 0
        TE $EQU 2
        TA $EQU 3
        B0 $EQU -1
        TB $EQU 1
        TMP $EQU -2
        "NAMES FOR DPY
        MSK $EQU -2
        MN8 $EQU -3
        MNM $EQU -4
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVPK16,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/I/OP, P4/I/IP,
                    P5/I/IP
FVPK16: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VPK16:  LDSPI EXB; DB=1000
        LDSPI E17; DB=17
        LDSPI E15;DB=15
        LDSPI E14; DB=14
        RPSF MSKMN; DPY(MNM)<DB
        RPSF MNB; DPY(MN8)<DB
        RPSF MSKN; DPY(MSK)<DB
        "THIS PROGRAM WAS ORIGINALLY WRITTEN TO PACK BYTES FROM
        "RIGHT TO LEFT IN THE DESTINATION VECTOR.  THE
        "FOLLOWING PUSSYFOOTING WITH S PADS IS TO MAKE THE
        "PROGRAM PACK BYTES FROM LEFT TO RIGHT.
        MOVL I,I3
        ADD I,I3
        SUB I,A
        SUB I,A
        ADD I3,A; SETMA                 "FETCH A0(0)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        SUB I,A; SETMA;                 "FETCH A1(0)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        SUB K,C                 "BACK UP C POINTER
        DPX(B0)<MD;                     "SAVE A0(0)
         INC N
        FIXT MD                 "FIX A1(0)
        FIXT DPX(B0)                    "FIX A0(0)
        DPX(TA)<FA;                     "SAVE FIXED A1(0)
        FAND DPY(MNM),FA                        "TO GET 11MB OF A1(0)
        CLR CL;DPX(TMP)<SPFN            "CLEAR DPX(TMP)
        DPX(TMP)<DPX(TA);WRTLMN         "WRITE MAN ONLY
        FSCLT DPX(TMP); MOV E15,E15;             "TO GET EXP BITS OF A1(0)
        DPY(B0)<FA                      "SAVE FIXED A0(0)
        ADD I3,A; SETMA;                 "FETCH A0(1)
                FAND DPY(MSK),DPX(TA);          "TO TEST FOR SB IN A1(0)
                DPX(TB)<FA              "SAVE 11MB OF A1(0)
                FOR DPY(MN8),DPX(TB);           "COMBINE SV + 11MB OF A1(0)
                DPX(TE)<FA              "SAVE EXP BITS OF A1(0)
        SUB I,A; SETMA;                 "FETCH A1(1)
                FADD
                BFEQ PSN1               "BRANCH IF SB OF A1(1) NOT TO BE SET
        DPX(B0)<MD;                     "SAVE A0(1)
                FSCLT FA; MOV E14,E14;  "UNNORMALIZE SB + 11MB OF A1(0)
                BR ENT1
PSN1:   DPX(B0)<MD;                     "SAVE A0(1)
        FSCLT DPX(TB); MOV E14,E14      "UNNORMALIZE 11MB OF A1(0)
ENT1:   FIXT MD;                        "FIX A1(1)
                DPY(ANS)<DPY(B0)                "BYTE0(0)<LMN
                LDSPI EX; DB=DPX(TE)
        FIXT DPX(B0);                   "FIX A0(1)
                DPY(ANS)<FA; WRTHMN             "SB + 11MB OF A1(0)<HMN
        DPX(TA)<FA;                     "SAVE FIXED A1(1)
        FAND DPY(MNM),FA;                        "GET 11MB OF A1(1)
                AND E17,EX              "GET 4 BITS OF EXP
        CLR CL;DPX(TMP)<SPFN            "SET UP ZERO
        DPX(TMP)<DPX(TA);WRTLMN         "WRITE ONLY LO MAN 16 BITS
        FSCLT DPX(TMP); MOV E15,E15;             "GET EXP BITS OF A(1)
        DPY(B0)<FA                      "SAVE FIXED A0(1)
LOOP:   ADD I3,A; SETMA;                 "FETCH A0(I+2)
                FAND DPY(MSK),DPX(TA);          "TO SEE IF SB OF A1(I+1) IS TO B
                DPX(TB)<FA                      "SAVE 11MB OF A1(I+1)
                FOR DPY(MN8),DPX(TB);           "COMBINE SB + 11MB OF A1(I+1)
                DPX(TE)<FA;                     "SAVE EXP BITS OF A1(I+1)
                        DEC N           "DECREMENT COUNTER
        SUB I,A; SETMA;                 "FETCH A1(I+2)
                FADD;
                        DPX(ANS)<DPY(ANS);
                        BNE NEXT
                        RETURN
NEXT:           BFEQ PSN;               "BRANCH IF SB OF A1(I+1) NOT TO BE SET
                        SUB EXB,EX; WRTEX;      "PUT IN EXP BITS OF A1(I)
                        DPX(ANS)<SPFN
        DPX(B0)<MD;                     "SAVE A0(I+2)
                FSCLT FA; MOV E14,E14                   "UNNORMALIZE SB + 11MB O
ENT:    LDSPI EX;DB=DPX(TE)             "GET EXP
        FIXT MD;                        "FIX A1(I+2)
                DPY(ANS)<DPY(B0);
                  AND E17,EX            "MASK ON FOUR BITS
        FIXT DPX(B0);                   "FIX A0(I+2)
                DPY(ANS)<FA; WRTHMN            "SB + 11MB OF A1(I+1) TO HMN
        DPX(TA)<FA;                     "SAVE FIXED A1(I+2)
        FAND DPY(MNM),FA;                       "GET 11MB IF A1(I+2)
                        ADD K,C; SETMA;
                        MI<DPX(ANS)                     "STORE A1(I)A0(I)
        CLR CL;DPX(TMP)<SPFN            "SET UP ZERO
        DPX(TMP)<DPX(TA);WRTLMN         "WRITE LO MAN ONLY 16 BITS
        FSCLT DPX(TMP); MOV E15,E15;                     "GET EXP BITS OF A1(I+2
        DPY(B0)<FA;                     "SAVE FIXED A0(I+2)
        BR LOOP
PSN:    DPX(B0)<MD;                     "SAVE FIXED A0(I+2)
                FSCLT DPX(TB); MOV E14,E14;     "UNNORMALIZE 11MB OF A1(I+1)
                BR ENT
MSKN:   $VAL 0,41,130000,4000
MNB:    $FP -2048.
MSKMN:   $VAL 0,41,130000,3777
        $END
"****** VUP8 = VECTOR 8-BIT BYTE UNPACK /COMMON/ = REL 3.2, AUG 80 *****
        $TITLE VUP8
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VUP8, 5                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "FOUR EIGHT BIT BYTES ARE UNPACKED FROMA A SINGLE MD WORD FROM
        "SOURCE VECTOR A TO GIVE FOUR FLOATING POINT WORDS IN DESTINATION VECTOR
        "IF BITS OF AN AP WORD ARE NUMBERED O TO 37 FROM LEFT TO RIGHT,
        "THE BYTES ARE UNPACKED
        "       A(I)  6 TO 13  > C(J)
        "       A(I) 14 TO 21  >  C(J+K)
        "       A(I) 22 TO 29  >  C(J + 2K)
        "       A(I) 30 TO 37  >  C(J+3K)
        "THE BYTES ARE ASSUMED TO BE POSITIVE NUMBERS FROM ZERO TO +255.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER(APAL)
        "EQUIPMENT:     AP-120B WITH STANDARD OR FAST MEMORY
        "SIZE:          64 + SPUFLT (8) = 72 INSTRUCTIONS
        "SPEED:         .5 MICROSECONDS PER BYTE OR 2 PER SOURCE WORD
"     ---HISTORY---
"ORIGINAL:  MAR 77  J. THROOP
" REVISED:  DEC 77  J. THROOP     FIXED SOME MINOR PROBLEMS
" REVISED:  JULY 78 J. THROOP     FIXED ERROR IN FIRST BYTE OF SECOND WORD
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80  R. GELLER      CORRECT ADC LINKAGE
"
        "NAMES FOR S PAD
        A $EQU 0                        "SOURCE VECTOR ADDRESS
        I $EQU 1                        "SOURCE VECTOR INCREMENT
        C $EQU 2                        "DESTINATION VECTOR ADDRESS
        K $EQU 3                        "DESTINATION VECTOR INCREMENT
        N $EQU 4                        "SOURCE VECTOR LENGTH
        NM $EQU 17
        EX $EQU 17
        EXB $EQU 16
        E3 $EQU 15
        E37 $EQU 14
        C33 $EQU 13
        C23 $EQU 12
        C13 $EQU 11
        "NAMES FOR DATA PAD
        M1 $EQU 0
        M2 $EQU 1
        M3 $EQU 2
        M4 $EQU 3
        T1 $EQU -4
        T2 $EQU -3
        T3 $EQU -1
        TE $EQU 2
        TMN $EQU -3
        TA $EQU -2
        NN $EQU 1
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVUP8,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/I/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVUP8: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VUP8:    MOV N,NM
        JSR SPUFLT
        RPSF MSKN; DPY(TMN)<DB
        RPSF MSK1; DPY(M1)<DB
        RPSF MSK2; DPY(M2)<DB
        RPSF MSK3; DPY(M3)<DB
        RPSF MSK4; DPY(M4)<DB
        LDSPI E37; DB=37;
        FSUBR TM,DPX(NN)
        LDSPI E3; DB=3; FADD
        LDSPI EXB; DB=1000;
        DPX(NN)<FA
        LDSPI C33; DB=33
        LDSPI C23; DB=23
        LDSPI C13; DB=13
        MOVL# EXB,EXB; DPY(T1)<SPFN; WRTEX
        MOV A,A; SETMA
        SUB K,C
        MOV N,N                 "IS ELEMENT COUNT = 0?
        LDSPE EX; DB=MD;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        ADD EXB,EX; DPX(TE)<SPFN                        "ADD BIAS AND WRITE TO S
        DPX<MD                  "STORE A(0)
        FADD ZERO,MDPX(TE); MOV E37,E37         "FLOAT EXP BITS OF BYTE ZERO
        DPX<DPY(T1); WRTEXP
        FADD ZERO,DPX                   "TO SEE IF SIGN BIT SET
        FAND DPY(M4),MDPX; MOV E3,E3;           "TO FLOAT MANTISSA BITS OF B0
        DPX(TE)<FA                      "SAVE FLOATED EXP BITS
        FADD
                BFGE PSN1;                      "BRANCH IF SIGN BIT NOT SET
                DPX(TA)<FA;
                FAND DPY(M3),MDPX; MOV C13,C13          "FLOAT BYTE 1
        ADD I,A; SETMA;                 "FETCH A(1)
                FADD DPY(TMN),DPX(TA)           "AND 8. FOR SIGN BIT
                FAND DPY(M2),MDPX; MOV C23,C23;         "GET BYTE 2
                DPY(T3)<FA;
                BR ENT1
PSN1:   ADD I,A; SETMA;                         "FETCH A(1)
                FADD ZERO,DPX(TA)               "
                FAND DPY(M2),MDPX; MOV C23,C23;          "GET BYTE 2
                DPY(T3)<FA
ENT1:           DPY(TA)<FA;
                FAND DPY(M1),MDPX; MOV C33,C33          "GET BYTE 3
        LDSPE EX; DB=MD;                        "GET EXP BITS OF A(1)
                FADD DPX(TE),DPY(TA);           "GET BYTE 0 FROM A(0)
                DPX(T2)<FA
                DPX(T1)<FA                      "SAVE BYTE 3 FROM A(0)
        ADD EXB,EX; DPX(TE)<SPFN;              "ADD BIAS AND EXP BITS OF A(1) TO
                FADD
        DPX<MD;
                ADD K,C; SETMA; MI<FA           "STORE BYTE 0 FROM A(0)
        FADD ZERO,MDPX(TE); MOV E37,E37         "FLOAT EXP BITS OF A(1)
        DPX<DPY(T1); WRTEXP                     "PATCH OF JULY 78
        FADD ZERO,DPX;                          "TO SEE UF SIGN BIT OF A(1) IS O
                ADD K,C; SETMA; MI<DPY(T3)      "STORE BYTE 1 OF A(0)
        FAND DPY(M4),MDPX; MOV E3,E3;           "GET MANTISSA BITS OF A(1)
        DPX(TE)<FA
        FADD;
                ADD K,C; SETMA; MI<DPX(T2)      "STORE BYTE 2 OF A(0)
LOOP:           BFGE PSN;
                DPX(TA)<FA;
                FAND DPY(M3),MDPX; MOV C13,C13  "GET BYTE1 OF A(I-1)
        ADD I,A; SETMA;                         "GET A(I-2)
                FADD DPY(TMN),DPX(TA)          "ADD 8. TO BYTE 0 OF A(I-1)
                FAND DPY(M2),MDPX; MOV C23,C23; "GET BYTE 2 FROM A(I-1)
                DPY(T3)<FA
ENT:            DPY(TA)<FA;
                FAND DPY(M1),MDPX; MOV C33,C33
        LDSPE EX; DB=MD;                        "GET EXP BITS FROM A)(I-2)
                FADD DPX(TE),DPY(TA);
                DPX(T2)<FA
                DPX(T1)<FA;                     "STORE BYTE 3 FROM A(I-1)
                ADD K,C; SETMA;
                        MI<DPX(T1)              "
        ADD EXB,EX; DPX(TE)<SPFN;               "ADD BIAS TO EXP BITS OF A(I-2)
                        FSUBR TM,DPX(NN)        "DECREMENT COUNTER
        DPX<MD;                                 "STORE A(I-2)
                ADD K,C; SETMA; MI<FA;          "STORE BYTE 0 OF A(I:1)
                FSUBR TM,DPX(NN)
        FADD ZERO,MDPX(TE);                     "FLOAT EXP BITS OF A(I-2)
        MOV E37,E37
        DPX<DPY(T1); WRTEXP; BFGT NEXT
        ADD K,C; SETMA; MI<DPY(T3); BR OUT
NEXT:   FADD ZERO,DPX;                          "TO SEE IF SB OF A(I-2) IS ON
                ADD K,C; SETMA; MI<DPY(T3);
                DPX(NN)<FA
        FAND DPY(M4),MDPX; MOV E3,E3;
        DPX(TE)<FA
        FADD;
                ADD K,C; SETMA; MI<DPX(T2);     "STORE BYTE 2 OF A(I-1)
                BR LOOP
PSN:    ADD I,A; SETMA;                         "GET A(I-2)
                FADD ZERO,DPX(TA)
                FAND DPY(M2),MDPX; MOV C23,C23;
                DPY(T3)<FA;
                BR ENT
OUT:    ADD K,C; SETMA; MI<DPX(T2)
        ADD K,C; SETMA; MI<DPX(T1); RETURN
MSKN:   $VAL 0,40,42000,0
MSK1:   $VAL 0,41,130000,377
MSK2:   $VAL 0,41,30000,177400
MSK3:   $VAL 0,40,130377,0
MSK4:   $VAL 0,40,33400,0
        $END
"****** VUPS8 = VECTOR 8-BIT SIGNED BYTE UNPACK /COMMON/ = REL 3.2, AUG 80
        $TITLE VUPS8
        $RADIX 8
        XADC    $EQU 1
        $ENTRY VUPS8, 5
        $EXT SPUFLT
        "FOUR EIGHT BIT BYTES ARE UNPACKED FROM A SINGLE MD WORD FROM
        "SOURCE VECTOR A TO GIVE FOUR FLOATING POINT WORDS IN DESTINATION VECTOR
        "IF BITS OF AN AP WORD ARE NUMBERED O TO 37 FROM LEFT TO RIGHT,
        "THE BYTES ARE UNPACKED
        "       A(I)  6 TO 13  >  C(J)
        "       A(I) 14 TO 21  >  C(J+K)
        "       A(I) 22 TO 29  >  C(J+2K)
        "       A(I) 30 TO 37  >  C(J+3K).
        "BYTES ARE UNPACKED FROM LEFT TO RIGHT WITHIN A MD WORD
        "THE BYTES AREE ASSUMED TO BE TWOS COMPLEMENT NUMBERS
        "FROM -128 TO +127.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER(APAL)
        "EQUIPMENT:     AP-120B WITH STANDARD OR FAST MEMORY
        "SIZE:          100 + SPUFLT (8) = 108 INSTRUCTIONS
        "SPEED:         835 NANOSECONDS PER BYTE
"     ---HISTORY---
"ORIGINAL:  MAR 77  J. THROOP
" REVISED:  DEC 77  J. THROOP     FIXED SOME MINOR PROBLEMS
" REVISED:  JUNE 78 J. THROOP     FIXED PROBLEMS WITH FIRST BYTE
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80  R. GELLER      CORRECT ADC LINKAGE
"          FEB 79 P PINCUS        FIXED MORE PROBLEMS WITH FIRST BYTE
"                                  EXTRA MOV INSTRUCTION IN "THIRT:"
"
        "NAMES FOR S PAD
        A $EQU 0                        "SOURCE VECTOR ADDRESS
        I $EQU 1                        "SOURCE VECTOR INCREMENT
        C $EQU 2                        "DESTINATION VECTOR ADDRESS
        K $EQU 3                        "DESTINATION VECTOR INCREMENT
        N $EQU 4                        "SOURCE VECTOR LENGTH
        NM $EQU 17
        EX $EQU 17
        EXB $EQU 16
        E3 $EQU 15
        E7 $EQU 14
        E13 $EQU 13
        E23 $EQU 12
        E33 $EQU 11
        E10 $EQU 6
        ET7 $EQU 10
        E37 $EQU 7
        "NAMES FOR DPY:
        MB0 $EQU -4
        MB1 $EQU -3
        MB2 $EQU -2
        MB3 $EQU -1
        SB1 $EQU 1
        SB2 $EQU 2
        SB3 $EQU 3
        T0 $EQU 2
        T1 $EQU 0
        "NAMES FOR DPX:
        TE $EQU -1
        C8 $EQU -4
        T2 $EQU -2
        T3 $EQU 3
        TEXP $EQU -3
        NN $EQU 1
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVUPS8,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/I/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVUPS8: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VUPS8:  MOV N,NM
        JSR SPUFLT
        RPSF CF128; DPY<DB
        RPSF MSK8; DPX(C8)<DB
        RPSF MSK1; DPY(MB1)<DB
        RPSF MSK2; DPY(MB2)<DB
        RPSF MSK3; DPY(MB3)<DB
        RPSF MSK0; DPY(MB0)<DB
        RPSF MSB1; DPY(SB1)<DB
        RPSF MSB2; DPY(SB2)<DB
        RPSF MSB3; DPY(SB3)<DB
        LDSPI E37; DB=37
        LDSPI E3; DB=3
        LDSPI EXB; DB=1000
        LDSPI E7; DB=7
        LDSPI E33; DB=33
        LDSPI E23; DB=23
        LDSPI E13; DB=13
        LDSPI E10; DB=10
        MOV E7,ET7;
        DPX(SB2)<DPY(SB2)
        MOVL# EXB,EXB; DPX(TEXP)<SPFN; WRTEX    "DUMMY EXPONENT FOR SIGN TEST
        MOV A,A; SETMA;
        FSUBR TM,DPX(NN)                        "DECREMENT COUNTER
        SUB K,C;
        FADD
        FMUL TM,DPY;                     "-128 IS STORED IN FM
        DPX(NN)<FA;                     "STORE COUNTER
        MOV EXB,EX
        DPX<MD; LDSPE EX; DB=MD;                "GET EXP BITS OF B0
        FMUL
        DPX<DPX(TEXP); WRTEXP                   "EXPONENT FOR SIGN TEST
        FADD ZERO,DPX;                  "TO SEE IF SIGN BIT IS SET IN B0
          MOV N,N               "IS ELEMENT COUNT = 0?
        FAND DPY(MB0),MDPX; MOV E3,E3;          "FLOAT 3MB OF B0
        FMUL;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        ADD EXB,EX;                     "ADD BIAS TO EXP BITS OF B0
        FADD
        BFGE PSN0;                      "BRANCH IF SIGN BIT NOT SET IN B0
        DPY(T0)<FA;                     "STORE 3MB OF B0
        AND EX,E7; DPX(TE)<SPFN                "EXP BITS TO DATA PAD
        FADD DPX(C8),DPY(T0);           "ADD 8 TO B0 FOR SB
        AND E10,EX; BR TEN0             "TO SEE IF B0<0
PSN0:   FADD ZERO,DPY(T0);
        AND E10,EX;
        BR TEN0
TEN0:   FAND DPY(SB1),MDPX;             "TEST SIGN OF B1
        MOV E13,E13; BEQ PSE0           "BRANCH IF B0<0
        FADD FM,MDPX(TE);              "FLOAT EXP BIT OF B0
        MOV E37,E37; DPY(T0)<FA; "SAVE 3MB + SB OF B0
        BR PS9
PSE0:   FADD ZERO,MDPX(TE);
        MOV E37,E37; DPY(T0)<FA         "SAVE SB + 3MB OF B0
PS9:    FAND DPY(MB1),MDPX; MOV E13,E13 "FLOAT B1
        FADD DPY(T0),FA;                        "GET B0
        BFEQ PS10
        MOV ET7,E7;                     "BECAUSE E7 WAS CLOBBERED
        FADD FM,FA;                     "B1<0 SO ADD -128
        BR FIFT0
PS10:   FADD ZERO,FA;
        MOV ET7,E7                      "BECAUSE E7 WAS CLOBBERED
FIFT0:  ADD K,C; SETMA; MI<FA;          "STORE B0
                FADD;
        DPY(SB2)<DPX(SB2)
        FAND DPY(SB2),MDPX; MOV E23,E23;        "TEST SIGN OF B2
        DPY(T1)<FA                      "SAVE B1
        ADD K,C; SETMA; MI<DPY(T1);             "STORE B1
        FADD
        FAND DPY(MB2),MDPX; MOV E23,E23 "FLOAT B2
        BFEQ ONEP;
        MOV EXB,EX
        FAND DPY(SB3),MDPX; MOV E33,E33 "TEST SIGN OF B3
        ADD I,A; SETMA;
                FADD FM,FA; BR THREE
ONEP:           FAND DPY(SB3),MDPX; MOV E33,E33 "TEST SIGN OF B3
        ADD I,A; SETMA;
                FADD ZERO,FA; BR THREE
FOUR:   ADD K,C; SETMA;         "STORE B2
                MI<FA; BFEQ PS3         "BRANCH IF B3<0
        DPX<MD; LDSPE EX; DB=MD                 "GET EXP BITS OF B0
        DPX<DPX(TEXP); WRTEXP
        FADD ZERO,DPX                   "TO SEE IF SIGN BIT OF B0 IS ON
        FAND DPY(MB0),MDPX; MOV E3,E3;  "GET 3MB OF B0
                DPX(T3)<FA
        ADD EXB,EX;                     "ADD BIAS TO EXP BITS
        FADD FM,DPX(T3);                "ADD -128 TO B3
                BR EIGHT
PS3:    DPX<MD; LDSPE EX; DB=MD                 "GET EXP BITS OF B0
        DPX<DPX(TEXP); WRTEXP                   "TO SET EXPONENT FOR SIGN TEST
        FADD ZERO,DPX           "TO SEE IF SIGN BIT OF B0 IS SET
        FAND DPY(MB0),MDPX; MOV E3,E3;          "FLOAT 3MB OF B0
                DPX(T3)<FA              "STORE B3
        ADD EXB,EX;                     "ADD BIAS TO EXP BITS OF B0
                FADD ZERO,DPX(T3);
                BR EIGHT
TWO:    ADD I,A; SETMA;                 "FETCH A(A-1)
                FADD FM,FA;             "ADD -128
                BR THREE
THREE:          FAND DPY(MB3),MDPX;             "FLOAT B3
                MOV E33,E33;
                BR FOUR
EIGHT:  BFGE PSN;                       "BRANCH IF SB OF B0 = 0
                FADD;
        DPY(T0)<FA;
        AND EX,E7; DPX(TE)<SPFN         "EXP BITS OF B0 TO DATA PAD
                ADD K,C; SETMA; MI<FA           "STORE B3
        FADD DPX(C8),DPY(T0);          "SB OF B0 SET SO ADD 8.
        AND E10,EX;                     "TO SEE IF B0<0
        BR TEN
PSN:            ADD K,C; SETMA; MI<FA           "STORE B3
        FADD ZERO,DPY(T0);
        AND E10,EX;                     "TO SEE IF B0<0
        BR TEN
TEN:    FAND DPY(SB1),MDPX;                     "TEST SIGN OF B1
        MOV E13,E13; BEQ PSE;           "BRANCH IF B0>0
                DPX(T3)<FA              "SAVE B3
        FADD FM,MDPX(TE);                       "FLOAT EX BITS OF B0
        MOV E37,E37; DPY(T0)<FA;
        BR TWELVE
PSE:    FADD ZERO,MDPX(TE);
        MOV E37,E37; DPY(T0)<FA;
        BR TWELVE
TWELVE: FAND DPY(MB1),MDPX;                     "FLOAT B1
        MOV E13,E13; BR THIRT
TWOP:   ADD I,A; SETMA;
                FADD FM,FA; BR THREE
TWOQ:   ADD I,A; SETMA;
                FADD ZERO,FA; BR THREE
ONE:            FAND DPY(SB3),MDPX;
                MOV E33,E33; BFGT TWOP
OUT1:           FADD FM,FA; BR OUT2
THIRT:  FADD DPY(T0),FA; BFEQ PS1
        FADD FM,FA; BR FIFT;
        MOV ET7,E7
PS1:    FADD ZERO,FA; BR FIFT;
        MOV ET7,E7
FIFT:   ADD K,C; SETMA;
        MI<FA; FADD;                    "STORE B1
                DPY(SB2)<DPX(SB2)
SIXT:   FAND DPY(SB2),MDPX;             "TEST SIGN OF B2
        MOV E23,E23; DPY(T1)<FA
        ADD K,C; SETMA; MI<DPY(T1);     "STORE B1
                FSUBR TM,DPX(NN)       "DECREMENT COUNTER
        FAND DPY(MB2),MDPX;             "GFLOAT B2
        MOV E23,E23
        BFNE ONE;
                DPX(NN)<FA              "STORE COUNTER
                FAND DPY(SB3),MDPX;
                MOV E33,E33;            "TEST SIGN OF B3
                BFNE TWOQ
OUT:            FADD ZERO,FA
OUT2:           FAND DPY(MB3),MDPX; MOV E33,E33
                ADD K,C; SETMA;
                MI<FA;
                FADD; BFEQ OUT5
                FADD FM,FA; BR OUT6
OUT5:           FADD ZERO,FA
OUT6:           FADD
                ADD K,C; SETMA; MI<FA;
                RETURN
CF128:  $FP -128.0
MSK8:   $FP 8.
MSB3:   $VAL 0,41,130000,200
MSB2:   $VAL 0,41,30000,100000
MSB1:   $VAL 0,40,130200,0
MSK0:   $VAL 0,40,33400,0
MSK1:   $VAL 0,40,130177,0
MSK2:   $VAL 0,41,30000,77400
MSK3:   $VAL 0,41,130000,177
        $END
"****** VPK8 = VECTOR 8-BIT BYTE PACK /COMMON/ = REL 3.2, AUG 80 *****
        $TITLE VPK8
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VPK8, 5                          "USER-DIRECTED-CALL ENTRY
        "FOUR WORDS FROM A SOURCE VECTOR ARE STORED AS EIGHT BIT BYTES IN A
        "SINGLE MD WORD.  VPK8 PACKS BOTH TWOS COMPLEMENT FLOATING
        "POINT NUMBERS FROM -128 TO +127 AND POSITIVE FLOATING
        "POINT INTEGERS FROM ZERO TO +255.
        "IF BITS OF AN AP WORD ARE NUMBERED 0 TO 37 FROM LEFT TO RIGHT
        "THE BYTES ARE PACKED
        "       A(M)     >  C(J)  6 TO 13
        "       A(M+I)   >  C(J) 14 TO 21
        "       A(M+2I)  >  C(J) 22 TO 29
        "       A(M+3I)  >  C(J) 30 TO 37.
        "VPK8 DOES NOT CHECK FOR NUMBERS OUT OF RANGE.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER(APAL)
        "EQUIMENT:      AP-120B WITH STANDARD OR FAST MEMORY
        "SIZE:          67. LOCATIONS
        "SPEED:         .92 MICROSECONDS PER BYTE
"     ---HISTORY---
"ORIGINAL:  MAR 77  J. THROOP
" REVISED:  DEC 77  J. THROOP     FIXED SOME MINOR PROBLEMS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80  R. GELLER      CORRECT ADC LINKAGE
"
        "NAMES FOR S PAD
        A $EQU 0                        "SOURCE VECTOR ADDRESS
        I $EQU 1                        "SOURCE VECTOR INCREMENT
        C $EQU 2                        "DESTINATION VECTOR ADDRESS
        K $EQU 3                        "DESTINATION VECTOR INCREMENT
        N $EQU 4                        "DESTINATION VECTOR LENGTH
        EX $EQU 17
        EXB $EQU 16
        E17 $EQU 15
        E24 $EQU 13
        E14 $EQU 12
        E11 $EQU 11
        E4 $EQU 10
        E15 $EQU 7
        E0 $EQU 6
        "NAMES FOR DPY
        MNM $EQU -4
        MSK $EQU -1
        MN8 $EQU -3
        LB $EQU 1
        A2 $EQU 2
        TE $EQU 3
        "NAMES FOR DPX
        TA $EQU 2
        ANS $EQU 0
        M3 $EQU 3
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVPK8,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/I/OP, P4/I/IP,
                    P5/I/IP
FVPK8: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VPK8:   LDSPI E0; DB=ZERO
        LDSPI EXB; DB=1000
        LDSPI E4; DB=4
        LDSPI E15; DB=14
        LDSPI E14; DB=14
        RPSF MSKN; DPY(MSK)<DB
        RPSF MSK3; DPX(M3)<DB
        RPSF MSKMN; DPY(MNM)<DB
        RPSF MSKM8; DPY(MN8)<DB
        MOV A,A; SETMA                  "FETCH A(0)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        SUB K,C;                "BACK UP DESTINATION VECTOR POINTER
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        LDSPI E24; DB=24
        ADD I,A; SETMA                  "FETCH A(1)
        FIXT MD;                 "FIX A(0)
        LDSPI E17; DB=17
        FADD;
        LDSPI E11; DB=11
        DPX(TA)<FA;                      "SAVE FIXED A(0)
        FAND DPY(MSK),FA                        "TO SEE IF SIGN BIT MST BE SET
        FSCLT MD; MOV E14,E14                   "SCALE A(1) RIGHT
        FAND DPY(MNM),DPX(TA);                  "GET BITS OF A(0) FOR EXP
        LDSPI EX; DB=DPX(TA)            "GET BITS OF A(0) FOR EXP
        BFEQ PSN1;                      "BRANCH IF SIGN BIT NOT TO BE SET
        MOVRR EX,EX;                    "SHIFT EX RIGHT 4 BITS
        FAND DPX(M3),FA                 "KNOCK OF HIGH BITS OF A(1)
        FOR DPY(MN8),FA;                        "FOR IN SIGN BIT FOR A(0)
        DPX(TA)<FA;                     "SAVE MANTISSA BITS OF A(1)
        MOVRR EX,EX                     "ONLY WANT 4 BITS OF A(0) FOR EXPONENT
        FADD;
        AND E17,EX;                     "KNOCK OFF HIGH BITS OF EX
        DPY(A2)<FA                      "SAVE SCALED AND TRUNCATED A(1)
        FSCLT FA; MOV E4,E4                     "UNNORMALOZE SB + 3MB
ENT1:   SUB EXB,EX;                     "SUBTRACT BIAS FOR WRT INTO EXP
        DPY(ANS)<SPFN;                  "EX BITS OF A(0) TO EXP OF ANS
        FADD
        DPX(TA)<FA;                     "SAVE SB + 3MB OF A(0)
        ADD I,A; SETMA
        FOR DPY(A2),MDPX(TA); DEC# E14          "FOR A(1) + SB + 3MB
        FADD;
        ADD I,A; SETMA                  "FETCH A(3)
        FSCLT FA; MOV E14,E14                   "UNNORMALIZE A(1) + SB + 3MB
        FSCLT MD; MOV E15,E15                   "A(2) TO LOW BITS OF HMN
        DPY(ANS)<FA; WRTHMN;                    "A(1) + SB + 3MB TO HMN OF ANS
        FADD
        FSCLT MD; MOV E24,E24;                  "A(3) TO HIGH BITS OF LMN
        DPY(LB)<FA                      "SAVE SHIFTED A(2)
                DPY(LB)<SPFN; MOV E0,E0; WRTEX         "SET EXP TO ZERO FOR SHIF
        ADD I,A; SETMA; FADD; BR LOOP
PSN1:   DPX(TA)<FA;                     "SAVE MANTISSA BITS OF A(0)
        MOVRR EX,EX;                    "SHIFT EX BITS RIGHT 4 BITS
        FADD ZERO,FA                    "SAVE MANTISSA BITS
        FADD;
        AND E17,EX;                     "WANT ONLY 4 BITS FOR EXP
        DPY(A2)<FA
        FSCLT FA; MOV E4,E4;                    "UNNORMALIZE 3MB
        BR ENT1
LOOP:           DPY(LB)<FA; WRTLMN
                FSCLT DPY(LB);MOV E11,E11               "SHIFT INTO LMN
        ADD I,A; SETMA;                 "FETCH A(I)
                                FADD;
                DPY(ANS)<DPY(ANS)               "FOR WRTLMN
        FIXT MD;                        "FIX A(I)
                DPY(ANS)<FA; WRTLMN             "INTO LMN WITH TWO BYTES
        FADD;
                ADD K,C; SETMA;
                MI<DPY(ANS)             "SPIT IT OUT
        DPX(TA)<FA;
        FAND DPY(MSK),FA;                       "TO SEE IF SIGN BIT IS TO BE SET
                DEC N           "DECREMENT COUNTER
        FSCLT MD; MOV E14,E14;          "A(I+1) TO LOW BITS OF HMN
                BNE NEXT                "BRANCH IF NOT DONE
                RETURN
NEXT:   FAND DPY(MNM),DPX(TA);          "GET MAN BITS OF A(I0
        LDSPI EX; DB=DPX(TA)            "GET EX BITS OF A(I)
        BFEQ PSN;                       "BR ANCH IF SB NOT TO BE SET
        MOVRR EX,EX;                   "WANT ONLY 4 BITS FOR EXP
        FAND DPX(M3),FA                 "KNOCK OFF HIGH BITS OF A(I+1)
        FOR DPY(MN8),FA;                "COMBINE SB + 3MB
        DPX(TA)<FA;
        MOVRR EX,EX             "FINISH 4 BIT SHIFT OF EX
        FADD;
        AND E17,EX;             "KNOCK OFR POSSIBLE SIGN BITS
        DPY(A2)<FA                      "SAVE A(I+1)
        FSCLT FA; MOV E4,E4;            "UNNORMALIZE SB + 3MB
        BR ENT
SKPB:   ADD I,A; SETMA;                 "FETCH A(I)
        FADD; BR LOOP
ENT:    SUB EXB,EX; DPY(ANS)<SPFN;
        FADD
        DPX(TA)<FA;
        ADD I,A; SETMA          "FETCH A(I+2)
        FOR DPY(A2),MDPX(TA); DEC# E14  "FOR SB + 3MB + A(I+1)
        FADD;
        ADD I,A; SETMA                  "FETCH A(I+3)
        FSCLT FA; MOV E14,E14           "UNNORMALIZE SB + 3MB + A(I+1)
        FSCLT MD; MOV E15,E15           "A(I+2) TO LOW BITS OF HMN
        DPY(ANS)<FA; WRTHMN;            "SB + 3MB + A(I;1) TO HMN
        FADD
        FSCLT MD; MOV E24,E24;          "A(I+3) TO HIGH BITS OF LMN
        DPY(LB)<FA
        DPY(LB)<SPFN; MOV E0,E0; WRTEX;
        BR SKPB
PSN:    DPX(TA)<FA;
        MOVRR EX,EX;
        FADD ZERO,FA
        FADD;
        AND E17,EX;
        DPY(A2)<FA
        FSCLT FA; MOV E4,E4;                    "UNNORMALIZE SB + 3MB +
        BR ENT
MSKN:   $VAL 0,41,130000,10
MSKM8:  $FP -8
MSK3:   $VAL 0,40,130377,0
MSKMN:  $VAL 0,41,130000,7
        $END
"
"****** MTRANS = MATRIX TRANSPOSE /FAST/ = REL 3.1, SEP 79 *****
$TITLE MTRANS
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
 $ENTRY MTRANS,6                          "USER-DIRECTED-CALL ENTRY
"MATRIX TRANSPOSE (FAST MEMORY ONLY)
"                            ---ABSTRACT---
"THIS TRANSPOSES MATRIX A INTO MATRIX C (SWITCHES ROWS
"AND COLUMNS).  IT ASSUMES THE USE OF 1-CYCLE MEMORY.
"ALL MATRICES ARE COLUMN-STORED.
"                            ---STATISTICS---
"LANGUAGE:                   AP-120B ASSEMBLER
"EQUIPMENT:                  AP-120B
"SIZE:                       18. LOCATIONS
"
"    --- HISTORY ---
"ORIGINAL:  JUL 76  S. CAMLEY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                            ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #    MNEMONIC  MEANING
" 0            A         BASE ADDRESS OF MATRIX A
" 1            I         INCREMENT FOR MATRIX A
" 2            C         BASE ADDRESS OF MATRIX C
" 3            K         INCREMENT FOR MATRIX C
" 4            NC        # OF COLS OF A (= # ROWS OF C)
" 5            NR        # OF ROWS OF A (= # COLS OF C)
"                            ---SCRATCH---
"S-PAD:                      0-7
"DATA PAD:                   DPX(0), DPY(0)
"                            DPA UNCHANGED
"S-PAD PARAMETERS:
A = 0
I = 1
C = 2
K = 3
NC = 4
NR = 5
"THE FOLLOWING ARE NOT PARAMETERS:
NRI = 6
SBSC = 7
TEMP = 7
C27 = 7
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMTRNS,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  72
        $PARAM  6 , P1(#2,#6,#5)/R/IP, P2/I/IP,
                    P3(#4,#5,#6)/R/OP, P4/I/IP,
                    P5/I/IP, P6/I/IP
FMTRNS: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MTRANS: MOV NR,NRI
        MOV I,TEMP                "DO...
        DEC TEMP                  "..I...
M:      DEC TEMP; BEQ .+2         "...*
        ADD NRI,NRI; BGT M        "....NR
        LDSPI C27; DB=27.
        MOV NC,NC; DPX<SPFN       "FLOAT...
        LDTMA; DB=!ONE;           "(GET 1.0)
          MOV NR,NR;            "IS ELEMENT COUNT = 0?
          BEQ DONE              "EXIT IF COUNT = 0
        FADD ZERO,MDPX;           "...NC
          MOV C27,C27;
          BEQ DONE              "EXIT IF COUNT = 0
        FADD; DPY<TM;             "STORE 1.0
          SUB I,A
        DPX<FA;                   "SAVE FLOAT(NC)
          SUB K,C
LOOP2:  ADD I,A; SETMA;           "GET A(M,1)
          FSUBR DPY,DPX           "COUNTER OPERATION
        FADD; MOV A,SBSC
LOOP1:  ADD NRI,SBSC; SETMA;      "GET A(M,L)
          FSUBR DPY,FA            "COUNTER - 1
        FADD; BFGT LOOP1;         "TEST IF DONE ROW OF A
          ADD K,C; SETMA; MI<MD   "STORE C(L-1,M)
        DEC NR
        BGT LOOP2                 "TEST IF DONE
DONE:   RETURN                  "EXIT
 $END
"****** SOLVEQ = LINEAR EQUATION SOLVER /FAST/ = REL 3.2, MAR 80 *****
        $TITLE SOLVEQ
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY SOLVEQ,7                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV
        $EXT SPUFLT
        "GAUSSIAN ELIMINATION FOR THE SOLUTION OF SIMULTANEOUS
        "LINEAR EQUATIONS.  THE N BY N MATRIX A IS THE MATRIX OF
        "COEFFICIENTS STORED IN COLUMN ORDER.  THE M COLUMN BY
        "N ROW MATRIX B IS THE MATRIX OF DATA VECTORS, SO THE
        "SOLUTION TO M SYSTEMS IS FOUND AT ONCE.  IN ADDITION TO
        "THE COEFFICIENT MATRIX AND DATA VECTORS, THE USER MUST
        "SPECIFY A WORK VECTOR OF LENGTH 2*N, ROWADD,
        "AND A DESTINATION MATRIX X.  IN THE PIVOTING,
        "ONLY ADDRESSES ARE SWAPPED.
        "MATRICES A AND B ARE DESTROYED.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER
        "EQUIPMENT:     AP 120B WITH FAST MEMORY
        "SIZE:          182 + DIV (28) + SPUFLT (8) = 218. AP WORDS
        "SPEED:         .800 MS FOR A 10 X 10 X 1 SYSTEM
        "               .880 MS FOR A 10 X 10 X 3 SYSTEM
        "               4.04 MS FOR A 20 X 20 X 1 SYSTEM
        "               4.20 MS FOR A 20 X 20 X 2 SYSTEM
        "               7.14 MS FOR A 20 X 20 X 20 SYSTEM
"
"     ---HISTORY---
"ORIGINAL:  DEC 77  J. THROOP
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
"REVISED:   APR 79  W.H.INSKEEP--NOW RETURNS SINGULARITY CONDITION, IERR,
"                       IN MD AS WELL AS IN SP(15.).
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0.
"                                  ALSO ADDS WRTLMN INSTRUCTION TO LDMA
"                                  TO AVOID CHANGING PAGES.
" REV 3.2 AND 2A.2: MAR 80  R.S. NORIN   FUNCTIONALITY RETURNED TO THAT
"                                        PRIOR TO APR 79 REVISION.  I.E.,
"                                        SINGULARITY STATUS RETURNED ONLY
"                                        IN SP(15).
"                                        THE ROUTINE XSOLVE PRESERVES THE
"                                        APR 79- FEB 80 FUNCTIONALITY. I.E.,
"                                        WHERE THE SINGULARITY STATUS IS ALSO
"                                        STORED INTO MD.
"
"
        "USAGE:
        "FORTRAN CALL:  CALL SOLVEQ(A,N,B,M,ROWADD,X,STST)
        "APAL CALL:     JSR SOLVEQ
        "SCRATCH:       SP(0-17),DPX(-4 TO 3),DPY(-4 TO 3),FA,FM,MD,TM
        "THE FOLLOWING DATA MUST BE SPECIFIED AS PARAMETERS:
        "A      ADDRESS OF THE MATRIX OF COEFFICIENTS STORED IN
        "       COLUMN ORDER.
        "
        "N      ORDER OF MATRIX
        "
        "B      BASE ADDRESS OF DATA VECTORS STORED IN COLUMN ORDER
        "
        "M      NUMBER OF DATA VECTORS.  B IS A M COLUMN, N ROW MATRIX.
        "
        "ROWADD WORK ADDRESS FOR ROW ADDRESSES.  ROWADD MUST
        "       BE A VECTOR 2*N ELEMENTS LONG.
        "
        "X      DESTINATION MARIX FOR SOLUTION VECTORS
        "
        "STST   ADDRESS FOR SINGULARITY VALUE TEST.
        "       IF THE ABSOLUTE VALUE OF ANY PIVOT ELEMENT IS
        "       FOUND TO BE LESS THAN THE NUMBER IN MD(STST),
        "       THEN THE SYSTEM IS ASSUMED TO BE SINGULAR AND
        "       THE CALCULATION ABORTED.  MD(STST) MUST BE >= 0.
        "       IF THE CALCULATION IS ABORTED, S PAD 15. = 1.
        "       IF THE CALCULATION IS SUCCRESSFUL, S PAD 15. = 0.
        "NAMES FOR S PAD:
        A $EQU 0                                "MATRIX OF COEFFICIENTS
        N $EQU 1                                "ORDER OF MATRIX
        Y $EQU 2                                "MATRIX OF DATA VECTORS
        M $EQU 3                                "NUMBER OF DATA VECTORS
        ROWADD $EQU 4                           "WORK VECTOR FOR ROW ADDRESSES
                                                "XIN IS THE SAME AS X ABOVE
        XIN $EQU 5                              "BASE ADDRESS OF SSOLUTION MATRI
        STST $EQU 6                             "ADDRESS OF SINGULARITY ERROR
        "THE FOLLOWING ARE SCRATCH ADDRESSES:
        X $EQU 2
        XADD $EQU 5
        YADD $EQU 5
        ADX $EQU 2
        ADY $EQU 2
        CTR1 $EQU 6
        CTR2 $EQU 2
        A1 $EQU 7
        A2 $EQU 10
        SAVEA $EQU 11
        A3 $EQU 17
        SAVADD $EQU 12
        NN $EQU 12
        K $EQU 17
        ADYT $EQU 16
        YROW $EQU 16
        YA $EQU 15
        SAVEY $EQU 15
        L $EQU 13
        SAVROW $EQU 13
        NCTR $EQU 14                            "COUNTS PASSES THROUGH
                                                "THE ELIMINATION SCHEME FROM N T
        "NAMES FOR DPX
        PIVI $EQU 1                             "INVERSE OF PIVOT
        ADT1 $EQU 1
        XNM $EQU -2
        TY $EQU -1
        TYA $EQU -2                     "TYA IS A NAME FOR BOTH DPX AND DPY
        ADS $EQU 2
        ADT $EQU 3
        KCTR $EQU -3
        SV $EQU -4
        "NAMES FOR DPY
        MX $EQU -3                      "MX IS A NAME FOR BOTH DPX & DPY
        XNCTR $EQU 3                    "FLOATED NCTR
        XCTR1 $EQU -2
        XMCTR $EQU 2                    "FLOATED M
        ADT2 $EQU 1
        XSAVE $EQU -1                           "TO SAVE BASE ADDRESS OF X
        ERR $EQU -4
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FSOVEQ,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  7 , P1(#2,#2)/R/IP, P2/I/IP,
                    P3(#2,#4)/R/IP, P4/I/IP,
                    P5(2,#2)/R/IP, P6(#2,#4)/R/OP,
                    P7/R/IP
FSOVEQ: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SOLVEQ: MOV N,17                                "TO FLOAT N
        JSR SPUFLT
        BFEQ ZDONE;             "EXIT IF COUNT = 0
        MOV M,17; DPY(XNCTR)<DPX(1)                     "SAVE FLOATED N
        JSR SPUFLT
        MOV N,NCTR;                "COUNTER TO SET ROW ADDRESSES
          BFNE .+2              "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        DPY(XMCTR)<DPX(1);                      "SAVE FLOATED M
        MOV STST,STST; SETMA                    "FETCH MINIMUN TERM
        MOV XIN,XIN; DPY(XSAVE)<SPFN            "SAVE BASE ADDRESS OF X
        MOV N,NCTR                              "COUNTER TO SET ROW ADDRESSES
        DEC ROWADD; SETMA
        MOV ROWADD,YADD                         "TO SET YADD
        MOV NCTR,CTR1;                          "SET CTR1
        DPY(ERR)<MD                             "STORE ERROR FOR SINGULARITY TES
        MOV A,A1;
        DPX<DB; DB=SPFN
LOOP:   INCMA; MI<DPX; DEC CTR1
        INC A1; DPX<DB; DB=SPFN; BGT LOOP
        "AFTER SETTING ROW ADDRESSES, THE VECTOR ROWADD CONTAINS
        "THE ADDRESSES OF THE FIRST COLUMN OF A:   A(0,0),
        "A(1,0), A(2,0), ....,A(N-1,0).
        "NEXT THE ADDRESSES OF THE Y VECTOR ARE
        "SET UP IN YADD.
        ADD N,YADD; SETMA                       "YADD = ROWADD + N
        MOV Y,A1; DPX<DB; DB=SPFN
        MOV NCTR,CTR1
LOOPY:  INCMA; MI<DPX; DEC CTR1
        INC A1; DPX<DB; DB=SPFN; BGT LOOPY
        "LOOPY SETS ADDRESSES OF THE Y VECTOR IN YADD.
        LDTMA; DB=!ONE;                          "GET ONE FOR PIVOT INVERSE
        MOV N,NCTR
        "NOW GO THROUGH THE ELIMINATION FROM 1 TO N-1.
        "SEARCH THROUGH THE ROWS FROM NCTR TO 1 FOR THE MAX
        "ELEMENT IN A COLUMN.  IF THE MAXIMUM ELEMENT
        "IS NOT THE PIVOT ELEMENT, THEN SWAP THE ADDRESSES
        "SO THAT THE MAXIMUM ELEMENT BECOMES THE PIVOT
        "ELEMENT.  ALSO SWAP THE CORRESPONDING ADDRESSES
        "OF THE Y VECTOR IN YADD.
MAX:    INC ROWADD; SETMA
        INC YADD; SETMA                         "GET ADDRESS OF Y(J)
        MOV ROWADD,SAVEA
        LDSPI SAVADD; DB=MD
        DPX(TY)<MD;                             "CURRENT YADD
        MOV YADD,YA                             "TO RUNNING INDEX
        MOV SAVADD,SAVADD; SETMA; DPX(ADS)<SPFN
        INC SAVEA; SETMA;                       "FETCH ADDRESS OF A(J+1,J)
        DPY(XCTR1)<DPY(XNCTR)
        LDSPI A1; DB=-3                         "TO BACK UP ROWADD FOR SWAP
        FABS MD;                                "ABS(A(J,J)
        DPX(MX)<MD                              "SAVE A(J,J)
        LDMA; DB=MD; WRTLMN;                    "GET A(J+1,J)
        DPX(ADT)<MD                             "STORE ADRESS OF A(J+1,J)
        INC SAVEA; SETMA;                       "GET ADDRESS OF A(J+2,J)
        FADD
        LDSPI A2; DB=-1;                        "TO BACKUP YADD FOR SWAP
        DPY(MX)<FA;                             "STORE MAX ABSOLUTE VALUE
        FSUBR TM,DPY(XCTR1)                     "DECREMENT COUNTER
                FABS MD;                        "ABS(A(J+1,J))
                FMUL TM,MD;                     "STORE A(J+1,J)
                DPX(ADT1)<DPX(ADT)              "STORE ADDRESS OF A(J+1,J)
        LDMA; DB=MD; WRTLMN;                    "GET A(J+2,J)
        DPX(ADT)<MD                             "STORE ADDRES OF A(J+2,J)
        INC SAVEA; SETMA;                       "GET ADDRESS OF A(J+3,J)
                FSUBR TM,FA                     "DECREMENT  COUNTER
                        FSUB DPY(MX),FA;        "ABS(A(J+1,J))-MAX
                        DPX<FA;                 "SAVE ABS(A(J+1,J))
                        INC YA; SETMA;          "GET ADDRESS OF Y(J+1)
                        DPY(ADT2)<DPX(ADT1)     "SAVE ADDRESS OF A(J+1,J)
                FABS MD;                        "ABS(A(J+2,J))
                FMUL TM,MD;                     "SAVE A(J+2,J))
        DPX(ADT1)<DPX(ADT);                    "SAVE ADD OF A(J+2,J)
        DPY(XCTR1)<FA                           "SAVE COUNTER
        LDMA; DB=MD; WRTLMN;                    "GET A(J+3,J)
        DPX(ADT)<MD                             "SAVE ADDRESS OF A(J+3,J)
MLOOP:  INC SAVEA; SETMA;                       "GET ADDRESS OF A(J+L+3,J)
                                DPX(TYA)<MD;    "SAVE ADD OF Y(J+L)
                                FSUBR TM,DPY(XCTR1);    "DECREMENT COUNTER
                                BFGT .+2        "DONT SWAP
        MOV ROWADD,ROWADD; SETMA; MI<DPY(ADT2);  "NEW ADDRESS FOR PIVOT
                                BR SWAP
                        FSUB DPY(MX),FA;        "ABS(A(J+L+1,J))-MAX
                        DPX<FA;                 "SAVE ABS(A(J+L+1,J))
                        INC YA; SETMA;          "GET ADDRESS OF Y(J+L+1)
                        DPY(ADT2)<DPX(ADT1)     "SAVE ADD OF A(J+L+1,J)
                FABS MD;                        "ABS(A(J+L+2,J))
                FMUL TM,MD;                     "SAVE A(J+L+2,J)
                DPX(ADT1)<DPX(ADT);             "SAVE ADD OF A(J+L+2,J)
                                DPY(XCTR1)<FA   "SAVE COUNTER
ENT:    LDMA; DB=MD; WRTLMN;                    "GET A(J+L+3,J)
        DPX(ADT)<MD;                            "SAVE ADDRESS OF A(J+L+3,J)
                                BFGE MLOOP
        DPX<DPY(MX);                            "FOR ERROR TEST
                                BR NEXT
SWAP:   DPY<MD;                                 "SAVE A(J+L+2,J)
        FMUL TM,MD                              "SAVE A(J+L+2,J) IN PIPELINE
        ADD# A1,SAVEA; SETMA; MI<DPX(ADS)       "OLD ADDRESS OF PIVOT
        DPX(ADS)<DPY(ADT2)                      "
        DPY(MX)<DPX;                            "NEW MAX ABS VALUE
        DPX(MX)<FM;                             "NEW PIVOT ELEMENT
        FADD ZERO,FA                            "SAVE ABS(A(J+L+1,J))
        MOV YA,YA; SETMA; MI<DPX(TY)            "OLD ADDRESS OF Y(J)
        MOV YADD,YADD; SETMA; MI<DPX(TYA);      "NEW ADDRESS OF Y(J)
        DPX(TY)<DPX(TYA);
        FADD ZERO,FA                            "TO PUSH COUNTER
                FSUB DPY(MX),FA;                "ABS(A(J+L+1,J))-MAX
                        DPX<FA;                "SAVE ABS(A(J+L+1,J))
                        INC YA; SETMA;          "GET ADDRESS OF Y(J+L+1)
                        DPY(ADT2)<DPX(ADT1)     "SAVE ADD OF A(J+L+1,J)
                FABS DPY;                       "ABS(A(J+L+2,J))
                DPX(ADT1)<DPX(ADT);             "SAVE ADDRESS OF A(J+L+2,J)
                                DPY(XCTR1)<FA;  "SAVE COUNTER
                                BR ENT
NEXT:   FSUBR DPY(ERR),DPX                      "IS ABS OF MAX ELEMENT < ERR?
        FSUBR TM,DPY(XNCTR);                    "DECREMENT FLOATED NCTR
        DEC NCTR                                "DECREMENT NCTR
        FADD;
        LDSPI SAVADD; DB=DPX(ADS)
        DPX<DPX(MX);                            "PIVOT ELEMENT
        DPY(XNCTR)<FA; BFGT NONSING
SING:   LDSPI 17; DB=1; RETURN          "RETURN ONE FOR A SINGULAR SYSTEM
        "THROUGH EACH PASS ROWADD CONTAINS THE ADDRESS OF THE
        "PIVOT ELEMENT.
NONSING:        DPY<TM; JSR DIV
        DPX(PIVI)<DPX;                  "STORE PIVOT INVERSE
        MOV SAVADD,SAVADD; SETMA; MI<DPX
        "IN INCADD ALL ROW ADDRESSES > PIVOT ROW ARE INCREMENTED BY N.
INCADD: MOV ROWADD,K
        MOV K,L;
        LDTMA; DB=!ONE
        INC K; SETMA;                           "FETCH ADDRESS OF ROW(J+1)
        FADD ZERO,DPY(XNCTR)                    "INITIALIZE LOOP COUNTER
        FADD
INCLOOP:  INC K; SETMA;                         "FETCH ADDRESS OF ROW(J+L+1)
                FSUBR TM,FA                     "DECREMENT COUNTER
                LDSPI SAVADD; DB=MD; FADD
                ADD N,SAVADD; DPX<SPFN          "ADD N TO ADDRESS OF ROW(J+L)
                INC L; SETMA; MI<DPX;           "STORE ADDRESS OF ROW(J+L)
                BFGT INCLOOP
        MOV ROWADD,SAVEA; SETMA
        MOV YADD,YA; SETMA
        MOV NCTR,CTR2                           "CTR2 COUNTS # ROWS
        LDSPI SAVROW; DB=MD
        LDSPI YROW; DB=MD
NEXTROW:   INC SAVEA; SETMA             "GET ADDRESS OF ROW J+L
        NOP
        NOP
        LDSPI SAVADD; DB=MD                     "ADDRESS OF ROW J + L TO SAVADD
        SUB N,SAVADD; SETMA                    "GET A(J+L,J)
        MOV SAVROW,A1
        MOV SAVADD,A2
        FMUL DPX(PIVI),MD;              "A(J+L,J)*(1/PIVOT)
        ADD N,A1; SETMA                 "GET A(J,J+1)
        ADD N,A2; SETMA;                "GET A(J+L,J+1)
        FMUL
        MOV SAVADD,A3;
        DPY(XCTR1)<DPY(XNCTR);
        FMUL
        ADD N,A1; SETMA;
                FMUL FM,MD;             "A(J+L)*A(J,J+1)
                DPY<FM
        ADD N,A2; SETMA;
                FSUBR TM,DPY(XCTR1);
                FMUL; DPX<MD
                FMUL;
                BR THRUROW
NEXTC:  BR NEXTROW + 4;                  "BECAUSE OF LONG BRANCH
        LDSPI SAVADD; DB=MD
THRUROW:        ADD N,A1; SETMA;        "GET A(J,J+K+1)
                FMUL DPY,MD;            "A(J+L)*A(J,J+K+1)
                        FSUBR FM,DPX    "A(J+L,J+K) -
                                        "A(J+L,J)*A(J,J+K)
        ADD N,A2; SETMA;                "GET A(J+L,J+K+1)
                FSUBR TM,FA;            "DECREMENT LOOP COUNTER
                FMUL; DPX<MD
                FMUL;
                        ADD N,A3; SETMA;  "STORE A(J+L,J+K) -
                                        "A(J+L,J)*A(J,J+K)
                        MI<FA; BFGT THRUROW
        "THIS FINISHES THE ELIMINATION ON THE ROW OF COEFFICIENTS.
        "THE NEXT PART OF THE PROGRAM DOES THE ELIMINATION ON
        "THE M*N MATRIX OF SOURCE VECTORS.
        "VARIABLES IN THE Y ELIMINATION ARE NOT THE SAME AS
        "IN THE A ELIMINATION.  THE CORRESPONDENCE IS
        "       ROWADD  >  YADD
        "       SAVEA   >  YA
        "       SAVADD  >  SAVEY
        "       SAVROW  >  YROW
        INC YA; SETMA;
        BR .+2
NEXTB:  BR NEXTC
        NOP
        MOV YROW,A1; SETMA
        LDSPI A2; DB=MD; FMUL
        LDMA; DB=MD; WRTLMN
        MOV A2,A3; DPY(XCTR1)<DPY(XMCTR); FMUL
        ADD N,A1; SETMA; FMUL DPY,MD
        ADD N,A2; SETMA; FSUBR TM,DPY(XCTR1); FMUL; DPX<MD
        SUB N,A3;
                FMUL; BR NEXTY
NEXTA:  BR NEXTB
NEXTY:  ADD N,A1; SETMA;                        "GET Y(J,J+K+1)
                FMUL DPY,MD;                    "A(J+L)*Y(J,J+K+1)
                        FSUBR FM,DPX            "Y(J+L,J+K) - PRODUCT
        ADD N,A2; SETMA;                        "GET Y(J+L,J+K+1)
                FSUBR TM,FA;                    "DECREMENT COUNTER
                FMUL; DPX<MD
                FMUL;
                        ADD N,A3; SETMA;      "STORE NEW Y(J+L,J+K)
                        MI<FA; BFGT NEXTY
        DEC CTR2
        INC SAVEA; SETMA;                      "GET A(J+L+1,J)
        BGT NEXTA                               "TEST IF DONE ALL ROWS
        DEC# NCTR                               "IF NCTR=1 DO NOT DO ELIMN
        BGT .+2
        INC YADD; BR BACKSUB                    "DO BACK SUBSTITUTION
        JMP MAX                                 "DO NEXT ELIMINATION
        "AT BACKSUB NCTR=1
        "WE NEED TO FIND AND INVERT THE NTH PIVOT ELEMENT.
BACKSUB:   INC ROWADD; SETMA                    "GET ADDRESS OF LAST PIVOT
        MOV ROWADD,SAVROW                       "TO RUNNING INDEX
        MOV YADD,YROW                           "RUNNING INDEX
        LDMA; DB=MD; WRTLMN                     "GET LAST PIVOT
        LDSPI SAVADD; DB=MD                     "ADDRESS TO S PAD
        MOV NCTR,K;                             "WILL COUNT UP TO N FOR EACH M
        DPX(KCTR)<DPY(XNCTR)
        DPX<MD; FABS MD                         "TEST FOR NON SINGULAR
        FADD; DPY<TM                            "GET 1.0
        FSUBR DPY(ERR),FA
        FADD
        NOP
        BFGT .+2                                "BRANCH IF NON-SINGULAR
        JMP SING                                "SET SINGULAR FLAG AND RETURN
        JSR DIV                                 "INVERT LAST PIVOT
        MOV SAVADD,SAVADD; SETMA; MI<DPX        "STORE INVERSE OF LAST PIVOT
        "GO THROUGH BACKSUB LOOP M TIMES
        "FOR M INPUT VECTORS
        MOV M,15                                "COUNTS PASSES THROUGH NEXTM
        CLR NN;                                  "NN IS INCREMENT FOR Y VECTORS
        DPX(XNM)<DPX
        SUB N,NN;                               "INITIALIZE TO - N
        LDTMA; DB=!ONE
        MOV YADD,YADD; SETMA
        MOV YADD,YROW
NEXTM:  ADD N,NN                                "FOR NEXT Y VECTOR
        LDSPI ADY; DB=MD
        ADD NN,ADY; SETMA                       "ADD INCREMENT FOR MTH Y VECTOR
        MOV NCTR,3                              "WILL COUNT UP TO N FOR EACH M
        MOV ROWADD,SAVROW
        FMUL DPX(XNM),MD                        "Y(N*M)/A(N,N) = X(N*M)
        FMUL; DPX(KCTR)<DPY(XNCTR)
        FMUL
        MOV ADX,ADX; SETMA; MI<FM               "STORE X(N*M)
NEXTX:  DEC SAVROW; SETMA                       "GET PIVOT ADDRESS
        DEC YROW                                "FOR NEXT X ADDRESS
        MOV YROW,A2; SETMA                     "GET Y(N-NCTR) ADDRESS
        LDSPI A1; DB=MD                         "A1= PIVOT ADDRESS
        MOV A1,A1; SETMA                        "GET PIVOT
        LDSPI ADX; DB=MD
        ADD NN,ADX; SETMA                       "GET Y(N-NCTR)
        DPX(PIVI)<MD;
        INC A2; SETMA
        DPY(XCTR1)<DPX(KCTR)
        ADD N,A1; SETMA; FADD ZERO,MD
        LDSPI A3; DB=MD
        INC A2; SETMA
                ADD NN,A3; SETMA; DPX<MD
        ADD N,A1; SETMA
        LDSPI A3; DB=MD;
        BR XLOOP
NEXTXB:  DEC SAVROW; SETMA; BR NEXTX +1
XLOOP:  INC A2; SETMA;
                        FMUL DPX,MD;            "X(L)*A(J,J+L)
                        FSUBR TM,DPY(XCTR1)     "DECREMENT LOOP COUNTER
                ADD NN,A3; SETMA;               "GET X(L)
                        FMUL; FADD; DPX(SV)<FA
        ADD N,A1; SETMA;                        "GET A(J,J+L)
                DPX<MD;
                        FMUL; DPY(XCTR1)<FA
        LDSPI A3; DB=MD;                        "ADDRESS OF X(L) TO S PAD
                        FSUBR FM,DPX(SV);
                        BFGT XLOOP
        FADD TM,DPX(KCTR);
        INC 3
        FMUL DPX(PIVI),FA; FADD
        FMUL; DPX(KCTR)<FA
        FMUL; SUB# 3,N
        MOV ADX,ADX; SETMA; MI<FM; BGT NEXTXB
        DEC 15                                  "TEST IF DONE ALL X COLUMNS
        BGT .+2;
        MOV YADD,YROW; SETMA
        LDSPI A; DB=DPY(XSAVE);                 "TO GET BASE ADDRESS OF X
        BR .+2
        JMP NEXTM
        DEC A
        MOV N,NCTR
        INC XADD
        ADD N,A                         "TO STORE LAST ROW
RESWAP: DEC XADD; SETMA                 "UNSCRAMBLE THE SOLUTION
        MOV A,A3
        FSUBR TM,DPY(XMCTR); SUB N,A3
        LDMA; DB=MD; WRTLMN
        FADD; LDSPI A1; DB=MD
XSWAP:  ADD N,A1; SETMA; FSUBR TM,FA
        FADD;
                ADD N,A3; SETMA; MI<MD; BFGT XSWAP
        DEC NCTR                                "TEST IF DONE ALL ROWS
        DEC A; BGT RESWAP
        CLR 17; RETURN
        $END
"****** XSOLVE = LINEAR EQUATION SOLVER /FAST/ = REL 3.0, MAR 80 *****
        $TITLE XSOLVE
        $RADIX 8
        XADC  $EQU 1
        $ENTRY XSOLVE,10
        $EXT DIV
        $EXT SPUFLT
        "GAUSSIAN ELIMINATION FOR THE SOLUTION OF SIMULTANEOUS
        "LINEAR EQUATIONS.  THE N BY N MATRIX A IS THE MATRIX OF
        "COEFFICIENTS STORED IN COLUMN ORDER.  THE M COLUMN BY
        "N ROW MATRIX B IS THE MATRIX OF DATA VECTORS, SO THE
        "SOLUTION TO M SYSTEMS IS FOUND AT ONCE.  IN ADDITION TO
        "THE COEFFICIENT MATRIX AND DATA VECTORS, THE USER MUST
        "SPECIFY A WORK VECTOR OF LENGTH 2*N, ROWADD,
        "AND A DESTINATION MATRIX X.  IN THE PIVOTING,
        "ONLY ADDRESSES ARE SWAPPED.
        "MATRICES A AND B ARE DESTROYED.
        "STATISTICS:
        "LANGUAGE:      AP-120B ASSEMBLER
        "EQUIPMENT:     AP 120B WITH FAST MEMORY
        "SIZE:          188. + DIV (28) + SPUFLT (8) = 224. AP WORDS
        "SPEED:         .800 MS FOR A 10 X 10 X 1 SYSTEM
        "               .880 MS FOR A 10 X 10 X 3 SYSTEM
        "               4.04 MS FOR A 20 X 20 X 1 SYSTEM
        "               4.20 MS FOR A 20 X 20 X 2 SYSTEM
        "               7.14 MS FOR A 20 X 20 X 20 SYSTEM
"
"    --- HISTORY ---
"ORIGINAL:  MAR 80  R.S. NORIN    THIS ROUTINE ADDED TO PRESERVE THE
"                                 FUNCTIONALITY OF THE ROUTINE SOLVEQ
"                                 DURING THE APR 79 - FEB 80 PERIOD.
"                                 SINGULARITY STATUS IS STORED AS INTEGER
"                                 IN MD ADDR IERR.
"
        "USAGE:
        "FORTRAN CALL:  CALL XSOLVE(A,N,B,M,ROWADD,X,STST,IERR)
        "APAL CALL:     JSR XSOLVE
        "SCRATCH:       SP(0-17),DPX(-4 TO 3),DPY(-4 TO 3),FA,FM,MD,TM
"                       AND DPX(3) WITH DPA =ORIGINAL + 1
        "THE FOLLOWING DATA MUST BE SPECIFIED AS PARAMETERS:
        "A      ADDRESS OF THE MATRIX OF COEFFICIENTS STORED IN
        "       COLUMN ORDER.
        "
        "N      ORDER OF MATRIX
        "
        "B      BASE ADDRESS OF DATA VECTORS STORED IN COLUMN ORDER
        "
        "M      NUMBER OF DATA VECTORS.  B IS A M COLUMN, N ROW MATRIX.
        "
        "ROWADD WORK ADDRESS FOR ROW ADDRESSES.  ROWADD MUST
        "       BE A VECTOR 2*N ELEMENTS LONG.
        "
        "X      DESTINATION MARIX FOR SOLUTION VECTORS
        "
        "STST   ADDRESS FOR SINGULARITY VALUE TEST.
        "       IF THE ABSOLUTE VALUE OF ANY PIVOT ELEMENT IS
        "       FOUND TO BE LESS THAN THE NUMBER IN MD(IERR),
        "       THEN THE SYSTEM IS ASSUMED TO BE SINGULAR AND
        "       THE CALCULATION ABORTED.  MD(STST) MUST BE >= 0.
        "IERR   IF THE CALCULATION IS ABORTED, S PAD 15. = 1.
        "       ALSO, MD(IERR) = 1
        "       IF THE CALCULATION IS SUCCRESSFUL, S PAD 15. = 0.
        "       ALSO, MD(IERR) = 0.
        "NAMES FOR S PAD:
        A $EQU 0                                "MATRIX OF COEFFICIENTS
        N $EQU 1                                "ORDER OF MATRIX
        Y $EQU 2                                "MATRIX OF DATA VECTORS
        M $EQU 3                                "NUMBER OF DATA VECTORS
        ROWADD $EQU 4                           "WORK VECTOR FOR ROW ADDRESSES
                                                "XIN IS THE SAME AS X ABOVE
        XIN $EQU 5                              "BASE ADDR OF SOLUTION MATRIX
        STST $EQU 6                             "ADDR OF SINGULARITY TEST VALUE
        IERR $EQU 7                             "ADDRESS OF SINGULARITY FLAG
        "THE FOLLOWING ARE SCRATCH ADDRESSES:
        X $EQU 2
        XADD $EQU 5
        YADD $EQU 5
        ADX $EQU 2
        ADY $EQU 2
        CTR1 $EQU 6
        CTR2 $EQU 2
        A1 $EQU 7
        A2 $EQU 10
        SAVEA $EQU 11
        A3 $EQU 17
        SAVADD $EQU 12
        NN $EQU 12
        K $EQU 17
        ADYT $EQU 16
        YROW $EQU 16
        YA $EQU 15
        SAVEY $EQU 15
        L $EQU 13
        SAVROW $EQU 13
        NCTR $EQU 14                            "COUNTS PASSES THROUGH
                                                "THE ELIMINATION SCHEME FROM N T
        "NAMES FOR DPX
        PIVI $EQU 1                             "INVERSE OF PIVOT
        ADT1 $EQU 1
        XNM $EQU -2
        TY $EQU -1
        TYA $EQU -2                     "TYA IS A NAME FOR BOTH DPX AND DPY
        ADS $EQU 2
        ADT $EQU 3
        KCTR $EQU -3
        SV $EQU -4
        "NAMES FOR DPY
        MX $EQU -3                      "MX IS A NAME FOR BOTH DPX & DPY
        XNCTR $EQU 3                    "FLOATED NCTR
        XCTR1 $EQU -2
        XMCTR $EQU 2                    "FLOATED M
        ADT2 $EQU 1
        XSAVE $EQU -1                           "TO SAVE BASE ADDRESS OF X
        ERR $EQU -4
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FXSOVE,10                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  10 , P1(#2,#2)/R/IP, P2/I/IP,
                    P3(#2,#4)/R/IP, P4/I/IP,
                    P5(2,#2)/R/IP, P6(#2,#4)/R/OP,
                        P7/R/IP, P10/I/OP
FXSOVE: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
XSOLVE: MOV N,17                                "TO FLOAT N
        JSR SPUFLT
        BFEQ ZDONE;             "EXIT IF COUNT = 0
        MOV M,17; DPY(XNCTR)<DPX(1)                     "SAVE FLOATED N
        JSR SPUFLT
        MOV N,NCTR;                "COUNTER TO SET ROW ADDRESSES
          BFNE .+2              "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        DPY(XMCTR)<DPX(1);                      "SAVE FLOATED M
        MOV STST,STST; SETMA; INCDPA            "FETCH MINIMUN TERM
        MOV IERR,IERR; DPX(3)<SPFN; DECDPA      "STORE FLAG ADDRESS
        MOV IERR,IERR; SETMA; MI<ZERO           "INITIALIZE FLAG=NONSINGULAR
        MOV XIN,XIN; DPY(XSAVE)<SPFN            "SAVE BASE ADDRESS OF X
        MOV N,NCTR                              "COUNTER TO SET ROW ADDRESSES
        DEC ROWADD; SETMA
        MOV ROWADD,YADD                         "TO SET YADD
        MOV NCTR,CTR1;                          "SET CTR1
        DPY(ERR)<MD                             "STORE ERROR FOR SINGULARITY TES
        MOV A,A1;
        DPX<DB; DB=SPFN
LOOP:   INCMA; MI<DPX; DEC CTR1
        INC A1; DPX<DB; DB=SPFN; BGT LOOP
        "AFTER SETTING ROW ADDRESSES, THE VECTOR ROWADD CONTAINS
        "THE ADDRESSES OF THE FIRST COLUMN OF A:   A(0,0),
        "A(1,0), A(2,0), ....,A(N-1,0).
        "NEXT THE ADDRESSES OF THE Y VECTOR ARE
        "SET UP IN YADD.
        ADD N,YADD; SETMA                       "YADD = ROWADD + N
        MOV Y,A1; DPX<DB; DB=SPFN
        MOV NCTR,CTR1
LOOPY:  INCMA; MI<DPX; DEC CTR1
        INC A1; DPX<DB; DB=SPFN; BGT LOOPY
        "LOOPY SETS ADDRESSES OF THE Y VECTOR IN YADD.
        LDTMA; DB=!ONE;                          "GET ONE FOR PIVOT INVERSE
        MOV N,NCTR
        "NOW GO THROUGH THE ELIMINATION FROM 1 TO N-1.
        "SEARCH THROUGH THE ROWS FROM NCTR TO 1 FOR THE MAX
        "ELEMENT IN A COLUMN.  IF THE MAXIMUM ELEMENT
        "IS NOT THE PIVOT ELEMENT, THEN SWAP THE ADDRESSES
        "SO THAT THE MAXIMUM ELEMENT BECOMES THE PIVOT
        "ELEMENT.  ALSO SWAP THE CORRESPONDING ADDRESSES
        "OF THE Y VECTOR IN YADD.
MAX:    INC ROWADD; SETMA
        INC YADD; SETMA                         "GET ADDRESS OF Y(J)
        MOV ROWADD,SAVEA
        LDSPI SAVADD; DB=MD
        DPX(TY)<MD;                             "CURRENT YADD
        MOV YADD,YA                             "TO RUNNING INDEX
        MOV SAVADD,SAVADD; SETMA; DPX(ADS)<SPFN
        INC SAVEA; SETMA;                       "FETCH ADDRESS OF A(J+1,J)
        DPY(XCTR1)<DPY(XNCTR)
        LDSPI A1; DB=-3                         "TO BACK UP ROWADD FOR SWAP
        FABS MD;                                "ABS(A(J,J)
        DPX(MX)<MD                              "SAVE A(J,J)
        LDMA; DB=MD; WRTLMN;                    "GET A(J+1,J)
        DPX(ADT)<MD                             "STORE ADRESS OF A(J+1,J)
        INC SAVEA; SETMA;                       "GET ADDRESS OF A(J+2,J)
        FADD
        LDSPI A2; DB=-1;                        "TO BACKUP YADD FOR SWAP
        DPY(MX)<FA;                             "STORE MAX ABSOLUTE VALUE
        FSUBR TM,DPY(XCTR1)                     "DECREMENT COUNTER
                FABS MD;                        "ABS(A(J+1,J))
                FMUL TM,MD;                     "STORE A(J+1,J)
                DPX(ADT1)<DPX(ADT)              "STORE ADDRESS OF A(J+1,J)
        LDMA; DB=MD; WRTLMN;                    "GET A(J+2,J)
        DPX(ADT)<MD                             "STORE ADDRES OF A(J+2,J)
        INC SAVEA; SETMA;                       "GET ADDRESS OF A(J+3,J)
                FSUBR TM,FA                     "DECREMENT  COUNTER
                        FSUB DPY(MX),FA;        "ABS(A(J+1,J))-MAX
                        DPX<FA;                 "SAVE ABS(A(J+1,J))
                        INC YA; SETMA;          "GET ADDRESS OF Y(J+1)
                        DPY(ADT2)<DPX(ADT1)     "SAVE ADDRESS OF A(J+1,J)
                FABS MD;                        "ABS(A(J+2,J))
                FMUL TM,MD;                     "SAVE A(J+2,J))
        DPX(ADT1)<DPX(ADT);                    "SAVE ADD OF A(J+2,J)
        DPY(XCTR1)<FA                           "SAVE COUNTER
        LDMA; DB=MD; WRTLMN;                    "GET A(J+3,J)
        DPX(ADT)<MD                             "SAVE ADDRESS OF A(J+3,J)
MLOOP:  INC SAVEA; SETMA;                       "GET ADDRESS OF A(J+L+3,J)
                                DPX(TYA)<MD;    "SAVE ADD OF Y(J+L)
                                FSUBR TM,DPY(XCTR1);    "DECREMENT COUNTER
                                BFGT .+2        "DONT SWAP
        MOV ROWADD,ROWADD; SETMA; MI<DPY(ADT2);  "NEW ADDRESS FOR PIVOT
                                BR SWAP
                        FSUB DPY(MX),FA;        "ABS(A(J+L+1,J))-MAX
                        DPX<FA;                 "SAVE ABS(A(J+L+1,J))
                        INC YA; SETMA;          "GET ADDRESS OF Y(J+L+1)
                        DPY(ADT2)<DPX(ADT1)     "SAVE ADD OF A(J+L+1,J)
                FABS MD;                        "ABS(A(J+L+2,J))
                FMUL TM,MD;                     "SAVE A(J+L+2,J)
                DPX(ADT1)<DPX(ADT);             "SAVE ADD OF A(J+L+2,J)
                                DPY(XCTR1)<FA   "SAVE COUNTER
ENT:    LDMA; DB=MD; WRTLMN;                    "GET A(J+L+3,J)
        DPX(ADT)<MD;                            "SAVE ADDRESS OF A(J+L+3,J)
                                BFGE MLOOP
        DPX<DPY(MX);                            "FOR ERROR TEST
                                BR NEXT
SWAP:   DPY<MD;                                 "SAVE A(J+L+2,J)
        FMUL TM,MD                              "SAVE A(J+L+2,J) IN PIPELINE
        ADD# A1,SAVEA; SETMA; MI<DPX(ADS)       "OLD ADDRESS OF PIVOT
        DPX(ADS)<DPY(ADT2)                      "
        DPY(MX)<DPX;                            "NEW MAX ABS VALUE
        DPX(MX)<FM;                             "NEW PIVOT ELEMENT
        FADD ZERO,FA                            "SAVE ABS(A(J+L+1,J))
        MOV YA,YA; SETMA; MI<DPX(TY)            "OLD ADDRESS OF Y(J)
        MOV YADD,YADD; SETMA; MI<DPX(TYA);      "NEW ADDRESS OF Y(J)
        DPX(TY)<DPX(TYA);
        FADD ZERO,FA                            "TO PUSH COUNTER
                FSUB DPY(MX),FA;                "ABS(A(J+L+1,J))-MAX
                        DPX<FA;                "SAVE ABS(A(J+L+1,J))
                        INC YA; SETMA;          "GET ADDRESS OF Y(J+L+1)
                        DPY(ADT2)<DPX(ADT1)     "SAVE ADD OF A(J+L+1,J)
                FABS DPY;                       "ABS(A(J+L+2,J))
                DPX(ADT1)<DPX(ADT);             "SAVE ADDRESS OF A(J+L+2,J)
                                DPY(XCTR1)<FA;  "SAVE COUNTER
                                BR ENT
NEXT:   FSUBR DPY(ERR),DPX                      "IS ABS OF MAX ELEMENT < ERR?
        FSUBR TM,DPY(XNCTR);                    "DECREMENT FLOATED NCTR
        DEC NCTR                                "DECREMENT NCTR
        FADD;
        LDSPI SAVADD; DB=DPX(ADS)
        DPX<DPX(MX);                            "PIVOT ELEMENT
        DPY(XNCTR)<FA; BFGT NONSING
SING:   LDSPI 17; DB=1; DPX<DB          "RETURN ONE FOR A SINGULAR SYSTEM
        INCDPA
        LDSPI IERR; DB=DPX(3)
        MOV IERR,IERR; SETMA; MI<DB; DB=DPX(-1)
        DECDPA; RETURN
        "THROUGH EACH PASS ROWADD CONTAINS THE ADDRESS OF THE
        "PIVOT ELEMENT.
NONSING:        DPY<TM; JSR DIV
        DPX(PIVI)<DPX;                  "STORE PIVOT INVERSE
        MOV SAVADD,SAVADD; SETMA; MI<DPX
        "IN INCADD ALL ROW ADDRESSES > PIVOT ROW ARE INCREMENTED BY N.
INCADD: MOV ROWADD,K
        MOV K,L;
        LDTMA; DB=!ONE
        INC K; SETMA;                           "FETCH ADDRESS OF ROW(J+1)
        FADD ZERO,DPY(XNCTR)                    "INITIALIZE LOOP COUNTER
        FADD
INCLOOP:  INC K; SETMA;                         "FETCH ADDRESS OF ROW(J+L+1)
                FSUBR TM,FA                     "DECREMENT COUNTER
                LDSPI SAVADD; DB=MD; FADD
                ADD N,SAVADD; DPX<SPFN          "ADD N TO ADDRESS OF ROW(J+L)
                INC L; SETMA; MI<DPX;           "STORE ADDRESS OF ROW(J+L)
                BFGT INCLOOP
        MOV ROWADD,SAVEA; SETMA
        MOV YADD,YA; SETMA
        MOV NCTR,CTR2                           "CTR2 COUNTS # ROWS
        LDSPI SAVROW; DB=MD
        LDSPI YROW; DB=MD
NEXTROW:   INC SAVEA; SETMA             "GET ADDRESS OF ROW J+L
        NOP
        NOP
        LDSPI SAVADD; DB=MD                     "ADDRESS OF ROW J + L TO SAVADD
        SUB N,SAVADD; SETMA                    "GET A(J+L,J)
        MOV SAVROW,A1
        MOV SAVADD,A2
        FMUL DPX(PIVI),MD;              "A(J+L,J)*(1/PIVOT)
        ADD N,A1; SETMA                 "GET A(J,J+1)
        ADD N,A2; SETMA;                "GET A(J+L,J+1)
        FMUL
        MOV SAVADD,A3;
        DPY(XCTR1)<DPY(XNCTR);
        FMUL
        ADD N,A1; SETMA;
                FMUL FM,MD;             "A(J+L)*A(J,J+1)
                DPY<FM
        ADD N,A2; SETMA;
                FSUBR TM,DPY(XCTR1);
                FMUL; DPX<MD
                FMUL;
                BR THRUROW
NEXTC:  BR NEXTROW + 4;                  "BECAUSE OF LONG BRANCH
        LDSPI SAVADD; DB=MD
THRUROW:        ADD N,A1; SETMA;        "GET A(J,J+K+1)
                FMUL DPY,MD;            "A(J+L)*A(J,J+K+1)
                        FSUBR FM,DPX    "A(J+L,J+K) -
                                        "A(J+L,J)*A(J,J+K)
        ADD N,A2; SETMA;                "GET A(J+L,J+K+1)
                FSUBR TM,FA;            "DECREMENT LOOP COUNTER
                FMUL; DPX<MD
                FMUL;
                        ADD N,A3; SETMA;  "STORE A(J+L,J+K) -
                                        "A(J+L,J)*A(J,J+K)
                        MI<FA; BFGT THRUROW
        "THIS FINISHES THE ELIMINATION ON THE ROW OF COEFFICIENTS.
        "THE NEXT PART OF THE PROGRAM DOES THE ELIMINATION ON
        "THE M*N MATRIX OF SOURCE VECTORS.
        "VARIABLES IN THE Y ELIMINATION ARE NOT THE SAME AS
        "IN THE A ELIMINATION.  THE CORRESPONDENCE IS
        "       ROWADD  >  YADD
        "       SAVEA   >  YA
        "       SAVADD  >  SAVEY
        "       SAVROW  >  YROW
        INC YA; SETMA;
        BR .+2
NEXTB:  BR NEXTC
        NOP
        MOV YROW,A1; SETMA
        LDSPI A2; DB=MD; FMUL
        LDMA; DB=MD; WRTLMN
        MOV A2,A3; DPY(XCTR1)<DPY(XMCTR); FMUL
        ADD N,A1; SETMA; FMUL DPY,MD
        ADD N,A2; SETMA; FSUBR TM,DPY(XCTR1); FMUL; DPX<MD
        SUB N,A3;
                FMUL; BR NEXTY
NEXTA:  BR NEXTB
NEXTY:  ADD N,A1; SETMA;                        "GET Y(J,J+K+1)
                FMUL DPY,MD;                    "A(J+L)*Y(J,J+K+1)
                        FSUBR FM,DPX            "Y(J+L,J+K) - PRODUCT
        ADD N,A2; SETMA;                        "GET Y(J+L,J+K+1)
                FSUBR TM,FA;                    "DECREMENT COUNTER
                FMUL; DPX<MD
                FMUL;
                        ADD N,A3; SETMA;      "STORE NEW Y(J+L,J+K)
                        MI<FA; BFGT NEXTY
        DEC CTR2
        INC SAVEA; SETMA;                      "GET A(J+L+1,J)
        BGT NEXTA                               "TEST IF DONE ALL ROWS
        DEC# NCTR                               "IF NCTR=1 DO NOT DO ELIMN
        BGT .+2
        INC YADD; BR BACKSUB                    "DO BACK SUBSTITUTION
        JMP MAX                                 "DO NEXT ELIMINATION
        "AT BACKSUB NCTR=1
        "WE NEED TO FIND AND INVERT THE NTH PIVOT ELEMENT.
BACKSUB:   INC ROWADD; SETMA                    "GET ADDRESS OF LAST PIVOT
        MOV ROWADD,SAVROW                       "TO RUNNING INDEX
        MOV YADD,YROW                           "RUNNING INDEX
        LDMA; DB=MD; WRTLMN                     "GET LAST PIVOT
        LDSPI SAVADD; DB=MD                     "ADDRESS TO S PAD
        MOV NCTR,K;                             "WILL COUNT UP TO N FOR EACH M
        DPX(KCTR)<DPY(XNCTR)
        DPX<MD; FABS MD                         "TEST FOR NON SINGULAR
        FADD; DPY<TM                            "GET 1.0
        FSUBR DPY(ERR),FA
        FADD
        NOP
        BFGT .+2                                "BRANCH IF NON-SINGULAR
        JMP SING                                "SET SINGULAR FLAG AND RETURN
        JSR DIV                                 "INVERT LAST PIVOT
        MOV SAVADD,SAVADD; SETMA; MI<DPX        "STORE INVERSE OF LAST PIVOT
        "GO THROUGH BACKSUB LOOP M TIMES
        "FOR M INPUT VECTORS
        MOV M,15                                "COUNTS PASSES THROUGH NEXTM
        CLR NN;                                  "NN IS INCREMENT FOR Y VECTORS
        DPX(XNM)<DPX
        SUB N,NN;                               "INITIALIZE TO - N
        LDTMA; DB=!ONE
        MOV YADD,YADD; SETMA
        MOV YADD,YROW
NEXTM:  ADD N,NN                                "FOR NEXT Y VECTOR
        LDSPI ADY; DB=MD
        ADD NN,ADY; SETMA                       "ADD INCREMENT FOR MTH Y VECTOR
        MOV NCTR,3                              "WILL COUNT UP TO N FOR EACH M
        MOV ROWADD,SAVROW
        FMUL DPX(XNM),MD                        "Y(N*M)/A(N,N) = X(N*M)
        FMUL; DPX(KCTR)<DPY(XNCTR)
        FMUL
        MOV ADX,ADX; SETMA; MI<FM               "STORE X(N*M)
NEXTX:  DEC SAVROW; SETMA                       "GET PIVOT ADDRESS
        DEC YROW                                "FOR NEXT X ADDRESS
        MOV YROW,A2; SETMA                     "GET Y(N-NCTR) ADDRESS
        LDSPI A1; DB=MD                         "A1= PIVOT ADDRESS
        MOV A1,A1; SETMA                        "GET PIVOT
        LDSPI ADX; DB=MD
        ADD NN,ADX; SETMA                       "GET Y(N-NCTR)
        DPX(PIVI)<MD;
        INC A2; SETMA
        DPY(XCTR1)<DPX(KCTR)
        ADD N,A1; SETMA; FADD ZERO,MD
        LDSPI A3; DB=MD
        INC A2; SETMA
                ADD NN,A3; SETMA; DPX<MD
        ADD N,A1; SETMA
        LDSPI A3; DB=MD;
        BR XLOOP
NEXTXB:  DEC SAVROW; SETMA; BR NEXTX +1
XLOOP:  INC A2; SETMA;
                        FMUL DPX,MD;            "X(L)*A(J,J+L)
                        FSUBR TM,DPY(XCTR1)     "DECREMENT LOOP COUNTER
                ADD NN,A3; SETMA;               "GET X(L)
                        FMUL; FADD; DPX(SV)<FA
        ADD N,A1; SETMA;                        "GET A(J,J+L)
                DPX<MD;
                        FMUL; DPY(XCTR1)<FA
        LDSPI A3; DB=MD;                        "ADDRESS OF X(L) TO S PAD
                        FSUBR FM,DPX(SV);
                        BFGT XLOOP
        FADD TM,DPX(KCTR);
        INC 3
        FMUL DPX(PIVI),FA; FADD
        FMUL; DPX(KCTR)<FA
        FMUL; SUB# 3,N
        MOV ADX,ADX; SETMA; MI<FM; BGT NEXTXB
        DEC 15                                  "TEST IF DONE ALL X COLUMNS
        BGT .+2;
        MOV YADD,YROW; SETMA
        LDSPI A; DB=DPY(XSAVE);                 "TO GET BASE ADDRESS OF X
        BR .+2
        JMP NEXTM
        DEC A
        MOV N,NCTR
        INC XADD
        ADD N,A                         "TO STORE LAST ROW
RESWAP: DEC XADD; SETMA                 "UNSCRAMBLE THE SOLUTION
        MOV A,A3
        FSUBR TM,DPY(XMCTR); SUB N,A3
        LDMA; DB=MD; WRTLMN
        FADD; LDSPI A1; DB=MD
XSWAP:  ADD N,A1; SETMA; FSUBR TM,FA
        FADD;
                ADD N,A3; SETMA; MI<MD; BFGT XSWAP
        DEC NCTR                                "TEST IF DONE ALL ROWS
        DEC A; BGT RESWAP
        CLR 17; RETURN
        $END
"****** FMMM = FAST MEMORY MATRIX MULTIPLY /FAST/ = REL 3.1, SEP 79 *****
$TITLE FMMM
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
 $ENTRY FMMM,6                          "USER-DIRECTED-CALL ENTRY
"(FAST MEMORY) MATRIX MULTIPLY
"                               ---ABSTRACT---
"THIS MULTIPLIES MATRIX A BY MATRIX B AND STORES THE RESULT
"IN MATRIX C.  THIS ASSUMES THAT ALL
"INCREMENTS BETWEEN ELEMENTS = 1.  THIS IS FOR USE WITH THE
"1-CYCLE MEMORY ONLY.
"                               ---STATISTICS---
"LANGUAGE:                      AP-120B ASSEMBLER
"EQUIPMENT:                     AP-120B
"SIZE:                          64. LOCATIONS
"
"    --- HISTORY ---
"ORIGINAL:  JUN 76  S. CAMLEY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN NRC,NCC, OR NCA = 0
"
"                               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #    MNEMONIC  MEANING
" 0              A       BASE ADDRESS OF MATRIX A
" 1              B       BASE ADDRESS OF MATRIX B
" 2              C       BASE ADDRESS OF MATRIX C
" 3              NRC     NUMBER OF ROWS OF C
" 4              NCC     NUMBER OF COLUMNS OF C
" 5              NCA     NUMBER OF COLUMNS OF A
"                               ---SCRATCH---
"S-PAD:                         ALL
"DATA PAD:                      DPX(0-31.), DPY(-1 TO +3), DPA
"                               ---ALGORITHM---
"THIS HANDLES ROWS OF A AND COLUMNS OF B IN BLOCKS OF 32.
"IT MULTIPLIES UP TO 32 PAIRS OF ELEMENTS FROM A AND B
"IN THE BASIC DOT PRODUCT OPERATION AND STORES THE RESULTS
"IN C.  WHEN FINISHED WITH THE FIRST BLOCK, IT STARTS OVER
"WITH THE NEXT BLOCK OF 32 WITHIN EACH ROW OF A AND
"COLUMN OF B.  THESE RESULTS ARE ADDED TO THE OLD CONTENTS
"OF C.  THIS CONTINUES IN SUCH BLOCKS UNTIL THE LAST BLOCK,
"WHICH MAY BE EQUAL TO OR LESS THAN 32.
"THIS STORES A ROW OF A INTO DPX, AND MULTIPLIES IT BY ALL
"THE COLUMNS OF B TO PRODUCE ONE ROW OF C.  LOOP1 IS CONTAINED
"IN LOOP2, WHICH IS CONTAINED IN LOOP3, WHICH IS CONTAINED
"IN LOOP4.  LOOP1 DOES THE BASIC DOT PRODUCT.  LOOP2
"PRODUCES A ROW OF C.  LOOP3 STORES A NEW ROW OF A INTO
"DPX AND STARTS THE NEXT ROW OF C.  LOOP4 STARTS OVER
"WITH THE NEXT BLOCK OF 32 ELEMENTS OF THE ROWS OF A AND
"COLUMNS OF B.
"THE 1-CYCLE LOOP WHICH STORES A ROW OF A INTO DPX IS UNUSUAL,
"IN THAT IT USES THE FLOATING ADDER AS A COUNTER INSTEAD OF S-PAD.
"BEING A 1-CYCLE LOOP, HOWEVER, THE RESULT OF A FLOATING ADDER
"OPERATION (DECREMENTING A COUNTER) WILL NOT BE READY BY THE
"NEXT SUCH OPERATION.  HENCE, THERE ARE TWO COUNTERS INVOLVED,
"OFFSET BY 1.
"TWO FLAGS ARE BEING USED.  FLAG 0 DENOTES WHETHER C NEEDS
"TO BE ADDED TO THE OLD CONTENTS OF C--THE FIRST TIME THROUGH
"LOOP4, THIS NEED NOT OCCUR.  0=ADD, 1=DON'T ADD.  FLAG 1
"DENOTES WHETHER THE BLOCK BEING HANDLED IS LESS THAN 32
"ELEMENTS PER ROW OR COLUMN. 0=NO, 1=YES.  THIS IS USED BOTH
"TO DETERMINE THE PROPER COUNTER FOR LOOP1, AND TO
"DETERMINE THE END OF THE PROGRAM.
"S-PAD PARAMETERS:
A = 0
B = 1
C = 2
NRC = 3
NCC = 4
NCA = 5
"THE FOLLOWING ARE NOT PARAMETERS:
NRA = 3
NCB = 4
AP = 6
BC = 7
CP = 10
TT = 11
TEMP = 12
C27 = 12
CTR1 = 12
CTR2 = 13
CTR3 = 14
NRB = 15
SAVEA = 16
SAVEC = 17
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FFMMM,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  70
        $PARAM  6 , P1(#4,#6)/R/IP, P2(#6,#5)/R/IP,
                    P3(#4,#5)/R/OP,
                    P4/I/IP, P5/I/IP, P6/I/IP
FFMMM: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
FMMM:   LDSPI TT; DB=32.;
          SFL0               "FLAG 0 = 1
        MOV NRC,NRC             "IS ELEMENT COUNT = 0?
        MOV NCC,NCC;            "IS ELEMENT COUNT = 0?
          BEQ ZDONE             "EXIT IF COUNT = 0
        MOV NCA,NRB;         "NRB=NCA
          BEQ ZDONE             "EXIT IF COUNT = 0
        SUB NRC,C;           "POINTER CORRECTION
          DB=!TWO; LDTMA;    "GET 2.0
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV A,SAVEA;         "SAVE A
          CFL1               "FLAG 1 = 0
        MOV C,SAVEC;         "SAVE C
          DB=ZERO; LDDPA     "DPA=0
        RPSF F32; DPY(1)<DB  "GET 32, A COUNTER
        RPSF F31; DPY(2)<DB  "GET 31, OTHER COUNTER
        MOVL NRA,TEMP        "THIS...
        MOVL TEMP,TEMP       "...DOES...
        MOVL TEMP,TEMP       "...32...
        MOVL TEMP,TEMP       "...TIMES...
        MOVL TEMP,TEMP; DPY(-1)<SPFN "...NRA.
LOOP4:  SUB# TT,NCA
        BGE MORE;            "COMPARE NCA TO 32.
          MOV NRC,CTR3       "SET UP LOOP3 COUNTER
"IF NCA IS LESS THAN 32...
LESS:   MOV NCA,NCA; DPX<SPFN; "THIS...
          SFL1               "FLAG 1 = 1
        LDSPI C27; DB=27.    "...FLOATS...
        FADD ZERO,MDPX; MOV C27,C27 "...NCA
        DB=!ONE; LDTMA       "GET 1.0
        FADD; CLR# 17; SETDPA "DPA=0
        DPY(1)<FA;           "STORE FLOAT(NCA), A COUNTER
          FSUBR TM,FA        "MAKE FLOAT(NCA-1)
        DB=!TWO; LDTMA       "GET 2.0
        FADD; MOV SAVEA,A    "RESTORE A
        DPY(2)<FA;           "STORE FLOAT(NCA-1), OTHER COUNTER
          MOV SAVEC,C;       "RESTORE C
          BR LOOP3           "SKIP TO LOOP3
"IF NCA IS GREATER THAN OR EQUAL TO 32...
MORE:   MOV SAVEA,A;         "RESTORE A
          DB=ZERO; LDDPA     "DPA=0
        MOV SAVEC,C          "RESTORE C
LOOP3:  MOV A,AP; SETMA;     "GET A(J,1)
          FSUBR TM,DPY(1)    "(NCA)-2, A COUNTER
        ADD NRA,AP; SETMA;   "GET A(J,2)
          FSUBR TM,DPY(2)    "(NCA-1)-2, OTHER COUNTER
        ADD NRA,AP; SETMA;   "GET A(J,3)
          FSUBR TM,FA        "NCA-2-2
"THIS STORES A ROW OF A INTO DPX
LOOP:   ADD NRA,AP; SETMA;   "GET A(J,M+3)
          FSUBR TM,FA;       "COUNTER - 2
          DPX<MD; INCDPA;    "STORE A(J,M)
          BFGE LOOP          "TEST IF DONE
        MOV NCC,CTR2;        "SET UP LOOP2 COUNTER
          DB=ZERO; LDDPA     "DPA=0
        MOV C,CP
        MOV B,BC; SETMA;     "GET B(1,1)
          FADD ZERO,ZERO;    "PUT 0 IN ADDER
          BR .+2             "SKIP NEXT INSTRUCTION
LOOP2:  ADD NRB,BC; SETMA;   "GET B(1,K)
          FADD ZERO,ZERO     "PUT 0 IN ADDER
        INCMA; FADD;         "GET B(2,K)
                             "TEST IF DEALING WITH
                             "  BLOCK OF 32 OR WITH
          BFL1 .+2           "  REMAINING BLOCK
"IF 32...
        INCMA;               "GET B(3,K)
          MOV TT,CTR1;       "LOOP1 COUNTER=32
          BR .+2
"IF LESS...
        INCMA;               "GET B(3,K)
          MOV NCA,CTR1       "LOOP1 COUNTER=REMAINING NCA
        FMUL DPX,MD;         "A(J,1)*B(1,K)
          INCDPA;            "DPA=DPA+1
          INCMA              "GET B(4,K)
        FMUL DPX,MD;         "A(J,2)*B(2,K)
          INCDPA;            "DPA=DPA+1
          INCMA              "GET B(5,K)
        FMUL DPX,MD;         "A(J,3)*B(3,K)
          INCDPA;            "DPA=DPA+1
          INCMA;             "GET B(6,K)
          DEC CTR1
LOOP1:  FADD FM,FA;          "ADD A(J,L-3)*B(L-3,K) TO SUM
          FMUL DPX,MD;       "A(J,L)*B(L,K)
          INCDPA;            "DPA=DPA+1
          INCMA;             "GET B(L+3,K)
          DEC CTR1;
          BGT LOOP1          "TEST IF DONE WITH DOT PROD
                             "(THE NEXT 2 INSTRUCTIONS
                             "COULD NOT BE PUT IN THE SAME
                             "CYCLE DUE TO AN OBSCURE
                             "HARDWARE CONNECTION CONCERNING
                             "SPFN, DB, AND THE LDREG FIELD.)
        DB=ZERO; LDDPA       "DPA=0
        ADD# NRC,CP; SETMA   "GET OLD C(J,K)
        DPY<FA; FADD         "SAVE SUM1
        FADD DPY,FA;         "SUM1 + SUM2
                             "TEST IF THERE IS
          BFL0 FIRST         "  AN OLD C(J,K)
        FADD; DPY(3)<MD      "IF SO...
        FADD DPY(3),FA       "...C(J,K)+SUMS
FIRST:  FADD; DEC CTR2
        ADD NRC,CP; SETMA; MI<FA; "STORE C(J,K)
          BGT LOOP2          "TEST IF DONE WITH THIS ROW OF C
        DEC CTR3
        BEQ OUT;             "TEST IF DONE ALL ROWS OF C
          INC A              "MOVE TO NEXT ROW OF A
        INC C                "NEXT ROW OF C
        JMP LOOP3            "IF NOT, DO NEXT ROW
OUT:    CFL0;                "FLAG 0 = 0
          SUB TT,NCA         "NCA=NCA-32
        BEQ DONE;            "TEST IF NCA=32
                             "OR IF FINISHED
          BFL1 DONE          "  REMAINING SMALLER BLOCK
"IF NOT...
        LDSPI TEMP; DB=DPY(-1)
        ADD TEMP,SAVEA       "NEXT BLOCK OF A
        ADD TT,B             "NEXT BLOCK OF B
        JMP LOOP4            "BACK TO THE BEGINNING
"OTHERWISE, FINISHED.
DONE:   RETURN
F32:    $FP 32.0
F31:    $FP 31.0
 $END
"****** FMMM32 = FAST MEMORY MATRIX MULT (32 OR LESS) /FAST/ = REL 3.1, SEP 79
$TITLE FMMM32
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
 $ENTRY FMMM32,6                          "USER-DIRECTED-CALL ENTRY
"(FAST MEMORY) MATRIX MULTIPLY (DIMENSION 32 OR LESS)
"                               ---ABSTRACT---
"THIS MULTIPLIES MATRIX A BY MATRIX B AND STORES THE RESULT
"IN MATRIX C.  THE COMMON DIMENSION BETWEEN A AND B (NCA=NRB)
"MUST BE LESS THAN OR EQUAL TO 32.  THIS ASSUMES THAT ALL
"INCREMENTS BETWEEN ELEMENTS = 1.  THIS IS FOR USE WITH THE
"1-CYCLE MEMORY ONLY.
"                               ---STATISTICS---
"LANGUAGE:                      AP-120B ASSEMBLER
"EQUIPMENT:                     AP-120B
"SIZE:                          34. LOCATIONS
"
"    --- HISTORY ---
"ORIGINAL:  JUN 76  S. CAMLEY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN NRC,NCC, OR NCA = 0
"
"                               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #    MNEMONIC  MEANING
" 0              A       BASE ADDRESS OF MATRIX A
" 1              B       BASE ADDRESS OF MATRIX B
" 2              C       BASE ADDRESS OF MATRIX C
" 3              NRC     NUMBER OF ROWS OF C
" 4              NCC     NUMBER OF COLUMNS OF C
" 5              NCA     NUMBER OF COLUMNS OF A
"                               ---SCRATCH---
"S-PAD:                         0-13.
"DATA PAD:                      DPX(0-31.), DPY(0-2), DPA
"                               ---ALGORITHM---
"THIS STORES A ROW OF A INTO DPX, AND MULTIPLIES IT BY ALL
"THE COLUMNS OF B TO PRODUCE ONE ROW OF C.  LOOP1 IS CONTAINED
"IN LOOP2, WHICH IS CONTAINED IN LOOP3.  LOOP1 DOES THE BASIC
"DOT PRODUCT.  LOOP2 PRODUCES A ROW OF C.  LOOP3 STORES A NEW ROW
"OF A INTO DPX AND STARTS THE NEXT ROW OF C.
"THE 1-CYCLE LOOP WHICH STORES A ROW OF A INTO DPX IS UNUSUAL,
"IN THAT IT USES THE FLOATING ADDER AS A COUNTER INSTEAD OF S-PAD.
"BEING A 1-CYCLE LOOP, HOWEVER, THE RESULT OF A FLOATING ADDER
"OPERATION (DECREMENTING A COUNTER) WILL NOT BE READY BY THE
"NEXT SUCH OPERATION.  HENCE, THERE ARE TWO COUNTERS INVOLVED,
"OFFSET BY 1.
"S-PAD PARAMETERS:
A = 0
B = 1
C = 2
NRC = 3
NCC = 4
NCA = 5
"THE FOLLOWING ARE NOT PARAMETERS:
NRB = 5
NRA = 3
NCB = 4
AP = 6
BC = 7
CP = 10
CTR = 11
CTR1 = 12
CTR2 = 13
CTR3 = 14
C27 = 15
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FFMM32,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  70
        $PARAM  6 , P1(#4,#6)/R/IP, P2(#6,#5)/R/IP,
                    P3(#4,#5)/R/OP,
                    P4/I/IP, P5/I/IP, P6/I/IP
FFMM32: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
FMMM32: DB=!ONE; LDTMA;      "GET 1.0
          SUB NRC,C
        LDSPI C27; DB=27.    "THIS....
        MOV NCA,NCA; DPX<SPFN "....FLOATS...
        FADD ZERO,MDPX; MOV C27,C27; "....NCA
          BEQ ZDONE             "EXIT IF COUNT = 0
        FADD; CLR# 17; SETDPA "DPA=0
        FSUBR TM,FA;         "MAKE NCA-1
          DPY(1)<FA;         "STORE FLOAT(NCA)
          MOV NCC,NCC           "IS ELEMENT COUNT = 0?
        DB=!TWO; LDTMA;      "GET 2.0
          BEQ ZDONE             "EXIT IF COUNT = 0
        FADD; MOV NRC,CTR3   "SET UP LOOP3 COUNTER
        DPY(2)<FA;           "STORE FLOAT(NCA-1)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
LOOP3:  MOV A,AP; SETMA;     "GET A(J,1)
          FSUBR TM,DPY(1)    "(NCA)-2, A COUNTER
        ADD NRA,AP; SETMA;   "GET A(J,2)
          FSUBR TM,DPY(2)    "(NCA-1)-2, OTHER COUNTER
        ADD NRA,AP; SETMA;   "GET A(J,3)
          FSUBR TM,FA        "NCA-2-2
"THIS STORES A ROW OF A INTO DPX
LOOP:   ADD NRA,AP; SETMA;   "GET A(J,M+3)
          FSUBR TM,FA;       "COUNTER - 2
          DPX<MD; INCDPA;    "STORE A(J,M)
          BFGE LOOP          "TEST IF DONE
        MOV NCC,CTR2;        "SET UP LOOP2 COUNTER
          DB=ZERO; LDDPA     "DPA=0
        MOV C,CP
        MOV B,BC; SETMA;     "GET B(1,1)
          FADD ZERO,ZERO;    "PUT 0 IN ADDER
          BR .+2             "SKIP NEXT INSTRUCTION
LOOP2:  ADD NRB,BC; SETMA;   "GET B(1,K)
          FADD ZERO,ZERO     "PUT 0 IN ADDER
        INCMA; FADD;         "GET B(2,K)
          MOV NCA,CTR1       "SET UP LOOP1 COUNTER
        INCMA                "GET B(3,K)
        FMUL DPX,MD;         "A(J,1)*B(1,K)
          INCDPA;            "DPA=DPA+1
          INCMA              "GET B(4,K)
        FMUL DPX,MD;         "A(J,2)*B(2,K)
          INCDPA;            "DPA=DPA+1
          INCMA              "GET B(5,K)
        FMUL DPX,MD;         "A(J,3)*B(3,K)
          INCDPA;            "DPA=DPA+1
          INCMA;             "GET B(6,K)
          DEC CTR1
LOOP1:  FADD FM,FA;          "ADD A(J,L-3)*B(L-3,K) TO SUM
          FMUL DPX,MD;       "A(J,L)*B(L,K)
          INCDPA;            "DPA=DPA+1
          INCMA;             "GET B(L+3,K)
          DEC CTR1;
          BGT LOOP1          "TEST IF DONE WITH DOT PROD
        DB=ZERO; LDDPA       "DPA=0
        DPY<FA; FADD         "SAVE SUM1
        FADD DPY,FA          "SUM1 + SUM2
        FADD; DEC CTR2
        ADD NRC,CP; SETMA; MI<FA; "STORE C(J,K)
          BGT LOOP2          "TEST IF DONE WITH THIS ROW OF C
        DEC CTR3
        BEQ DONE;            "TEST IF DONE ALL ROWS OF C
          INC A
        INC C
        JMP LOOP3            "IF NOT, DO NEXT ROW
DONE:   RETURN
 $END
"
"****** MMUL = MATRIX MULTIPLY /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE MMUL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MMUL, 9.                          "USER-DIRECTED-CALL ENTRY
"              ---ABSTRACT---
"MATRIX MULTIPLY
"THIS WILL MULTIPLY MATRIX A BY MATRIX B, AND STORE THE
"ANSWER IN MATRIX C.  MATRICES A AND B MAY BE OF ANY
"DIMENSIONS, BUT THE NUMBER OF COLUMNS OF A MUST EQUAL
"THE NUMBER OF ROWS OF B.
"              ---STATISTICS---
"LANGUAGE:     AP-120B ASSEMBLER
"EQUIPMENT:    AP-120B WITH EITHER MEMORY
"STORAGE:      PS - 60.
"              MD - NONE
"              TM - NONE
"              DPX - 3
"              DPY - 32
"              SP - 9
"
"    --- HISTORY ---
"ORIGINAL:  NOV 75  S. CAMLEY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN NRC,NCC, OR NCA = 0
"
"              ---USAGE---
"SAMPLE CALL:  JSR MMUL
"ARGUMENTS:    IN S-PAD
"                0     A - BASE ADDRESS OF A
"                1     I - INCREMENT FOR A
"                2     B - BASE ADDRESS OF B
"                3     J - INCREMENT FOR B
"                4     C - BASE ADDRESS OF C
"                5     K - INCREMENT FOR C
"                6     NRC - # OF ROWS OF C
"                7     NCC - # OF COLUMNS OF C
"                10    NCA - # OF COLUMNS OF A
"SCRATCH:      SP(0-15.)
"               DPX(-1 TO +1) WHEN DPA=0
"               DPY(0) WHEN DPA = 0 TO 31.
"               ---ALGORITHM---
"       THE FIRST COLUMN OF B (UP TO THE FIRST 32. ELEMENTS)
"IS STORED  IN DPY.  IT IS THEN MULTIPLIED BY ALL THE
"ROWS OF A (FIRST 32.  ELEMENTS OF EACH ROW), TO PRODUCE
"THE FIRST COLUMN OF C.  THEN, IF THERE WERE MORE THAN
"32. ELEMENTS IN THE ROWS OF A AND COLUMNS OF B, THE NEXT
"BLOCK OF 32. (OR LESS) ARE MULTIPLIED, AND THE RESULTS
"ARE ADDED TO WHAT IS ALREADY IN C AND THEN STORED BACK
"IN C.  THIS CONTINUES UNTIL THE FIRST COLUMN OF B IS
"EXHAUSTED.  THEN THE SECOND COLUMN OF B IS STARTED,
"MULTIPLIED BY THE ROWS OF A, AND THE ANSWERS STORED
"IN THE SECOND COLUMN OF C, AND SO ON.
"       LOOP1 IS CONTAINED IN LOOP2 WHICH IS CONTAINED IN
"LOOP3 WHICH IS CONTAINED IN LOOP4.  LOOP1 IS THE BASIC
"DOT PRODUCT, ONE ROW OF A TIMES ONE COLUMN OF B.  LOOP2
"RUNS THROUGH ALL THE ROWS OF A.  LOOP3 TESTS IF THERE
"IS ANOTHER BLOCK OF 32. ELEMENTS (OR LESS) TO BE DONE
"AND ARRANGES POINTERS.  LOOP4 STARTS THE WHOLE THING
"OVER WITH THE NEXT COLUMN OF B.
A = 0
I = 1
B = 2
J = 3
C = 4
K = 5
NRC = 6
NCC = 7
NCA = 10
"THE FOLLOWING ARE NOT PARAMETERS
NRA = 6
NRB = 10
NCB = 7
SAVNRA = 11
SAVNRB = 12
TT = 13
SBSC = 14
NRACTR = 15
NCACTR = 16
NRBCTR = 17
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMMUL,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  752
        $PARAM  9., P1(#2,#7,#11)/R/IP, P2/I/IP,
                    P3(#4,#11,#10)/R/IP, P4/I/IP,
                    P5(#6,#7,#10)/R/OP, P6/I/IP,
                    P7/I/IP, P8/I/IP, P9/I/IP
FMMUL: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MMUL:   MOV NRB,SAVNRB
        MOV NCB,NCB;            "IS ELEMENT COUNT = 0?
          BEQ ZDONE             "EXIT IF COUNT = 0
        MOV NRA,SAVNRA; DB=ZERO; LDDPA;
          BEQ ZDONE             "EXIT IF COUNT = 0
        MOV A,A; DPX<SPFN;              "SAVE ORIG A (POINTER)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        MOV I,TT                        "DO
        DEC TT                          "     I
M:      DEC TT; BEQ .+2                 "           *
        ADD NRA,NRA; BNE M              "             NRA
        LDSPI TT; DB=32.
        ADD J,B; DB=ZERO; LDDPA
LOOP4:  MOV C,C;                        "SAVE BEGINNING
                                        "  OF THIS COLUMN
        DPX(1)<SPFN                     " OF C
        MOV SAVNRB,NRB; CFL2            "RE-INITIALIZE NRB
LOOP3:  SUB J,B
                                        "TEST IF THERE ARE
                                        "  MORE THAN 32 MORE
                                        "  ELEMENTS TO DO IN
        SUB# TT,NRB                     "  COLUMN OF B
        BGT .+2; DB=ZERO; LDDPA
        CFL1; MOV NRB,NRBCTR; BR .+2    "IF NOT, USE NRB
        SFL1; MOV TT,NRBCTR             "IF SO, USE JUST 32.
"HERE START STORING COL. OF B INTO DPY
        MOV B,B; SETMA                  "GET ELE. OF COL. OF B
        NOP                             "FOR UPWARD COMPATIBILITY
        ADD J,B;                        "GET NEXT ELEMENT
          SETMA                         "  OF COL. OF B
GET:    DPY<MD; INCDPA;                 "STORE COL. OF B IN
          DEC NRBCTR                    "  DPY (UP TO 32.)
        ADD J,B; SETMA; BNE GET         "SAME
        SUB K,C; DB=ZERO; LDDPA
        SUB I,A
        MOV SAVNRA,NRACTR               "RE-INITIALIZE NRACTR
LOOP2:  ADD K,C;                        "GET WHAT WAS PUT
          SETMA                         "IN C LAST TIME
                                        "CHECK IF THERE ARE
                                        "  MORE THAN 32. MORE
                                        "  ELEMENTS TO DO IN ROW
                                        "  OF A (SEE TEST OF
        BFL1 .+2                        "  COL. OF B)
        MOV NCA,NCACTR; BR .+2          "IF NOT, USE NCA
        MOV TT,NCACTR                   "IF SO, USE JUST 32.
"HERE START GETTING INTO DOT PRODUCT
        ADD I,A; SETMA;                 "GET ELE.  OF ROW OF A
          DPX(-1)<MD                    "STORE WHAT GOT OUT OF C
        MOV A,SBSC
        ADD NRA,SBSC;                   "GET NEXT ELEMENT
          SETMA                         "  IN ROW OF A
                                        "MULT. ELE. OF COL. OF
        FMUL DPY,MD;                    "  B BY ELE. OF ROW OF A
          INCDPA;                       "TEST IF HAD ALREADY
                                        " PUT SOMETHING IN
        BFL2 .+2                        "  THIS COL. OF C
        FMUL;                           "IF NOT, USE 0 INSTEAD,
          ADD NRA,SBSC; SETMA;          "  AND GET NEXT ELEMENT
          DPX(-2)<ZERO; BR .+2          "  OF ROW OF A
        FMUL;                           "IF SO, JUST GET NEXT
          ADD NRA,SBSC; SETMA           "  ELE. OF ROW OF A
        FMUL DPY,MD; INCDPA;            "CONTINUE DOT PRODUCT,
          DEC NCACTR                    "  TESTING WHEN DONE
        FADD FM,DPX(-3);                "ADD EITHER 0 OR WHAT
          FMUL;                         "  GOT BACK OUT OF C,
          ADD NRA,SBSC; SETMA;          "  AND CONTINUE DOT
          BEQ ONE                       "  PRODUCT
"NOTE:  DPX(-3) OF THE LAST INSTRUCTION = DPX(-2) ABOVE
"       = DPX(-1) ABOVE, DUE TO INCDPA
LOOP1:  DEC NCACTR;                     "BASIC
          FMUL DPY,MD; INCDPA;          "  DOT PRODUCT
          FADD                          "  LOOP
        BNE LOOP1; FADD FM,FA; FMUL;    "SAME
          ADD NRA,SBSC; SETMA
ONE:    FADD
        MOV C,C; SETMA; MI<FA           "STORE ANSWER INTO C
                                        "TEST IF DONE
        DEC NRACTR                      "  ALL ROWS OF A
        BNE JUMP2;                      "IF NOT, GO DO
          DB=ZERO; LDDPA                "  NEXT ROW
                                        "IF SO, CHECK IF
                                        "  HAD MORE THAN
        BFL1 .+2                        "  32. ELEMENTS
                                        "IF NOT, THEN CAN
                                        "  GO ON TO NEXT COL.
        BR  NEXT                        "  OF B (AND C)
                                        "IF SO, GET A (PTR) TO
                                        "  APPROPRIATE PLACE
                                        "  FOR NEXT BLOCK OF
        SUB NRA,SBSC                    "  32. (OR LESS)
        SUB NRA,SBSC                    "SAME
        SUB NRA,SBSC                    "SAME
        ADD I,SBSC                      "SAME
        MOV SBSC,A                      "SAME
        LDSPI C;                        "RETURN TO BEGIN.
          DB=DPX(1)                     "  OF SAME COL. OF C
                                        "SUBTRACT 32. FROM
                                        "  NRB LEFT TO DO AND
        SUB TT,NRB;                     "  CONT WITH SAME COL OF B
                                        "SET FLAG TO DENOTE SOME-
                                        "  THING HAS ALREADY BEEN
        SFL2                            "  PUT IN THIS COL OF C
                                        "GO BACK TO DOING DOT
                                        "  PRODUCT WITH NEXT
                                        "  BLOCK OF 32. ELE.
                                        "  FROM THIS COL OF
        JMP LOOP3                       "  B AND ROWS OF A
JUMP2:  JMP LOOP2
                                        "TEST IF FINISHED
NEXT:   DEC NCB                         "  ALL COLS OF B
        BNE .+2
        RETURN                          "IF SO, DONE AT LAST
        ADD K,C;                        "IF NOT, MOVE ON
          DB=ZERO; LDDPA                "  TO NEXT COL. OF C
        LDSPI A; DB=DPX                 "RETURN ORIG A (POINTER)
                                        "START OVER WITH
        JMP LOOP4                       "  NEXT COL OF B
        $END
"****** MMUL32 = MATRIX MULTIPLY, 32 X 32 OR LESS /COMMON= REL 3.1, SEP 79 *****
        $TITLE MMUL32
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MMUL32, 9.                          "USER-DIRECTED-CALL ENTRY
"               ---ABSTRACT---
"MATRIX MULTIPLY (SHORTENED FORM) FOR USE WHEN THE
"NUMBER OF COLUMNS IN MATRIX A AND THE NUMBER OF
"ROWS IN MATRIX B ARE LESS THAN OR EQUAL TO 32.
"THIS MULTIPLIES MATRIX A BY MATRIX B AND PUTS
"THE ANSWER IN MATRIX C.
"               ---STATISTICS---
"LANGUAGE:      AP-120B ASSMEBLER
"EQUIPMENT:     AP-120B WITH EITHER MEMORY
"STORAGE:       PS - 29.
"               MD - NONE
"             TM - NONE
"               DPX - NONE
"               DPY - UP TO 32.
"               SP - 15.
"
"    --- HISTORY ---
"ORIGINAL:  NOV 75  S. CAMLEY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN NRC,NCC, OR NCA = 0
"
"               ---USAGE---
"SAMPLE CALL:   JSR MMUL32
"ARGUMENTS:     IN S-PAD
"                 0     A - BASE ADDRESS OF A
"                 1     I - INCREMENT FOR A
"                 2     B - BASE ADDRESS OF B
"                 3     J - INCREMENT FOR B
"                 4     C - BASE ADDRESS OF C
"                 5     K - INCREMENT FOR C
"                 6     NRC - # OF ROWS OF C
"                 7     NCC - # OF COLUMNS OF C
"                 10    NCA - # OF COLUMNS OF A
"SCRATCH:       SP(0-14.), DPY(0), DPA(0- # OF ROWS OF B)
"                  --- TIMING ---
"TIMING:  IN CYCLES OF 167 NS.
"
"<2-3> MEANS 2 OR 3 CYCLES, DEPENDING ON THE MEMORY INTERLEAVE
"       DOT PRODUCTS: NRC(2+(NCA+3)<2-3>)   LOOP2 AND LOOP3
"       GETTING A COLUMN OF C:  (NCA+2)<2-3>   GET
"       TOTAL PER COLUMN OF C:     LOOP1
"         (4+(NCA+2)<2-3> + NRC(2+(NCA+3)<2-3>)
"TOTAL:  7 +2(I-1) + NCC(4+(NCA+2)<2-3> + NRC(2+(NCA+3)<2-3>))
"
"IN US.: 1.2 + .33(I-1) + NCC(.67+(NCA+2)<.33-.5> + NRC(.33+(NCA+3)
"         <.33-.5>))
"S-PAD PARAMETERS:
A = 0
I = 1
B = 2
J = 3
C = 4
K = 5
NRC = 6
NCC = 7
NCA = 10
"THE FOLLOWING ARE NOT PARAMETERS:
NRA = 6
NRB = 10
NCB = 7
SAVNRA = 11
SAVEA = 12
NCACTR = 13
NRACTR =14
SBSC = 15
JUNK = 16
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMMU32,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  752
        $PARAM  9., P1(#2,#7,#11)/R/IP, P2/I/IP,
                    P3(#4,#11,#10)/R/IP, P4/I/IP,
                    P5(#6,#7,#10)/R/OP, P6/I/IP,
                    P7/I/IP, P8/I/IP, P9/I/IP
FMMU32: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MMUL32: SUB K,C
        SUB I,A
        MOV A,SAVEA
        MOV NCB,NCB             "IS ELEMENT COUNT = 0?
        MOV NRA,SAVNRA;
          BEQ ZDONE             "EXIT IF COUNT = 0
        MOV I,JUNK;             "DO
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        DEC JUNK                "  I
M:      DEC JUNK; BEQ .+2       "    *
        ADD NRA,NRA; BGT M      "     NRA
LOOP3:  MOV B,B; SETMA          "GET FIRST B IN COL.
        MOV NRB,JUNK;           "SET COUNTER
          DB=ZERO; LDDPA
        ADD J,B; SETMA;         "GET NEXT B IN COL.
          BEQ ZDONE             "EXIT IF COUNT = 0
GET:    DPY<MD; DEC JUNK        "THIS LOOP STORES
        INCDPA; ADD J,B; SETMA; "  FIRST COL OF B
          BGT GET               "  INTO DPY
        MOV SAVNRA,NRACTR
        MOV SAVEA,A
LOOP2:  ADD I,A; SETMA;         "GET FIRST A IN ROW
          FADD ZERO,ZERO
        MOV A,SBSC; DB=ZERO; LDDPA
        ADD NRA,SBSC; SETMA     "GET NEXT A IN ROW
        FMUL DPY,MD; INCDPA;    "FIRST A * FIRST B
          MOV NCA,NCACTR        "SET COUNTER
        ADD NRA,SBSC; SETMA;    "GET THIRD A IN ROW
          FMUL
LOOP1:  FMUL DPY,MD; INCDPA;    "BASIC DOT
          FADD; DEC NCACTR      "  PRODUCT LOOP
        FADD FM,FA; FMUL;       "SAME
          ADD NRA,SBSC; SETMA;
          BGT LOOP1
        FADD; DEC NRACTR
        ADD K,C; SETMA; MI<FA;  "STORE ANSWER IN C
                                "TEST IF DONE ALL
          BGT LOOP2             "  ROWS OF A
        DEC NCB
        BGT LOOP3 + 1;          "TEST IF DONE ALL
                                "  COLUMNS OF B
                                "GET FIRST B IN
        SUB J,B; SETMA          "  NEXT COLUMN
        RETURN
        $END
"****** MVML3 = MATRIX-VECTOR MULTIPLY (3 X 3) /COMMON/ = REL 3.1, SEP 79 *****
"  FOR EITHER MEMORY
        $TITLE MVML3
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MVML3, 9.                          "USER-DIRECTED-CALL ENTRY
"A SERIES OF O ELEMENT VECTORS MULTIPLIED BY A 3X3 MATRIX
"               ---ABSTRACT---
"THIS MULTIPLIES A 3X3 MATRIX BY A SERIES OF VECTORS (3 ELEMENTS EACH).
"THE OUTPUT IS A SERIES OF 3-ELEMENT VECTORS.
"               ---STATISTICS---
"LANGUAGE:      AP-120B ASSEMBLER
"EQUIPMENT:     AP-120B WITH EITHER MEMORY
"SIZE:          29. LOCATIONS
"
"    --- HISTORY ---
"ORIGINAL:  JAN 76  S. CAMLEY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC   MEANING
" 0             A       BASE ADDRESS OF 3X3 MATRIX
" 1             I       INCREMENT FOR A
" 2             B       BASE ADDRESS OF VECTORS
" 3             J       INCREMENT WITHIN EACH VECTOR
" 4             JP      INCREMENT BETWEEN VECTORS
" 5             C       BASE ADDRESS OF ANSWER VECTORS
" 6             K       INCREMENT WITHIN VECTORS
" 7             KP      INCREMENT BETWEEN VECTORS
" 10            N       # OF VECTORS
"NOTE:          THE INCREMENTS BETWEEN VECTORS, JP AND KP, ARE
"               FIGURED FROM THE FIRST ELEMENT OF THE LTH VECTOR TO THE
"               FIRST ELEMENT OF THE (L+1)TH VECTOR.
"               ---SCRATCH---
"S-PAD:         0-11.
"DATA PAD:      DPX(-4 TO +4), DPY(-4,-3,-2,0,1,2), FOR DPA=4
"S-PAD PARAMETERS:
A = 0
I = 1
B = 2
J = 3
JP = 4
C = 5
K = 6
KP = 7
N = 10
"THE FOLLOWING ARE NOT PARAMETERS:
CTR = 11
SAVEB = 12
SAVEC = 13
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMVMU3,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  732
        $PARAM  9., P1(#2,3,3)/R/IP, P2/I/IP,
                    P3(#5,3)/R/IP, P4/I/IP, P5/I/IP,
                    P6(#10,3)/R/OP, P7/I/IP, P8/I/IP,
                    P9/I/IP
FMVMU3: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MVML3:  MOV A,A; SETMA               "GET A(1,1)
          DB=ZERO; LDDPA             "DPA=0
        DB=9.; LDSPI CTR
        ADD I,A; SETMA               "GET A(2,1)
PUT:    DPX<MD; INCDPA; DEC CTR      "THIS LOOP PUTS
        ADD I,A; SETMA; BGT PUT      "MATRIX A INTO DPX
        MOV B,SAVEB; SETMA           "GET B(1)
        DB=4; LDDPA                  "DPA=4
        ADD J,B; SETMA               "GET B(2)
        DPY<MD;                      "STORE B(1)
          FMUL DPX(-4),MD;           "DO A(1,1)*B(1)
          MOV C,SAVEC
        ADD J,B; SETMA;              "GET B(3)
          FMUL DPX(-3),MD            "DO A(2,1)*B(1)
        DPY(1)<MD;                   "STORE B(2)
          FMUL DPX(-1),MD;           "DO A(1,2)*B(2)
          SUB KP,SAVEC
        FMUL DPX,MD;                 "DO A(2,2)*B(2)
          FADD FM,ZERO               "A(1,1) IN ADDER
        DPY(2)<MD;                   "STORE B(3)
          FMUL DPX(2),MD;           "AA(1,3)*B(3)
          FADD FM,ZERO               "A(2,1)B(1) IN ADDER
        FMUL DPX(3),MD;              "DO A(2,3)*B(3)
          FADD FM,FA                 "A(1,1)B(1)+A(1,2)B(2)
        FADD FM,FA; FMUL;            "A(2,1)B(1)+A(2,2)B(2)
          MOV N,N               "IS ELEMENT COUNT = 0?
        FADD FM,FA; FMUL;            "A(1,1)B(1)+A(1,2)B(2)+A(1,3)B(3)
          BEQ DONE              "EXIT IF COUNT = 0
LOOP:   FADD FM,FA;                  "A(2,1)B(1)+A(2,2)B(2)+A(2,3)B(3)
          FMUL DPX(-2),DPY           "DO A(3,1)*B(1)
        DPY(-4)<FA;                  "SAVE C(1)
          FMUL DPX(1),DPY(1);        "DO A(3,2)*B(2)
          INCDPA; FADD;              "DPA=5
          ADD JP,SAVEB; SETMA        "GET B(1) OF NEXT VECTOR
        DPY(-4)<FA;                  "SAVE C(2)
          FMUL DPX(3),DPY(1);        "DO A(3,3)*B(3)
          DECDPA;                    "DPA=4
          MOV SAVEB,B
        DPY(-2)<FM; FMUL;            "SAVE A(3,1)B(1)
          ADD J,B; SETMA             "GET B(2) OF NEXT VECTOR
        FADD FM,DPY(-2);             "A(3,1)B(1)+A(3,2)B(2)
          DPY<MD;                    "STORE NEW B(1)
          FMUL DPX(-4),MD            "DO A(1,1)*B(1)  (NEW)
        DPY(-2)<FM; FADD;            "SAVE A(3,3)B(3)
          ADD J,B; SETMA;            "GET NEW B(3)
          FMUL DPX(-3),MD            "DO A(2,1)*B(1)  (NEW)
        FADD DPY(-2),FA;             "A(3,1)B(1)+A(3,2)B(2)+A(3,3)B(3)
          DPY(1)<MD;                 "STORE NEW B(2)
          FMUL DPX(-1),MD            "DO A(1,2)*B(2)  (NEW)
"HEREAFTER, B(L) REFERS TO THE NEW B
        ADD KP,SAVEC; SETMA; MI<DPY(-4); "STORE C(1)
          DECDPA;                    "DPA=3
          FMUL DPX,MD;               "DO A(2,2)*B(2)
          FADD FM,ZERO               "A(1,1)B(1) IN ADDER
        DPX(-4)<FA;                  "SAVE C(3)
          INCDPA;                    "DPA=4
          DPY(3)<MD;                 "STORE B(3)
          FMUL DPX(3),MD;            "DO A(1,3)*B(3)
          FADD FM,ZERO;              "A(2,1)B(1) IN ADDER
          MOV SAVEC,C
        ADD K,C; SETMA; MI<DPY(-3);  "STORE C(2)
          FMUL DPX(3),MD;            "DO A(2,3)B(3)
          FADD FM,FA                 "A(1,1)B(1)+A(1,2)B(2)
        DEC N; DECDPA;               "DPA=3
          FADD FM,FA; FMUL           "A(2,1)B(1)+A(2,2)B(2)
        ADD K,C; SETMA; MI<DPX(-4);  "STORE C(3)
          INCDPA;                    "DPA=4
          BNE LOOP;                  "TEST IF DONE
          FADD FM,FA; FMUL           "A(1,1)B(1)+A(1,2)B(2)+A(1,3)B(3)
DONE:   RETURN                  "EXIT
        $END
"****** MVML4 = MATRIX-VECTOR MULTIPLY (4 X 4) /COMMON/ = REL 3.2, AUG 80 *****
"   FOR EITHER MEMORY
        $TITLE MVML4
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MVML4, 9.                          "USER-DIRECTED-CALL ENTRY
"4 ELEMENT VECTORS MULTIPLIED BY A 4X4 MATRIX
"               ---ABSTRACT---
"THIS MULTIPLIES A 4X4 MATRIX BY A SERIES OF VECTORS (4 ELEMENTS EACH).
"THE OUTPUT IS A SERIES OF 4-ELEMENT VECTORS.
"               ---STATISTICS---
"LANGUAGE:      AP-120B ASSEMBLER
"EQUIPMENT:     AP-120B WITH EITHER MEMORY
"SIZE:          40. LOCATIONS
"
"         ---HISTORY---
"ORIGINAL:  DEC 75, S. CAMLEY
" REV 2.1:  JUL 77, R.S. NORIN    CORRECTS MISSING  ADD JP,SAVEB; IN 'INTER:'
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80  R. GELLER      CORRECT ADC LINKAGE
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC   MEANING
" 0             A       BASE ADDRESS OF 4X4 MATRIX
" 1             I       INCREMENT FOR A
" 2             B       BASE ADDRESS OF VECTORS
" 3             J       INCREMENT WITHIN EACH VECTOR
" 4             JP      INCREMENT BETWEEN VECTORS
" 5             C       BASE ADDRESS OF ANSWER VECTORS
" 6             K       INCREMENT WITHIN VECTORS
" 7             KP      INCREMENT BETWEEN VECTORS
" 10            N       # OF VECTORS
"NOTE:          THE INCREMENTS BETWEEN VECTORS, JP AND KP, ARE
"               FIGURED FROM THE FIRST ELEMENT OF THE LTH VECTOR TO THE
"               FIRST ELEMENT OF THE (L+1)TH VECTOR.
"               ---SCRATCH---
"S-PAD:         0-13.
"DATA PAD:      DPX(0-15.), DPY(0,4,8., 12.), DPA
"S-PAD PARAMETERS:
A = 0
I = 1
B = 2
J = 3
JP = 4
C = 5
K = 6
KP = 7
N = 10
"THE FOLLOWING ARE NOT PARAMETERS:
NEXT = 11
CTR = 12
FOUR = 13
SAVEB = 14
SAVEC = 15
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMVML4,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  732
        $PARAM  9., P1(#2,4,4)/R/IP, P2/I/IP,
                    P3(#5,4)/R/IP, P4/I/IP, P5/I/IP,
                    P6(#10,4)/R/OP, P7/I/IP, P8/I/IP,
                    P9/I/IP
FMVML4: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MVML4:  LDSPI FOUR; DB=4
        MOV N,N                 "IS ELEMENT COUNT = 0?
        MOV A,A; SETMA;          "GET A(1,1)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
          DB=ZERO; LDDPA
        LDSPI CTR; DB=16.
        ADD I,A; SETMA           "GET A(2,1)
LOOP:   DPX<MD; INCDPA; DEC CTR  "THIS LOOP STORES
        ADD I,A; SETMA; BGT LOOP "  MATRIX A INTO DPX
        MOV B,SAVEB; SETMA       "GET B(1)
        CLR NEXT; SETDPA         "DPA=0
        ADD J,B; SETMA           "GET B(2)
        DPY<MD;                  "STORE B(1)
          ADD FOUR,NEXT; SETDPA; "DPA=4
          FMUL DPX,MD            "DO A(1,1)*B(1)
        ADD J,B; SETMA;          "GET B(3)
          FMUL DPX(-3),MD        "DO A(2,1)*B(1)
        DPY<MD;                  "STORE B(2)
          ADD FOUR,NEXT; SETDPA; "DPA=8
          FMUL DPX,MD            "DO A(1,2)*B(2)
        ADD J,B; SETMA;          "GET B(4)
          FMUL DPX(-3),MD;       "DO A(2,2)*B(2)
          FADD FM,ZERO           "A(1,1)*B(1) IN ADDER
        DPY<MD;                  "STORE B(3)
          FMUL DPX,MD;           "DO A(1,3)*B(3)
          FADD FM,ZERO;          "A(2,1)*B(1) IN ADDER
          MOV C,SAVEC
        FMUL DPX(1),MD;          "DO A(2,3)*B(3)
          ADD FOUR,NEXT; SETDPA; "DPA=12
          FADD FM,FA             "A(1,1)B(1)+A(1,2)B(2)
        DPY<MD;                  "STORE B(4)
          FMUL DPX,MD;           "DO A(1,4)*B(4)
          FADD FM,FA;            "A(2,1)B(1)+A(2,2)B(2)
          SUB KP,SAVEC
        FMUL DPX(1),MD;          "DO A(2,4)B(4)
          CLR NEXT; SETDPA;      "DPA=0
          FADD FM,FA             "A(1,1)B(1)+A(1,2)B(2)+A(1,3)B(3)
LOOP2:  FMUL DPX(2),DPY;         "DO A(3,1)*B(1)
          FADD FM,FA;            "A(2,1)B(1)+A(2,2)B(2)+A(2,3)B(3)
          ADD JP,SAVEB
        FMUL DPX(3),DPY;         "DO A(4,1)*B(1)
          ADD FOUR,NEXT; SETDPA; "DPA=4
          FADD FM,FA             "A(1,1)B(1)+...+A(1,4)B(4)
        FMUL DPX(2),DPY;         "DO A(3,2)*B(2)
          FADD FM,FA;            "A(2,1)B(1)+...+A(2,4)B(4)
          ADD KP,SAVEC
        MOV SAVEC,C; SETMA; MI<FA"STORE C(1)
        FMUL DPX(3),DPY;         "DO A(4,2)*B(2)
           ADD FOUR,NEXT; SETDPA;"DPA=8
          FADD FM,ZERO           "A(3,1)*B(1) IN ADDER
        FMUL DPX(2),DPY;         "DO A(3,3)*B(3)
          FADD FM,ZERO;          "A(4,1)*B(1) IN ADDER
          ADD K,C; SETMA; MI<FA  "STORE C(2)
        FMUL DPX(3),DPY;         "DO A(4,3)*B(3)
           ADD FOUR,NEXT; SETDPA;"DPA=12
          FADD FM,FA             "A(3,1)B(1)+A(3,2)B(2)
        FMUL DPX(2),DPY;         "DO A(3,4)*B(4)
          FADD FM,FA;            "A(4,1)B(1)+A(4,2)B(2)
          MOV SAVEB,B; SETMA     "GET B(1) OF NEXT VECTOR
        FMUL DPX(3),DPY;         "DO A(4,4)B(4)
          FADD FM,FA;            "A(3,1)B(1)+A(3,2)B(2)+A(3,3)B(3)
           CLR NEXT; SETDPA      "DPA=0
         ADD J,B; SETMA;          "GET B(2) OF NEXT VECTOR
          BR .+2
"--------------------------------------------------------------------
"THE END OF LOOP2 CAN'T BRANCH ALL THE WAY BACK TO THE BEGINNING, SO
"IT BRANCHES TO THIS INTERMEDIATE POINT.  THIS IS JUST THE FIRST
"INSTRUCTION OF LOOP2, BRANCHING TO THE SECOND.  THE FLOW OF
"INSTRUCTIONS BRANCHES AROUND THIS POINT.
INTER:  FMUL DPX(2),DPY;
          FADD FM,FA;
          ADD JP,SAVEB;
          BR LOOP2 + 1
"--------------------------------------------------------------------
        DPY<MD;                  "STORE NEW B(1)
          ADD FOUR,NEXT; SETDPA; "DPA=4
          FMUL DPX,MD;           "DO A(1,1)*B(1)  (NEW)
          FADD FM,FA             "A(4,1)B(1)+A(4,2)B(2)+A(4,3)B(3)
        ADD J,B; SETMA;          "GET NEW B(3)
          FMUL DPX(-3),MD;       "DO A(2,1)*B(1)  (NEW)
          FADD FM,FA             "A(3,1)B(1)+...+A(3,4)B(4)
        DPY<MD;                  "STORE NEW B(2)
           ADD FOUR,NEXT; SETDPA;"DPA=8
          FMUL DPX,MD;           "DO A(1,2)*B(2)  (NEW)
          FADD FM,FA             "A(4,1)B(1)+...+A(4,4)B(4)
        ADD K,C; SETMA; MI<FA    "STORE C(3)
"FROM HERE ON, B(L) REFERS TO THE NEW VECTOR
        ADD J,B; SETMA;          "GET B(4)
          FMUL DPX(-3),DPY(-4);  "DO A(2,2)B(2)
          FADD FM,ZERO           "A(1,1)B(1) IN ADDER
        DPY<MD;                  "STORE B(3)
          FMUL DPX,MD;           "DO A(1,3)*B(3)
          FADD FM,ZERO;          "A(2,1)B(1) IN ADDER
          ADD K,C; SETMA; MI<FA  "STORE C(4)
        FMUL DPX(1),DPY;         "DO A(2,3)*B(3)
          ADD FOUR,NEXT; SETDPA; "DPA=12
          FADD FM,FA             "A(1,1)B(1)+A(1,2)B(2)
        DPY<MD;                  "STORE B(4)
          FMUL DPX,MD;           "DO A(1,4)*B(4)
          FADD FM,FA;            "A(2,1)B(1)+A(2,2)B(2)
          DEC N
        FMUL DPX(1),MD;          "DO A(2,4)B(4)
           CLR NEXT; SETDPA;     "DPA=0
          FADD FM,FA;            "A(1,1)B(1)+A(1,2)B(2)+A(1,3)B(3)
          BNE INTER              "TEST IF DONE ALL VECTORS
        RETURN                   "IF SO, THE END
        $END
"***** MATINV = MATRIX INVERSE (GAUSSIAN ELIMINATION) /COMMO= REL 3.2, MAR 80 **
"   FOR EITHER MEMORY
        $TITLE MATINV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MATINV, 2                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV
"MATRIX INVERSE
"                  --- ABSTRACT ---
"THIS INVERTS AN N-BY-N MATRIX BY GAUSSIAN ELIMINATION AND PUTS
"THE INVERSE IN THE N*N MEMORY LOCATIONS FOLLOWING THE ORIGINAL
"MATRIX, WHICH IS DESTROYED.
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH EITHER MEMORY
"SIZE:       133. LOCATIONS   PLUS DIVIDE(28.) = 161.
"SUBROUTINE USED:  DIVIDE
"       --- HISTORY ---
"
"ORIGINAL:      DEC 75         S. CAMLEY
"REVISED:       APR 79          W.H.INSKEEP--NOW RETURNS SINGULARITY CONDITION
"                                  IN MD(IERR) AS WELL AS IN SP(15.).
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2: MAR 80  R.S. NORIN   FUNCTIONALITY RETURNED TO THAT
"                                        PRIOR TO APR 79 REVISION.  I.E.,
"                                        SINGULARITY STATUS RETURNED ONLY
"                                        IN SP(15).
"                                        THE ROUTINE XMATIN PRESERVES THE
"                                        APR 79- FEB 80 FUNCTIONALITY. I.E.,
"                                        WHERE THE SINGULARITY STATUS IS ALSO
"                                        STORED INTO MD.
"
"                  ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC      MEANING
"0           A (APTR)      BASE ADDRESS OF INPUT MATRIX
"1           N             DIMENSION OF MATRIX
"NOTE:       MATRICES ARE COLUMN-STORED.  THE BEGINNING OF THE
"            OUTPUTTED MATRIX IS AT LOCATION APTR+N*N.
"                  --- ERROR CONDITIONS ---
"       IF THE MATRIX IS SINGULAR, THE INVERSION IS ABORTED, AND +1
"         IS RETURNED IN S-PAD REGISTER 15.    OTHERWISE 0 IS RETURNED
"                  --- SCRATCH ---
"S-PAD:   0 - 10.
"DATA PAD: DPX: 0 - 31.,   DPY:  0-31.,   DPA
"PLUS THAT USED BY DIVIDE
"                  --- ALGORITHM ---
"(SEE FLOWCHART AND EXPLANATION FOR GENERAL STRUCTURE.  THE FOLLOWING
"IS DONE SECTION-BY-SECTION, MATCHING THE PROGRAM.)
"
"
"IDMAT:    AN IDENTITY MATRIX IS CREATED FOLLOWING THE INPUTTED MATRIX
"          SUCH THAT ITS MTH ROW IS  A CONTINUATION OF THE MTH ROW OF
"          THE MTH ROW OF A.  SINCE A IS INPUTTED COLUMN-WISE, IT JUST
"          ADDS N MORE COLUMNS OF 1'S AND 0'S, THUS DOUBLING THE AMOUNT
"          OF MEMORY USED.
"          POINTERS--IPTR STARTS AT THE LAST LOCATION OF A AND MOVES
"                    THROUGH THE IDENTITY MATRIX COLUMN-WISE.
"          COUNTERS--CTR2 IS INITIALIZED TO N AND COUNTS THE # OF 1'S
"                    CREATED.
"                    CTR1 COUNTS THE # OF 0'S CREATED AFTER EACH 1,
"                    AND IS REINITIALIZED TO N AFTER EACH BATCH.
"(NOTE FOR THE FOLLOWING:  NCTR IS A GLOBAL COUNTER, COUNTING DOWN FROM
"N FOR EACH TIME THROUGH MAX-FORDELIM.  WITHIN BACKSUB, IT COUNTS
"BACK UP TO N.)
"MAX:      THE SCAN FOR MAXIMUM WITHIN A COLUMN PRODUCES THE PIVOT
"          POINT.  THE PROGRAM LEADS INTO AN UNUSUAL 2-CYCLE LOOP,
"          WHICH ASSUMES THE OLD MAXIMUM WILL REMAIN THE MAXIMUM UNTIL
"          PROVEN OTHERWISE, BY WHICH TIME DATA FOLLOWING THE NEW MAX
"          HAS ALREADY BEEN COMPARED WITH THE OLD MAX.  AT THIS POINT
"          THE PROGRAM BRANCHES TO TRADE, WHICH RE-INSTATES THE NEW MAX
"          AND COMPARES THE ALREADY-COMPARED DATA FOLLOWING THE NEW MAX.
"          THEN IT GOES BACK TO THE LOOP.  THE ADDRESS OF THE NEW MAX IS
"          ALSO DISCOVERED TOO LATE, SO A DISPLACEMENT CORRECTION IS
"          MADE WHEN THIS SECTION IS DONE.
"          POINTERS--SAVEA HOLDS THE TOP OF THE PART OF THE COLUMN
"                    BEING CONSIDERED AND MOVES DOWN ALONG THE MAIN
"                    DIAGONAL EACH TIME THROUGH MAX.
"                    APTR FETCHES THE POINTS BEING COMPARED AND MOVES
"                    DOWN THE COLUMN.
"                    SAVADD HOLDS THE ADDRESS (PLUS DISP.) OF THE PIVOT.
"          COUNTERS--CTR1 COUNTS DOWN FROM NCTR-1 TO 0 WITHIN MAXLOOP.
"                    NCTR=N, FIRST TIME THROUGH MAX
"                        =N-1, SECOND TIME THROUGH MAX
"                        =2, LAST TIME THROUGH MAX
"DONEMAX:  ONCE THE PIVOT POINT IS FOUND, ITS INVERSE IS MULTIPLIED BY
"SWAP:     THE ENTIRE PIVOT ROW.  IF THE PIVOT ROW IS NOT THE 'TOP' ROW,
"NOSWAP:   THE 2 ROWS ARE SWAPPED.  THE 'TOP' ROW IS THE FIRST ROW THE
"          FIRST TIME THROUGH THIS SECTION, THE SECOND ROW THE NEXT
"          TIME THROUGH, ETC.
"          POINTERS--SAVEA HOLDS THE BEGINNING OF THE 'TOP' ROW.  (THE
"                    BEGINNING IS PT. A(J,J) FOR ROW J.)
"                    APTR MOVES ALONG THE 'TOP' ROW.
"                    SAVADD HOLDS THE BEGINNING OF THE PIVOT ROW (PT.
"                    A(J+L,J) FOR ROW J+L), I.E. THE PIVOT PT.
"                    APTR2 MOVES ALONG THE PIVOT ROW.
"          COUNTERS--NCTR IS DECREMENTED IN DONEMAX.
"                    CTR1 COUNTS DOWN FROM N+NCTR TO 0.  IT KEEPS TRACK
"                    OF HOW MANY ELEMENTS TO MULT. AND SWAP.
"FORDELIM: THE PIVOT ROW IS NOW THE 'TOP' ROW (ROW J).  THE TERM
"          'FIRST ELEMENT' REFERS TO THE ELEMENT IN COLUMN J.  ROW
"          J+L IS REPLACED BY
"          (FIRST ELE OF ROW J+L)*(ROW J)-(FIRST ELE OF ROW J)*(ROW J+L)
"          SINCE THE MULTIPLICATION BY 1/PIV WOULD AUTOMATICALLY HAVE
"          CAUSED THE FIRST ELE OF ROW J TO BECOME 1 (THE ACTUAL
"          MULTIPLICATION FOR THAT PT WAS THEREFORE NEVER DONE), THE
"          ABOVE IS REDUCED TO
"          A(J+L,J)*(ROW J)-(ROW J+L).
"          THE NEW FIRST ELE OF ROW J+L WILL ALWAYS BECOME 0, SO THE
"          CALCULATION FOR THIS PT IS NOT DONE.
"          THRUROW GOES THROUGH THE ELEMENTS OF EACH ROW.
"          NEXT ROW GOES THROUGH ROWS J+1 TO N.
"          POINTERS--SAVEA PTS TO A(J,J) (FIRST ELE OF 'TOP' ROW).
"                    APTR MOVES ALONG THE 'TOP' ROW.
"                    SAVADD PTS TO A(J+L,J) (FIRST ELE OF ROW J+L).
"                    APTR2 MOVES ALONG ROW J+L.
"          COUNTERS--CTR1 COUNTS DOWN FROM N+NCTR TO 0, KEEPS TRACK OF
"                    THE # OF ELE TO DO IN EACH ROW, AND IS
"                    RE-INITIALIZED AT EACH NEW ROW.
"                    CTR2 COUNTS DOWN FROM NCTR TO 0 AND KEEPS TRACK
"                    OF HOW MANY ROWS NEED TO BE DONE.
"AT THIS POINT THE PROGRAM JUMPS BACK TO MAX AND STARTS OVER WITH
"COLUMN J+1.  NCTR HAS ALREADY BEEN DECREMENTED.  THE 'TOP' ROW WILL
"BE ROW J+1.
"HOWEVER, IF NCTR=1, THERE IS NO POINT IN SCANNING FOR MAX OR DOING A
"FORWARD ELIMINATION.  ALL THAT NEEDS TO BE DONE IS
"(1/PIV)*(ROW N), WHERE PIV=A(N,N).
"LASTROW:  THIS HANDLES THE NCTR=1 CASE, DOING THE ELEMENTS OF ROW N
"          FROM THE END BACKWARD.  IT DOES NOT COMPUTE (1/PIV)*PIV.
"          POINTERS--SAVEA HOLDS THE PIVOT PT.
"                    SAVADD HOLDS THE LAST PT IN ROW N.
"                    APTR MOVES ALONG THE ROW FROM SAVADD TOWARD SAVEA.
"          COUNTERS--CTR1 COUNTS DOWN FROM N TO 0, KEEPING TRACK OF THE
"                    # OF ELE TO DO.
"BACKSUB:  THE LAST ROW OF THE FORMER IDENTITY MATRIX IS NOW THE LAST
"          ROW OF A INVERSE.  ROWS 1 TO N-1 STILL HAVE TO BE COMPUTED.
"          THE ROWS ARE DONE IN REVERSE ORDER, FROM N-1 TO 1.  WITHIN
"          A ROW, EACH PT IS COMPUTED STARTING WITH THE LAST PT.
"          A POINT IS COMPUTED BY GETTING THE CORRESPONDING ELE FROM THE
"          FORMER IDENTITY MATRIX, AND SUBTRACTING FROM IT THE DOT
"          PRODUCT OF THE ELEMENTS BELOW IT IN THE SAME COLUMN AND THE
"          ELEMENTS OF ITS CORRESPONDING ROW IN A STARTING AFTER THE
"          MAIN DIAGONAL.  IN OTHER WORDS, PT I(M,Q) OF THE FORMER
"          IDENTITY MATRIX IS REPLACED BY
"          I(M,Q)-I(M+1,Q)*A(M,M+1)-I(M+2,Q)*A(M,M+2)..-I(N,Q)*A(M,N).
"          PTSUB COMPUTES EACH PT.  ROWSUB GOES THROUGH EACH ROW
"          (Q=Q-1).  BACKSUB GOES THROUGH ALL THE ROWS (M=M-1).
"          POINTERS--SAVEA PTS TO A(M,M+1) FOR EACH ROW OF I
"                    APTR2 MOVES FROM A(M,M+1) TO A(M,N) FOR EACH PT.
"                    SAVADD PTS TO I(M,N) FOR EACH ROW M OF I
"                    IT PTS TO I(M,Q) FOR EACH PT.
"                    APTR MOVES FROM I(M+1,Q) TO I(N,Q) FOR EACH PT.
"          COUNTERS--NCTR STARTS AT 1 AND IS INCREMENTED FOR EACH NEW
"                    ROW.  WHEN IT REACHES N, BACKSUB HAS DONE N-1 ROWS,
"                    AND THE PROGRAM IS FINISHED.
"                    CTR1 COUNTS DOWN FROM NCTR TO 0, AND IS
"                    RE-INITIALIZED FOR EACH NEW PT.  IT KEEPS TRACK OF
"                    THE # OF ELEMENTS IN THE DOT PRODUCT.
"                    CTR2 COUNTS DOWN FROM N TO 0, AND IS RE-INITIALIZED
"                    FOR EACH NEW ROW.  IT KEEPS TRACK OF THE NUMBER OF
"                    PTS TO BE COMPUTED IN EACH ROW.
"S-PAD PARAMETERS:
APTR = 0
N = 1
"THE FOLLOWING ARE NOT PARAMETERS:
IPTR = 2
APTR2 = 2
CTR1 = 3
CTR2 = 4
FOUR = 5
C27 = 5
SAVEA = 6
SAVADD = 7
NCTR = 10
N2 = 11
IT = 12
ONE = !ONE
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMATIN,2                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  2
        $PARAM  2 , P1(#2,#2,2)/R/IP/OP, P2/I/IP
FMATIN: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MATINV:    LDSPI C27; DB=27.
"THIS COMPUTES N**2
           MOV N,N; DPX<SPFN
           MOV C27,C27; FADD ZERO,MDPX; "FLOAT N
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
           FADD
           DPX<FA;
             LDTMA; DB=ONE
           FMUL DPX,DPX                "DO N*N
           FMUL; MOV N,NCTR
           FMUL; MOV N,CTR2
           DPX<FM;
             MOV N,CTR1
           FIX DPX                     "FIX N**2
           FADD; DEC APTR
           DPX<FA
           LDSPI N2; DB=DPX            "STORE INTO N2
"THIS GENERATES AN IDENTITY MATRIX
IDMAT:     MOV N2,IPTR
           ADD APTR,IPTR               "SETS PTR TO IDENT MAT
PUTONE:    DEC CTR2
           INC IPTR; SETMA; MI<TM;     "PUT 1'S ALONG DIAGONAL
             BEQ OUT
PUT0:      DEC CTR1
           INC IPTR; SETMA; MI<ZERO;   "PUT 0'S ELSEWHERE
             BGT PUT0
           MOV N,CTR1; BR PUTONE
OUT:       SUB N,APTR
"THIS SEARCHES FOR THE MAXIMUM IN THE JTH COLUMN FROM ROW J DOWN.
"THIS WILL BE THE PIVOT PT.
MAX:       ADD N,APTR
           INC APTR; SETMA             "GET A(J,J)
           MOV APTR,SAVEA              "SAVEA HOLDS PTR TO A(J,J)
           INC APTR; SETMA             "GET A(J+1,J)
           FABS MD;                    "DO /A(J,J)/
             MOV NCTR,CTR1             "CTR=N+1-J
           INC APTR; SETMA; FADD       "GET A(J+2,J)
           FABS MD;                    "DO /A(J+1,J)/
             DPX<FA;                   "STORE /A(J,J)/ IN MAX
             LDSPI FOUR; DB=4
           INC APTR; SETMA; FADD       "GET A(J+3,J)
           FABS MD;                    "DO /A(J+2,J)/
             DPY<FA;                   "STORE /A(J+1,J)/
             DEC CTR1
           INC APTR; SETMA;            "GET A(J+4,J)
             FSUB DPY,DPX;             "COMPARE MAX,/A(J+1,J)/
             INCDPA                    "DPA=DPA+1
           FABS MD;                    "DO /A(J+3,J)/
             DPY<FA;                   "STORE /A(J+2,J)/
             DPX<DPX(-1);              "MOVE UP MAX
             MOV APTR,SAVADD           "SAVE ADDRESS
           INC APTR; SETMA;            "GET A(J+5,J)
             FSUB DPY,DPX;             "COMPARE MAX,/A(J+2,J)/
             INCDPA                    "DPA=DPA+1
MAXLOOP:   FABS MD;                    "DO /A(L+1,J)/
             DPY<FA;                   "STORE /A(L,J)/
             DPX<DPX(-1);              "MOVE UP MAX
             BFGT TRADE;               "TEST IF SHOULD HAVE CHANGED MAX
             DEC CTR1                  "DEC CTR
           INC APTR; SETMA;            "GET A(L+3,J)
             FSUB DPY,DPX;             "COMPARE MAX,/A(L,J)/
             INCDPA;                   "DPA=DPA+1
             BGT MAXLOOP               "TEST IF FINISHED COL
           SUB FOUR,SAVADD; SETMA;     "IF SO, GET MAX (NOT ABS)
             FADD ZERO,DPX(-1);
             BR DONEMAX
"IF SHOULD HAVE CHANGED MAX:
TRADE:     DPX<DPY(-2)                 "PUT /A(L-1,J)/ IN MAX
           FSUB DPY(-1),DPX;           "COMPARE MAX,/A(L,J)/
             MOV APTR,SAVADD           "SAVE ADDRESS
           FADD ZERO,FA;               "PUT /A(L+1,J)/ IN ADDER
             MOV CTR1,CTR1;
             BR MAXLOOP + 1            "CONTINUE WHERE LEFT OFF IN LOOP
"THIS INVERTS THE PIVOT PT AND TESTS WHETHER THE PIVOT ROW AND
"THE JTH ROW ARE THE SAME ROW
DONEMAX:   DPY<TM; FADD;               "PUT 1 IN DPY
             DEC NCTR
           MOV SAVEA,APTR; SETMA       "GET A(J,J)
           MOV NCTR,CTR1;
             BFEQ SINGULAR             "TEST IF SINGULAR MATRIX
           DPX<MD;                     "PUT MAX IN DPX
             JSR DIV                   "DO INV OF PIVOT PT
           SUB# APTR,SAVADD            "TEST IF PIV ROW=JTH ROW
           BNE SWAP;                   "IF NOT SWAP THEM
             LDTMA; DB=ONE;
             ADD N,CTR1
           JMP NOSWAP                  "IF SO, DON'T SWAP
SINGULAR:  LDSPI 17; DB=1;             "IF SINGULAR, LEAVE NOTE
             RETURN                    "  AND GO HOME
"THIS SWAPS THE JTH ROW AND THE PIVOT ROW WHILE MULTIPLYING THE
"PIVOT ROW BY THE INVERSE OF THE PIVOT PT.
                                       "FOR PIVOT ROW=PTH ROW
SWAP:      ADD N,SAVADD; SETMA         "GET A(P,P+1)
           DEC CTR1
           SUB# N,SAVADD; SETMA; MI<MD "PUT A(J,J) INTO A(P,P)
           FMUL DPX,MD                 "DO 1/PIV * A(P,P+1)
           ADD N,APTR; SETMA; FMUL     "GET A (J,J+1)
           FMUL                        "PUT 1/PIV * A(P,P+1)
           MOV APTR,APTR; SETMA; MI<FM "  INTO A(J,J+1)
SWAPLOOP:  ADD N,SAVADD; SETMA         "GET A(P,P+L)
           NOP                          "FOR UPWARD COMPATIBILITY
           SUB N,SAVADD; SETMA; MI<MD  "A(J,J+L-1) INTO A(P,P+L-1)
           ADD N,SAVADD;
             FMUL DPX,MD               "DO 1/PIV * A(P,P+L)
           ADD N,APTR; SETMA; FMUL     "GET A(J,J+L)
           DEC CTR1; FMUL
           BGT SWAPLOOP;               "TEST IF ALMOST DONE
                                       "PUT 1/PIV * A(P,P+L)
             MOV APTR,APTR; SETMA; MI<FM "  INTO A(J,J+L)
OUT1EARLY: MOV SAVADD,SAVADD; SETMA; MI<MD; "A(J,J+L) INTO A(P,P+L)
             BR FORDELIM               "GO TO FORWARD ELIMINATION
"THE PROGRAM HAS JUMPED HERE IF NO SWAP WAS NECESSARY.  THIS
"MULTIPLIES THE PIVOT ROW BY THE INVERSE OF THE PIVOT PT.
NOSWAP:    ADD N,APTR; SETMA           "GET A(J,J+1)
           NOP                         "  (SAME AS A(P,P+1))
           SUB N,APTR
NOSWLOOP:  ADD N,APTR;
             FMUL DPX,MD               "DO 1/PIV * A(P,P+L)
           ADD N,APTR; SETMA; FMUL     "GET A(P,P+L+1)
           FMUL; DEC CTR1              "STORE 1/PIV * A(P,P+L)
           SUB N,APTR; SETMA; MI<FM;   "  IN A(P,P+L)
             BGT NOSWLOOP              "TEST IF DONE
"THIS DOES THE FORWARD ELIMINATION.
"SAVEA POINTS TO THE PIVOT ROW (J).
"SAVADD WILL POINT TO EACH FOLLOWING ROW.
FORDELIM:  MOV NCTR,CTR2
           MOV SAVEA,SAVADD
NEXTROW:   INC SAVADD; SETMA           "GET A(J+L,J)
           MOV SAVEA,APTR
           MOV NCTR,CTR1
           DPY<MD;                     "STORE A(J+L,J)
             ADD N,APTR; SETMA         "GET A(J,J+1)
           MOV SAVADD,APTR2
           ADD N,APTR2; SETMA          "GET A(J+L,J+1)
           FMUL DPY,MD;                "DO A(J+L,J) * A(J,J+1)
             ADD N,CTR1
           FMUL; SUB N,APTR2
THRUROW:   FMUL; ADD N,APTR2
                                       "DO A(J+L,J) * A(J,J+K)
           FSUB FM,MD;                 "  -A(J+L,J+K)
             ADD N,APTR; SETMA         "GET A(J,J+K+1)
           FADD
           ADD N,APTR2; SETMA          "GET A(J+L,J+K+1)
           FMUL DPY,MD;                "DO A(J+L,J) * A(J,J+K+1)
             DEC CTR1
                                       "STORE A(J+L,J) * A(J,J+K)
           FMUL; SUB N,APTR2; SETMA; MI<FA; "-A(J+L,J+K) IN A(J+L,J+K)
             BGT THRUROW               "TEST IF DONE WITH ROW J+L
           DEC CTR2                    "IF SO
           INC SAVADD; SETMA;          "GET A(J+L+1,J)
             BGT NEXTROW + 1           "TEST IF DONE ALL ROWS
           DEC# NCTR                   "IF SO
           MOV SAVEA,APTR;
                                       "TEST IF NEED TO FIND MAX IN
             BGT .+2                   "  COL J+1 (NEXT PIVOT)
"IF SO, GO BACK TO MAX.  OTHERWISE MULT 1/(LAST ROW PIV) BY
"LAST ROW.
LASTROW:   ADD N,APTR; BR .+2
           JMP MAX
           INC APTR; SETMA             "GET PIV PT OF LAST ROW
           DPY<TM;                     "DPY=1
             MOV APTR,SAVEA
             ADD N,SAVEA; BR .+2
           LDSPI 17; DB=1; RETURN      "SING EXIT
           DPX<MD;                     "DPX=PIV PT
             MOV APTR,SAVADD
             BDBZ .-2                  "TEST FOR DIV BY 0
           JSR DIV                     "DO 1/PIV
                                       "GET LAST ELE OF LAST ROW OF
           ADD N2,SAVADD; SETMA        "  FORMER IDENT MAT
           MOV SAVADD,APTR
           MOV N,CTR1
           ADD N,APTR
LOOP:      SUB N,APTR;
             FMUL DPX,MD               "DO 1/PIV * ELE OF LAST ROW
           SUB N,APTR; SETMA;          "GET NEXT ELE
             FMUL
           FMUL; DEC CTR1
           ADD N,APTR; SETMA; MI<FM;   "STORE BACK INTO PLACE
             BGT LOOP                  "TEST IF DONE
"THIS STARTS THE BACK SUBSTITUTION.
BACKSUB:   MOV N,CTR2
"SAVEA MOVES BACKWARDS ALONG THE DIAGONAL ABOVE THE MAIN DIAGONAL OF
"A AS NECESSARY (WHEN DOING NEW ROW)
           SUB N,SAVEA
           DEC SAVEA
"SAVADD PTS TO LAST ELE OF ROW BEING DONE
           DEC SAVADD
           MOV SAVADD,IT               "'IT' IS PT BEING COMPUTED
           ADD N,IT
ROWSUB:    SUB N,IT; SETMA             "GET IT   I(M,Q)
           MOV NCTR,CTR1
           MOV SAVEA,APTR2; SETMA      "GET A(M,M+1)
           FADD ZERO,MD;               "I(M,Q) IN ADDER
             MOV IT,APTR
           INC APTR; SETMA; FADD       "GET I(M+1,Q)
           DPY<MD                      "STORE A(M,M+1)
           ADD N,APTR2; SETMA          "GET A(M,M+2)
           FMUL DPY,MD                 "DO A(M,M+1) * I(M+1,Q)
           FMUL; INC APTR; SETMA       "GET I(M+2,Q)
PTSUB:     FMUL; DPY<MD                "STORE A(M,M+L)
           FSUBR FM,FA;                "ADDER-A(M,M+L-1)*I(M+L-1,Q)
             ADD N,APTR2; SETMA        "GET A(M,M+L+1)
           FADD; DEC CTR1;
             FMUL DPY,MD               "DO A(M,M+L) * I(M+L,Q)
           BGT PTSUB; FMUL;            "TEST IF DONE WITH PT IT
             INC APTR; SETMA           "GET I(M+L+1,Q)
           DEC CTR2
           MOV IT,IT; SETMA; MI<FA;    "STORE IT
             BGT ROWSUB                "TEST IF DONE WITH ROW
           INC NCTR
           SUB# NCTR,N
           BGT .+2                     "TEST IF DONE ALL ROWS
DONE:      RETURN; CLR 17
           JMP BACKSUB
        $END
"****** XMATIN = MATRIX INVERSE (GAUSSIAN ELIMINATION) /COMMO= REL 3.0, MAR 80
"   FOR EITHER MEMORY
        $TITLE XMATIN
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY XMATIN, 3                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV
"MATRIX INVERSE
"                  --- ABSTRACT ---
"THIS INVERTS AN N-BY-N MATRIX BY GAUSSIAN ELIMINATION AND PUTS
"THE INVERSE IN THE N*N MEMORY LOCATIONS FOLLOWING THE ORIGINAL
"MATRIX, WHICH IS DESTROYED.
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH EITHER MEMORY
"SIZE:       136.  PLUS DIVIDE (28.) = 164. WORDS
"SUBROUTINE USED:  DIVIDE
"
"    --- HISTORY ---
"ORIGINAL:  MAR 80  R.S. NORIN    THIS ROUTINE ADDED TO PRESERVE THE
"                                 FUNCTIONALITY OF THE ROUTINE MATINV
"                                 DURING THE APR 79 - FEB 80 PERIOD.
"                                 SINGULARITY STATUS IS STORED AS INTEGER
"                                 IN MD ADDR IERR.
"
"                  ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC      MEANING
"0           A (APTR)      BASE ADDRESS OF INPUT MATRIX
"1           N             DIMENSION OF MATRIX
"2           IERR          ADDRESS OF SINGULARITY FLAG
"NOTE:       MATRICES ARE COLUMN-STORED.  THE BEGINNING OF THE
"            OUTPUTTED MATRIX IS AT LOCATION APTR+N*N.
"                  --- ERROR CONDITIONS ---
"       IF THE MATRIX IS SINGULAR, THE INVERSION IS ABORTED, AND +1
"         IS RETURNED IN S-PAD REGISTER 15.    OTHERWISE 0 IS RETURNED
"                  --- SCRATCH ---
"S-PAD:   0 - 10. 14., 15.
"DATA PAD: DPX: 0 - 31.,   DPY:  0-31.,   DPA
"PLUS THAT USED BY DIVIDE
"                  --- ALGORITHM ---
"(SEE FLOWCHART AND EXPLANATION FOR GENERAL STRUCTURE.  THE FOLLOWING
"IS DONE SECTION-BY-SECTION, MATCHING THE PROGRAM.)
"
"
"IDMAT:    AN IDENTITY MATRIX IS CREATED FOLLOWING THE INPUTTED MATRIX
"          SUCH THAT ITS MTH ROW IS  A CONTINUATION OF THE MTH ROW OF
"          THE MTH ROW OF A.  SINCE A IS INPUTTED COLUMN-WISE, IT JUST
"          ADDS N MORE COLUMNS OF 1'S AND 0'S, THUS DOUBLING THE AMOUNT
"          OF MEMORY USED.
"          POINTERS--IPTR STARTS AT THE LAST LOCATION OF A AND MOVES
"                    THROUGH THE IDENTITY MATRIX COLUMN-WISE.
"          COUNTERS--CTR2 IS INITIALIZED TO N AND COUNTS THE # OF 1'S
"                    CREATED.
"                    CTR1 COUNTS THE # OF 0'S CREATED AFTER EACH 1,
"                    AND IS REINITIALIZED TO N AFTER EACH BATCH.
"(NOTE FOR THE FOLLOWING:  NCTR IS A GLOBAL COUNTER, COUNTING DOWN FROM
"N FOR EACH TIME THROUGH MAX-FORDELIM.  WITHIN BACKSUB, IT COUNTS
"BACK UP TO N.)
"MAX:      THE SCAN FOR MAXIMUM WITHIN A COLUMN PRODUCES THE PIVOT
"          POINT.  THE PROGRAM LEADS INTO AN UNUSUAL 2-CYCLE LOOP,
"          WHICH ASSUMES THE OLD MAXIMUM WILL REMAIN THE MAXIMUM UNTIL
"          PROVEN OTHERWISE, BY WHICH TIME DATA FOLLOWING THE NEW MAX
"          HAS ALREADY BEEN COMPARED WITH THE OLD MAX.  AT THIS POINT
"          THE PROGRAM BRANCHES TO TRADE, WHICH RE-INSTATES THE NEW MAX
"          AND COMPARES THE ALREADY-COMPARED DATA FOLLOWING THE NEW MAX.
"          THEN IT GOES BACK TO THE LOOP.  THE ADDRESS OF THE NEW MAX IS
"          ALSO DISCOVERED TOO LATE, SO A DISPLACEMENT CORRECTION IS
"          MADE WHEN THIS SECTION IS DONE.
"          POINTERS--SAVEA HOLDS THE TOP OF THE PART OF THE COLUMN
"                    BEING CONSIDERED AND MOVES DOWN ALONG THE MAIN
"                    DIAGONAL EACH TIME THROUGH MAX.
"                    APTR FETCHES THE POINTS BEING COMPARED AND MOVES
"                    DOWN THE COLUMN.
"                    SAVADD HOLDS THE ADDRESS (PLUS DISP.) OF THE PIVOT.
"          COUNTERS--CTR1 COUNTS DOWN FROM NCTR-1 TO 0 WITHIN MAXLOOP.
"                    NCTR=N, FIRST TIME THROUGH MAX
"                        =N-1, SECOND TIME THROUGH MAX
"                        =2, LAST TIME THROUGH MAX
"DONEMAX:  ONCE THE PIVOT POINT IS FOUND, ITS INVERSE IS MULTIPLIED BY
"SWAP:     THE ENTIRE PIVOT ROW.  IF THE PIVOT ROW IS NOT THE 'TOP' ROW,
"NOSWAP:   THE 2 ROWS ARE SWAPPED.  THE 'TOP' ROW IS THE FIRST ROW THE
"          FIRST TIME THROUGH THIS SECTION, THE SECOND ROW THE NEXT
"          TIME THROUGH, ETC.
"          POINTERS--SAVEA HOLDS THE BEGINNING OF THE 'TOP' ROW.  (THE
"                    BEGINNING IS PT. A(J,J) FOR ROW J.)
"                    APTR MOVES ALONG THE 'TOP' ROW.
"                    SAVADD HOLDS THE BEGINNING OF THE PIVOT ROW (PT.
"                    A(J+L,J) FOR ROW J+L), I.E. THE PIVOT PT.
"                    APTR2 MOVES ALONG THE PIVOT ROW.
"          COUNTERS--NCTR IS DECREMENTED IN DONEMAX.
"                    CTR1 COUNTS DOWN FROM N+NCTR TO 0.  IT KEEPS TRACK
"                    OF HOW MANY ELEMENTS TO MULT. AND SWAP.
"FORDELIM: THE PIVOT ROW IS NOW THE 'TOP' ROW (ROW J).  THE TERM
"          'FIRST ELEMENT' REFERS TO THE ELEMENT IN COLUMN J.  ROW
"          J+L IS REPLACED BY
"          (FIRST ELE OF ROW J+L)*(ROW J)-(FIRST ELE OF ROW J)*(ROW J+L)
"          SINCE THE MULTIPLICATION BY 1/PIV WOULD AUTOMATICALLY HAVE
"          CAUSED THE FIRST ELE OF ROW J TO BECOME 1 (THE ACTUAL
"          MULTIPLICATION FOR THAT PT WAS THEREFORE NEVER DONE), THE
"          ABOVE IS REDUCED TO
"          A(J+L,J)*(ROW J)-(ROW J+L).
"          THE NEW FIRST ELE OF ROW J+L WILL ALWAYS BECOME 0, SO THE
"          CALCULATION FOR THIS PT IS NOT DONE.
"          THRUROW GOES THROUGH THE ELEMENTS OF EACH ROW.
"          NEXT ROW GOES THROUGH ROWS J+1 TO N.
"          POINTERS--SAVEA PTS TO A(J,J) (FIRST ELE OF 'TOP' ROW).
"                    APTR MOVES ALONG THE 'TOP' ROW.
"                    SAVADD PTS TO A(J+L,J) (FIRST ELE OF ROW J+L).
"                    APTR2 MOVES ALONG ROW J+L.
"          COUNTERS--CTR1 COUNTS DOWN FROM N+NCTR TO 0, KEEPS TRACK OF
"                    THE # OF ELE TO DO IN EACH ROW, AND IS
"                    RE-INITIALIZED AT EACH NEW ROW.
"                    CTR2 COUNTS DOWN FROM NCTR TO 0 AND KEEPS TRACK
"                    OF HOW MANY ROWS NEED TO BE DONE.
"AT THIS POINT THE PROGRAM JUMPS BACK TO MAX AND STARTS OVER WITH
"COLUMN J+1.  NCTR HAS ALREADY BEEN DECREMENTED.  THE 'TOP' ROW WILL
"BE ROW J+1.
"HOWEVER, IF NCTR=1, THERE IS NO POINT IN SCANNING FOR MAX OR DOING A
"FORWARD ELIMINATION.  ALL THAT NEEDS TO BE DONE IS
"(1/PIV)*(ROW N), WHERE PIV=A(N,N).
"LASTROW:  THIS HANDLES THE NCTR=1 CASE, DOING THE ELEMENTS OF ROW N
"          FROM THE END BACKWARD.  IT DOES NOT COMPUTE (1/PIV)*PIV.
"          POINTERS--SAVEA HOLDS THE PIVOT PT.
"                    SAVADD HOLDS THE LAST PT IN ROW N.
"                    APTR MOVES ALONG THE ROW FROM SAVADD TOWARD SAVEA.
"          COUNTERS--CTR1 COUNTS DOWN FROM N TO 0, KEEPING TRACK OF THE
"                    # OF ELE TO DO.
"BACKSUB:  THE LAST ROW OF THE FORMER IDENTITY MATRIX IS NOW THE LAST
"          ROW OF A INVERSE.  ROWS 1 TO N-1 STILL HAVE TO BE COMPUTED.
"          THE ROWS ARE DONE IN REVERSE ORDER, FROM N-1 TO 1.  WITHIN
"          A ROW, EACH PT IS COMPUTED STARTING WITH THE LAST PT.
"          A POINT IS COMPUTED BY GETTING THE CORRESPONDING ELE FROM THE
"          FORMER IDENTITY MATRIX, AND SUBTRACTING FROM IT THE DOT
"          PRODUCT OF THE ELEMENTS BELOW IT IN THE SAME COLUMN AND THE
"          ELEMENTS OF ITS CORRESPONDING ROW IN A STARTING AFTER THE
"          MAIN DIAGONAL.  IN OTHER WORDS, PT I(M,Q) OF THE FORMER
"          IDENTITY MATRIX IS REPLACED BY
"          I(M,Q)-I(M+1,Q)*A(M,M+1)-I(M+2,Q)*A(M,M+2)..-I(N,Q)*A(M,N).
"          PTSUB COMPUTES EACH PT.  ROWSUB GOES THROUGH EACH ROW
"          (Q=Q-1).  BACKSUB GOES THROUGH ALL THE ROWS (M=M-1).
"          POINTERS--SAVEA PTS TO A(M,M+1) FOR EACH ROW OF I
"                    APTR2 MOVES FROM A(M,M+1) TO A(M,N) FOR EACH PT.
"                    SAVADD PTS TO I(M,N) FOR EACH ROW M OF I
"                    IT PTS TO I(M,Q) FOR EACH PT.
"                    APTR MOVES FROM I(M+1,Q) TO I(N,Q) FOR EACH PT.
"          COUNTERS--NCTR STARTS AT 1 AND IS INCREMENTED FOR EACH NEW
"                    ROW.  WHEN IT REACHES N, BACKSUB HAS DONE N-1 ROWS,
"                    AND THE PROGRAM IS FINISHED.
"                    CTR1 COUNTS DOWN FROM NCTR TO 0, AND IS
"                    RE-INITIALIZED FOR EACH NEW PT.  IT KEEPS TRACK OF
"                    THE # OF ELEMENTS IN THE DOT PRODUCT.
"                    CTR2 COUNTS DOWN FROM N TO 0, AND IS RE-INITIALIZED
"                    FOR EACH NEW ROW.  IT KEEPS TRACK OF THE NUMBER OF
"                    PTS TO BE COMPUTED IN EACH ROW.
"S-PAD PARAMETERS:
APTR = 0
N = 1
IERR = 2
"THE FOLLOWING ARE NOT PARAMETERS:
IPTR = 2
APTR2 = 2
CTR1 = 3
CTR2 = 4
FOUR = 5
C27 = 5
SAVEA = 6
SAVADD = 7
NCTR = 10
N2 = 11
IT = 12
SIERR = 13
ONE = !ONE
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FXMATI,3                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  2
        $PARAM  3 , P1(#2,#2,2)/R/IP/OP, P2/I/IP, P3/OP
FXMATI: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
XMATIN:    LDSPI C27; DB=27.
           MOV IERR,SIERR       "GET IERR OUT OF THE WAY
"THIS COMPUTES N**2
           MOV N,N; DPX<SPFN
           MOV C27,C27; FADD ZERO,MDPX; "FLOAT N
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
           FADD
           DPX<FA;
             LDTMA; DB=ONE
           FMUL DPX,DPX                "DO N*N
           FMUL; MOV N,NCTR
           FMUL; MOV N,CTR2
           DPX<FM;
             MOV N,CTR1
           FIX DPX                     "FIX N**2
           FADD; DEC APTR
           DPX<FA
           LDSPI N2; DB=DPX            "STORE INTO N2
"THIS GENERATES AN IDENTITY MATRIX
IDMAT:     MOV N2,IPTR
           ADD APTR,IPTR               "SETS PTR TO IDENT MAT
PUTONE:    DEC CTR2
           INC IPTR; SETMA; MI<TM;     "PUT 1'S ALONG DIAGONAL
             BEQ OUT
PUT0:      DEC CTR1
           INC IPTR; SETMA; MI<ZERO;   "PUT 0'S ELSEWHERE
             BGT PUT0
           MOV N,CTR1; BR PUTONE
OUT:       SUB N,APTR
"THIS SEARCHES FOR THE MAXIMUM IN THE JTH COLUMN FROM ROW J DOWN.
"THIS WILL BE THE PIVOT PT.
MAX:       ADD N,APTR
           INC APTR; SETMA             "GET A(J,J)
           MOV APTR,SAVEA              "SAVEA HOLDS PTR TO A(J,J)
           INC APTR; SETMA             "GET A(J+1,J)
           FABS MD;                    "DO /A(J,J)/
             MOV NCTR,CTR1             "CTR=N+1-J
           INC APTR; SETMA; FADD       "GET A(J+2,J)
           FABS MD;                    "DO /A(J+1,J)/
             DPX<FA;                   "STORE /A(J,J)/ IN MAX
             LDSPI FOUR; DB=4
           INC APTR; SETMA; FADD       "GET A(J+3,J)
           FABS MD;                    "DO /A(J+2,J)/
             DPY<FA;                   "STORE /A(J+1,J)/
             DEC CTR1
           INC APTR; SETMA;            "GET A(J+4,J)
             FSUB DPY,DPX;             "COMPARE MAX,/A(J+1,J)/
             INCDPA                    "DPA=DPA+1
           FABS MD;                    "DO /A(J+3,J)/
             DPY<FA;                   "STORE /A(J+2,J)/
             DPX<DPX(-1);              "MOVE UP MAX
             MOV APTR,SAVADD           "SAVE ADDRESS
           INC APTR; SETMA;            "GET A(J+5,J)
             FSUB DPY,DPX;             "COMPARE MAX,/A(J+2,J)/
             INCDPA                    "DPA=DPA+1
MAXLOOP:   FABS MD;                    "DO /A(L+1,J)/
             DPY<FA;                   "STORE /A(L,J)/
             DPX<DPX(-1);              "MOVE UP MAX
             BFGT TRADE;               "TEST IF SHOULD HAVE CHANGED MAX
             DEC CTR1                  "DEC CTR
           INC APTR; SETMA;            "GET A(L+3,J)
             FSUB DPY,DPX;             "COMPARE MAX,/A(L,J)/
             INCDPA;                   "DPA=DPA+1
             BGT MAXLOOP               "TEST IF FINISHED COL
           SUB FOUR,SAVADD; SETMA;     "IF SO, GET MAX (NOT ABS)
             FADD ZERO,DPX(-1);
             BR DONEMAX
"IF SHOULD HAVE CHANGED MAX:
TRADE:     DPX<DPY(-2)                 "PUT /A(L-1,J)/ IN MAX
           FSUB DPY(-1),DPX;           "COMPARE MAX,/A(L,J)/
             MOV APTR,SAVADD           "SAVE ADDRESS
           FADD ZERO,FA;               "PUT /A(L+1,J)/ IN ADDER
             MOV CTR1,CTR1;
             BR MAXLOOP + 1            "CONTINUE WHERE LEFT OFF IN LOOP
"THIS INVERTS THE PIVOT PT AND TESTS WHETHER THE PIVOT ROW AND
"THE JTH ROW ARE THE SAME ROW
DONEMAX:   DPY<TM; FADD;               "PUT 1 IN DPY
             DEC NCTR
           MOV SAVEA,APTR; SETMA       "GET A(J,J)
           MOV NCTR,CTR1;
             BFEQ SINGULAR             "TEST IF SINGULAR MATRIX
           DPX<MD;                     "PUT MAX IN DPX
             JSR DIV                   "DO INV OF PIVOT PT
           SUB# APTR,SAVADD            "TEST IF PIV ROW=JTH ROW
           BNE SWAP;                   "IF NOT SWAP THEM
             LDTMA; DB=ONE;
             ADD N,CTR1
           JMP NOSWAP                  "IF SO, DON'T SWAP
SINGULAR:  LDSPI 17; DB=1;             "IF SINGULAR, LEAVE NOTE
               DPX<DB
           MOV SIERR,SIERR; SETMA; MI<DPX;
             RETURN                    "  AND GO HOME
"THIS SWAPS THE JTH ROW AND THE PIVOT ROW WHILE MULTIPLYING THE
"PIVOT ROW BY THE INVERSE OF THE PIVOT PT.
                                       "FOR PIVOT ROW=PTH ROW
SWAP:      ADD N,SAVADD; SETMA         "GET A(P,P+1)
           DEC CTR1
           SUB# N,SAVADD; SETMA; MI<MD "PUT A(J,J) INTO A(P,P)
           FMUL DPX,MD                 "DO 1/PIV * A(P,P+1)
           ADD N,APTR; SETMA; FMUL     "GET A (J,J+1)
           FMUL                        "PUT 1/PIV * A(P,P+1)
           MOV APTR,APTR; SETMA; MI<FM "  INTO A(J,J+1)
SWAPLOOP:  ADD N,SAVADD; SETMA         "GET A(P,P+L)
           NOP                          "FOR UPWARD COMPATIBILITY
           SUB N,SAVADD; SETMA; MI<MD  "A(J,J+L-1) INTO A(P,P+L-1)
           ADD N,SAVADD;
             FMUL DPX,MD               "DO 1/PIV * A(P,P+L)
           ADD N,APTR; SETMA; FMUL     "GET A(J,J+L)
           DEC CTR1; FMUL
           BGT SWAPLOOP;               "TEST IF ALMOST DONE
                                       "PUT 1/PIV * A(P,P+L)
             MOV APTR,APTR; SETMA; MI<FM "  INTO A(J,J+L)
OUT1EARLY: MOV SAVADD,SAVADD; SETMA; MI<MD; "A(J,J+L) INTO A(P,P+L)
             BR FORDELIM               "GO TO FORWARD ELIMINATION
"THE PROGRAM HAS JUMPED HERE IF NO SWAP WAS NECESSARY.  THIS
"MULTIPLIES THE PIVOT ROW BY THE INVERSE OF THE PIVOT PT.
NOSWAP:    ADD N,APTR; SETMA           "GET A(J,J+1)
           NOP                         "  (SAME AS A(P,P+1))
           SUB N,APTR
NOSWLOOP:  ADD N,APTR;
             FMUL DPX,MD               "DO 1/PIV * A(P,P+L)
           ADD N,APTR; SETMA; FMUL     "GET A(P,P+L+1)
           FMUL; DEC CTR1              "STORE 1/PIV * A(P,P+L)
           SUB N,APTR; SETMA; MI<FM;   "  IN A(P,P+L)
             BGT NOSWLOOP              "TEST IF DONE
"THIS DOES THE FORWARD ELIMINATION.
"SAVEA POINTS TO THE PIVOT ROW (J).
"SAVADD WILL POINT TO EACH FOLLOWING ROW.
FORDELIM:  MOV NCTR,CTR2
           MOV SAVEA,SAVADD
NEXTROW:   INC SAVADD; SETMA           "GET A(J+L,J)
           MOV SAVEA,APTR
           MOV NCTR,CTR1
           DPY<MD;                     "STORE A(J+L,J)
             ADD N,APTR; SETMA         "GET A(J,J+1)
           MOV SAVADD,APTR2
           ADD N,APTR2; SETMA          "GET A(J+L,J+1)
           FMUL DPY,MD;                "DO A(J+L,J) * A(J,J+1)
             ADD N,CTR1
           FMUL; SUB N,APTR2
THRUROW:   FMUL; ADD N,APTR2
                                       "DO A(J+L,J) * A(J,J+K)
           FSUB FM,MD;                 "  -A(J+L,J+K)
             ADD N,APTR; SETMA         "GET A(J,J+K+1)
           FADD
           ADD N,APTR2; SETMA          "GET A(J+L,J+K+1)
           FMUL DPY,MD;                "DO A(J+L,J) * A(J,J+K+1)
             DEC CTR1
                                       "STORE A(J+L,J) * A(J,J+K)
           FMUL; SUB N,APTR2; SETMA; MI<FA; "-A(J+L,J+K) IN A(J+L,J+K)
             BGT THRUROW               "TEST IF DONE WITH ROW J+L
           DEC CTR2                    "IF SO
           INC SAVADD; SETMA;          "GET A(J+L+1,J)
             BGT NEXTROW + 1           "TEST IF DONE ALL ROWS
           DEC# NCTR                   "IF SO
           MOV SAVEA,APTR;
                                       "TEST IF NEED TO FIND MAX IN
             BGT .+2                   "  COL J+1 (NEXT PIVOT)
"IF SO, GO BACK TO MAX.  OTHERWISE MULT 1/(LAST ROW PIV) BY
"LAST ROW.
LASTROW:   ADD N,APTR; BR .+2
           JMP MAX
           INC APTR; SETMA             "GET PIV PT OF LAST ROW
           DPY<TM;                     "DPY=1
             MOV APTR,SAVEA
             ADD N,SAVEA; BR .+2
           LDSPI 17; DB=1; RETURN      "SING EXIT
           DPX<MD;                     "DPX=PIV PT
             MOV APTR,SAVADD
             BDBZ .-2                  "TEST FOR DIV BY 0
           JSR DIV                     "DO 1/PIV
                                       "GET LAST ELE OF LAST ROW OF
           ADD N2,SAVADD; SETMA        "  FORMER IDENT MAT
           MOV SAVADD,APTR
           MOV N,CTR1
           ADD N,APTR
LOOP:      SUB N,APTR;
             FMUL DPX,MD               "DO 1/PIV * ELE OF LAST ROW
           SUB N,APTR; SETMA;          "GET NEXT ELE
             FMUL
           FMUL; DEC CTR1
           ADD N,APTR; SETMA; MI<FM;   "STORE BACK INTO PLACE
             BGT LOOP                  "TEST IF DONE
"THIS STARTS THE BACK SUBSTITUTION.
BACKSUB:   MOV N,CTR2
"SAVEA MOVES BACKWARDS ALONG THE DIAGONAL ABOVE THE MAIN DIAGONAL OF
"A AS NECESSARY (WHEN DOING NEW ROW)
           SUB N,SAVEA
           DEC SAVEA
"SAVADD PTS TO LAST ELE OF ROW BEING DONE
           DEC SAVADD
           MOV SAVADD,IT               "'IT' IS PT BEING COMPUTED
           ADD N,IT
ROWSUB:    SUB N,IT; SETMA             "GET IT   I(M,Q)
           MOV NCTR,CTR1
           MOV SAVEA,APTR2; SETMA      "GET A(M,M+1)
           FADD ZERO,MD;               "I(M,Q) IN ADDER
             MOV IT,APTR
           INC APTR; SETMA; FADD       "GET I(M+1,Q)
           DPY<MD                      "STORE A(M,M+1)
           ADD N,APTR2; SETMA          "GET A(M,M+2)
           FMUL DPY,MD                 "DO A(M,M+1) * I(M+1,Q)
           FMUL; INC APTR; SETMA       "GET I(M+2,Q)
PTSUB:     FMUL; DPY<MD                "STORE A(M,M+L)
           FSUBR FM,FA;                "ADDER-A(M,M+L-1)*I(M+L-1,Q)
             ADD N,APTR2; SETMA        "GET A(M,M+L+1)
           FADD; DEC CTR1;
             FMUL DPY,MD               "DO A(M,M+L) * I(M+L,Q)
           BGT PTSUB; FMUL;            "TEST IF DONE WITH PT IT
             INC APTR; SETMA           "GET I(M+L+1,Q)
           DEC CTR2
           MOV IT,IT; SETMA; MI<FA;    "STORE IT
             BGT ROWSUB                "TEST IF DONE WITH ROW
           INC NCTR
           SUB# NCTR,N
           BGT .+3                     "TEST IF DONE ALL ROWS
DONE:      CLR 17; DPX<DB; DB=SPFN
           MOV SIERR,SIERR; SETMA; MI<DPX;
           RETURN
"
           JMP BACKSUB
        $END
"****** CTRN3 = 3-DIMENSIONAL COORDINATE TRANS /COMMON/ = REL 3.1, SEP 79 *****
"  FOR EITHER MEMORY
        $TITLE CTRN3
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CTRN3,9.                          "USER-DIRECTED-CALL ENTRY
"
"                     ---ABSTRACT---
"FOR A SERIES OF N 3 ELEMENT VECTORS REPRESENTING THE (X,Y,Z)
"COORDINATES OF A POINT, PERFORMS THE TRANSLATION OF THE POINTS
"BY A 3 ELEMENT VECTOR (XO,YO,ZO), AND THEN THE ROTATION BY
"MULTIPLYING BY THE 3X3 MATRIX.  THE OUTPUT IS A SERIES OF
"3 ELEMENT VECTORS REPRESENTING THE TRANSFORMED COORDINATES.
"
"FORMULA: D(MLP+QL) = SUM (A(Q+3R) * {B(MJP+RK) - C(R)} ) FOR R=0,1,2
"                            FOR Q=0,1,2 AND M=0 TO N-1
"
"               ---STATISTICS---
"LANGUAGE:      AP-120B ASSEMBLER
"EQUIPMENT:     AP-120B WITH EITHER MEMORY
"SIZE:          37. LOCATIONS
"SPEED:  BEST:    14.*N  (FAST MEMORY)
"                 15.*N  (SLOW MEMORY)
"       TYPICAL:  14.*N (FAST MEMORY)  A,B,C,D EVEN, J,JP,L,LP ODD
"                 15.*N (SLOW MEMORY)
"       WORST:    14.*N (FAST MEMORY)
"                 18.*N (SLOW MEMORY)
"
"    --- HISTORY ---
"ORIGINAL:  APR 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"               ---USAGE---
"FORTRAN:  CALL CTRN3(A,B,J,JP,C,D,L,LP,N)
"APAL:     JSR  CTRN3
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC   MEANING
" 0             A       BASE ADDRESS OF 3X3 MATRIX
" 1             B       BASE ADDRESS OF SOURCE 3-ELEMENT COORDINATE VECTORS
" 2             J       INCREMENT WITHIN EACH VECTOR
" 3             JP      INCREMENT BETWEEN VECTORS(I.E. BETWEEN X COORDS)
" 4             C       BASE ADDRESS OF 3 ELEMENT TRANSLATION VECTOR
" 5             D       BASE ADDRESS OF ANSWER VECTORS
" 6             L       INCREMENT WITHIN VECTORS
" 7             LP      INCREMENT BETWEEN VECTORS(I.E. BETWEEN X COORDS)
" 10            N       # OF VECTORS
"NOTE:          THE INCREMENTS BETWEEN VECTORS, JP AND LP, ARE
"               FIGURED FROM THE FIRST ELEMENT OF THE MTH VECTOR TO THE
"               FIRST ELEMENT OF THE (M+1)TH VECTOR.
"               ---SCRATCH---
"S-PAD:         0-11.
"DATA PAD:      DPX(-5 TO +4), DPY(-4 TO +2), FOR DPA=4
" FA,FM,MD,TM
"S-PAD PARAMETERS:
A = 0
B = 1
J = 2
JP = 3
C = 4
D = 5
L = 6
LP = 7
N = 10
"THE FOLLOWING ARE NOT PARAMETERS:
CTR = 11
SAVEB = 12
SAVED = 13
"TABLE MEMORY ADDRESSES:
 ONE $EQU !ONE                             "1.0
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCTRN3,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  714
        $PARAM  9., P1(3,3)/R/IP,
                    P2(#4,#11)/R/IP, P3/I/IP, P4/I/IP,
                    P5(3)/R/IP,
                    P6(#10,#11)/R/OP, P7/I/IP, P8/I/IP,
                    P9/I/IP
FCTRN3: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CTRN3:  MOV A,A; SETMA               "GET A(1,1)
          DB=ZERO; LDDPA             "DPA=0
        DB=9.; LDSPI CTR
        INCMA                        "GET A(2,1)
PUT:    DPX<MD; INCDPA; DEC CTR      "THIS LOOP PUTS
        INCMA;   BGT PUT            "MATRIX A INTO DPX
        MOV C,C; SETMA          "FETCH C(1) -- X TRANSLATION
        DB=4; LDDPA                 "DPA=4
        INCMA;                  "FETCH C(2) -- Y TRANSLATION
          MOV D,SAVED               "SET OUTPUT POINTER
        DPY(1)<MD;              "SAVE C(1)
          SUB LP,SAVED              "BACK UP OUTPUT POINTER
        INCMA                   "1.  FETCH C(3) -- Z TRANSLATION
        MOV B,SAVEB; SETMA;      "2.  GET B(1)
            DPY(2)<MD               "SAVE C(1)
        LDTMA; DB=ONE                "3.  GET 1.0 FROM TM
        ADD J,B; SETMA;           "4.  GET B(2)
            DPY(-4)<MD              "SAVE C(3)
        FMUL TM,DPX(-4)           "5.  SAVE A(1,1) IN FM
        ADD J,B; SETMA;             "6.  FETCH B(2)
          FSUBR DPY(1),MD;          "    B(1)=B(1)-C(1)
          FMUL                      "    PUSH
        FMUL TM,DPX(-3);            "7.  SAVE A(2,1) IN FM
          FSUBR DPY(2),MD           "    B(2)=B(2)-C(2)
        FMUL FM,FA;                 "8.  A(1,1)*B(1)
          DPY(-1)<FA;               "    SAVE B(1)=B(1)-C(1)
          FADD                      "    PUSH
        FMUL DPX(-1),FA;            "9.  A(1,2)*B(2)
          FSUBR DPY(-4),MD;         "    B(3)=B(3)-C(3)
          DPY(-2)<FA                "    SAVE B(2)
        FMUL FM,DPY(-1);            "10. A(2,1)*B(1)
          FADD                      "    PUSH
        FMUL DPX(0),DPY(-2);        "11. A(2,2)*B(2)
        MOV N,N;                "IS ELEMENT COUNT = 0?
          FADD FM,ZERO;             "    SAVE A(1,1)*B(1) IN FA
          DPY(-3)<FA;               "    SAVE B(3)
          DECDPA                    "    DPA=3
        FMUL DPX(3),DPY(-2);        "12. A(1,3)*B(3)
          FADD DPY(-2),ZERO;        "    SAVE B(3) IN FA
          DPX(-4)<FM;               "    SAVE A(1,2)*B(2)
          BEQ DONE              "EXIT IF COUNT = 0
LOOP:       FMUL TM,DPY(-1);        "1.  SAVE B(2) IN FA
              FADD DPX(-4),FA;      "    A(1,1)*B(M+1)+A(1,2)*B(M+2)
              DPY(1)<FM;            "    SAVE A(2,1)*B(M+1)
              ADD LP,SAVED;         "    UPDATE OUTPUT POINTER
              INCDPA                "    DPA=4
        ADD JP,SAVEB; SETMA;        "2.  FETCH NEW B(1)
            FMUL DPX(3),FA;         "    A(2,3)*B(3)
              FADD FM,DPY(0);       "    A(2,2)*B(2)+A(2,1)*B(1)
              INCDPA                "    DPA=5
        MOV SAVEB,B;                "3.  SET POINTER
            FMUL DPX(3),DPY(-4);    "    A(3,3)*B(3)
              FADD FM,FA;           "    A(1,1)*B(1)+A(1,2)*B(2)+A(1,3)*B(3)
              DECDPA                "    DPA=4
        ADD J,B; SETMA;             "4.  FETCH NEW B(2)
            FMUL FM,DPX(1);         "    A(3,2)*B(2)
              FADD DPY(-1),ZERO;    "    SAVE B(1) IN FA
              DPY(0)<FA             "    SAVE A(2,2)*B(2)+A(2,1)*B(1)
        FMUL TM,DPX(-4);            "5.  SAVE A(1,1) IN FM
            FADD FM,DPY(0);         "    A(2,3)*B(3)+A(2,2)*B(2)+A(2,1)*B(1)
              DPY(0)<FA             "    SAVE D(1)
        ADD J,B;SETMA;              "6.  FETCH B(3)
          FSUBR DPY(1),MD;          "    B(1)=B(1)-C(1)
            FMUL DPX(-2),FA;        "    A(3,1)*B(1)
              DPY(-1)<FM;           "    SAVE A(3,3)*B(3)
              DECDPA                "    DPA=3
        FMUL TM,DPX(-2);            "7.  SAVE A(2,1) IN FM
          FSUBR DPY(3),MD;          "    B(2)=B(2)-C(2)
            DPX(-4)<FM;             "    SAVE A(3,2)*B(2)
              DPY(-2)<FA            "    SAVE D(2)
        FMUL FM,FA;                 "8.  A(1,1)*B(1)
            MOV SAVED,D;SETMA;MI<DPY(1) "    STORE D(1)
          DPY(0)<FA;                "9.  SAVE B(1)
            FADD DPY(0),DPX(-4)     "    A(3,3)*B(3)+A(3,2)*B(2)
        FMUL DPX(0),FA;             "10. A(1,2)*B(2)
          FSUBR DPY(-3),MD;         "    B(3)=B(3)-C(3)
          DPY(-1)<FA;               "    SAVE B(2)
            DPX(-4)<FM              "    SAVE A(3,1)*B(1)
        FMUL FM,DPY(0)              "11.  A(2,1)*B(1)
            FADD DPX(-4),FA;        "12. A(3,1)*B(1)+A(3,2)*B(2)+A(3,3)*B(3)
              ADD L,D;SETMA;MI<DPY(-2) "    STORE D(2)
        FMUL DPX(1),DPY(-1);        "13. A(2,2)*B(2)
          FADD FM,ZERO;             "    SAVE A(1,1)*B(1) IN FA
          DPY(-2)<FA;               "    SAVE B(3)
            DEC N                   "    DECREMENT VECTOR COUNT
        FMUL DPX(3),DPY(-2);        "14. A(1,3)*B(3)
          FADD DPY(-2),ZERO;        "    SAVE B(3) IN FA
          DPX(-4)<FM;               "    SAVE A(1,2)*B(2)
            ADD L,D;SETMA;MI<FA;    "    STORE D(3)
              BNE LOOP              "    CONTINUE UNTIL
DONE:   RETURN                  "EXIT
        $END
"****** RFFT = REAL FFT (IN PLACE) /COMMON/ = REL 3.1, SEP 79 *****
"
        $TITLE RFFT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY RFFT, 3                          "USER-DIRECTED-CALL ENTRY
        $EXT REALTR,CFFT
"
"
"                               --- ABSTRACT ---
"MAINLINE PROGRAM TO DO A REAL FFT
"
"
"                  --- STATISTICS ---
"EQUIPMENT:  AP-120B WITH EITHER MEMORY
"SIZE:18 LOCS + REALTR (49) + CFFT (187 FAST, 185 STD) = 254 (FAST), 252 (STD)
"SUBROUTINES USED: CFFT,REALTR
"
"ARGUMENTS IN S-PAD
"0      C    BASE ADDRESS OF REAL DATA VECTOR
"1      N    NUMBER OF REAL POINTS  (A POWER OF 2)
"2      F    FLAG:  +1 FOR DIRECT, -1 FOR INVERSE TRANSFORM
"
"
"
"    --- HISTORY ---
"ORIGINAL:  AUG 76  A.E. CHARLESWORTH
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                               --- SCRATCH (OVERALL) ---
"SPAD:                          2-17
"DATA PAD X:                    -4 TO +3 (RELATIVE TO DPA)
"DATA PAD Y:                    -4 TO +3 (RELATIVE TO DPA)
"
"
"
"                  --- ALGORITHM ---
"DOES A REAL FFT:
"       DIRECT:    DOES FIRST AN N/2 POINT COMPLEX FFT, AND THEN
"                      AN N POINT REAL UNRAVEL PASS
"       INVERSE:   DOES AN N POINT INVERSE REAL TRANSFORM PASS,
"                      AND THEN AN N/2 POINT INVERSE COMPLEX FFT
"S/PAD NAMES:
        C $EQU 0
        N $EQU 1
        F $EQU 2
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FRFFT,3                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  6
        $PARAM  3 , P1(#2)/R/IP/OP, P2/I/IP, P3/I/IP
FRFFT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
RFFT:   MOV F,F                         "SEE IF DIRECT OR INVERSE
        BGT DIRECT;                     "BRANCH IF DIRECT
          MOV N,N               "IS ELEMENT COUNT = 0?
INVRSE: MOV F,3;                        "SET PARAMETERS FOR REALTR
          BEQ DONE              "EXIT IF COUNT = 0
        MOV N,2
        MOV C,1
        JSR REALTR                      "GO DO THE REAL PASS
        MOVR 2,N                        "MAKE N THE # OF COMPLEX POINTS
        MOV 3,F                         "PUT PARAMETERS BACK FOR CFFT
        JSR CFFT                        "DO AN N/2 POINT COMPLEX FFT
        MOVL N,N;  BR DONE              "RESTORE N REAL AND RETURN
DIRECT: MOVR N,N;                       "MAKE N # OF COMPLEX POINTS
          BEQ DONE              "EXIT IF COUNT = 0
        JSR CFFT                        "DO AN N/2 POINT COMPLEX FFT
        LDSPI 3; DB=1                   "SET 'F' FOR REALTR, ETC.
        MOVL N,2                        "RESTORE N TO BE # REAL POINTS
        MOV C,1
        JSR REALTR                      "DO THE REAL PASS
        MOV 2,N                         "PUT N BACK IN SPAD(1)
DONE:   RETURN
        $END
"****** RFFTB = REAL FFT (NOT IN PLACE) /COMMON/ = REL 3.1, SEP 79 *****
"
        $TITLE RFFTB
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY RFFTB, 4                          "USER-DIRECTED-CALL ENTRY
        $EXT REALTR,CFFTB
"
"
"                               --- ABSTRACT ---
"MAINLINE PROGRAM TO DO A REAL FFT. NOT-IN-PLACE, COMBINES
"  THE BIT-REVERSE ALONG WITH THE FIRST PASS OF THE COMPLEX FFT
"
"
"                  --- STATISTICS ---
"EQUIPMENT:    AP-120B WITH EITHER MEMORY
"SIZE:15 LOCATIONS + REALTR (49) + CFFTB (190) = 254
"SUBROUTINES USED: CFFTB,REALTR
"
"        --- HISTORY ---
"ORIGINAL:  AUG 76  A.E. CHARLESWORTH
" REV 2.1:  JUL 77  R.S. NORIN         MINOR MODS TO SAVE 3 WORDS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"
"ARGUMENTS IN S-PAD
"0      A    BASE ADDRESS OF THE INPUT REAL DATA VECTOR
"1      C    BASE ADDRESS OF OUTPUT REAL DATA VECTOR
"2      N    NUMBER OF REAL POINTS  (A POWER OF 2)
"3      F    FLAG:  +1 FOR DIRECT, -1 FOR INVERSE TRANSFORM
"
"
"                               --- SCRATCH (OVERALL) ---
"SPAD:                          0-17
"DATA PAD X:                    -4 TO +4 (RELATIVE TO DPA)
"DATA PAD Y:                    -3 TO +4 (RELATIVE TO DPA)
"
"
"
"                  --- ALGORITHM ---
"DOES A REAL FFT:
"       DIRECT:    DOES FIRST AN N/2 POINT COMPLEX FFT, AND THEN
"                      AN N POINT REAL UNRAVEL PASS
"       INVERSE:   DOES AN N POINT INVERSE REAL TRANSFORM PASS,
"                      AND THEN AN N/2 POINT INVERSE COMPLEX FFT
"S/PAD NAMES:
        A $EQU 0
        C $EQU 1
        N $EQU 2
        F $EQU 3
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FBRFFT,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  14
        $PARAM  4 , P1(#3)/R/IP, P2(#3)/R/OP,
                    P3/I/IP, P4/I/IP
FBRFFT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
RFFTB:   MOV F,F                         "SEE IF DIRECT OR INVERSE
        BGT DIRECT;                     "BRANCH IF DIRECT
          MOV N,N               "IS ELEMENT COUNT = 0?
INVRSE: MOV C,4;                        "SAVE C, SET PAREMETERS FOR REALTR
          BEQ DONE              "EXIT IF COUNT = 0
        MOV A,C                         "MAKE INPUT AND OUTPUT THE SAME
        JSR REALTR                      "GO DO THE REAL PASS
        MOVR N,N                        "MAKE N THE # OF COMPLEX POINTS
        MOV 4,C                         "RESTORE C
        JMP CFFTB                        "DO AN N/2 POINT COMPLEX FFT
                                          "AND EXIT THRU CFFTB
DIRECT: MOVR N,N;               "MAKE N # OF COMPLEX POINTS
          BEQ DONE              "EXIT IF COUNT = 0
        JSR CFFTB                        "DO AN N/2 POINT COMPLEX FFT
        LDSPI F; DB=1                   "SET 'F' FOR REALTR, ETC.
        MOVL 1,N                        "RESTORE N (COMPLEX)
        MOV A,C
        JMP REALTR                      "DO THE REAL PASS
                                        " AND EXIT THRU REALTR
DONE:   RETURN                  "EXIT
        $END
"****** CFFT = COMPLEX FFT (IN PLACE) /COMMON/ = REL 3.1, SEP 79 *****
"
        $TITLE CFFT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CFFT,3                          "USER-DIRECTED-CALL ENTRY
"
        $EXT FFT2,FFT4,STSTAT,CLSTAT,ADV2,ADV4,BITREV
"
"
"
"
"                               --- ABSTRACT ---
"DOES A COMPLEX FFT
"
"
"                               --- STATISTICS ---
"EQUIPMENT:                     AP-120B WITH EITHER MEMORY
"SIZE:        21 + FFT2 (16) + FFT4 (79) + STATUS (19) + ADV (7)
"                  + BITREV (45 FAST, 43 SLOW) = 187 (FAST MEM), 185 (SLOW MEM)
"
"         --- HISTORY ---
"ORIGINAL:  JUN 76  A.E. CHARLESWORTH
" REV 2.1:  JUL 77  R.S. NORIN          MINOR MODS TO SAVE 2 WORDS
" REVISED:  NOV 78  R.S. NORIN          LABEL !FFTX2 REPLACES TBLSZE*2
"                                         FOR APAL3 COMPATIBILITY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"
"
"                               --- USEAGE ---
"DOES A COMPLEX FFT
"
"S-PAD PARAMETERS:
"       NAME     NUMBER          PURPOSE
        C   $EQU 0              "BASE ADDRESS OF ARRAY
        N   $EQU 1              "# OF COMPLEX POINTS IN THE ARRAY (>1)
        F   $EQU 2              "DIRECTION: 1= FORWARD,  -1= INVERSE
"
"
"                               --- SCRATCH (OVERALL) ---
"S-PAD:                         2-17
"DATA PAD X:                    -4 THROUGH +3 (RELATIVE TO DPA)
"DATA PAD Y:                    -4 THROUGH +3 (RELATIVE TO DPA)
"
"
"
"
"                               --- ALGORITHM ---
"
"PROCEEDURE:
"
"1.      CALL 'STSTAT'      THIS TAKES 'N' AND 'F', AND SETS THE BIT-REVERSE
"                           AND FFT-MODE BITS IN THE STATUS REGISTER,  AND
"                           LEAVES 2**N IN SPAD(17)
"2.      PARAMETER INITIALIZE  SET THE FOUR 'PASS VARIABLES'
"                            WD = TBLSZE * 2
"                            MDEL = 2
"                            JCOUNT = 1
"                            ICOUNT = N/4  IF N A POWER OF 4
"                                   = N/2 IF N A POWER OF 2
"                            AND SET MINC = 2
"3.     DO THE FIRST PASS:   RADIX 2 (FFT2) IF N WAS A POWER OF 2
"                               AND ADVANCE (ADV2)
"                            RADIX 4 (FFT4) IF N WAS A POWER OF 4
"                               AND ADVANCE (ADV4)
"4.     DO THE REST OF THE RADIX 4 PASSES.
"                            CALL FFT4  (TO DO THE NEXT FFT PASS)
"                            CALL ADV4  (TO ADVANCE TO THE NEXT PASS)
"                            TEST ICOUNT (SPFN AFTER ADV4) FOR ZERO TO TEST
"                                 FOR DONE
"5.     WHEN DONE, CALL 'CLSTAT' TO CLEAR THE BIT-REVERSE AND FFT-MODE
"                             STATUS BITS
"
"
"OTHER S-PAD NAMES:
        MINC   $EQU 13          "ARRAY INCREMENT BETWEEN REAL ELEMENTS (2)
        WD     $EQU 14          "W DELTA
        MDEL   $EQU 15          "MEMORY DELTA
        ICOUNT $EQU 16          "I-LOOP COUNT
        JCOUNT $EQU 17          "J-LOOP COUNT
"
"
        FP $EQU 16              "PARAMETER FOR STSTAT (F)
        NP $EQU 17              "FOR STSTAT (N)
        M  $EQU 17              "FROM STSTAT (M = LOG2(N) )
"
"
"
"SIZE OF INSTALLED FFT TABLE
        TBLSZE $EQU !FFTSZ
"
"
"
"SET UP FOR THE FFT
"
"INITIALIZE POINTERS:
"
"SET AP-STATUS FOR FORWARD OR INVERSE FFT
"SET AP-STATUS FOR BIT-REVERSE SIZE
"JCOUNT<1
"WD<!FFTSZ*2
"MDEL<2
"MINC<2
"ICOUNT<N/4  IF 1ST PASS RADIX 4
"ICOUNT<N/2  IF 1ST PASS RADIX 2
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCFFT,3                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  6
        $PARAM  3 , P1(2,#2)/R/IP/OP, P2/I/IP, P3/I/IP
FCFFT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CFFT:   MOV N,NP                "IS ELEMENT COUNT = 0?
        MOV F,FP;               "SET-UP FOR STSTAT
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        JSR STSTAT              "SET FFT STATUS BITS
        JSR BITREV              "BIT-REVERSE THE ARRAY
        LDSPI WD; DB=!FFTX2      "SET WD=!FFTSZ*2
        LDSPI MDEL; DB=2
        LDSPI MINC; DB=2        "PUT 2 INTO MINC
        MOVR M,M                "WAS LOG2(N) ODD ?????
        BNC R2                  "IF SO, DO A RADIX 2 PASS FIRST
"
"SET UP FOR FIRST RADIX 4 PASS
R4:     MOVRR N,ICOUNT          "SET ICOUNT=N/4
        LDSPI JCOUNT; DB=1;     "SET COUNT=1
          BR LOOP
"
"DO A RADIX 2 PASS FIRST
R2:     MOVR N,ICOUNT           "SET ICOUNT=N/2
        JSR FFT2
        LDSPI JCOUNT; DB=1      "SET JCOUNT=1
        JSR ADV2                "RADIX 2 ADVANCE
        BEQ DONE                "SEE IF DONE
"
"
"LOOP HERE TO DO ALL THE PASES
LOOP:   JSR FFT4                "DO A RADIX 4 PASS
        JSR ADV4                "RADIX 4 PASS ADVANCE
"
"DONE IF 'ADV' HAS SHIFTED ICOUNT TO ZERO
        BNE LOOP                "IF NOT DONE, GO BACK FOR MORE
"
"
"WHEN DONE, CLEAR FFT MODE BITS
"
DONE:   JMP CLSTAT              "CLEAR STATUS REGISTER
                                "AND EXIT THRU CLSTAT
        $END
"****** CFFTB = COMPLEX FFT (NOT IN PLACE) /COMMON/ = REL 3.1, SEP 79 *****
"
        $TITLE CFFTB
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CFFTB,4                          "USER-DIRECTED-CALL ENTRY
        $EXT FFT2B,FFT4,STSTAT,CLSTAT,FFT4B,ADV2,ADV4
"
"
"                               --- ABSTRACT ---
"
"DOES A NOT-IN-PLACE COMPLEX FFT WHICH COMBINES THE BIT-REVERSE WITH
"THE FIRST PASS OF THE FFT
"
"
"                               --- STATISTICS ---
"EQUIPMENT:                     AP-120B WITH EITHER MEMORY
"SIZE:         25 + FFT2B (25) + FFT4 (79) + STATUS (19) + FFT4B (43-SET24B(8))
"                  + ADV (7)  =  190
"
"      --- HISTORY ---
"ORIGINAL:  JUN 76  A.E. CHARLESWORTH
" REV 2.1:  JUL 77  R.S. NORIN         MINOR MODS TO SAVE 2 WORDS
" REVISED:  NOV 78  R.S. NORIN         LABEL !FFTX2 REPLACES TBLSZE*2
"                                         FOR APAL3 COMPATIBILITY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"
"                               --- USEAGE ---
"DOES A COMPLEX FFT WHICH AVOIDS A SEPARATE BIT-REVERSING
"PASS BY COMBINING THE BIT-REVERSE WITH THE FIRST FFT PASS.
"THIS NECESSITATES THAT THE FFT IS NOT-IN-PLACE, I.E. THE OUTPUT MUST
"GO INTO A DIFFERENT ARRAY FROM THE INPUT.
"
"S-PAD PARAMETERS:
"       NAME     NUMBER          PURPOSE
        A   $EQU 0              "SOURCE ARRAY
        C   $EQU 1              "DESTINATION ARRAY
        N   $EQU 2              "# OF COMPLEX POINTS IN THE ARRAY(>1)
        F   $EQU 3              "DIRECTION: 1= FORWARD,  -1= INVERSE
"
"
"                               --- SCRATCH (OVERALL) ---
"S-PAD:                         0-17  (0 SET TO C, 1 SET TO N)
"DATA PAD X:                    -4 THROUGH +3 (RELATIVE TO DPA)
"DATA PAD Y:                    -4 THROUGH +3 (RELATIVE TO DPA)
"
"
"
"
"                               --- ALGORITHM ---
"
"PROCEEDURE:
"
"1.      CALL 'STSTAT'      THIS TAKES 'N' AND 'F', AND SETS THE BIT-REVERSE
"                           AND FFT-MODE BITS IN THE STATUS REGISTER,  AND
"                           LEAVES 2**N IN SPAD(17)
"2.      PARAMETER INITIALIZE  SET THE FOUR 'PASS VARIABLES'
"                            WD = TBLSZE * 2
"                            MDEL = 2
"                            JCOUNT = 1
"                            ICOUNT = N/4  IF N A POWER OF 4
"                                   = N/2 IF N A POWER OF 2
"                            AND SET MINC = 2
"3.     DO THE FIRST PASS:   RADIX 2 (FFT2B) IF N WAS A POWER OF 2
"                            RADIX 4 (FFT4B) IF N WAS A POWER OF 4
"                              THESE BOTH BIT-REVERSE ORDER
"                              THE INPUT DATA WHILE DOING THE FIRST PASS
"4.     SWITCH 'C' TO 'A'    SET THE ORIGINAL DESTINATION TO BE BOTH
"                            THE SOURCE AND DESTINATION FOR THE REST
"                            OF THE FFT
"5.     DO THE REST OF THE RADIX 4 PASSES.
"                            CALL FFT4  (TO DO THE NEXT FFT PASS)
"                            CALL ADV4  (TO ADVANCE TO THE NEXT PASS)
"                            TEST ICOUNT (SPFN AFTER ADV4) FOR ZERO TO TEST
"                                 FOR DONE
"6.     WHEN DONE, CALL 'CLSTAT' TO CLEAR THE BIT-REVERSE AND FFT-MODE
"                             STATUS BITS
"
"
"
"OTHER S-PAD NAMES:
        MINC   $EQU 13          "ARRAY INCREMENT BETWEEN REAL ELEMENTS (2)
        WD     $EQU 14          "W DELTA
        MDEL   $EQU 15          "MEMORY DELTA
        ICOUNT $EQU 16          "I-LOOP COUNT
        JCOUNT $EQU 17          "J-LOOP COUNT
"
"
        FP $EQU 16              "PARAMETER FOR STSTAT (F)
        NP $EQU 17              "FOR STSTAT (N)
        M  $EQU 17              "FROM STSTAT ( M = LOG2(N) )
        NN $EQU 1               "PLACE TO SAVE N
"
"
"
"SIZE OF INSTALLED FFT TABLE
        TBLSZE $EQU !FFTSZ
"
"
"SET UP FOR THE FFT
"
"INITIALIZE POINTERS:
"
"SET AP-STATUS FOR FORWARD OR INVERSE FFT
"SET AP-STATUS FOR BIT-REVERSE SIZE
"JCOUNT<1
"WD<!FFTSZ*2
"MDEL<2
"MINC<2
"ICOUNT<N/4  IF 1ST PASS RADIX 4
"ICOUNT<N/2  IF 1ST PASS RADIX 2
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FBCFFT,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  14
        $PARAM  4 , P1(2,#3)/R/IP, P2(2,#3)/R/OP,
                    P3/I/IP, P4/I/IP
FBCFFT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CFFTB:  MOV N,NP                "IS ELEMENT COUNT = 0?
        MOV F,FP;               "SET-UP FOR STSTAT
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        JSR STSTAT              "SET FFT STATUS BITS
        LDSPI WD; DB=!FFTX2     "SET WD=!FFTSZ*2
        LDSPI MDEL; DB=2
        LDSPI MINC; DB=2        "PUT 2 INTO MINC
        MOVR M,M                "WAS LOG2(N) ODD ????
        BNC R2                  "IF SO, DO A RADIX 2 PASS FIRST
"
"SET UP FOR FIRST RADIX 4 PASS
R4:     MOVRR N,ICOUNT          "SET ICOUNT=N/4
        JSR FFT4B               "GO DO THE FIRST RADIX 4 PASS
        LDSPI JCOUNT; DB=1      "JCOUNT=1
        MOV C,A                 "SET NEW SOURCE
        MOV N,NN; BR LP4        "SAVE N, AND GO LOOP
"
"DO A RADIX 2 PASS FIRST
R2:     MOVR N,ICOUNT           "SET ICOUNT=N/2
        JSR FFT2B
        LDSPI JCOUNT; DB=1      "JCOUNT=1
        MOV C,A                 "SET NEW SOURCE
        MOV N,NN                "SAVE N
        JSR ADV2                "RADIX 2 ADVANCE
        BEQ DONE                "SEE IF DONE ???
"
"
"LOOP HERE TO DO ALL THE PASES
LOOP:   JSR FFT4                "DO A RADIX 4 PASS
LP4:    JSR ADV4                "RADIX 4 PASS ADVANCE
"
"ADV4 SETS SPFN ON EXIT, DONE IF ZERO
        BNE LOOP                "IF NOT DONE, GO BACK FOR MORE
"
"
"WHEN DONE, CLEAR FFT MODE BITS
"
DONE:   JMP CLSTAT              "CLEAR STATUS REGISTER
                                "AND EXIT THRU CLSTAT
        $END
"****** RFFTSC = REAL FFT SCALE AND/OR FORMAT /COMMON/ = REL 3.2, AUG 80 *****
"       FOR EITHER MEMORY
        $TITLE RFFTSC
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY RFFTSC,4                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV
"
"       ---ABSTRACT---
"ROUTINE IS CALLED AFTER A FORWARD RFFT OPERATION OR
"BEFORE AN INVERSE RFFT OPERATION TO PROPERLY SCALE RESULTS
"AND FORMAT COMPLEX NUMBERS.
"ROUTINE CAN ALSO BE CALLED PRIOR TO  THE 2N IFFT IN
"CONVOLUTION OR CORRELATION TO SCALE THESE RESULTS.
"
"FORMATTING MAY BE NECESSARY BECAUSE OF THE PACKED COMPLEX
"RESULT OF A FORWARD RFFT OPERATION INTO N/2 COMPLEX NUMBERS
"OF THE FORM:
" I.  RE(0),RE(N/2),RE(1),IM(1),....,RE(N/2-1),IM(N/2-1)
"
"UNPACKING CAN PUT THE RESULTS INTO N/2 COMPLEX NUMBERS
"(BY DISCARDING RE(N/2) ) OF THE FORM
" II.  RE(0),0,RE(1),IM(1),....,RE(N/2-1),IM(N/2-1)
"
"UNPACKING CAN ALSO PUT THE RESULTS INTO N/2 + 1 PROPER
"COMPLEX NUMBERS OF THE FORM:
" III.  RE(0),0,RE(1),IM(1),....,RE(N/2-1),IM(N/2-1),RE(N/2),0
"
"SCALING REQUIRES THAT THE RESULTS BE MULTIPLIED BY
"    0.5/N IN THE FORWARD DIRECTION (NO SCALING NEEDED IN INVERSE)
"    0.25/N FOR FFT CONVOLUTION OR CORRELATION
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP120 WITH EITHER MEMORY
"SIZE: 35 LOCATIONS + DIV (28 LOCATIONS) = 63 LOCATIONS
"TIMING: FORMATTING: 7-13 CYCLES
"                    1.17-2.17 USEC WITH 167 NSEC CLOCK
"        SCALING: INTRO: 4-35 CYCLES
"                 LOOP: 4-5 CYCLES
"                 COLUMNS/LOOP: 2
"                 FLOPS/LOOP:   1
"                 (0.67-0.83)N + (0.67-5.17)  USEC FOR 167 NSEC CLOCK
"                 MEGAFLOPS: 1.2-1.5
"SUBROUTINES USED: DIV
"
"    --- HISTORY ---
"ORIGINAL:  DEC 76  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80  T. E. SKINNER  PROVIDES FOR CASE OF N=32768
"
"       ---USAGE---
"FORTRAN: CALL RFFTSC(C,N,F,FS)
"APAL:    JSR RFFTSC
"S-PAD PARAMETERS:
"  NAME  NUMBER
    C $EQU 0                    "BASE ADDRESS OF DATA
    N $EQU 1                    "NUMBER OF ELEMENTS IN C
    F $EQU 2                    "FORMATTING FLAG
                "FFT: F=1 NO FORMAT CHANGE (LEAVE PACKED IN FORM I.)
                "     F=2  UNPACK FROM FORMAT I. TO II.
                "     F=3  UNPACK FROM FORMAT I. TO III.
                "IFFT: F=-1  NO FORMAT CHANGE (LEAVE PACKED IN FORM I.)
                "      F=-2  PACK FROM II. TO I.
                "      F=-3  PACK FORM III. TO I.
    FS $EQU 3                   "SCALING FLAG
                                "FS=0  DO NOT SCALE
                                "FS>0 SCALE RESULTS FOR NORMAL FORWARD
                                "    FFT (0.5/N)
                                "FS<0 SCALE RESULTS FOR COMPLETE CORRELATION (CO
                                "    (0.25/N)
"
"THE FOLLOWING ARE NOT ARGUMENTS:
    CC $EQU 12
    NN $EQU 13
    I1 $EQU 14
    FT $EQU 15
    CN $EQU 16
    C1 $EQU 17
    TP $EQU 17
"
"RESTRICTIONS: RFFTSC, IF USED, SHOULD BE CALLED IMMEDIATELY
"                AFTER A FORWARD RFFT CALL, OR BEFORE AN
"                INVERSE RFFT CALL.
"
"SCRATCH: SP(12-17), DPX(0), DPY(0), DPA UNCHANGED
"
"TABLE MEMORY REFERENCES:
  HALF $EQU !HALF
  FORTH $EQU !FORTH
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCRFFT,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  16
        $PARAM  4 , P1(#2)/R/IP/OP, P2/I/IP,
                    P3/I/IP, P4/I/IP
FCRFFT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
RFFTSC: LDSPI TP; DB=2          "FORMAT
        MOV N,NN                "SAVE N
        MOV F,FT;               "FORWARD OR INVERSE?
          BEQ SCALE             "EXIT IF COUNT = 0
        MOV N,CN;               "SAVE N
            BGT FWDFMT          "FORWARD
INVFMT: ADD C,CN; SETMA         "GET RE(N/2)
        ADD TP,FT
        MOV FT,FT;              "NOTHING TO DO IF F=-1
            BGT SCALE
        MOV C,C1;               "F=-2 MEANS
            BEQ ZIM0            "IM(0)=RE(N/2)=0
        INC C1; SETMA; MI<MD;   "LET IM(0)=RE(N/2)
            BR SCALE
FWDFMT: SUB TP,FT               "DETECT THE DIFFERENT CASES
        MOV C,C1;
            BEQ ZIM0            "F=2 MEANS IM(0)=0
        INC FT
                                "F=3 MEANS N/2 + 1 COMPLEX PAIRS
        INC C1; SETMA;          "GET IM(0)
            BEQ SCALE           "NOTHING TO DO IF F=1
        INC NN                  "MUST SCALE 1 MORE ELEMENT
        ADD C1,CN; SETMA; MI<ZERO   "SET IM(N/2)=0
        DECMA; MI<MD;           "SET RE(N/2)=IM(0)
            DEC C1
ZIM0:   INC C1; SETMA; MI<ZERO  "SET IM(0)=0
"
"SCALING ROUTINE STARTS HERE
"
SCALE:  MOV FS,FS;              "GET SCALING FLAG
            LDTMA; DB=HALF      "GET FACTOR FOR FFT SCALING (0.5)
        MOV FS,FS;              "CORRELATION SCALING?
            BEQ DONE            "NO SCALING NEEDED.
        MOV C,CC;SETMA;         "GET C(0)
            BGT COM             "FFT SCALING
        LDTMA; DB=FORTH;        "CORRELATION SCALING (0.25/N)
            BR COM
COM:    LDSPI TP; DB=27.        "GET EXPONENT
        MOV N,N; DPX<SPFN       "FLOAT N
"
" --- MODIFICATION FOR 32K RFFTI
        BGE NORMAL; MOV N,N
        RPSF FP32K; DPX<DB
        FADD ZERO,DPX; BR CONT
"
NORMAL: FADD ZERO,MDPX; MOV TP,TP;
          BEQ DONE              "EXIT IF COUNT = 0
CONT:   LDSPI I1; DB=1;         "SET INCREMENT
            FADD
        DPX<FA; DPY<TM; JSR DIV "FORM 1/N
LOOP:       FMUL DPX,MD         "1.  K*C(M)
        ADD I1,CC; SETMA;       "2.  GET C(M+1)
            FMUL
            FMUL; DEC NN        "3.  PUSH, DECREMENT COUNT
            DECMA; MI<FM;       "4.  STORE C(M)
            BNE LOOP            "    CONTINUE UNTIL
DONE:   RETURN                  "DONE THEN EXIT.
"
" --- FLOATING POINT 32768.
FP32K:  $FP 32768.
"
        $END
"****** CFFTSC = COMPLEX FFT SCALE /COMMON/ = REL 3.1, AUG 80 *****
"       FOR EITHER MEMORY
        $TITLE CFFTSC
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CFFTSC,2                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV
"
"       ---ABSTRACT---
"ROUTINE IS CALLED AFTER A FORWARD CFFT OPERATIONTO SCALE RESULTS
"
"SCALING REQUIRES THAT THE RESULTS BE MULTIPLIED BY
"    1.0/N IN THE FORWARD DIRECTION (NO SCALING NEEDED IN INVERSE)
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP120 WITH EITHER MEMORY
"SIZE: 18 LOCATIONS + DIV (28 LOCATIONS) = 46 LOCATIONS
"TIMING:   FAST: 5N
"         STANDARD: 8N
"                 COLUMNS/LOOP: 2
"                 FLOPS/LOOP:   1
"SUBROUTINES USED: DIV
"
"       --- HISTORY ---
"ORIGINAL:  APR 77  R. S. NORIN
" REVISED:  AUG 80  T. E. SKINNER  PROVIDE FOR CASE OF N=32768
"                                  EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN: CALL CFFTSC(C,N)
"APAL:    JSR CFFTSC
"S-PAD PARAMETERS:
"  NAME  NUMBER
    C $EQU 0                    "BASE ADDRESS OF DATA
    N $EQU 1                    "NUMBER OF COMPLEX ELEMENTS IN C
"
"THE FOLLOWING ARE NOT ARGUMENTS:
    CC $EQU 13
    I2 $EQU 14
    NN $EQU 15
   CCC $EQU 16
    TP $EQU 17
"
"RESTRICTIONS: CFFTSC, IF USED, SHOULD BE CALLED IMMEDIATELY
"                AFTER A FORWARD CFFT CALL, OR BEFORE AN
"                INVERSE CFFT CALL.
"
"SCRATCH: SP(13-17), DPX(0), DPY(0,1), DPA UNCHANGED
"
"TABLE MEMORY REFERENCES:
  ONE $EQU !ONE
"
"
"SCALING ROUTINE STARTS HERE
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCCFFT,2                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  2
        $PARAM  2 , P1(2,#2)/R/IP/OP, P2/I/IP
FCCFFT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CFFTSC: MOV C,CC;SETMA          "GET C(0)
        LDTMA; DB=ONE           "GET 1.0 FROM TM
        LDSPI TP; DB=27.        "GET EXPONENT
        MOV N,N; DPX<SPFN;      "FLOAT N
            INCMA               "GET C(0) IMAG
"
" --- MODIFICATION FOR 32K CFFTI
        BGE NORMAL; MOV N,N
        RPSF FP32K; DPX<DB
        FADD ZERO,DPX; BR CONT; DPY(1)<MD
"
NORMAL: FADD ZERO,MDPX; MOV TP,TP;
            DPY(1)<MD; BEQ DONE "SAVE C(0)
CONT:   LDSPI I2; DB=2;         "SET INCREMENT
            FADD
        DPX<FA; DPY<TM; JSR DIV "FORM 1/N
        FMUL DPX,DPY(1);        "C(0)*(1/N)
                MOV N,NN        "SET COUNT
LOOP:   ADD I2,CC;SETMA;        "GET C(M+1) REAL
            BEQ DONE            "QUIT IF DONE
        INCMA;                  "GET C(M+1) IMAG
            FMUL DPX,MD         "C(M)*(1/N) IMAG
            FMUL;               "PUSH
            MOV CC,CCC          "SET OUTPUT POINTER
        FMUL DPX,MD;            "C(M+1)*(1/N) REAL
            SUB I2,CCC;SETMA;MI<FM "STORE REAL
            INCMA;MI<FM;        "STORE IMAG
            DEC NN; BR LOOP     "DECREMENT COUNT AND LOOP
DONE:   RETURN                  "DONE THEN EXIT.
"
" --- FLOATING POINT 32768.
FP32K:  $FP 32768.
        $END
"****** CONV = CONVOLUTION /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE CONV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CONV, 8.                          "USER-DIRECTED-CALL ENTRY
"              ---ABSTRACT---
"THIS DOES A CONVOLUTION, WITH THE OPERATOR POINTS IN
"VECTOR B, THE TRACE POINTS (DATA POINTS) IN VECTOR A, AND
"THE ANSWER POINTS IN VECTOR C.
"              ---STATISTICS---
"LANGUAGE:     AP-120B ASSEMBLER
"EQUIPMENT:    AP-120B WITH EITHER MEMORY
"STORAGE:      PS - 103.
"              DPX - 32.
"              DPY - 32.
"              SP - 8.
"
"    --- HISTORY ---
"ORIGINAL:  NOV 75  S. CAMLEY
" REVISED:  AUG 79  D. GANGULY     MADE MINOR MODS TO ACCOMODATE ADC
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"              ---USAGE---
"SAMPLE CALL:  JSR CONV
"ARGUMENTS:    IN S-PAD
"                0     A - BASE ADDRESS OF A (TRACE)
"                1     I - INCREMENT FOR A
"                2     B - BASE ADDRESS OF B (OPERATORS)
"                3     J - INCREMENT FOR B
"                4     C - BASE ADDRESS OF C (ANSWER)
"                5     K - INCREMENT FOR C
"                6     N - NUMBER OF ANSWERS
"                7     M - NUMBER OF OP POINTS
"
"NOTE: 1) FOR ADC MODE CALLS AN ADDITIONAL PARAMETER ,L,IS REQUIRED.HERE
"      L=THE ELEMENT COUNT OF A.THE FORTRAN CALL SHOULD THEN LOOK LIKE:
"
"      CALL FCONV (A,I,B,J,C,K,N,M,L)
"      HERE, A,B & C ARE ACTUAL ARRAY NAMES.
"
"      2) TO DO CONVOLUTION IN ADC MODE ,BOTH I & J MUST BE POSITIVE.
"      THEREFORE,IT IS RECOMMENDED THAT THE ARRAY B BE PREPROCESSED
"      TO CONTAIN THE OPERATOR ELEMENTS ARRANGED IN A REVERSE ORDER.
"
"
"SCRATCH:      SP(0-16.), DPX(0-31), DPY(0-31)
"              DPA(0-31)
"              ---ALGORITHM---
"LOOP1A MULTIPLIES THE FIRST OPERATOR POINT BY EACH
""OF THE FIRST 32. TRACE POINTS, AND PUTS THE PRODUCTS
"IN THE FIRST 32. ANSWER POINTS. THEN IT GETS THE
"NEXT OP. PT., MULTIPLIES IT BY TRACE PTS. 2-33, ADDS
"THE PRODUCTS TO THE PREVIOUS ANSWERS, AND PUTS THEM
"BACK IN ANSWER POINTS 1-32.  THE NEXT OP. PT. IS
"MULTIPLIED BY TRACE PTS. 3-34, THE PRODUCTS ARE
"ADDED TO ANSWER PTS. 1-32, AND THEN PUT BACK THERE.
"THIS CONTINUES UNTIL IT HAS RUN OUT OF OP. PTS.
"ANSWER PTS. 1-32 NOW REPRESENT THE FINAL BLOCK
"OF THE FIRST 32 ANSWERS.
"
"IF THERE IS ANOTHER BLOCK OF 32 (OR MORE) ANSWER
"POINTS TO DETERMINE, THEN IT WILL START OVER WITH THE
"FIRST OP. PT. TRACE PTS. 33-64, AND PUT THE PRODUCTS
"IN ANSWER PTS. 33-64.  IT FOLLOWS THE ABOVE PATTERN
"UNTIL IT RUNS OUT OF OP. PTS.
"LOOP2 ROUTES THE PROBLEM TO LOOP1A AS MANY TIMES AS
"THERE ARE BLOCKS OF 32 ANSWERS DESIRED.  WHEN THERE
"ARE LESS THAN 32 LEFT TO DO, THE PROBLEM GOES TO
"LOOP1B, WHICH GENERALLY DOES THE SAME THING AS
"LOOP1A EXCEPT THAT IT HANDLES THE TRACE AND ANSWER PTS.
"IN BLOCKS OF LESS THAN 32.
"EXAMPLE:  100 ANSWER PTS. ARE DESIRED.
"LOOP2 PUTS THE FIRST 32 TRACE PTS. IN DPX. LOOP1A
"MULTIPLIES EACH BY THE FIRST OP. PT., PUTS THE
"PRODUCTS IN THE 32 DPY REGISTERS.  DPX(2-32)
"ARE MOVED INTO DPX(1-31), AND THE NEXT TRACE PT.(33)
"IS MOVED INTO DPX(32).  THUS, THE NEXT OP. PT. IS
"MULTIPLIED BY TRACE PTS. 2-33, THE PRODUCTS ARE ADDED
"TO DPY(1-32), AND THESE SUMS GO BACK INTO DPY(1-32).
"WHEN ALL OP. PTS. HAVE BEEN USED, DPY(1-32) IS STORED
"INTO THE FINAL ANSWER VECTOR.
"LOOP2 DETERMINES THAT THERE IS ANOTHER BLOCK OF
"32 ANSWER PTS. TO BE DONE, PUTS TRACE PTS. 33-64 INTO
"DPX(1-32), AND LETS LOOP1A TAKE OVER AGAIN.  THIS
"MULTIPLIES DPX(1-32) BY THE FIRST OP. PT., PUTS THE
"PRODUCTS INTO DPY(1-32) (DPY WAS INITIALIZED TO ZERO
"BY LOOP2), MOVES DPX(2-32) INTO DPX(1-31), GETS THE
"NEXT TRACE PT.(65), AND PUTS IT INTO DPX(32),
"MULTIPLIES DPX(1-32) BY THE NEXT OP. PT., ADDS THE 32
"PRODUCTS TO DPY(1-32), MOVES DPX(2-32) INTO DPX(1-31), GETS
"THE NEXT TRACE PT.(66) AND PUTS IT INTO DPX(32), ETC.
"WHEN IT RUNS OUT OF OP. PTS., DPY(1-32) IS STORED INTO
"FINAL ANSWER PTS. 33-64.
"LOOP2 PUTS TRACE PTS. 65-96 INTO DPX(1-32) AND GIVES IT
"TO LOOP1A ONCE MORE. WHEN LOOP1A RUNS OUT OF OP.
"PTS., DPY(1-32) IS STORED INTO ANSWER PTS. 65-96.
"NOW LOOP2 FINDS THAT THERE ARE ONLY 4 ANSWER PTS. LEFT TO
"DO.  IT PUTS TRACE PTS. 97-100 INTO DPX(1-4), THEN GOES
"TO LOOP1B.  THIS MULTIPLIES DPX(1-4) BY THE FIRST OP. PT.,
"PUTS THE PRODUCTS INTO DPY(1-4), MOVES DPX(2-4) INTO
"DPX(1-3), GETS THE NEXT TRACE PT.(101) AND PUTS IT INTO
"DPX(4), MULTIPLIES DPX(1-4) BY THE NEXT OP. PT., ETC.
"FINALLY, DPY(1-4) ARE STORED INTO ANSWER PTS. 97-100,
"AND THE PROBLEM IS DONE.
"ACTUALLY, THE CONSTRUCTION OF LOOP1B REQUIRES A
"MINIMUM OF 6 ANSWER PTS. DESIRED.  IF THERE ARE LESS
"THAN THAT TO DO, IT BRANCHES OFF TO 5 SPECIAL CASES
"(ELSE 1-ELSE5).
"S-PAD PARAMETERS:
A  $EQU  0                   "BASE ADDR. OF A.
I  $EQU  1                   " INC. FOR A.
B  $EQU  2                   " BASE ADDR. OF B.
J  $EQU  3                   " INC. FOR B.
C  $EQU  4                    " BASE ADDR. FOR C
K  $EQU  5                    "INC. FOR C.
N  $EQU  6                     "NUMBER OF ANSWERS.
M  $EQU  7                      "SIZE OF B.
"THE FOLLOWING ARE NOT PARAMETERS:
TT  $EQU  10                   "THIS WILL CONTAIN THE SIZE OF A FOR ADC.
                               "THIS PARAM.CAN BE WRITTEN OVER AFTER
                               "THE CALL.
SAVEB  $EQU  11
SAVEA  $EQU  12
SAVEM  $EQU  13
JUNK  $EQU  14
ITT  $EQU  15
CCTR  $EQU  16
TF  $EQU  17
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCONV,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  752
        $PARAM  9., P1(#2,#9.)/R/IP, P2/I/IP,
                    P3(#4,#8.)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP, P8/I/IP ,P9/I/IP
FCONV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CONV:   SUB K,C
        MOV B,SAVEB
        MOV A, SAVEA
        MOV N,N                 "IS ELEMENT COUNT = 0?
        MOV M,SAVEM;
          BEQ ZDONE             "EXIT IF COUNT = 0
        LDSPI TT; DB=32.;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        CLR ITT
        MOV I,JUNK                      "IF I=0
        BEQ LOOP2;                      "  SKIP INTEGER MULT
          MOV I,JUNK
        BGT LOOPP
LOOPM:  INC JUNK
        SUB TT,ITT; BNE LOOPM           "I*32=ITT
        BR LOOP2
LOOPP:  DEC JUNK
        ADD TT,ITT; BGT LOOPP           "I*32=ITT
LOOP2:  SUB# TT,N                       "TEST IF NEED TO DO
        BGE .+2                         " BLOCK OF 32 OR LESS
                                        "IF LESS,
        CFL1; MOV N,CCTR; BR .+2        " USE REMAINING N
        SFL1; MOV TT,CCTR               " OTHERWISE, USE 32.
                               "GET FIRST TR. PT. FROM BLOCK
        MOV SAVEA,A; SETMA              " (E.G. 1, 33, 65, ETC.)
        DB=ZERO; LDDPA; MOV CCTR,JUNK
        ADD I,A; SETMA; DPY<ZERO        "GET NEXT TR. PT.
GET:    DPX<MD;                         "THIS LOOP PUTS
          INCDPA;                       " TR PTS INTO DPX(1-32)
          DEC JUNK                      " AND 0'S INTO DPY(1-32)
        ADD I,A; SETMA; BGT GET;        "SAME
          DPY<ZERO
        BFL1 .+2                        "CHECK IF DOING 32 OR LESS
        JMP LESS
"IF BLOCK OF 32:
        MOV SAVEB,B; SETMA              "GET FIRST OP PT
        DB=2; LDDPA; SUB I,A            "DPA=2
        DB=24.; LDSPI TF
        FMUL DPX(-2),MD;                "DO FIRST TR PT
          SUB I,A                       " * FIRST OP PT
"HEREAFTER, THE NTH TRACE PT AND OP PT WILL BE
"REFERRED TO AS TR(N) AND OP(N)
        FMUL DPX(-1),MD;                "DO TR(2)*OP(1)
          DPX(-2)<DPX(-1);              "MOVE TR(2) INTO TR(1)
                                        " POSITION FOR NEXT
          MOV TF,JUNK                   " TIME AROUND
        FMUL DPX,MD;                    "DO TR(3)*OP(1)
          DPX(-1)<DPX                   "MOVE TR(3) INTO TR(2)
"NTH ANSWER PT = ANS(N)
LOOP1A: FADD FM,DPY(-2);                "DO ANS(1)+TR(1)*OP(L)
          FMUL DPX(1),MD;               "DO TR(4)*OP(L)
          DPX<DPX(1)                    "MOVE TR(4) INTO TR(3)
        FADD FM,DPY(-1);                "DO ANS(2)+TR(2)*OP(L)
          FMUL DPX(2),MD;               "DO TR(5)*OP(L)
          DPX(1)<DPX(2);                "MOVE TR(5) INTO TR(4)
          DEC JUNK
        DPY(-2)<FA;  INCDPA;            "STORE ANS(P-2)
          FADD FM,DPY;                  "ANS(P)+TR(P)*OP(L)
          FMUL DPX(3),MD; DPX(2)<DPX(3); "TR(P+3)*OP(L)
          DEC JUNK; BGT .               " MOVE TR(P+3) INTO TR(P+2)
        DPY(-2)<FA; INCDPA;             "SAME AS ABOVE
          FADD FM,DPY;                  " FOR P=P+1
          FMUL DPX(3),MD; DPX(2)<DPX(3);
          ADD I,A; SETMA                "GET NEXT TR PT
        DPY(-2)<FA; INCDPA;             "STORE ANS(26)
          FADD FM,DPY;                  "ANS(28)+TR(28)*OP(L)
          FMUL DPX(3),MD;               "DO TR(31)*OP(L)
          DPX(2)<DPX(3)                  "MOVE TR(31) INTO TR(30)
        DPY(-2)<FA; INCDPA;             "SAME AS ABOVE,
          FADD FM,DPY;                  " INCREMENTING NUMERAL
          FMUL DPX(3),MD; DPX(2)<DPX(3);" INDICES BY ONE
          ADD J,B; SETMA                "GET OP(L+1)
        DPY(-2)<FA; INCDPA;             "STORE ANS(28)
          FADD FM,DPY;                  "ANS(30)+TR(30)*OP(L)
          DPX(2)<MD; FMUL               "MOVE NEW TR PT INTO  TR(32)
        DPY(-2)<FA; INCDPA;             "STORE ANS(29)
          FADD FM,DPY;                  "ANS(31)+TR(31)*OP(L)
          FMUL
        DPY(-2)<FA; INCDPA;             "STORE ANS(30)
          FADD FM,DPY;                  "ANS(32)+TR(32)*OP(L)
          FMUL DPX(1),MD;               "NEW TR(1)*OP(L+1)
          MOV TF,JUNK                   "RE-INIT INNER COUNTER
        DPY(-2)<FA; INCDPA;             "STORE ANS(31)
          FADD; FMUL DPX(1),MD;          "NEW TR(2)*OP(L+1)
          DPX<DPX(1);                   "MOVE TR(2) INTO TR(1)
          DEC M
        DPY(-2)<FA; INCDPA;             "STORE ANS(32)
          FMUL DPX(1),MD;               "TR(3)*OP(L+1)
          DPX<DPX(1);                   "MOVE TR(3) INTO TR(2)
          BGT LOOP1A                    "TEST IF DONE ALL OP PTS
        DB=ZERO; LDDPA;                 "IF SO, SUBTRACT
          SUB TT,N                      " 32 FROM N
        BGT .+2
        JMP STORE
        DEC CCTR
        ADD K,C; SETMA; MI<DPY;         "STORE BLOCK OF
          INCDPA; BGT .-1               " 32 ANSWERS
        MOV SAVEM,M                     "RESTORE OP PT COUNTER
                                        "SET NEXT TR PT BLOCK
        ADD ITT,SAVEA                   " STARTING PT
        JMP LOOP2                       "BACK TO LOOP2
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY ONE ANSWER
        FMUL DPX(-2),MD
ELSE1:  FMUL; ADD I,A; SETMA
        FMUL
        FADD FM,DPY(-2);
          ADD J,B; SETMA
        FADD; DPX(-2)<MD; DEC M
        DPY(-2)<FA;
          BGT ELSE1 - 1
        JMP OUT
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY TWO ANSWERS
        FMUL DPX(-2),MD
        FMUL DPX(-1),MD;
          DPX(-2)<DPX(-1)
ELSE2:  FMUL; ADD I,A; SETMA
        FMUL; FADD FM,DPY(-2)
        FADD FM,DPY(-1);
          ADD J,B; SETMA
        DPY(-2)<FA; FADD;
          DPX(-1)<MD; DEC M
        DPY(-1)<FA;
          BGT ELSE2 - 2
        JMP OUT
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY THREE ANSWERS
ELSE3:  FADD FM,DPY(-2); FMUL;
          ADD I,A; SETMA
        FADD FM,DPY(-1); FMUL;
          MOV CCTR,JUNK
        DPY(-2)<FA;
          FADD FM,DPY;
          ADD J,B; SETMA
        DPY(-1)<FA; FADD;
          DPX<MD; DEC M
        DPY<FA; DEC JUNK;
          BGT LOOP1B
        JMP OUT
JUMP1:  JMP ELSE1
JUMP2:  JMP ELSE2
"LEADING INTO LOOP1B...THE PROGRAM HAS JUMPED HERE
"IF THERE WERE LESS THAN 32 ANSWER PTS (LEFT) TO DO
LESS:   SUB I,A
        SUB I,A
        MOV SAVEB,B; SETMA              "GET OP(1)
        DB=2; LDDPA; MOV CCTR,JUNK      "DPA=2
        DEC JUNK
LOOP1B: FMUL DPX(-2),MD;                 "TR(1)*OP(L)
                                        "TEST IF GO TO
          DEC JUNK; BEQ JUMP1           " SPECIAL CASE 1
        FMUL DPX(-1),MD;                "TR(2)*OP(L)
          DPX(-2)<DPX(-1);              "MOVE TR(2) INTO TR(1)
          DEC JUNK; BEQ JUMP2           "TEST SPEC CASE 2
        FMUL DPX,MD;                    "TR(3)*OP(L)
          DPX(-1)<DPX;                     "MOVE TR(3) INTO TR(2)
          DEC JUNK; BEQ ELSE3           "TEST SPEC CASE 3
        FADD FM,DPY(-2);                "ANS(1)+TR(1)*OP(L)
          FMUL DPX(1),MD;               "TR(4)*OP(L)
          DPX<DPX(1);                   "MOVE TR(4) INTO TR(3)
          DEC JUNK; BEQ ELSE4           "TEST SPEC CASE 4
        FADD FM,DPY(-1);                "ANS(2)+TR(2)*OP(L)
          FMUL DPX(2),MD;               "TR(5)*OP(L)
          DPX(1)<DPX(2);                "MOVE TR(5) INTO TR(4)
          DEC JUNK; BEQ ELSE5           "TEST SPEC CASE 5
        DPY(-2)<FA; INCDPA;             "STORE ANS(P)
          FADD FM,DPY;                  "ANS(P+2)+TR(P+2)*OP(L)
          FMUL DPX(3),MD; DPX(2)<DPX(3); "TR(P+5)*OP(L)
          DEC JUNK; BGT .               "TR(P+5) INTO TR(P+4)
        DPY(-2)<FA; INCDPA;             "STORE ANS(P+1)
          FADD FM,DPY; FMUL;            "ANS(P+3)+TR(P+3)*OP(L)
          ADD I,A; SETMA                "GET NEXT TR PT
        DPY(-2)<FA; INCDPA;             "STORE ANS(P+2)
          FADD FM,DPY; FMUL;            "ANS(P+4)+TR(P+4)*OP(L)
          MOV CCTR,JUNK                 "RE-INIT INNER COUNTER
        DPY(-2)<FA; INCDPA;             "STORE ANS(P+3)
          FADD FM,DPY;                  "ANS(P+5)+TR(P+5)*OP(L)
          ADD J,B; SETMA                "GET OP(L+1)
        DPY(-2)<FA; INCDPA;              "STORE ANS(P+4)
          FADD; DPX(-1)<MD;             "MOVE NEXT TR PT
          DEC M                         " INTO TR(P+5)
        DB=2; LDDPA;                       "DPA=2
          DPY(-2)<FA;                    "STORE ANS(P+5)
          DEC JUNK;
          BGT LOOP1B                    "TEST IF DONE ALL OP PTS
OUT:    DB=ZERO; LDDPA; BR STORE        "IF SO, GO TO STORE
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY 4 ANSWERS
ELSE4:  FADD FM,DPY(-1); FMUL;
          ADD I,A; SETMA
        DPY(-2)<FA;
          FADD FM,DPY; FMUL;
          MOV CCTR,JUNK
        DPY(-1)<FA;
          FADD FM,DPY(1);
          ADD J,B; SETMA
        DPY<FA; FADD;
          DPX(1)<MD; DEC M
        DPY(1)<FA;
          DEC JUNK;
          BGT LOOP1B
        JMP OUT
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULAGE ONLY 5 ANSWERS
ELSE5:  DPY(-2)<FA;
          FADD FM,DPY; FMUL;
          ADD I,A; SETMA
        DPY(-1)<FA;
          FADD FM,DPY(1); FMUL;
          MOV CCTR,JUNK
        DPY<FA;
          FADD FM,DPY(2);
          ADD J,B; SETMA
        DPY(1)<FA; FADD;
          DPX(2)<MD; DEC M
        DPY(2)<FA;
          DEC JUNK;
          BGT .+2
        JMP OUT
        JMP LOOP1B
"THE PROGRAM HAS JUMPED HERE IF THE LAST ANSWERS
"ARE READY TO STORE
STORE:  DEC CCTR
        ADD K,C; SETMA; MI<DPY;         "STORE THEM
          INCDPA; BGT STORE
        RETURN
        $END
"****** VPOLY = VECTOR POLYNOMIAL EVALUATE /COMMON/ = REL 3.1, SEP 79 *****
"  FOR EITHER MEMORY
        $TITLE VPOLY
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VPOLY, 8.                          "USER-DIRECTED-CALL ENTRY
"               -- ABSTRACT--
"FOR POLYNOMIAL OF ORDER P, THIS WILL CALCULATE Y
"FOR ANY GIVEN X.
"Y(M*K)=A(P)*X(M*J)**P+A(P-1)*X(M*J)**(P-1)+...+A(0)
"       =((...(A(P)*X(M*J)+A(P-1))X(M*J)...+A(0)
"   FOR M= 0 TO N-1
"IN THIS PROGRAM, THE X'S WILL BE REPRESENTED
"BY VECTOR B, AND THE Y'S BY VECTOR C.  HENCE:
"C(M*K)=A(P)*B(M*J)**P+A(P-1)*B(M*J)**(P-1)+...+A(0)
"       =((...(A(P)*B(M*J)+A(P-1))*B(M*J)...+A(0)
 "FOR M= 0 TO N-1
"THE B'S ARE DONE IN BLOCKS OF 5 AT A TIME.
"WHEN THERE ARE LESS THAN 5 (LEFT) TO DO,
"THE PROGRAM BRANCHES TO SPECIAL CASES FOR
"STORING THE ANSWERS (ELSE).
"               ---STATISTICS---
"EQUIPMENT:   AP-120B WITH EITHER MEMORY
"SIZE:   37 WORDS
"
"    --- HISTORY ---
"ORIGINAL:  NOV 75  S. CAMLEY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"               ---USAGE---
"SAMPLE CALL:   JSR VPOLY
"ARGUMENTS:     IN S-PAD
"                 0     A - BASE ADDRESS OF
"                           CO-EFFICIENTS,
"                           WITH CO-EFF OF HIGHEST
"                           ORDER X (B) FIRST
"                 1     I - INCREMENT FOR A
"                 2     B - BASE ADDRESS OF B (X)
"                 3     J - INCREMENT FOR B
"                 4     C - BASE ADDRESS OF C (Y)
"                 5     K - INCREMENT FOR C
"                 6     N - NUMBER OF B'S
"                 7     P - POWER
"                           (ORDER OF POLY)
"NOTE:          THE POLYNOMIAL MUST BE AT LEAST
"               SECOND ORDER.
"SCRATCH:       SP(0-9), DPX(-4 TO 0), DPY(-2, -4)
"               DPA UNCHANGED
A = 0
I = 1
B = 2
J = 3
C = 4
K = 5
N = 6
P = 7
"SAVE ORIGINAL A AND P IN ALTERNATE LOCATIONS
ALT = 8.
ALTP = 9.
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVPOLY,8.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  352
        $PARAM  8., P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP, P8/I/IP
FVPOLY: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VPOLY:  SUB J,B
        SUB K,C
        MOV A,A; SETMA          "GET A(P)
        MOV A,ALT
        MOV P,ALTP
        DPY(-4)<MD              "SAVE A(P)
LOOP2:  ADD J,B; SETMA          "GET B(0)
        NOP                             "FOR UPWARD COMPATIBILITY
        ADD J,B; SETMA          "GET B(1)
        DPX(0)<MD;              "SAVE B(0)
          FMUL DPY(-4),MD       "DO A(P)*B(0)
        ADD J,B; SETMA          "GET B(2)
        DPX(-1)<MD;             "SAVE B(1)
          FMUL DPY(-4),MD       "DO A(P)*B(1)
        ADD J,B; SETMA          "GET B(3)
        MOV ALT,A;              "MOVE A TO ORIG POSITION
            DPX(-2)<MD;         "SAVE B(2)
          FMUL DPY(-4),MD       "DO A(P)*B(2)
        ADD I,A; SETMA;         "GET A(P-1)
          DPY(-2)<FM            "SAVE A(P)*B(0)
        DPX(-3)<MD;             "SAVE B(3)
          FMUL DPY(-4),MD;      "DO A(P)*B(3)
          MOV ALTP,P            "RESET ORDER-OF-POLY COUNTER
        ADD J,B; SETMA          "GET B(4)
        FADD DPY(-2),MD;        "DO A(P)B(0)+A(P-1)
          DEC P                 "DECREMENT ORDER-OF-POLY COUNTER
        FADD FM,NC              "DO A(P)B(1)+A(P-1)
        DPX(-4)<MD;             "SAVE B(4)
          FMUL DPY(-4),MD       "DO A(P)B(4)
LOOP1:  FMUL DPX(0),FA;         "DO A(P)B(0)**2+A(P-1)B(0)
          FADD FM,NC;           "DO A(P)B(2)+A(P-1)
          ADD I,A; SETMA        "GET A(P-2)
        FMUL DPX(-1),FA;        "DO A(P)B(1)**2+A(P-1)B(1)
          FADD FM,NC            "DO A(P)B(3)+A(P-1)
        FMUL DPX(-2),FA;        "DO A(P)B(2)**2+A(P-1)B(2)
          FADD FM,NC            "DO A(P)B(4)+A(P-1)
        FMUL DPX(-3),FA;        "DO A(P)B(3)**2+A(P-1)B(3)
          FADD FM,MD;   "DO A(P)B(0)**2+A(P-1)B(0)+A(P-2)
          DEC P         "DECREMENT ORDER-OF-POLY COUNTER
        FMUL DPX(-4),FA;        "DO A(P)B(4)**2+A(P-1)B(4)
          FADD FM,NC;   "DO A(P)B(1)**2+A(P-1)B(1)+A(P-2)
          MOV N,N;              "IS ELEMENT COUNT = 0?
                        "TEST IF HAVE RUN THROUGH ENTIRE
          BNE LOOP1     "  POLY WITH THIS BLOCK OF 5 B'S
"COMING OUT OF COMPLETED POLY:
        DEC N;
          BEQ DONE              "EXIT IF COUNT = 0
        DEC N; BEQ ELSE + 2     "TEST IF CASE 1
        DEC N; BEQ ELSE + 1     "TEST IF CASE 2
        DEC N; BEQ ELSE         "TEST IF CASE 3
        FADD FM,NC; "DO A(P)B(2)**P+A(P-1)B(2)**(P-1)+..+A(0)
          ADD K,C; SETMA; MI<FA; "ANSWER IN C(0)
          FMUL; BEQ ELSE        "TEST IF CASE 4
        FADD FM,NC; "DO A(P)B(3)**P+A(P-1)B(3)**(P-1)+..+A(0)
          ADD K,C; SETMA; MI<FA; "ANSWER IN C(1)
          FMUL
        FADD FM,NC; "DO A(P)B(4)**P+A(P-1)B(4)**(P-1)+..+A(0)
          ADD K,C; SETMA; MI<FA "ANSWER IN C(2)
        ADD K,C; SETMA; MI<FA;  "ANSWER IN C(3)
          FADD
        ADD K,C; SETMA; MI<FA   "ANSWER IN C(4)
        DEC N
                                "TEST IF THERE ARE MORE
        BEQ DONE                " B'S TO DO
"IF SO,
"DO NEXT BLOCK OF B'S, WHERE B(5) REPLACES B(0),
"B(6) REPLACES B(1), ETC., AND C(5) REPLACES C(0), ETC.
        JMP LOOP2
ELSE:   ADD K,C; SETMA; MI<FA;
          FADD FM,NC
        ADD K,C; SETMA; MI<FA;
          FADD
        ADD K,C; SETMA; MI<FA
DONE:   RETURN
        $END
"****** DEQ22 = DIFFERENCE EQUATION, 2-POLES, 2 ZEROS /COMMO= REL 3.0, NOV 78 **
"  FOR EITHER MEMORY
"
        $TITLE DEQ22
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY DEQ22,6                          "USER-DIRECTED-CALL ENTRY
"
"
"                               --- ABSTRACT ---
"DOES A 2 POLE, 2 ZERO RECURSIVE (IIR - INFINITE IMPULSE RESPONSE)
"DIGITAL FILTERING OPERATION ON A VECTOR.
"
"
"                               --- STATISTICS ---
"EQUIPMENT:                     AP-120B WITH EITHER MEMORY
"SIZE:                          25 LOCATIONS
"SPEED:                         0.833 US/POINT
"
"    --- HISTORY ---
"ORIGINAL:  SEP 76  A.E. CHARLESWORTH
" REVISED:  MAY 77  R.S. NORIN     ADDS 5TH COEFF TO B WHICH MULTIPLIES A(I)
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"TAB-STOPS FOR EDITING:  9 25 41 57
"
"                               --- SCRATCH ---
"S-PAD: 0,3,5
"DPX:   -1 THROUGH 3
"DPY:   0 THROUGH 2 (REL TO DPA)
"FA,FM,MD
"
"
"                               --- USAGE ---
"DOES THE EQUATION:
"
"C(M) = B(0)*A(M) + B(1)*A(M-1) + B(2)*A(M-2) - B(3)*C(M-1) - B(4)*C(M-2)
"   FROM M=0 THROUGH N-1
"
"THE INITIAL CONDITIONS:
"   A(-1), A(-2), C(-1), C(-2)
"ARE OBTAINED FROM THE TWO ELEMENTS IN FRONT OF THE SPECIFIED
"  INITIAL ELEMENTS OF A AND C
"
"S-PAD PARAMETERS:
"       NAME   NUMBER            PURPOSE
        A $EQU 0                "BASE ADDRESS OF A (LOCATION OF A(0))
        I $EQU 1                "INCREMENT BETWEEN ELEMENTS OF A
        B $EQU 2                "BASE ADDRESS OF THE 5 COEFFICIENTS (ADDRESS OF
        C $EQU 3                "BASE ADDRESS OF DESTINATION VECTOR (ADDRESS OF
        K $EQU 4                "INCREMENT BETWEEN ELEMENTS OF C
        N $EQU 5                "NUMBER OF ELEMENTS IN THE VECTORS
"
"
"DATA PAD NAMES:
"DPX:
       B0 $EQU -1       "B(0)
        B1 $EQU 0       "B(1)
        B2 $EQU 1       "B(2)
        B3 $EQU 2       "B(3)
        B4 $EQU 3       "B(4)
"DPY:
        AM1 $EQU 0      "A(I-1)
        AM2 $EQU 1      "A(I-2)
        CM2 $EQU 2      "C(I-2) AND C(M-1)
"
"FETCH WEIGHTS (THE B'S) AND INITIAL CONDITIONS:
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FDEQ22,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  62
        $PARAM  6 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3(5)/R/IP,
                    P4(#5,#6)/R/OP, P5/I/IP,
                    P6/I/IP
FDEQ22: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
DEQ22:   LDSPNL 16; RDPA        "REMEMBER DPA
        MOV B,B; SETMA;         "FETCH B(0)
             DECDPA     "BACK UP DPA
        LDSPI 17; DB=5          "SET LOOP COUNTER TO 5 TIMES
"LOOP TO FETCH THE B'S
BLP:    DEC 17; INCMA           "COUNT & FETCH NEXT B
        DPX<MD; INCDPA;         "STORE THE B VALUE & INCREMENT D.P. POINTER
           BNE BLP              "AND LOOP BACK IF NOT DONE
"
"NOW FETCH A-1), A(-2), C(-1), AND C(-2)
        SUB I,A; SETMA          "FETCH A(-1)
        MOV 16,16; SETDPA       "RESTORE DPA
        SUB# I,A; SETMA         "FETCH A(-2)
        DPY(AM1)<MD;            "SAVE A(-1)
           SUB K,C      "POINT AT C(-1)
        SUB K,C; SETMA          "FETCH C(-2)
"
"HERE STARTS THE FIRST PASS THROUGH THE LOOP FOR C(0)
        FMUL DPX(B2),MD                 "2. B(2)*A(-2)
        FMUL;                           "3. PUSH
           ADD K,C; SETMA                               "FETCH C(-1)
        FMUL DPX(B1),DPY(AM1);          "4. B(1)*A(-1)
        DPY(AM2)<DPY(AM1)
        ADD I,A; SETMA;                 "5. FETCH A(0)
        FADD FM,ZERO;                   "SAVE B(2)*A(-2)
        FMUL; DPY(CM2)<MD               "PUSH AND SAVE C(-2)
"
"
"HERE STARTS THE SECOND PASS THROUGH THE LOOP FOR C(0)
        MOV N,N;                "IS ELEMENT COUNT = 0?
                        FMUL DPX(B4),DPY(CM2);          "1. B(4)*C(-2)
                        FADD
        ADD I,A; SETMA;                                 "2. FETCH A(1)
        BEQ DONE;               "EXIT IF COUNT = 0
        FMUL DPX(B2),DPY(AM2);                           "B(2)*A(-1)
                        FADD FM,FA;                     "START SUM FOR C(0)
                        DPY(CM2)<MD                     "SAVE C(-1)
                        FMUL DPX(B0),MD;                "3. B(0)*A(0)
                        FADD DPY(CM2),ZERO;              "SAVE C(-1)
                        DPY(AM1)<MD                     "SAVE A(0)
        FMUL DPX(B1),DPY(AM1);                          "4. B(1)*A(-1)
        DPY(AM2)<DPY(AM1);
                        FSUBR FM,FA                     "2ND SUM FOR C(0)
        FADD FM,ZERO;                                   "5. SAVE B(2)*A(-1)
                        FMUL DPX(B3),FA;                "   B(3)*C(-1)
                        DPY(CM2)<FA                     "SAVE C(-1)
"
"AND NOW INTO THE LOOP, WHERE C(0) GETS FINISHED AND SUCEEDING POINTS
"  GET COMPUTED
"
LOOP:                   FMUL DPX(B4),DPY(CM2);          "1. B(4)*C(M+1-2)
                                        FADD FM,FA      "3RD SUM FOR C(M)
        ADD I,A; SETMA;                                 "2. FETCH C(M+2)
        FMUL DPX(B2),DPY(AM2);                           "B(2)*A(M+2-2)
                        FADD FM,FA                      "START SUM FOR C(M+1)
                        FMUL DPX(B0),MD;                "3. B(0)*A(M+1)
                        DPY(AM1)<MD;                    "SAVE A(M+1)
                                        FSUBR FM,FA     "LAST SUM FOR C(M)
        FMUL DPX(B1),DPY(AM1);                          "4. B(1)*A(M+2-1)
        DPY(AM2)<DPY(AM1);
                        FSUBR FM,FA;                    "2ND SUM FOR C(M+1)
                                        DEC N           "DECREMENT LOOP COUNT
        FADD FM,ZERO;                                   "5. SAVE B(2)*A(M+2-2)
                        FMUL DPX(B3),FA;                "   B(3)*C(M+1-1)
                        DPY(CM2)<FA;
                                        MI<FA; ADD K,C; SETMA; "STORE C(M)
                                        BNE LOOP        "BRANCH BACK FOR MORE
"
"DONE WITH THE LOOP, RETURN
DONE:   RETURN                  "EXIT
        $END
"****** VSUM = RUNNING SUM INTEGRATION /COMMON/ = REL 3.2, AUG 80 *****
"  FOR EITHER MEMORY
        $TITLE VSUM
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSUM,6                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"APPROXIMATES THE INTEGRATION OF A VECTOR BY ASSIGNING AS AN
"ELEMENT VALUE IN THE DESTINATION VECTOR THE SUM OF THE
"CORRESPONDING ELEMENT AND ALL PREVIOUS ELEMENTS IN THE SOURCE
"VECTOR MULTIPLIED BY THE INTEGRATION STEP SIZE.  WITH A STEP
"SIZE OF 1.0 THE INTEGRATION SIMPLY PRODUCES A RUNNING SUM OF
"ELEMENTS OF THE SOURCE VECTOR.
"
"FORMULA:   C(MK)=SUM H*A(LI) FROM L=0 TO M, FOR M=0,1,...,N-1
"
"ACCURACY: ERROR IS PROPORTIONAL TO H*D WHERE D=MAX(A)
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120B WITH EITHER MEMORY
"SIZE:  13 LOCATIONS
"SPEED: INTRO: 8-9 CYCLES
"       LOOP:  4-6 CYCLES
"       COLUMNS/LOOP: 3
"       FLOPS/LOOP:  2
"       (0.67-1.0)N + (1.33-1.50) USEC FOR 167 NSEC CLOCK
"       MEGAFLOPS: 2.0-3.0
"SUBROUTINES USED: NONE
"
"    --- HISTORY ---
"ORIGINAL:  NOV 76  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80  R. GELLER      CORRECT ADC LINKAGE
"
"       ---USEAGE---
"FORTRAN: CALL VSUM(A,I,C,K,N,H)
"APAL:    JSR VSUM
"S-PAD PARAMETERS
"  NAME        NUMBER
    A   $EQU    0               "BASE ADDRESS OF SOURCE VECTOR A
    I   $EQU    1               "INCREMENT BETWEEN ELEMENTS OF A
    C   $EQU    2               "BASE ADDRESS OF DESTINATION VECTOR C
    K   $EQU    3               "INCREMENT BETWEEN ELEMENTS OF C
    N   $EQU    4               "NUMBER OF ELEMENTS IN C
    H   $EQU    5               "ADDRESS OF INTEGRATION STEP SIZE H
"
"RESTRICTIONS: RESULTS WILL BE CORRECT WHEN C=A AND I=K, BUT IF A AND C
"                OVERLAP AND A<C-2 THEN RESULTS WILL BE INCORRECT.
"FOR VECTORS WHERE THE ELEMENTS ARE CONTIGUOUS, THE INCREMENTS SHOULD BE 1.
"
"       ---SCRATCH---
"SP (0,2,4)
"DPX   0   (RELATIVE TO DPA)
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSUM,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  6 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP,P6/R/IP
FVSUM: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSUM: MOV H,H;SETMA           "FETCH H
        MOV A,A;SETMA           "FETCH A(0)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        SUB K,C;                "TO OFFSET PROPERLY IN LOOP
        DPX<MD;                 "PUT H INTO DATA PAD X
          BEQ DONE              "EXIT IF COUNT = 0
PREP2:  FMUL DPX,MD             "H*A(0)
        ADD I,A;SETMA;          "FETCH A(I)
            FMUL                "PUSHER
        FMUL                    "ANOTHER PUSHER
        FADD FM,ZERO            "H*A(0)+0
LOOP:   FMUL DPX,MD;            "1, H*A((M+1)I)
            FADD                "0, PUSH MTH SUM
        ADD I,A;SETMA;          "2, FETCH A((M+2)I)
            FMUL                "1, PUSH (M+1)TH PRODUCT
        FMUL;                   "1, PUSH (M+1)TH PRODUCT
            DEC N               "0, DECREMENT ELEMENT COUNT
        FADD FM,FA;             "1, FORM (M+1)TH SUM
            ADD K,C;SETMA;MI<FA; "0, STORE MTH SUM
            BNE LOOP            "0, CONTINUE LOOP UNTIL
DONE:   RETURN                  "DONE. THEN EXIT.
$END
"****** VTRAPZ = TRAPEZOIDAL INTEGRATION /COMMON/ = REL 3.1, SEP 79 *****
"   FOR EITHER MEMORY
        $TITLE VTRAPZ
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VTRAPZ,6                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"INTEGRATES A VECTOR BY USING THE TRAPEZOIDAL RULE.
"FORMULA:   C(0)=0.0
"           C(MK)=SUM(A((L-1)I) + A(LI))*H/2 FROM L=1 TO M,
"                      FOR M=1,2,...,N-1
"
"ACCURACY: ERROR IS PROPORTIONAL TO H*H*D WHERE D IS MAX OF
"               SECOND DERIVATIVE OF A
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120B WITH EITHER MEMORY
"SIZE:  16 LOCATIONS
"SPEED: INTRO: 11-14 CYCLES
"       LOOP:   4-6  CYCLES
"       COLUMNS/LOOP: 3
"       FLOPS/LOOP:   3
"       (0.67-1.0)N + (1.83-2.33) USEC FOR 167 NSEC CLOCK
"       MEGAFLOPS: 3.0-4.5
"SUBROUTINES USED: NONE
"
"    --- HISTORY ---
"ORIGINAL:  NOV 76  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USEAGE---
"FORTRAN: CALL VTRAPZ(A,I,C,K,N,H)
"APAL:    JSR VTRAPZ
"S-PAD PARAMETERS
"  NAME        NUMBER
    A   $EQU    0                "BASE ADDRESS OF SOURCE VECTOR A
    I   $EQU    1                "INCREMENT BETWEEN ELEMENTS OF A
    C   $EQU    2                "BASE ADDRESS OF DESTINATION VECTOR C
    K   $EQU    3                "INCREMENT BETWEEN ELEMENTS OF C
    N   $EQU    4                "NUMBER OF ELEMENTS IN C
    H   $EQU    5                "ADDRESS OF INTEGRATION STEP SIZE H
"TABLE MEMORY:
HALF    $EQU  !HALF
"
"RESTRICTIONS: RESULTS WILL BE CORRECT FOR IN PLACE INTEGRATION.
"
"SCRATCH: SP(0,2,4), DPX(0), DPY(0-1), DPA UNCHANGED
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVTRAP,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  6 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP, P6/R/IP
FVTRAP: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VTRAPZ: MOV H,H; SETMA          "FETCH STEP SIZE H
        LDTMA; DB=HALF          "GET 0.5 FROM TABLE MEMORY
        MOV A,A; SETMA          "FETCH A(0)
        FMUL TM,MD;              "FORM H/2
        MOV N,N;                "IS ELEMENT COUNT = 0?
            DPY(1)<ZERO         "INITIALIZE LAST RESULT VALUE
        ADD I,A; SETMA;         "FETCH A(I)
            FMUL;               "PUSHER
          BEQ DONE              "EXIT IF COUNT = 0
        DPY<MD;                 "INITIALIZE LAST SOURCE ELEMENT, A(0)
            FMUL;               "PUSHER
            DEC N               "DECREMENT COUNT FOR C(0)
        MOV C,C; SETMA; MI<ZERO; "SET C(0)=0
            DPX<FM;             "SAVE H/2 IN DATA PAD X
            BEQ DONE            "EXIT IF N=1
PREP2:  FADD DPY,MD;            "A(I)+A(0)
            DPY<MD              "SAVE A(I) IN DATA PAD Y
        ADD I,A; SETMA;         "FETCH A(2I)
            FADD                "PUSHER
        FMUL DPX,FA             "(A(I)+A(0))*H/2
        FMUL                    "PUSHER
LOOP:   FADD DPY,MD;            "1, A((M+1)I+A(MI)
            DPY<MD;             "1, SAVE A((M+1)I)
            FMUL                "0, PUSH MTH PRODUCT
        ADD I,A; SETMA;         "2, FETCH A((M+2)I)
            FADD FM,DPY(1)      "0, FORM C(MK) AND
                                "1, PUSH (M+1)TH SUM OF A'S
        FMUL DPX,FA;            "1, (A((M+1)I)+A(MI))*H/2
            FADD;               "0, PUSH C(MK)
            DEC N               "0, DECREMENT COUNT
        ADD K,C; SETMA; MI<FA;  "0, STORE C(MK)
            DPY(1)<FA;          "0, SAVE LAST RESULT ON DATA PAD Y
            FMUL;               "1, PUSH (M+1)TH PRODUCT
            BNE LOOP            "0, CONTINUE LOOP UNTIL
DONE:   RETURN                  "DONE. THEN EXIT
        $END
"****** VSIMPS = SIMPSON INTEGRATION /COMMON/ = REL 3.1, SEP 79 *****
"        FOR EITHER MEMORY
        $TITLE VSIMPS
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSIMPS,6                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"INTEGRATES A VECTOR BY USING SIMPSON'S 1/3 RULE.
"
"FORMULA: C(0)=0.0
"         C(K)=(A(0)+A(I))*H/2  (USE TRAPEZOIDAL RULE TO GET STARTED)
"         C(MK)=C((M-2)K)+(A((M-2)I)+4*A((M-1)I)+A(MI))*H/3
"                               FOR M=2,3,....,N-1
"
"ACCURACY:  ERROR IS PROPORTIONAL TO (H**4)*D FOR M EVEN
"                                    (H**4)*D+(H**2)*E FOR M ODD
"                   WHERE D=MAX OF FOURTH DERIVATIVE OF A
"                    AND  E=MAX OF SECOND DERIVATIVE OF A OVER THE INTERVAL (0,I
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 26. LOCATIONS
"SPEED: INTRO: 20-25 CYCLES
"       LOOP:   4-6  CYCLES
"       COLUMNS/LOOP: 4
"       FLOPS/LOOP: 5
"       (0.67-1.0)N + (3.33-4.17) USEC, FOR 167 NSEC CLOCK
"       MEGAFLOPS: 5.0-7.5
"SUBROUTINES USED: NONE
"
"    --- HISTORY ---
"ORIGINAL:  NOV 76  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN: CALL VSIMPS(A,I,C,K,N,H)
"APAL:    JSR VSIMPS
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                  "BASE ADDRESS OF SOURCE VECTOR A
     I  $EQU  1                  "INCREMENT BETWEEN ELEMENTS OF A
     C  $EQU  2                  "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  3                  "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  4                  "NUMBER OF ELEMENTS IN C
     H  $EQU  5                  "ADDRESS OF INTEGRATION STEP SIZE H
"
"RESTRICTIONS: N>0
"       RESULTS WILL BE CORRECT FOR IN PLACE INTEGRATION
"
"       ---SCRATCH---
" SP(0,2,4), DPX(0-31),DPY(0-31), DPA IS CHANGED!!!
"
"TABLE MEMORY
 HALF  $EQU  !HALF
 THIRD $EQU  !THIRD
 FOUR  $EQU  !FOUR
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSIMP,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  6 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP, P6/R/IP
FVSIMP: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSIMPS: MOV H,H; SETMA          "FETCH H
        LDTMA; DB=HALF          "FETCH 1/2 FROM TABLE MEMORY
        MOV A,A; SETMA          "FETCH A(0)
        FMUL TM,MD;             "FORM H/2 FOR SECOND POINT
        MOV N,N;                "IS ELEMENT COUNT = 0?
            DPY(2)<MD           "TEMPORARILY SAVE H
        ADD I,A; SETMA;         "FETCH A(I)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        LDTMA; DB=THIRD         "FETCH 1/3 FROM TABLE MEMORY
        DPX(0)<MD;INCDPA        "SAVE A(0)
        FADD DPX(-1),MD;        "A(0)+A(I)
            DPX(0)<MD;          "SAVE A(I)
            FMUL TM,DPY(1);     "FORM H/3 FOR ALL OTHER POINTS
            ADD I,A;SETMA      "FETCH A(2I)
        FADD; FMUL;             "PUSHERS
            DEC N               "DECREMENT COUNT
        LDTMA; DB=FOUR          "FETCH 4.0 FROM TABLE MEMORY
        FMUL FM,FA;             "FORM C(K)=(A(0)+A(I))*H/2 (TRAPEZOIDAL RULE)
            MOV C,C; SETMA; MI<ZERO;"STORE C(0)=0.0
            DPY(2)<ZERO;        "SAVE C(0)
            INCDPA;             "BUMP DATA PAD ADDRESS
                BEQ DONE        "EXIT IF N=1
PREP3:  FMUL TM,DPX(-1);        "4*A(I)
            ADD I,A; SETMA;     "FETCH A(3I)
            DPX(3)<FM           "SAVE H/3
        FMUL;                   "PUSHER
            DEC N;              "DECREMENT COUNT
            DPX(0)<MD           "SAVE A(2I)
        ADD K,C; SETMA; MI<FM;  "STORE C(K)
            DPY(2)<FM;          "SAVE C(K)
            FMUL;               "PUSHER
            INCDPA;             "BUMP DATA PAD ADDRESS
            BEQ DONE            "EXIT IF N=2
PREP2:  FMUL TM,DPX(-1);        "4*A(2I)
            FADD FM,DPX(-1);    "4*A(I)+A(2I)
            DPX(0)<MD           "SAVE A(3I)
        ADD I,A; SETMA;         "FETCH A(4I)
            DPX(3)<DPX(2);      "SAVE H/3
            FADD; FMUL          "PUSHERS
        FADD DPX(-3),FA;        "A(0)+4*A(I)+A(2I)
            FMUL; INCDPA        "PUSH AND BUMP DATA PAD ADDRESS
PREP1:  FMUL TM,DPX(-1);        "4*A(3I)
            FADD FM,DPX(-1)     "4*A(2I)+A(3I)
        ADD I,A; SETMA;         "FETCH A(5I)
            FMUL DPX(2),FA;     "(A(0)+4*A(I)+A(2I))*H/3
            FADD; DPX(0)<MD     "PUSHER, SAVE A(4I)
        FADD DPX(-3),FA;        "A(I)+4*A(2I)+A(3I)
            FMUL;INCDPA         "PUSH AND BUMP DATA PAD ADDRESS
LOOP:   FMUL TM,DPX(-1);        "3, 4*A((M+2)I)
            FADD FM,DPX(-1)    "2, 4*A((M+1)I)+A((M+2)I)
        ADD I,A; SETMA;         "3, FETCH A((M+4)I)
            DPX(0)<MD;          "2, SAVE A((M+3)I
            FMUL DPX(1),FA;     "1, (A((M-1)I)+4*A(MI)+A((M+1)I))*H/3
            FADD FM,DPY(-2)     "0, FORM C(MK)
        FMUL;                   "3, PUSHER
            FADD DPX(-3),FA;    "2, A(MI)+4*A((M+1)I)+A((M+2)I)
            DEC N               "0, DECREMENT OPERATION COUNT
        INCDPA;                 "3, INCREMENT DATA PAD ADDRESS
            DPX(2)<DPX(1);      "2, SAVE H/3
            ADD K,C; SETMA; MI<FA; "0, STORE C(MK)
            DPY(0)<FA;          "0, SAVE C(MK)
            BNE LOOP            "0, CONTINUE LOOPING UNTIL
DONE:   RETURN                  "DONE, THEN EXIT
        $END
"****** SETC5 = SET CONTROL BIT 5 INTERRUPT /COMMON/ = REL 3.0  , NOV 78 *****
        $TITLE SETC5
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY SETC5,0                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"ATTEMPTS TO GENERATE A HOST-CPU INTERRUPT BY TRYING TO WRITE TO CONTROL
"REGISTER BIT 05.  THE SPECIFIC OPERATION OF INTERRUPT GENERATION DEPENDS
"ON THE PARTICULAR HOST-CPU AND HOST-INTERFACE EMPLOYED.
"HOST-CPU MUST HAVE PREVIOUSLY SET CTL05 TO 1 IF AN INTERRUPT IS TO OCCUR.
"
"FORMULA: N/A
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 1
"
"EXECUTION      BEST     TYPICAL     WORST       SETUP(US)
"TIME/LOOP:     0.17       0.17       0.17        N/A         167 NS MEMORY
" (US)          0.17       0.17       0.17        N/A         333 NS MEMORY
"
"
"     --- HISTORY ---
"ORIGINAL:  DEC 77  R.S. NORIN
"
"
"       ---USAGE---
"FORTRAN: CALL SETC5
"APAL:    JSR SETC5
"S-PAD PARAMETERS
"   NAME     NUMBER
"
"SCRATCH:  NONE
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FSETC5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  0
FSETC5: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SETC5:  INTEN; RETURN           "ATTEMPT TO SET CTL05
        $END
"****** RDC5 = READ CONTROL BIT 5 INTERRUPT /COMMON/ = REL 3.0  , NOV 78 *****
        $TITLE RDC5
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY RDC5,1                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"READS CONTROL REGISTER BIT 05 (IHENB), THE HOST INTERRUPT ENABLE BIT,
"AND PUTS IT INTO SP(15) AND MAIN DATA ADDRESS C (IN LOW MANTISSA).
"
"FORMULA: SP(15) AND C(0) = CTL05 BIT
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 8
"
"EXECUTION      BEST     TYPICAL     WORST       SETUP(US)
"TIME/LOOP:     1.33       1.33       1.33        N/A         167 NS MEMORY
" (US)          1.33       1.33       1.33        N/A         333 NS MEMORY
"
"
"     --- HISTORY ---
"ORIGINAL:  DEC 77  R.S. NORIN
"
"
"       ---USAGE---
"FORTRAN: CALL RDC5(C)
"APAL:    JSR RDC5
"S-PAD PARAMETERS
"   NAME     NUMBER
     C  $EQU    0                            "DESTINATION ADDRESS FOR STATUS
"
"SCRATCH:  SP(14,15),DPX(0),DA
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FRDC5,1                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  0
        $PARAM  1 , P1/I/OP
FRDC5: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
RDC5:   LDDA; DB=2              "SET DA TO CONTROL REGISTER
        IN; DPX<INBS            "READ CONTROL REGISTER
        LDSPI 17; DB=DPX        "PUT REG INTO SPAD
        LDSPI 16; DB=2000       "MASK FOR CTL05
        AND 16,17               "ISOLATE BIT 5
        BEQ DONE                "NOT SET
        LDSPI 17; DB=1          "SET, SO PUT 1 INTO SPAD
DONE:   DPX<SPFN; MOV 17,17     "GET FLAG ONTO DPBS
        MOV C,C; SETMA; MI<DPX; RETURN "SET STATUS INTO C AND EXIT
        $END
"****** DAREAD = READ DEVICE ADDRESS REGISTER /COMMON/ = REL 3.3, AUG 80 *****
        $TITLE DAREAD
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY DAREAD,1                          "USER-DIRECTED-CALL ENTRY
"
"     ---ABSTRACT---
"READS THE CONTENTS OF SPECIFIED DEVICE ADDRESS REGISTER INTO SP(15).
"
"DEVICE ADDRESS REGISTER ASSIGNMENTS:
"   NUMBER        CONTENTS
"     0       AP120B  WORD COUNTER
"     1         '     HOST MEMORY ADDRESS
"     2         '     CONTROL REGISTER
"     3         '     AP MEMORY ADDRESS
"     4         '     FORMAT
"     5         '     TMRAM
"    10        IOP    WORD COUNTER
"    11         '     EXTERNAL MEMORY ADDRESS
"    12         '     CONTROL REGISTER
"    13         '     AP MEMORY ADDRESS
"    14         '     FORMAT
"    30       PAGE SELECT  - MAE
"    31         '    '     - APMAE
"    32         '    '     - MASK, M, I/O
"    33      PARITY  - MDLMAN
"    34         '    - MDHMAN
"    35         '    - MDEXP
"    36         '    - PEAD
"    37         '    - MDCA
"   100       PIOP
"   101         '
"   110         '    FLAG 7
"   111         '      '  6
"   112         '      '  5
"   113         '      '  4
"   114         '      '  3
"   115         '      '  2
"   116         '      '  1
"   117         '      '  0
"
"FORMULA:  SP(15) = DEVICE REGISTER (DA)
"
"     ---HISTORY---
"ORIGINAL:  DEC 77  R.S. NORIN
"
"REVISED:  APR 79 W.H.INSKEEP--THE ADDRESS IS ALSO STORED IN MD(VAL).
" REV 3.2 AND 2A.2: MAR 80  R.S. NORIN   FUNCTIONALITY RETURNED TO THAT
"                                        PRIOR TO APR 79 REVISION.  I.E.,
"                                        DA CONTENTS RETURNED ONLY
"                                        IN SP(15).
"                                        THE ROUTINE XDAREA PRESERVES THE
"                                        APR 79- FEB 80 FUNCTIONALITY. I.E.,
"                                        WHERE THE DA CONTENTS ALSO
"                                        STORED INTO MD.
" REV 3.3:  AUG 80   R. GELLER                    CORRECT ADC LINKAGE
"
"
"     ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT:  AP120B WITH EITHER MEMORY
"SIZE:       2
"EXECUTION     BEST    TYPICAL     WORST     SETUP(US)
"TIME:         0.33     0.33       0.33        N/A
" (US)         0.33     0.33       0.33        N/A
"
"     ---USAGE---
"FORTRAN CALL:  CALL DAREAD(DA)
"APAL CALL:     JSR DAREAD
"SCRATCH:       DA
"
"ENTER WITH FOLLOWING S-PAD PARAMETERS:
"  NAME      NUMBER
    DA  $EQU   0                "DEVICE ADDRESS
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FDARED,1                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  1
        $PARAM  1 , P1/I/IP
FDARED: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
DAREAD: LDDA; DB=SPFN; MOV DA,DA "SET DA TO DESIRED REGISTER
        IN; DB=INBS; LDSPI 17;  "PUT REGISTER CONTENTS INTO SP(15)
         RETURN                 "EXIT
        $END
"****** XDAREA = READ DEVICE ADDRESS REGISTER /COMMON/ = REL 3.1, AUG 80 ***
        $TITLE XDAREA
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY XDAREA,2                          "USER-DIRECTED-CALL ENTRY
"
"     ---ABSTRACT---
"READS THE CONTENTS OF SPECIFIED DEVICE ADDRESS REGISTER INTO SP(15).
"
"DEVICE ADDRESS REGISTER ASSIGNMENTS:
"   NUMBER        CONTENTS
"     0       AP120B  WORD COUNTER
"     1         '     HOST MEMORY ADDRESS
"     2         '     CONTROL REGISTER
"     3         '     AP MEMORY ADDRESS
"     4         '     FORMAT
"     5         '     TMRAM
"    10        IOP    WORD COUNTER
"    11         '     EXTERNAL MEMORY ADDRESS
"    12         '     CONTROL REGISTER
"    13         '     AP MEMORY ADDRESS
"    14         '     FORMAT
"    30       PAGE SELECT  - MAE
"    31         '    '     - APMAE
"    32         '    '     - MASK, M, I/O
"    33      PARITY  - MDLMAN
"    34         '    - MDHMAN
"    35         '    - MDEXP
"    36         '    - PEAD
"    37         '    - MDCA
"   100       PIOP
"   101         '
"   110         '    FLAG 7
"   111         '      '  6
"   112         '      '  5
"   113         '      '  4
"   114         '      '  3
"   115         '      '  2
"   116         '      '  1
"   117         '      '  0
"
"FORMULA:  SP(15) = DEVICE REGISTER (DA)
"
"     ---HISTORY---
"ORIGINAL:  DEC 77  R.S. NORIN
"
"REVISED:  APR 79 W.H.INSKEEP--THE ADDRESS IS ALSO STORED IN MD(VAL).
"
"    --- HISTORY ---
"ORIGINAL:  MAR 80  R.S. NORIN    THIS ROUTINE ADDED TO PRESERVE THE
"                                 FUNCTIONALITY OF THE ROUTINE DAREAD
"                                 DURING THE APR 79 - FEB 80 PERIOD.
"                                 DEVICE ADDRESS CONTENTS STORED AS INTEGER
"                                 IN MD ADDR VAL.
"REV 3.1:  AUG 80   R. GELLER     CORRECT ADC LINKAGE
"
"     ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT:  AP120B WITH EITHER MEMORY
"SIZE:       3
"EXECUTION     BEST    TYPICAL     WORST     SETUP(US)
"TIME:         0.50     0.50       0.50        N/A
" (US)         0.50     0.50       0.50        N/A
"
"     ---USAGE---
"FORTRAN CALL:  CALL XDAREA(DA,VAL)
"APAL CALL:     JSR XDAREA
"SCRATCH:       DA
"               DPX(DPA)
"
"ENTER WITH FOLLOWING S-PAD PARAMETERS:
"  NAME      NUMBER
    DA  $EQU   0                "DEVICE ADDRESS
   VAL  $EQU   1                "MD ADDRESS TO STORE DA
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FXDARE,2                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  1
        $PARAM  2, P1/I/IP, P2/I/OP
FXDARE: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
XDAREA: LDDA; DB=SPFN; MOV DA,DA "SET DA TO DESIRED REGISTER
        IN; DB=INBS; LDSPI 17;  "PUT REGISTER CONTENTS INTO SP(15)
          DPX<DB
        MOV VAL,VAL; SETMA; MI<DPX;  "STORE REGISTER IN MD(VAL)
         RETURN                 "EXIT
        $END
"****** DAWRIT = WRITE DEVICE ADDRESS REGISTER /COMMON/ = REL 3.1  , AUG 80 ****
        $TITLE DAWRIT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY DAWRIT,2                          "USER-DIRECTED-CALL ENTRY
"
"     ---ABSTRACT---
"WRITE THE INTEGER VAL INTO DEVICE REGISTER DA.
"
"DEVICE ADDRESS REGISTER ASSIGNMENTS:
"   NUMBER        CONTENTS
"     0       AP120B  WORD COUNTER
"     1         '     HOST MEMORY ADDRESS
"     2         '     CONTROL REGISTER
"     3         '     AP MEMORY ADDRESS
"     4         '     FORMAT
"     5         '     TMRAM
"    10        IOP    WORD COUNTER
"    11         '     EXTERNAL MEMORY ADDRESS
"    12         '     CONTROL REGISTER
"    13         '     AP MEMORY ADDRESS
"    14         '     FORMAT
"    30       PAGE SELECT  - MAE
"    31         '    '     - APMAE
"    32         '    '     - MASK, M, I/O
"    33      PARITY  - MDLMAN
"    34         '    - MDHMAN
"    35         '    - MDEXP
"    36         '    - PEAD
"    37         '    - MDCA
"   100       PIOP
"   101         '
"   110         '    FLAG 7
"   111         '      '  6
"   112         '      '  5
"   113         '      '  4
"   114         '      '  3
"   115         '      '  2
"   116         '      '  1
"   117         '      '  0
"
"FORMULA:  DEVICE REGISTER (DA) = VAL
"
"     ---HISTORY---
"ORIGINAL:  DEC 77  R.S. NORIN
" REV 3.1:  AUG 80  R. GELLER           CORRECT ADC LINKAGE
"
"     ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT:  AP120B WITH EITHER MEMORY
"SIZE:       2
"EXECUTION     BEST    TYPICAL     WORST     SETUP(US)
"TIME:         0.33     0.33       0.33        N/A
" (US)         0.33     0.33       0.33        N/A
"
"     ---USAGE---
"FORTRAN CALL:  CALL DAWRIT(DA,VAL)
"APAL CALL:     JSR DAWRIT
"SCRATCH:       DA
"
"ENTER WITH FOLLOWING S-PAD PARAMETERS:
"  NAME      NUMBER
    DA  $EQU   0                "DEVICE ADDRESS
    VAL $EQU   1                "VALUE TO WRITE TO REGISTER
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FDAWRT,2                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  3
        $PARAM  2 , P1/I/IP, P2/I/IP
FDAWRT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
DAWRIT: LDDA; DB=SPFN; MOV DA,DA "SET DA TO DESIRED REGISTER
        OUT; DB=SPFN; MOV VAL,VAL; "WRITE TO REGISTER
         RETURN                 "AND EXIT
        $END
"****** MDCOM = MAIN DATA FLOATING COMPARE /COMMON/ = REL 3.0  , NOV 78 *******
"
        $TITLE MDCOM
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MDCOM,2                          "USER-DIRECTED-CALL ENTRY
"
"     --- ABSTRACT ---
"COMPARES THE FLOATING POINT NUMBERS IN MD ADDRESSES A AND B AND
"SETS SP(17) ACCORDING TO THE RESULT OF THE COMPARISON.
"
"FORMULA:  SP(17) =  1  IF A>B
"                 =  0  IF A=B
"                 = -1  IF A<B
"
"     --- STATISTICS ---
"LANGUAGE: APAL
"EQUIPMENT:  AP120B WITH EITHER MEMORY
"SIZE:       11 LOCATIONS
"EXECUTION
" TIME (US):  1.83 US (1.67 US IF A>B)
"
"     --- HISTORY ---
"ORIGINAL:  AUG 77  R.S. NORIN
"
"    --- USAGE ---
"APAL:  JSR MDCOM
"
"S-PAD PARAMETERS:
   A  $EQU   0                  "ADDRESS OF FIRST VALUE
   B  $EQU   1                  "ADDRESS OF SECOND VALUE
"
"SCRATCH:  DPX,FA,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMDCOM,2                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  0
        $PARAM  2 , P1/R/IP, P2/R/IP
FMDCOM: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MDCOM:  MOV A,A; SETMA          "GET A
        MOV B,B; SETMA          "GET B
        NOP                     "WAIT FOR MEMORY
        DPX<MD                  "SAVE A
        FSUB DPX,MD             "A-B
        FSUB DPX,MD             "A-B AGAIN
        FADD;                   "PUSH
          LDSPI 17; DB=1        "ASSUME A>B
        BFGT DONE               "BRANCH IF A>B
        LDSPI 17; DB=-1;        "ASSUME A<B
          BFNE DONE             "BRANCH IF A<B
        CLR 17; RETURN          "A=B
DONE:   RETURN                  "EXIT
        $END
$ENDLIB
 