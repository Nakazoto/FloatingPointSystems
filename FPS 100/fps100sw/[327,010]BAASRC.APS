$LIB
"****** BAASRC = BASIC MATH LIBRARY (PART 1) /FAST/ = REL 3.4, DEC 80 ******
"
"====================  CONDITIONAL ASSEMBLY SWITCHES  ==================
"
"    XADC   DETERMINES WHETHER ASSEMBLY WILL INCLUDE BOTH ADC AND UDC
"              ENTRY POINTS, OR ONLY UDC ENTRY POINTS
"           XADC $EQU 1    ASSEMBLE BOTH ADC AND UDC ENTRY POINTS (DEFAULT)
"           XADC $EQU 0    ASSEMBLE ONLY UDC ENTRY POINTS
"
"           TO CHANGE FROM THE DEFAULT (ADC AND UDC) TO UDC ONLY ASSEMBLY,
"           GLOBALLY EDIT THIS FILE TO CHANGE ALL OCCURRENCES (1 PER
"           ROUTINE) OF
"               XADC $EQU 1      TO     XADC $EQU 0
"
"======================================================================
"
"     ---HISTORY---
"REV 3.4 AND 2A.4:  DEC 80
"       1. RECT, CVEXP, AND CVMEXP FIXED TO WORK FOR CASE WHEN OUTPUT
"          ADDRESS INCREMENT IS GREATER THAN 2.
"
"REV 3.3 AND 2A.3:  AUG 80
"       1. VRVRS FIXED TO WORK FOR N=1 AND ADDRESS INCREMENTS NOT 1
"       2. (REV 3.3 ONLY) ADC LINKAGES CORRECTED FOR THE FOLLOWING ROUTINES:
"              VCLR
"              VFILL
"              VRVRS
"              DOTPR
"
"REV 3.2 AND 2A.2:  MAR 80
"       1. VRAND REWRITTEN WITH IMPROVED RANDOM NUMBER ALGORITHM.
"       2. (REV 3.2 ONLY) THE STATEMENT    $RADIX 8    HAS BEEN ADDED TO ALL
"             ROUTINES SO THAT THEY WILL ASSEMBLE PROPERLY EVEN IF FOR SOME
"             REASON THE ASSEMBLER DEFAULT RADIX HAS BEEN CHANGED TO 10 OR 16.
"       3. THE FOLLOWING ROUTINES HAVE BEEN MODIFIED TO ELIMINATE TMROM
"             SIZE DEPENDENCY IN THE SOURCE CODE.  ROUTINES NOW TEST
"             FOR TMROM SIZE ON THE FLY.  CHANGE ADDS 8 PS WORDS TO EACH
"             ROUTINE, BUT HAS NO EFFECT ON EXECUTION SPEED.
"                  RECT
"                  CVEXP
"                  CVMEXP
"                  VSIN
"                  VCOS
"       4. THE FUNCTIONALITY OF THE FOLLOWING ROUTINES IS CHANGED BACK
"          TO THAT WHICH EXISTED PRIOR TO LIBRARY RELEASES 3.1 (SEP 79)
"          OR 2.3 (MAY 79).  FOR THESE ROUTINES THE SECOND WORD IN THE
"          OUTPUT VECTOR C WILL CONTAIN THE MD ADDRESS OF THE EXTREMUM
"          VALUE AS AN INTEGER IN LOW MANTISSA, RATHER THAN THE ARRAY
"          INDEX (SUBSCRIPT) OF THE EXTREMUM AS A FLOATING-POINT VALUE.
"                  MAXV
"                  MINV
"                  MAXMGV
"                  MINMGV
"       5. THE FOLLOWING NEW ROUTINES ARE ADDED TO RETAIN THE FUNCTIONALITY
"          OF VERSIONS 3.1 (SEP 79), 2A.1 (SEP 79), AND 2.3 (MAY 79) OF THE
"          ROUTINES MAXV, MINV, MAXMGV, AND MINMGV, RESPECTIVELY.  IN THE
"          NEW ROUTINES THE SECOND WORD IN THE OUTPUT VECTOR C CONTAINS
"          THE ARRAY INDEX (SUBSCRIPT) OF THE EXTREMUM AS A FLOATING-POINT
"          VALUE.
"                  XMAXV
"                  XMINV
"                  XMAXMG
"                  XMINMG
"      6. (REV 3.2 ONLY) IN ROUTINE VSWAP, FIXED PROBLEM WITH $PARAM STATEMENT
"         FOR ADC CALL (FVSWAP).  ARRAYS A AND C ARE NOW SPECIFIED AS
"         BOTH INPUT AND OUTPUT ARRAYS.
"
"REV 3.1 AND 2A.1:  SEP 79
"       1. FIXES BUGS IN THE FOLLOWING ROUTINES:
"             CVREAL
"             VLOG
"             VLN
"             MAXV
"             MINV
"             MAXMGV
"             MINMGV
"       2. ALL ROUTINES NOW DO NOTHING WHEN THE VECTOR LENGTH IS ZERO.
"       3. THE FOLLOWING ROUTINE HAS BEEN ADDED:
"             VRVRS   --  INPLACE VECTOR REVERSE
"       4. VINDEX FIXED TO WORK PROPERLY WITH EXTENDED MEMORY.
"
"REV 2.3:  MAY 79
"       1.  FIXED BUGS IN THE FOLLOWING ROUTINES:
"               VLOG
"               VLN
"       2.  CHANGED FOLLOWING ROUTINES SUCH THAT INDEX OF EXTREMUM IS
"           PLACED IN MD AS WELL AS IN SP(15):
"               MAXV
"               MINV
"               MAXMGV
"               MINMGV
"
"REV 3.0:  NOV 78
"       1. ADDS ENTRY POINTS FOR AP FORTRAN
"       2. MINOR MOD TO VSQRT FOR APAL3 COMPATIBILITY
"REV 2.2:  SEP 78
"       1. SPLITS BASIC LIBRARY INTO 3 PARTS:
"               BAASRC --  COMPLEX VECTOR OPERATIONS
"                          BASIC VECTOR OPERATIONS
"                          VECTOR-TO-SCALAR OPERATIONS
"
"               BABSRC --  VECTOR COMPARISON OPERATIONS
"                          DATA FORMATING OPERATIONS
"                          MATRIX ROUTINES
"                          FFT ROUTINES
"                          AUXILIARY ROUTINES
"
"               UTLSRC --  APAL-CALLABLE UTILITY ROUTINES
"
"       2. ADDS THE FOLLOWING NEW ROUTINES:
"               CVEXP  --  COMPLEX VECTOR EXPONENTIAL
"               CVMEXP --  COMPLEX VECTOR MULTIPLY BY EXPONENTIAL
"               VTSADD --  VECTOR TABLE SCALAR ADD
"               VMSA   --  VECTOR MULTIPLY AND SCALAR ADD
"               VSMA   --  VECTOR SCALAR MULTIPLY AND ADD
"               VSMSB  --  VECTOR SCALAR MULTIPLY AND SUBTRACT
"
"       3. INCLUDES FASTER VERSIONS OF THE FOLLOWING ROUTINES:
"               VSIN   --   1.3 US  VS  5.4 US
"               VCOS   --   1.3 US  VS  5.7 US
"               VLOG   --   2.7 US  VS  5.7 US
"               VLN    --   2.7 US  VS  5.0 US
"               VEXP   --   2.3 US  VS  5.2 US
"               VALOG  --   2.3 US  VS  5.0 US
"               CVMA   --   1.3 US  VS  2.7 US
"               SCJMA  --   0.8 US  VS  1.3 US
"               CVCONJ --   0.7 US  VS  1.2 US
"               RECT   --   2.3 US  VS 10.7 US
"
"       4. FIXES PROBLEMS WHEN EXECUTING WITH N>32767 IN THE
"          FOLLOWING ROUTINES:
"               VCLR
"               VMOV
"               VSWAP
"               VNEG
"               VADD
"               VSUB
"               VMUL
"               VSADD
"               VSMUL
"               VSSQ
"               VABS
"               VMA
"               VMSB
"               VAM
"               VSBM
"               VSMSA
"               VMMA
"               VMMSB
"               VAAM
"               VSBSBM
"               VAND
"               VEQV
"               VOR
"               VINDEX
"               DOTPR
"               RMSQV
"               MEANV
"               MEAMGV
"               MEASQV
"
"       5. FIXES BUGS IN THE FOLLOWING ROUTINES:
"               VMOV
"               VRAND
"               MAXV
"               MINV
"               MAXMGV
"               MINMGV
"
"------NOTE: REV 2.1 AND EARLIER REFER TO THE TOTAL BASIC LIBRARY, WHICH
"            WITH REV 2.2 IS SPLIT INTO BAASRC, BABSRC, AND UTLSRC.
"
"REV 2.1:  MAR 78
"       1. FIXES BUGS IN THE FOLLOWING ROUTINES:
"           SAVSP0
"REV 2.0:  DEC 77
"        1. FIXES BUGS IN THE FOLLOWING ROUTINES:
"                  MAXV
"                  MINV
"                  MAXMGV
"                  MINMGV
"                  VPK8
"                  VUP8
"                  VUPS8
"                  VUP16
"        2. ADDS THE FOLLOWING ROUTINES:
"                  CVSMUL    COMPLEX VECTOR SCALAR MULTIPLY
"                  VSEFLT    VECTOR SIGN EXTEND AND FLOAT
"                  SOLVEQ    SIMULTANEOUS LINEAR EQUATION SOLVER
"                  RDC5      READS CONTROL BIT 5
"                  SETC5     SETS CONTROL BIT 5
"                  ZMD       ZEROS MAIN DATA MEMORY PAGES
"                  DAREAD    READ DEVICE ADDRESS REGISTER
"                  DAWRIT    WRITE DEVICE ADDRESS REGISTER
"        3. ADDS INDEX LINE FOR SET2SP.
"        4. DELETES THE FOLLOWING ROUTINES WHICH NOW COMPRISE A PART
"           OF DGNSRC, THE DIAGNOSTIC LIBRARY:
"                  SCFIFT
"                  FGRN
"                  FCHK
"
"=====================================================================
"
"****** CVADD = COMPLEX VECTOR ADD /FAST/ = REL 3.0, NOV 78 *****
"       FOR FAST MEMORY
        $TITLE CVADD
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVADD,7                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"ADDS ELEMENTS OF TWO COMPLEX VECTORS.
"
"FORMULA:  C(MK)+IC(MK+1) = (A(MI)+B(MJ))+I(A(MI+1)+B(MJ+1)) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH FAST MEMORY
"SIZE: 13 LOCATIONS
"SPEED: BEST (FAST): 6N  (A,C SAME; I,K EVEN)
"     TYPICAL (FAST): 6N
"      WORST  (FAST): 8N
"       COLUMNS/LOOP: 2
"SUBROUTINES USED: NONE
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL CVADD(A,I,B,J,C,K,N)
"APAL:    JSR CVADD
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "BASE ADDRESS OF SOURCE VECTOR
     J  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF B
     C  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  6                 "NUMBER OF COMPLEX ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4,6),DPX(0),DPY(0),FA,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVADD,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FCVADD: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVADD:  MOV A,A; SETMA          "GET A(0) REAL
        INCMA                   "GET A(1) IMAG
        MOV B,B; SETMA          "GET B(0) REAL
        INCMA;                  "GET B(1) IMAG
            DPX<MD              "SAVE A(0)
        DPY<MD;                 "SAVE A(1) IMAG
            SUB K,C             "BACK UP POINTER
        FADD DPX,MD;            "A(0)+B(0)
            MOV N,N             "TEST FOR N=0
LOOP:   ADD I,A; SETMA;         "GET A(M) REAL
            FADD DPY,MD;        "ADD IMAG PARTS
            BEQ DONE            "QUIT IF DONE
        INCMA                   "GET A(M) IMAG
        ADD J,B; SETMA          "GET B(M) REAL
        INCMA;                  "GET B(M) IMAG
            DPX<MD              "SAVE A(M) REAL
        DPY<MD;                 "SAVE A(M) IMAG
            ADD K,C; SETMA; MI<FA; "STORE REAL
            FADD                "PUSH
        FADD DPX,MD;            "ADD REALS
            INCMA; MI<FA;       "STORE IMAGS
            DEC N; BR LOOP      "DECREMENT COUNT AND GO LOOP
DONE:   RETURN                  "EXIT
        $END
"****** CVSUB = COMPLEX VECTOR SUBTRACT /FAST/ = REL 3.0, NOV 78 *****
"       FOR FAST MEMORY
        $TITLE CVSUB
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVSUB,7                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"SUBTRACTS ELEMENTS OF TWO COMPLEX VECTORS.
"
"FORMULA:  C(MK)+IC(MK+1) = (A(MI)-B(MJ))+I(A(MI+1)-B(MJ+1)) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH FAST MEMORY
"SIZE: 13 LOCATIONS
"SPEED: BEST (FAST): 6N  (A,C SAME; I,K EVEN)
"     TYPICAL (FAST): 6N
"      WORST  (FAST): 8N
"       COLUMNS/LOOP: 2
"SUBROUTINES USED: NONE
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL CVSUB(A,I,B,J,C,K,N)
"APAL:    JSR CVSUB
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "BASE ADDRESS OF SOURCE VECTOR
     J  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF B
     C  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  6                 "NUMBER OF COMPLEX ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4,6),DPX(0),DPY(0),FA,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVSUB,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FCVSUB: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVSUB:  MOV A,A; SETMA          "GET A(0) REAL
        INCMA                   "GET A(1) IMAG
        MOV B,B; SETMA          "GET B(0) REAL
        INCMA;                  "GET B(1) IMAG
            DPX<MD              "SAVE A(0)
        DPY<MD;                 "SAVE A(1) IMAG
            SUB K,C             "BACK UP POINTER
        FSUB DPX,MD;            "A(0)-B(0)
            MOV N,N             "TEST FOR N=0
LOOP:   ADD I,A; SETMA;         "GET A(M) REAL
            FSUB DPY,MD;        "SUBTRACT IMAG PARTS
            BEQ DONE            "QUIT IF DONE
        INCMA                   "GET A(M) IMAG
        ADD J,B; SETMA          "GET B(M) REAL
        INCMA;                  "GET B(M) IMAG
            DPX<MD              "SAVE A(M) REAL
        DPY<MD;                 "SAVE A(M) IMAG
            ADD K,C; SETMA; MI<FA; "STORE REAL
            FADD                "PUSH
        FSUB DPX,MD;            "SUBTRACT REALS
            INCMA; MI<FA;       "STORE IMAGS
            DEC N; BR LOOP      "DECREMENT COUNT AND GO LOOP
DONE:   RETURN                  "EXIT
        $END
"****** CVMUL = COMPLEX VECTOR MULTIPLY /FAST/ = REL 3.1, SEP 79 *****
       $TITLE CVMUL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY CVMUL, 8.                          "USER-DIRECTED-CALL ENTRY
"VECTOR COMPLEX MULTIPLY
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE:  26
"
"    --- HISTORY ---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"S-PAD PARAMETERS
       A $EQU 0                        "VECTOR A ORIGIN
       I $EQU 1    "VECTOR A INCREMENT
       B $EQU 2                        "VECTOR B ORIGIN
       J $EQU 3                        "VECTOR B INCREMENT
       C $EQU 4                        "VECTOR C ORIGIN
       K $EQU 5                        "VECTOR C INCREMENT
       N $EQU 6                        "VECTOR LENGTH
       F $EQU 7                        "FLAG FOR COMPLEX CONJUGATE
"DATA PAD PARAMETERS
       AR $EQU 0   "REAL PART OF A
       RB $EQU 0   "REAL PART OF B
       AI $EQU 1   "IMAGINARY PART OF A
       BI $EQU 1   "IMAGINARY PART OF B
       TR $EQU 2                       "STORAGE FOR REAL PART
       TI $EQU 2                       "STORAGE FOR IMAGINARY PART
"SCRATCH:
"          S-PADS:  0, 2, 4
"          DPX:  0, 1, 2.      DPY: 0, 1, 2.
"F = 1:  COMPLEX MULTIPLY
"REAL PART OF C = AR*BR - AI*BI
"IMAGINARY PART OF C = AI*BR - AR*BI
"F = - 1:  COMPLEX MULTIPLY WITH A CONJUGATE
"REAL PART OF C = AR*BR - AI*BI
"IMAGINARY PART OF C = AR*BI - AI*BR
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVMUL,8.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  352
        $PARAM  8., P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP, P8/I/IP
FCVMUL: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVMUL:         MOV A,A;SETMA           "FETCH AR(0)
               INCMA;SUB K,C           "FETCH AI(0)
               MOV B,B;SETMA           "FETCH BR(0)
               INCMA;                  "FETCH BI(0)
               DPX(AR)<MD              "SAVE AR (0)
        MOV N,N;                "IS ELEMENT COUNT = 0?
               DPX(AI)<MD              "SAVE AI(0)
               DPY(RB)<MD;             "SAVE BR(0)
               FMUL DPX(AR),MD;        "AR(0)*BR(0)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
           ADD I,A;SETMA;              "FETCH AR(1)
               FMUL DPX(AR),MD         "AR(0)*BI(0)
           INCMA;                      "FETCH AI(1)
               FMUL DPX(AI),MD;        "AI(0)*BI(0)
               MOV F,F                 "TEST FOR COMPLEX CONJUGATE
           ADD J,B; SETMA;             "FETCH BR(1)
               FMUL DPY(RB),DPX(AI);   "AI(0)*BR(0)
               DPX(TR)<FM;             "SAVE AR(0)*BR(0)
               BGE NCONJ1              "BRANCH IF NOT CONJUGATE
           INCMA;                       "FETCH BI(1)
           DPX(AR)<MD;                 "SAVE AR(1)
               DPY(TI)<FM;             "SAVE AR(0)*BI(0)
               FMUL                    "PUSH
           DPX(AI)<MD;                 "SAVE AI(1)
               FADD FM,DPX(TR);        "AR(0)*BR(0) + AI(0)*BI(0)
               FMUL                    "PUSH
           DPY(RB)<MD;                 "SAVE BR(1)
           FMUL DPX(AR),MD;            "AR(1)*BR(1)
               FSUBR FM,DPY(TI);       "AR(0)*BI(0) - AI(0)*BR(0)
               BR LOOP                 "SKIP OVER CONJUGATE CALCULATION
NCONJ1:    INCMA;                      "FETCH BI(1)
           DPX(AR)<MD;                 "SAVE AR(1)
               DPY(TI)<FM;             "SAVE AR(1)*BI(1)
               FMUL
           DPX(AI)<MD;                 "SAVE AI(1)
               FSUBR FM,DPX(TR);       "AR(0)*BR(0) - AI(0)*BI(0)
               FMUL
           DPY(RB)<MD;                 "SAVE BR(1)
           FMUL DPX(AR),MD;            "AR(1)*BI(1)
               FADD FM,DPY(TI)         "AI(0)*BR(0) + AR(0)*BI(0)
LOOP:  ADD I,A;SETMA;                  "FETCH AR(M)
           FMUL DPX(AR),MD             "AR(M+1)*BI(M+1)
       INCMA;                          "FETCH AI(M)
           FMUL DPX(AI),MD;            "AI(M+1)*BI(M+1)
           MOV F,F                     "TEST FOR CONJUGATE
       ADD J,B;SETMA;                  "FETCH BR(M)
           FMUL DPY(RB), DPX(AI);      "BR(M+1)*AI(M+1)
           DPX(TR)<FM;                 "SAVE AR(M+1)*BR(M+1)
           BGE NCONJ                   "BRANCH IF NOT CONJUGATE
       INCMA;                          "FETCH BI(M)
       DPX(AR)<MD;                     "SAVE AR(M)
           DPY(TI)<FM;                 "SAVE AR(M+1)*BI(M+1)
           FMUL;
               DEC N                   "DECREMENT COUNTER
       DPX(AI)<MD;                     "SAVE AI(M)
           FADD FM,DPX(TR);            "AR(M+1)*BR(M+1) + AI(M+1)*BI(M+1
           FMUL;
               ADD K,C;SETMA;MI<FA;    "STORE REAL PART OF C(M+2)
               BEQ DONE                "BRANCH IF DONE
       DPY(RB)<MD;                     "SAVE BR(M)
       FMUL DPX(AR),MD;                "AR(M)*BR(M)
           FSUBR FM,DPY(TI);           "AI(M+1)*BR(M+1) - AR(M+1)*BI(M+1
               INCMA; MI<FA;           "STORE IMAGINARY PART OF C(M+2)
               BR LOOP                 "DO NEXT ONE
NCONJ: INCMA;                          "FETCH BI(M)
       DPX(AR)<MD;                     "SAVE AR(M)
           DPY(TI)<FM;                 "SAVE AR(M+1)*BI(M+1)
           FMUL;
               DEC N                   "DECREMENT COUNTER
       DPX(AI)<MD;                     "SAVE AI(M)
           FSUBR FM,DPX(TR);           "AR(M+1)*BR(M+1) - AI(M+1)*BI(M+1
           FMUL;
               ADD K,C;SETMA;MI<FA;    "STORE REAL PART OF C(M+2)
               BEQ DONE                "BRANCH IF DONE
       DPY(RB)<MD;                     "SAVE BR(M)
       FMUL DPX(AR),MD;                "AR(M)*BR(M)
           FADD  FM,DPY(TI);           "AR(M+1)*BI(M+1) + AI(M+1)*BR(M+1
               INCMA; MI<FA;           "STORE IMAGINAARY PART OF C(M+2)
               BR LOOP                 "DO NEXT ONE
DONE:          INCMA;MI<FA;            "STORE IMAGINARY PART OF C(N-1)
               RETURN
       $END
"****** CVMAGS = COMPLEX VECTOR MAGNITUDE SQUARED /FAST/ = REL 3.1, SEP 79 *****
       $TITLE CVMAGS
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY CVMAGS, 5                          "USER-DIRECTED-CALL ENTRY
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE:  13 LOCATIONS
"
"    --- HISTORY ---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"COMPLEX VECTOR SQUARED MAGNITUDE.
"DOES C(M) = AR(M)*AR(M) + AI(M)*AI(M)
"FOR M = 0 TO N - 1, WHERE AR(M) AND AI(M) ARE
"THE REAL AND IMAGINARY PARTS OF A(M).
"S PAD PARAMETERS:
       A $EQU 0    "VECTOR A ORIGIN
       I $EQU 1    "VECTOR A INCREMENT
       C $EQU 2    "VECTOR C ORIGIN
       K $EQU 3    "VECTOR C INCREMENT
       N $EQU 4    "VECTOR LENGTH
"SCRATCH:
"          S-PADS:  0, 2.
"          DPX:  0, 1.     DPY:  0.
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVMGS,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FCVMGS: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVMAGS:            MOV A,A;SETMA       "FETCH AR(0)
        MOV N,N;                "IS ELEMENT COUNT = 0?
                   INCMA               "FETCH AI(0)
        BEQ DONE;               "EXIT IF COUNT = 0
                   SUB K,C
               ADD I,A;SETMA;          "FETCH AR(1)
                   DPX<MD              "SAVE AR(0)
               INCMA;                  "FETCH AI(1)
                   DPY<MD;             "SAVE AI(0)
                   FMUL DPX,DPX        "AR(0)*AR(0)
                   FMUL DPY,DPY        "AI(0)*AI(0)
           ADD I,A;SETMA;              "FETCH AR(2)
               DPX<MD;                 "SAVE AR(1)
                   FMUL                "PUSH
           INCMA;                      "FETCH AI(2)
               DPY<MD;                 "SAVE AI(1)
               FMUL DPX,DPX;           "AR(1)*AR(1)
                   FADD FM,ZERO        "SAVE AR(0)*AR(0)
               FMUL DPY,DPY;           "AI(1)*AI(1)
                   DPX(1)<FM;          "SAVE AI(0)*AI(0)
                   FADD
LOOP:  ADD I,A;SETMA;                  "FETCH AR(M)
           DPX<MD;                     "SAVE AR(M+1)
               FMUL;
                   FADD DPX(1),FA      "AR(M+3)*AR(M+3) + AI(M+3)*AI(M+3
       INCMA;                          "FETCH AI(M)
           DPY<MD;                     "SAVE AI(M+1)
           FMUL DPX,DPX;               "AR(M+1)*AR(M+1)
               FADD FM,ZERO;           "SAVE AR(M+2)*AR(M+2)
                   DEC N               "DECREMENT COUNTER
           FMUL DPY,DPY;               "AI(M+1)*AI(M+1)
               DPX(1)<FM;              "SAVE AI(M+2)*AI(M+2)
               FADD;
                   ADD K,C;SETMA;MI<FA; "C(M+3)<AR(M+3)*AR(M+3) + AI(M+3
                   BNE LOOP
DONE:   RETURN                  "EXIT
       $END
"****** CVCONJ = COMPLEX VECTOR CONJUGATE /FAST/ = REL 3.1, SEP 79 *****
        $TITLE CVCONJ
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVCONJ,5                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"TAKES CONJUGATE OF A COMPLEX VECTOR A.
"
"FORMULA:  C(MK) + IC(MK+1) = A(MI) - IA(MI+1), FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH FAST MEMORY
"SIZE: 10 LOCATIONS
"SPEED: INTRO: 5 CYCLES
"       LOOP:  4-6  CYCLES
"       COLUMNS/LOOP: 3
"       FLOPS/LOOP: 1
"       SPEED:  BEST     (1.00 + 0.67 * N) USEC
"               TYPICAL  (1.00 + 0.67 * N) USEC
"               WORST    (1.00 + 1.00 * N) USEC
"       MEGAFLOPS: 1.0-1.5
"SUBROUTINES USED: NONE
"                    ---HISTORY---
"ORIGINAL:  R.S. NORIN   JAN.77
"REVISION:  D. DAVIS   JUL.78    FOR FAST MEMORY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN: CALL CVCONJ(A,I,C,K,N)
"APAL:    JSR CVCONJ
"
"RESTRICTIONS:  SINCE A AND C ARE COMPLEX, I AND K MUST BE AT LEAST 2.
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "ADDRESS OF COMPLEX SOURCE VECTOR A
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     C  $EQU  2                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  4                 "NUMBER OF ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4), DPX(0), DPA UNCHANGED
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVCNJ,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FCVCNJ: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVCONJ: MOV A,A;  SETMA                         "4. FETCH AR(1)
        INCMA;                                  "1. FETCH AI(1)
          MOV N,N               "IS ELEMENT COUNT = 0?
        SUB K,C;                                "COMPENSATE C ADDRESS
          BEQ DONE              "EXIT IF COUNT = 0
        DPX<MD                                  "3. STORE AR(1)  TEMP.
        ADD I,A;  SETMA;  FSUB ZERO,MD          "4. FETCH AR(2),  NEGATE AI(1)
"...............................................................................
LOOP:   INCMA;                                  "1. FETCH AI(M+1)
                FADD                            "PUSH FSUB
                ADD K,C;  SETMA;  MI<DPX        "2. STORE CR(M)
        DPX<MD;                                 "3. STORE AR(M+1) TEMP.
                INCMA;  MI<FA;  DEC N           "STORE AI(M),  DECREMENT COUNT
        FSUB ZERO,MD;                           "4. NEGATE AI(M+1)
    ADD I,A;  SETMA;                            "FETCH AR(M+2)
                BNE LOOP                        "REPEAT LOOP IF NOT DONE
"............................................................................
DONE:   RETURN                  "DONE. THEN EXIT
        $END
"****** CVMA = COMPLEX VECTOR MULTIPLY AND ADD /FAST/ = REL 3.1, SEP 79 *****
        $TITLE CVMA
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVMA,10.                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"COMPUTES A COMPLEX VECTOR MULTIPLY OF VECTOR B WITH
"EITHER A (F=1) OR THE CONJUGATE OF A (F=-1) AND
"ADDS THIS RESULT TO THE CORRESPONDING ELEMENTS OF COMPLEX
"VECTOR C.
"THIS ROUTINE IS TYPICALLY USED TO CALCULATE AN AVERAGED
"CROSS-SPECTRUM (WITH C OVERLAYING B).
"
"FORMULA: (D(ML)+ID(ML+1))=(C(MK)+IC(MK+1)) +
"                               (B(MJ)+IB(MJ+1))*(A(MI)+IF*A(MI+1))
"                               FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH FAST MEMORY
"SIZE: 35 LOCATIONS
"SPEED: INTRO: 15 CYCLES
"       LOOP: 8 CYCLES
"       COLUMNS/LOOP: 2
"       BEST & TYPICAL:(1.33)(N-1) + (2.50) USEC FOR 167 NSEC CLOCK
"       WORST:(2.00)(N-1) + (3.33) USEC FOR 167 NSEC CLOCK
"       FLOPS/LOOP: 8
"       MEGAFLOPS: 4.0-6.0
"SUBROUTINES USED: NONE
"                     ---HISTORY---
"ORIGINAL: R.S. NORIN,  NOV.76
"REVISED: D. DAVIS,  JUL.78   FOR FAST MEMORY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN CALL: CALL CVMA(A,I,B,J,C,K,D,L,N,F)
"APAL CALL:    JSR CVMA
"S-PAD PARAMETERS
"   NAME     NUMBER
      A  $EQU  0                "BASE ADDRESS OF COMPLEX SOURCE VECTOR A
      I  $EQU  1                "INCREMENT BETWEEN REAL ELEMENTS OF A
      B  $EQU  2                "BASE ADDRESS OF COMPLEX SOURCE VECTOR B
      J  $EQU  3                "INCREMENT BETWEEN REAL ELEMENTS OF B
      C  $EQU  4                "BASE ADDRESS OF COMPLEX SOURCE VECTOR C
      K  $EQU  5                "INCREMENT BETWEEN REAL ELEMENTS OF C
      D  $EQU  6                "BASE ADDRESS OF COMPLEX DESTINATION VECTOR D
      L  $EQU  7                "INCREMENT BETWEEN REAL ELEMENTS OF D
      N  $EQU 10                "NUMBER OF ELEMENTS IN C
      F  $EQU 11                "FLAG FOR NORMAL OR CONJUGATE MULTIPLY
                                "  F=1, NORMAL
                                "  F=-1, CONJUGATE
"NOTE:  I,J,K,L ALL MUST BE AT LEAST 2 SINCE A,B,C,D ARE COMPLEX.
"       D CAN OVERLAY C,B, OR A.
"SCRATCH:  SP(0,2,4,6),  DPX(-2,-1,0,1),  DPY(0,1),  DPA UNCHANGED
"..................................................................
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVMCA,10.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  1652
        $PARAM 10., P1(#2,#11)/R/IP, P2/I/IP,
                    P3(#4,#11)/R/IP, P4/I/IP,
                    P5(#6,#11)/R/IP, P6/I/IP,
                    P7(#10,#11)/R/OP, P8/I/IP,
                    P9/I/IP, P10/I/IP
FCVMCA: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVMA:   MOV A,A;SETMA                          "2. FETCH AR(1)
        INCMA;                                 "3. FETCH AI(1)
          MOV N,N               "IS ELEMENT COUNT = 0?
        MOV B,B;SETMA;                          "4. FETCH BR(1)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        INCMA;  DPX(0)<MD                        "5. FETCH BI(1),  STORE AR(1)
        MOV C,C;SETMA;  DPX(1)<MD                 "6. FETCH CR(1),  STORE AI(1)
        INCMA;  DPY(0)<MD;  FMUL DPX(0),MD        "7. FETCH CI(1),  STORE BR(1),
                                                        "8. AR(1) * BR(1)
        FMUL DPX(1),MD;  DPY(1)<MD;  MOV F,F    "1. AI(1) * BI(1),  STORE BI(1)
"...........................................................................
        ADD I,A;  SETMA;                           "2. FETCH AR(2)
                FMUL DPY(0),DPX(1);  DPX(-2)<MD;  BGT NORM1
                                   "BR(1) * AI(1),  STORE CR(1),  BR NORM. COMP.
"........................................................................
        INCMA;                                   "3. FETCH AI(2)
                FMUL DPY(1),DPX(0);  DPY(0)<FM;  DPX(-1)<MD
                             "BI(1) * AR(1),  STORE AR(1) * BR(1),  STORE CI(1)
        ADD J,B;  SETMA;                            "4. FETCH BR(2)
                FADD FM,DPY(0);  FMUL        "AI(1)*BI(1) + AR(1)*BR(1)    REAL
        INCMA;  DPX(0)<MD;                       "5. FETCH BI(2),  STORE AR(2)
                FSUBR FM,DPX(-1);  FMUL;  BR COM1   "CI(1) - BR(1)*AI(1)    IMAG
"....................................................................
NORM1:  INCMA;                                "3. FETCH AI(2)
                FMUL DPY(1),DPX(0);  DPY(0)<FM;  DPX(-1)<MD
                               "BI(1) * AR(1),  STORE AR(1)*BR(1),  STORE CI(1)
        ADD J,B;  SETMA;                    "4. FETCH BR(2)
                FSUBR FM,DPY(0);  FMUL      "AR(1)*BR(1) - AI(1)*BI(1)    REAL
        INCMA;  DPX(0)<MD;                   "5. FETCH BI(2),  STORE AR(2)
                FADD FM,DPX(-1);  FMUL        "CI(1) + BR(1)*AI(1)    IMAG
"..........................................................................
COM1:   ADD K,C;  SETMA;  DPX(1)<MD;          "6. FETCH CR(2),  STORE AI(2)
                FADD DPX(-2),FA;  DPY(0)<FM  "CR(1) + AR(1)*BR(1) - AI(1)*BI(1)
                                                        "NORMAL/REAL
                                             "CR(1) + AI(1)*BI(1) + AR(1)*BR(1)
                                                        "CONJUGATE/REAL
        INCMA;  DPY(0)<MD;                    "7. FETCH CI(2),  STORE BR(2)
                FADD DPY(0),FA;  DEC N      " BI(1)*AR(1) + CI(1) + BR(1)*AI(1)
                                                        "NORMAL/IMAG
                                              "BI(1)*AR(1) + CI(1) - BR(1)*AI(1)
                                                        "CONJUGATE/IMAG
        FMUL DPX(0),DPY(0);DPY(1)<MD;          "8. AR(2) * BR(2),  STORE BI(2)
                MOV D,D;SETMA;  MI<FA;  FADD;  BEQ DONE     "STORE DR(1),  REAL
".........................................................
"..................................................................
LOOP:   FMUL DPX(1),DPY(1);  DPX(-2)<MD;  MOV F,F;    "1. AI(N) * BI(N),
                                                        "   STORE CR(N), FETCH F
                INCMA;  MI<FA                           "STORE DI(N)    IMAG
        ADD I,A;  SETMA;                                "2. FETCH AR(N+1)
                FMUL DPY(0),DPX(1);  DPX(-1)<MD;  BGT NORM2    "BR(N) * AI(N),
                                                                "STORE CI(N),
                                                                "BRANCH NORMAL
".........................................................................
        INCMA;                                           "3. FETCH AI(N+1)
                FMUL DPY(1),DPX(0);  DPY(0)<FM          "BI(N) * AR(N),
                                                        "STORE AR(N) * BR(N)
        ADD J,B;SETMA;                                 "4. FETCH BR(N+1)
                FADD FM,DPY(0);  FMUL        "AI(N)*BI(N) + AR(N)*BR(N)    REAL
        INCMA;  DPX(0)<MD;                     "5. FETCH BI(N+1),  STORE AR(N+1)
                FSUBR FM,DPX(-1);  FMUL        "CI(N) - BR(N)*AI(N)    IMAG
"............................................................................
COM2:   ADD K,C;  SETMA;  DPX(1)<MD;           "6. FETCH C(N+1),  STORE AI(N+1)
                FADD DPX(-2),FA;  DPY(0)<FM   "CR(N) + AR(N)*BR(N) - AI(N)*BI(N)
                                                        "NORMAL/REAL
                                             "CR(N) + AI(N)*BI(N) + AR(N)*BR(N)
                                                        "CONJUGATE/REAL
        INCMA;  DPY(0)<MD;                    "7. FETCH CI(N+1),  STORE BR(N+1)
                FADD DPY(0),FA;  DEC N      " BI(N)*AR(N) + CI(N) + BR(N)*AI(N)
                                                        "NORMAL/IMAG
                                            "BI(N)*AR(N) + CI(N) - BR(N)*AI(N)
                                                "CONJUGATE/IMAG
        FMUL DPX(0),DPY(0);  DPY(1)<MD;    "8. AR(N+1) * BR(N+1),  STORE BI(N+1)
                ADD L,D; SETMA; MI<FA;  FADD;  BNE LOOP     "STORE DR(N),  REAL
".............................................................................
"......................................................................
DONE:           INCMA;  MI<FA;  RETURN                    "STORE LAST DI    IMAG
"...........................................................................
"............................................................................
NORM2:  INCMA;                                        "3. FETCH AI(N+1)
                FMUL DPY(1),DPX(0);  DPY(0)<FM         "BI(N) * AR(N),
                                                        "STORE AR(N)*BI(N)
        ADD J,B;  SETMA;                                "4. FETCH BR(N+1)
                FSUBR FM,DPY(0);  FMUL       "AR(N)*BR(N) - AI(N)*BI(N)    REAL
        INCMA;  DPX(0)<MD;                    "5. FETCH BI(N+1),  STORE AR(N+1)
                FADD FM,DPX(-1);  FMUL;  BR COM2     "CI(N) + BR(N)*AI(N)  IMAG
"..............................................................................
        $END
"****** SCJMA = SELF-CONJUGATE COMPLEX MULTIPLY /FAST/ = REL 3.1, SEP 79 *****
        $TITLE SCJMA
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY SCJMA,7                          "USER-DIRECTED-CALL ENTRY
"
"..............................................................................
"       ---ABSTRACT---
"COMPUTES A SELF-CONJUGATE MULTIPLY (MAGNITUDE SQUARED)
"OF COMPLEX VECTOR A AND ADDS THE RESULT TO THE
"CORRESPONDING ELEMENT OF REAL VECTOR B.
"THIS ROUTINE IS TYPICALLY USED TO CALCULATE AN AVERAGED
"AUTO-SPECTRUM (WITH C OVERLAYING B).
"
"FORMULA: C(MK)=B(MJ)+(A(MI))**2+(A(MI+1))**2
        "   FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP120 WITH FAST MEMORY
"SIZE: 14 LOCATIONS
"SPEED: INTRO  9-11 CYCLES
"       LOOP   4-5 CYCLES PER POINT
"       COLUMNS/LOOP  4
"       BEST:  (1.67 + 0.83(N) )USEC
"       TYPICAL: (2.00 + 0.83(N) )USEC
"       WORST: (2.00 + 1.17(N) )USEC
"       FLOPS/LOOP: 4
"       MEGAFLOPS: 4.0-6.0
"SUBROUTINES USED: NONE
"                   ---HISTORY---
"ORIGINAL: R.S. NORIN  NOV.76
"REVISED: D. DAVIS  JUL.78  FOR FAST MEMORY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN CALL: CALL SCJMA(A,I,B,J,C,K,N)
"APAL CALL: JSR SCJMA
"S-PAD PARAMETERS
"NAME   NUMBER
 A $EQU  0                      "BASE ADDRESS OF COMPLEX SOURCE VECTOR A
 I $EQU  1                      "INCREMENT BETWEEN REAL ELEMENTS OF A
 B $EQU  2                      "BASE ADDRESS OF REAL SOURCE VECTOR B
 J $EQU  3                      "INCREMENT BETWEEN ELEMENTS OF B
 C $EQU  4                      "BASE ADDRESS OF REAL DESTINATION VECTOR C
 K $EQU  5                      "INCREMENT BETWEEN ELEMENTS OF C
 N $EQU  6                      "NUMBER OF ELEMENTS IN C
"NOTE I MUST BE AT LEAST 2, SINCE A IS COMPLEX.
"     C CAN OVERLAY B OR A.
"SCRATCH:  SP(0,2,4,6), DPX(0,1), DPY(1),  DPA UNCHANGED.
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FSCJMA,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FSCJMA: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SCJMA:  MOV A,A;SETMA                           "2. FETCH AR(1)
        INCMA;                                  "3. FETCH AI(1)
          MOV N,N               "IS ELEMENT COUNT = 0?
        MOV B,B;SETMA;                          "1. FETCH B(1)
          BEQ DONE              "EXIT IF COUNT = 0
        ADD I,A;  SETMA;                        "2. FETCH AR(2)
                DPX(0)<MD                       "1. STORE AR(1)
        INCMA;                                  "3. FETCH AI(2)
                FMUL DPX(0),DPX(0);  DPX(1)<MD  "2. AR(1) * AR(1), STORE AI(1)
        ADD J,B;  SETMA;                        "1. FETCH B(2)
                FMUL DPX(1),DPX(1);  DPY(0)<MD  "3. AI(1) * AI(1),  STORE B(1)
        ADD I,A;  SETMA;                        "2. FETCH AR(3)
                DPX(0)<MD                       "1. STORE AR(2)
        INCMA;                                  "3. FETCH AI(3)
                FMUL DPX(0),DPX(0);  DPX(1)<MD  "2. AR(2) * AR(2),  STORE AI(2)
                FMUL DPX(1),DPX(1);  DPY(0)<MD; "3. AI(2) * AI(2),  STORE B(2)
                        FADD FM,DPY(0);  SUB K,C"3. AR(1)*AR(1) + B(1)
LOOP:           ADD J,B;  SETMA;  DPX(0)<MD;    "1. FETCH B(M+2),  STORE AR(M+2)
                                FADD
        ADD I,A;  SETMA;                        "2. FETCH AR(M+3)
                FMUL DPX(0),DPX(0);  DPX(1)<MD; "2. AR(M+2) * AR(M+2),
                                                "2. STORE AI(M+2)
                                FADD FM,FA      "2. AI(M)*AI(M) + AR(M)*AI(M)
                                                "2.                  + B(M)
        INCMA;                                  "3. FETCH AI(M+3)
                FMUL DPX(1),DPX(1);             "3. AI(M+2) * AI(M+2)
                        FADD FM,DPY(0);         "3. AR(M+1)*AR(M+1) + B(M+1)
                                DEC N           "3. DECREMENT COUNTER
                DPY(0)<MD;                      "4. STORE B(M+2)
                                ADD K,C;  SETMA;  MI<FA;  BNE LOOP
                                                "4. STORE C(M),  REPEAT LOOP
"4.             IF NOT DONE
DONE:   RETURN                  "EXIT
        $END
"****** CDOTPR = COMPLEX DOT PRODUCT /FAST/ = REL 3.1, SEP 79 *****
        $TITLE CDOTPR
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CDOTPR,6.                          "USER-DIRECTED-CALL ENTRY
        "A&B ARE COMPLEX VECTORS WITH INCREMENTS I&J RESPECTIVELY. THIS
        "ALGORITHM DOES THE DOT PRODUCT OF THESE VECTORS.
        "R(E)+(-1)**1/2 *IMG(E)=SUM FROM 1 TO N OF
        "(R(A)*R(B)-IMG(A)*IMG(B))+
        "            ((-1)**1/2)*(R(A)*IMG(B)+IMG(A)*R(B))
        "
        "
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST MEMORY
        "SIZE:      15. LOCATIONS
        "TIME:      WORST CASE: 15+6*N CYCLES
        "           BEST CASE:  11+4*N CYCLES
        "           TYPICAL:    11+4*N CYCLES
"
"    --- HISTORY ---
"ORIGINAL:  FEB 77  S. BERKOWITZ
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
        "DPX(-2),DPX(-1),DPY(1),DPY(2) ---- TEMPORARY STORAGE
        "S-PAD                       ---- LOCATIONS 0 THROUGH 5
        A $EQU 0                                        "BASE ADDR OF A
        I $EQU 1                                        "INCREMENT OF A
        B $EQU 2                                        "BASE ADDR OF B
        J $EQU 3                                        "INCREMENT OF B
        C $EQU 4                                        "BASE ADDR OF C
        N $EQU 5                                        "LENGTH OF VECTORS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCDOTP,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  52
        $PARAM  6 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3(#4,#6)/R/IP, P4/I/IP,
                    P5(2)/R/OP,
                    P6/I/IP
FCDOTP: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CDOTPR: MOV A,A;SETMA;FSUB ZERO,ZERO             "1,FETCH R(A(0))
        INCMA;FSUB ZERO,ZERO;                    "2,FETCH IMG(A(0))
          MOV N,N               "IS ELEMENT COUNT = 0?
        MOV B,B;SETMA;                          "3,FETCH R(B(0))
          BEQ DONEX             "EXIT IF COUNT = 0
        INCMA;                                  "4,FETCH IMG(B(0))
        DPX(-2)<MD
        ADD I,A;SETMA;                          "1,FETCH R(A(1))
                DPX(-1)<MD
        INCMA;                                  "2,FETCH IMG(A(1))
                FMUL DPX(-2),MD;                "2,R(A(0))*R(B(0))
                DPY(1)<MD
        ADD J,B;SETMA;                          "3,FETCH R(A(1))
                FMUL DPX(-2),MD;                "3,R(A(0))*IMG(B(0))
                DPY(2)<MD
        INCMA;                                  "4,FETCH IMG(B(1))
        DPX(-2)<MD;
                FMUL DPX(-1),DPY(2)             "4,IMG(A(0))*IMG(B(0))
LOOP:   ADD I,A;SETMA;                          "1,FETCH RA(P+1)
                DPX(-1)<MD;
                        FMUL DPX(-1),DPY(1);    "1,IA(P-1)*RB(P-1)
                        FADD FM,FA              "1,REAL SUM
        INCMA;                                  "2,FETCH IA(P+1)
                FMUL DPX(-2),MD;                "2,RA(P)*RB(P)
                DPY(1)<MD;
                        FADD FM,FA;             "2,ADD TO IMAG SUM
                        DEC N                   "2,N=N-1
        ADD J,B;SETMA;                          "3,FETCH RB(P)
                FMUL DPX(-2),MD;                "3,RA(P)*IB(P)
                DPY(2)<MD;
                        FSUBR FM,FA;            "3,SUBTRACT FROM REAL SUM
                        BEQ DONE
        INCMA;                                  "4,FETCH IB(P+1)
        DPX(-2)<MD;
                FMUL DPX(-1),DPY(2);           "4,IA(P)*IB(P)
                        FADD FM,FA;             "4,ADD TO IMAGINARY SUM
                        BR LOOP
DONE:   FADD FM,FA                              "4,ADD TO IMAGINARY SUM
DONEX:  MOV C,C;SETMA;MI<FA;FADD                "WRITE REAL PART
        INCMA;MI<FA; RETURN                     "WRITE IMAGINARY PART
        $END
"
"****** CVMOV = COMPLEX VECTOR MOVE /COMMON/ = REL 3.0, NOV 78 *****
"       FOR EITHER MEMORY
        $TITLE CVMOV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVMOV,5                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"MOVES ELEMENTS OF A COMPLEX VECTOR FROM ONE LOCATION TO ANOTHER.
"
"FORMULA:  C(MK)+IC(MK+1) = A(MI)+IA(MI+1) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 9 LOCATIONS
"SPEED: BEST (FAST): 5N  (A,C SAME; I,K EVEN)
"         (STANDARD): 8N
"     TYPICAL (FAST): 5N
"        (STANDARD) : 8N
"      WORST  (FAST): 6N
"         (STANDARD): 10N
"       COLUMNS/LOOP: 1
"SUBROUTINES USED: NONE
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL CVMOV(A,I,C,K,N)
"APAL:    JSR CVMOV
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     C  $EQU  2                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  4                 "NUMBER OF COMPLEX ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4),MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVMOV,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FCVMOV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVMOV:  SUB I,A                 "BACK UP POINTERS
        SUB K,C
        MOV N,N                 "TEST FOR N=0
LOOP:   ADD I,A; SETMA;         "FETCH A(M)  REAL
            BEQ DONE            "QUIT IF DONE
        INCMA                   "FET A(M+1)  IMAG
        NOP "WAIT FOR DATA
        ADD K,C; SETMA; MI<MD   "STORE REAL
        INCMA; MI<MD;           "STORE IMAG
            DEC N; BR LOOP      "DECREMENT COUNTER AND LOOP
DONE:   RETURN                  "EXIT
        $END
"****** CVFILL = COMPLEX VECTOR FILL /COMMON/ = REL 3.1, SEP 79 *****
"       FOR EITHER MEMORY
        $TITLE CVFILL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVFILL,4                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"FILLS COMPLEX VECTOR C WITH COMPLEX CONSTANT A
"
"FORMULA:  C(MK)+IC(MK+1) = A(0)+IA(1) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 8 LOCATIONS
"SPEED: BEST (FAST): 3N
"         (STANDARD): 4N
"     TYPICAL (FAST): 3N   (K EVEN)
"        (STANDARD) : 4N
"      WORST  (FAST): 3N
"         (STANDARD): 5N   (K ODD)
"       COLUMNS/LOOP: 1
"SUBROUTINES USED: NONE
"
"    --- HISTORY ---
"ORIGINAL:  APR 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN: CALL CVFILL(A,C,K,N)
"APAL:    JSR CVFILL
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "ADDRESS OF CONSTANT REAL VALUE
                                "A+1 CONTAINS IMAG PART
     C  $EQU  1                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  2                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  3                 "NUMBER OF COMPLEX ELEMENTS IN C
"
"SCRATCH:  SP(1,3), DPX(0),MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVFIL,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  14
        $PARAM  4 , P1(2)/R/IP,
                    P2(#3,#4)/R/OP, P3/I/IP,
                    P4/I/IP
FCVFIL: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVFILL:  MOV A,A; SETMA          "FETCH THE CONSTANT REAL PART
        SUB K,C                 "BACK UP OUTPUT ADDRESS
        INCMA;                  "FETCH CONSTANT IMAG PART
          MOV N,N               "IS ELEMENT COUNT = 0?
        DPX<MD;                 "SAVE REAL CONSTANT
          BEQ DONE              "EXIT IF COUNT = 0
LOOP:   ADD K,C;SETMA;MI<DPX    "1. STORE C(MK) - REAL
        INCMA;MI<MD;            "2. STORE C(MK+1) - IMAG
            DEC N               "   DECREMENT COUNT
        BNE LOOP                "3. LOOP UNTIL DONE
DONE:   RETURN                  "EXIT
        $END
"****** CVCOMB = COMPLEX VECTOR COMBINE /COMMON/ = REL 3.0, NOV 78 *****
"       FOR EITHER MEMORY
        $TITLE CVCOMB
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVCOMB,7                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"COMBINES TWO REAL VECTORS TO FORM A COMPLEX VECTOR.
"
"FORMULA:  C(MK)+IC(MK+1) = A(MI)+IB(MJ) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 10 LOCATIONS
"SPEED: BEST (FAST): 5.5N  (A OPPOSITE; I,J ODD; K EVEN)
"         (STANDARD): 9N
"     TYPICAL (FAST): 6.5N   (A,B,C SAME; I,J ODD; K EVEN)
"        (STANDARD) : 10N
"      WORST  (FAST): 7N
"         (STANDARD): 11N
"       COLUMNS/LOOP: 1
"SUBROUTINES USED: NONE
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL CVCOMB(A,I,B,J,C,K,N)
"APAL:    JSR CVCOMB
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF REAL VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "BASE ADDRESS OF IMAGINARY VECTOR
     J  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF B
     C  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  6                 "NUMBER OF COMPLEX ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4,6),MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVCMB,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FCVCMB: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVCOMB: SUB I,A                 "BACK UP POINTERS
        SUB J,B
        SUB K,C
        MOV N,N                 "TEST FOR N=0
LOOP:   ADD I,A; SETMA;         "GET A(M) REAL
            BEQ DONE            "STOP IF DONE
        ADD J,B; SETMA          "GET B(M) IMAG
        NOP                     "WAIT FOR DATA
        ADD K,C; SETMA; MI<MD   "STORE REAL
        INCMA; MI<MD;           "STORE IMAG
            DEC N; BR LOOP      "DECREMENT COUNT AND LOOP AGAIN
DONE:   RETURN                  "EXIT
        $END
"****** CVREAL = FORM COMPLEX VECTOR OF REALS /COMMON/ = REL 3.1, SEP 79 ****
"       FOR EITHER MEMORY
        $TITLE CVREAL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVREAL,5                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"COMBINES A REAL VECTOR AND A ZERO VECTOR TO FORM A COMPLEX VECTOR.
"
"FORMULA:  C(MK)+IC(MK+1) = A(MI)+I0.0 FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 9 LOCATIONS
"SPEED: BEST (FAST): 4.5N  (A,C SAME; I ODD; K EVEN)
"         (STANDARD): 7N
"     TYPICAL (FAST): 4.5N
"        (STANDARD) : 7N
"      WORST  (FAST): 5N
"         (STANDARD): 8N
"       COLUMNS/LOOP: 1
"SUBROUTINES USED: NONE
"
"   --- HISTORY ---
"ORIGINAL:  APR 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN   CHANGED ADC ENTRY TO FCVREA (FROM FCVREAL)
"
"
"       ---USAGE---
"FORTRAN: CALL CVREAL(A,I,C,K,N)
"APAL:    JSR CVREAL
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF REAL VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     C  $EQU  2                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  4                 "NUMBER OF COMPLEX ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4),MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVREA,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FCVREA: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVREAL: SUB I,A                 "BACK UP POINTERS
        SUB K,C
        INC C
        MOV N,N                 "TEST FOR N=0
LOOP:   ADD I,A; SETMA;         "GET A(M) REAL
            BEQ DONE            "STOP IF DONE
        NOP                     "WAIT FOR DATA
        ADD K,C; SETMA; MI<ZERO   "STORE IMAG
        DECMA; MI<MD;           "STORE REAL
            DEC N; BR LOOP      "DECREMENT COUNT AND LOOP AGAIN
DONE:   RETURN                  "EXIT
        $END
"****** VREAL = EXTRACT REALS OF COMPLEX VECTOR /COMMON/ = REL 3.0, NOV 78 *****
"       FOR EITHER MEMORY
        $TITLE VREAL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VREAL,5                          "USER-DIRECTED-CALL ENTRY
        $EXT VMOV
"
"       ---ABSTRACT---
"EXTRACTS THE REALS FROM A COMPLEX VECTOR TO FORM A REAL VECTOR.
"
"FORMULA:   C(MK) = A(MI) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 1 + VMOV (14 - FAST; 6 - SLOW) = 15 FAST; 7 SLOW
"SPEED: SAME AS VMOV
"SUBROUTINES USED: VMOV
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL VREAL(A,I,C,K,N)
"APAL:    JSR VREAL
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF COMPLEX VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
                                "ABS(I) AT LEAST 2
     C  $EQU  2                 "BASE ADDRESS OF REAL DESTINATION VECTOR C
     K  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  4                 "NUMBER OF ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4),MD    (SLOW MEM)
"          SP(0,2,14,15),DPX(1),FA,MD,TM    (FAST MEM)
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVREAL,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVREAL: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VREAL: JMP VMOV                 "GO DIRECTLY TO VMOV ROUTINE
                                "AND EXIT THROUGH ITS RETURN!!
        $END
"****** VIMAG = EXTRACT IMAGINARIES OF COMPLEX VECTOR /COMMO= REL 3.0, NOV 78 **
"       FOR EITHER MEMORY
        $TITLE VIMAG
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VIMAG,5                          "USER-DIRECTED-CALL ENTRY
        $EXT VMOV
"
"       ---ABSTRACT---
"EXTRACTS THE IMAGINARIES FROM A COMPLEX VECTOR TO FORM A REAL VECTOR.
"
"FORMULA:   C(MK) = A(MI+1) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 2 + VMOV (14 - FAST; 6 - SLOW) = 16 FAST; 8 SLOW
"SPEED: SAME AS VMOV
"SUBROUTINES USED: VMOV
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL VIMAG(A,I,C,K,N)
"APAL:    JSR VIMAG
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF COMPLEX VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
                                "ABS(I) AT LEAST 2
     C  $EQU  2                 "BASE ADDRESS OF REAL DESTINATION VECTOR C
     K  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  4                 "NUMBER OF ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4),MD    (SLOW MEM)
"          SP(0,2,14,15),DPX(1),FA,MD,TM    (FAST MEM)
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVIMAG,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVIMAG: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VIMAG: INC A                    "POINT AT FIRST IMAGINARY
       JMP VMOV                 "GO DIRECTLY TO VMOV ROUTINE
                                "AND EXIT THROUGH ITS RETURN!!
        $END
"****** CVNEG = COMPLEX VECTOR NEGATE /COMMON/ = REL 3.0, NOV 78 *****
"       FOR EITHER MEMORY
        $TITLE CVNEG
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVNEG,5                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"NEGATES A COMPLEX VECTOR.
"
"FORMULA:  C(MK)+IC(MK+1) = -A(MI)-IA(MI+1) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 11 LOCATIONS
"SPEED: BEST (FAST): 5N  (A,C SAME; I,K EVEN)
"         (STANDARD): 8N
"     TYPICAL (FAST): 5N
"        (STANDARD) : 8N
"      WORST  (FAST): 7N
"         (STANDARD): 10N
"       COLUMNS/LOOP: 2
"SUBROUTINES USED: NONE
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL CVNEG(A,I,C,K,N)
"APAL:    JSR CVNEG
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     C  $EQU  2                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  4                 "NUMBER OF COMPLEX ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4),FA,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVNEG,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FCVNEG: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVNEG:  MOV A,A; SETMA          "GET A(0) REAL
        INCMA                   "GET A(1) IMAG
        SUB K,C                 "BACK UP POINTER
        FSUB ZERO,MD            " - A(0)
        FSUB ZERO,MD;           " - A(1)
            MOV N,N             "TEST FOR N=0
LOOP:   ADD I,A; SETMA;         "GET REAL
            BEQ DONE            "QUIT IF DONE
        INCMA                   "GET IMAG
            NOP                 "WAIT FOR DATA
        FSUB ZERO,MD;           "NEGATE REAL
            ADD K,C;SETMA;MI<FA "STORE REAL
        FSUB ZERO,MD;           "NEGATE IMAG
            INCMA;MI<FA;        "STORE IMAG
              DEC N;            "DECREMENT COUNT
              BR LOOP           "CONTINUE
DONE:   RETURN                  "EXIT
        $END
"****** CVSMUL = COMPLEX VECTOR SCALAR MULTIPLY /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE CVSMUL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVSMUL,6                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"MULTIPLIES THE ELEMENTS OF A COMPLEX VECTOR BY A REAL SCALAR VALUE.
"
"FORMULA:  C(MK)+IC(MK+1) = B * (A(MI)+IA(MI+1))  FOR M=0 TO N-1
"
"       ---HISTORY---
"ORIGINAL:  DEC 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---STATISTICS---
"LANGUAGE:  APAL
"EQUIPMENT: AP120B WITH EITHER SPEED MEMORY
"SIZE:      12
"EXECUTION   BEST    TYPICAL      WORST        SETUP(US)
"TIME/LOOP   0.83      0.83        1.0           1.33        167 NS MEMORY
" (US)       1.33      1.33        1.67          1.5         333 NS MEMORY
"
"       ---USAGE---
"FORTRAN CALL:  CALL CVSMUL(A,I,B,C,K,N)
"APAL CALL:     JSR CVSMUL
"SCRATCH:       SP(0,3,5),DPX(0),FM,MD
"
"ENTER WITH FOLLOWING S-PAD PARAMETERS:
"   NAME      NUMBER
     A  $EQU     0              "SOURCE VECTOR BASE ADDRESS
     I  $EQU     1              "A ADDRESS INCREMENT
     B  $EQU     2              "SCALAR ADDRESS
     C  $EQU     3              "DESTINATION VECTOR BASE ADDRESS
     K  $EQU     4              "C ADDRESS INCREMENT
     N  $EQU     5              "ELEMENT COUNT
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVSMU,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  62
        $PARAM  6 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3/R/IP,
                    P4(#5,#6)/R/OP, P5/I/IP,
                    P6/I/IP
FCVSMU: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVSMUL: MOV B,B; SETMA          "GET SCALAR B
        MOV A,A; SETMA          "5. GET A(0)     REAL
        SUB K,C                 "BACK UP OUTPUT POINTER
        MOV N,N;                "IS ELEMENT COUNT = 0?
            INCMA;              "1. GET A(1)     IMAG
             DPX<MD             "   SAVE SCALAR B
        BEQ DONE;               "EXIT IF COUNT = 0
            FMUL DPX,MD         "3. A(0)*B
        ADD I,A; SETMA          "5. GET A(I)     REAL
LOOP:       INCMA;              "1. GET IMAG
                FMUL DPX,MD     "   IMAG*B
                FMUL            "2. PUSH
            FMUL DPX,MD;        "3. REAL*B
                ADD K,C; SETMA; MI<FM "  STORE REAL
                INCMA; MI<FM;   "4. STORE IMAG
                 DEC N          "   DECREMENT COUNT
        ADD I,A; SETMA;         "5. GET NEXT REAL
                BNE LOOP        "   LOOP UNTIL DONE
DONE:   RETURN                  "EXIT
        $END
"****** CVRCIP = COMPLEX VECTOR RECIPROCAL /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE CVRCIP
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVRCIP, 5                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV
"DOES THE ELEMENT BY ELEMENT RECIPROCAL OF A COMPLEX VECTOR
"C(MK) + C(MK+1) = 1.0 / (A(MI) + A(MI+1))
"                  --- STATISTICS ---
"EQUIPMENT: AP-120B WITH EITHER MEMORY
"SIZE: 23 LOCATIONS + DIVIDE
"SCRATCH: SP:0,2,4; DPX: 0-2;  DPY: 0-2  (REL TO DPA) PLUS DIVIDE
"SPEED: 1.33 US. PLUS DIVIDE
"SUBROUTINE USED:   DIVIDE
"
"    --- HISTORY ---
"ORIGINAL:  OCT 75  A.E. CHARLESWORTH
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"S-PAD PARAMETERS:
        A $EQU 0                        "BASE ADDRESS OF A VECTOR
        I $EQU 1                        "INCREMENT FOR VECTOR A
        C $EQU 2                        "BASE ADDRESS OF VECTOR C
        K $EQU 3                        "INCREMENT FOR VECTOR C
        N $EQU 4                        "ELEMENT COUNT FOR C
"                  --- ALGORITHM ---
"REAL PART: CR =  AR / (AR**2 + AI**2)
"IMAG PART: CI = -AI / (AR**2 + AI**2)
"NOTE: THIS WILL GIVE A SPURIOUS OVERFLOW IF (AR**2 + AI**2) > 10**153
"       OR UNDERFLOW IF (AR**2 + AI**2) < 10**-155
"       THUS, THE WORST CASE FOR THIS SPURIOUS CONDITION IS WHEN BOTH
"         ARGUEMENTS ARE > 10**77
"OTHER S-PAD REGISTERS:
        ONEPTR $EQU 5                   "POINTER TO 1.0 IN TM
"NAMES FOR DATA PAD:
"DPX:
        R $EQU 0
        AR1 $EQU 2
        AI1 $EQU 3
"DPY:
        ONE $EQU 0
        AR2 $EQU 1
        AI2 $EQU 2
"TABLE LOCATION OF ONE:
        ONEADR $EQU !ONE
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVRCI,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FCVRCI: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVRCIP: MOV A,A; SETMA                  "GET AR(M)
        SUB K,C
        INCMA                           "GET AI(M)
        DPX(AR1)<MD                     "SAVE AR(M)
        DB=ONEADR; LDSPI ONEPTR
        DPX(AI1)<MD                     "SAVE AI(M)
        FMUL DPX(AR1),DPX(AR1);         "DO AR(M)**2
        FADD DPX(AR1),ZERO;             "  SAVE AR(M) IN ADDER
           ADD I,A; SETMA               "  GET AR(M+1)
        FADD; FMUL;
          MOV N,N               "IS ELEMENT COUNT = 0?
        FMUL DPX(AI1),DPX(AI1);         "DO AI(M)**2
        FSUB ZERO,DPX(AI1);             "  NEGATE AI(M)
        DPY(AR2)<FA;                    "  SAVE AR(M)
           INCMA;                       "  GET AI(M+1)
          BEQ DONE              "EXIT IF COUNT = 0
        FADD FM,ZERO; FMUL;             "SAVE AR(M)**2 IN ADDER
        MOV ONEPTR,ONEPTR; SETTMA;      "  GET 1.0 FROM TM
           DPX(AR1)<MD                  "  SAVE AR(M+1)
        DPY(AI2)<FA; FADD; FMUL         "SAVE -AI(M)
        FADD FM,FA;                     "DO SUMSQ(M)
           DPX(AI1)<MD                  "  SAVE AI(M+1)
        FADD; DPY(ONE)<TM               "SAVE DIVIDEND
LOOP:   JSR DIV; DPX(R)<FA              "DO 1/SUMSQ(M)
           FMUL DPX(AR1),DPX(AR1);      "  DO AR(M+1)**2
           FADD DPX(AR1),ZERO;          "  SAVE AR(M+1) IN ADDER
              ADD I,A; SETMA            "  GET AR(M+2)
        FMUL DPY(AR2),DPX(R);           "DO RECIP*AR(M)
           FADD
           FMUL DPX(AI1),DPX(AI1);      "DO AI(M+1)**2
           FSUB ZERO,DPX(AI1);          "  NEGATE AI(M+1)
           DPY(AR2)<FA;                 "  SAVE AR(M+1)
              INCMA                     "  GET AI(M+2)
        FMUL DPY(AI2),DPX(R);           "DO RECIP*AI(M)
           FADD FM,ZERO;                "  SAVE AR(M+1)**2 IN ADDER
           MOV ONEPTR,ONEPTR; SETTMA;   "  GET 1.0 FROM TM
              DPX(AR1)<MD               "  SAVE AR(M+2)
        ADD K,C; SETMA; MI<FM;          "STORE CR(M)
           DPY(AI2)<FA; FADD; FMUL      "  SAVE -AI(M+1)
        FMUL; DEC N;                    "TEST IF DONE
           FADD FM,FA;                  "  DO SUMSQ(M+1)
              DPX(AI1)<MD               "  SAVE AI(M+2)
        INCMA; MI<FM;                   "STORE CI(M)
        BNE LOOP;                       "  LOOP IF NOT DONE
           FADD; DPY(ONE)<TM            "  SAVE DIVIDEND
DONE:   RETURN                  "EXIT
        $END
"****** CRVADD = COMPLEX AND REAL VECTOR ADD /COMMON/ = REL 3.0, NOV 78 *****
"       FOR EITHER MEMORY
        $TITLE CRVADD
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CRVADD,7                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"ADDS ELEMENTS OF A REAL VECTOR TO BOTH REAL AND IMAGINARY PARTS
"OF THE CORRESPONDING ELEMENTS OF A COMPLEX VECTOR.
"
"FORMULA:  C(MK)+IC(MK+1) = (A(MI)+B(MJ))+I(A(MI+1)+B(MJ)) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 14 LOCATIONS
"SPEED: BEST (FAST): 7.5N  (A,C SAME; I,K EVEN)
"          (STANDARD): 11N
"     TYPICAL (FAST): 7.5N
"         (STANDARD): 11N
"      WORST  (FAST): 8N
"         (STANDARD): 13N
"       COLUMNS/LOOP: 2
"SUBROUTINES USED: NONE
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL CRVADD(A,I,B,J,C,K,N)
"APAL:    JSR CRVADD
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR (COMPLEX)
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "BASE ADDRESS OF SOURCE VECTOR (REAL)
     J  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF B
     C  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  6                 "NUMBER OF COMPLEX ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4,6),DPX(0),FA,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCRVAD,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FCRVAD: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CRVADD: MOV B,B;SETMA           "GET B(0) REAL
        NOP
         MOV A,A; SETMA          "GET A(0) REAL
        INCMA;                  "GET A(1) IMAG
            DPX<MD              "SAVE B(0)
            SUB K,C             "BACK UP POINTER
        FADD DPX,MD;            "A(0)+B(0)
            MOV N,N             "TEST FOR N=0
LOOP:   ADD J,B; SETMA;         "GET B(M) REAL
            BEQ DONE            "QUIT IF DONE
            FADD DPX,MD         "ADD B TO IMAGS
        ADD I,A; SETMA          "GET A(M) REAL
        INCMA;                  "GET A(M) IMAG
            DPX<MD              "SAVE B(M) IMAG
        NOP                     "WAIT FOR DATA
        FADD DPX,MD;            "ADD B TO REALS
            ADD K,C; SETMA; MI<FA  "STORE REAL
            INCMA; MI<FA;       "STORE IMAGS
            DEC N; BR LOOP      "DECREMENT COUNT AND GO LOOP
DONE:   RETURN                  "EXIT
        $END
"****** CRVSUB = COMPLEX AND REAL VECTOR SUBTRACT /COMMON= REL 3.0, NOV 78 *****
"       FOR EITHER MEMORY
        $TITLE CRVSUB
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CRVSUB,7                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"SUBTRACTS ELEMENTS OF A REAL VECTOR FROM BOTH REAL AND IMAGINARY PARTS
"OF THE CORRESPONDING ELEMENTS OF A COMPLEX VECTOR.
"
"FORMULA:  C(MK)+IC(MK+1) = (A(MI)-B(MJ))+I(A(MI+1)-B(MJ)) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 14 LOCATIONS
"SPEED: BEST (FAST): 7.5N  (A,C SAME; I,K EVEN)
"          (STANDARD): 11N
"     TYPICAL (FAST): 7.5N
"         (STANDARD): 11N
"      WORST  (FAST): 8N
"         (STANDARD): 13N
"       COLUMNS/LOOP: 2
"SUBROUTINES USED: NONE
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL CRVSUB(A,I,B,J,C,K,N)
"APAL:    JSR CRVSUB
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR (COMPLEX)
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "BASE ADDRESS OF SOURCE VECTOR (REAL)
     J  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF B
     C  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  6                 "NUMBER OF COMPLEX ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4,6),DPX(0),FA,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCRVSU,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FCRVSU: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CRVSUB: MOV B,B;SETMA           "GET B(0) REAL
        NOP
         MOV A,A; SETMA          "GET A(0) REAL
        INCMA;                  "GET A(1) IMAG
            DPX<MD              "SAVE B(0)
            SUB K,C             "BACK UP POINTER
        FSUBR DPX,MD;            "A(0)-B(0)
            MOV N,N             "TEST FOR N=0
LOOP:   ADD J,B; SETMA;         "GET B(M) REAL
            BEQ DONE            "QUIT IF DONE
            FSUBR DPX,MD         "SUBTRACT B FROM IMAGS
        ADD I,A; SETMA          "GET A(M) REAL
        INCMA;                  "GET A(M) IMAG
            DPX<MD              "SAVE B(M) IMAG
        NOP                     "WAIT FOR DATA
        FSUBR DPX,MD;            "SUBTRACT B FROM REALS
            ADD K,C; SETMA; MI<FA  "STORE REAL
            INCMA; MI<FA;       "STORE IMAGS
            DEC N; BR LOOP      "DECREMENT COUNT AND GO LOOP
DONE:   RETURN                  "EXIT
        $END
"****** CRVMUL = COMPLEX AND REAL VECTOR MULTIPLY /COMMON= REL 3.0, NOV 78 *****
"       FOR EITHER MEMORY
        $TITLE CRVMUL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CRVMUL,7                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"MULTIPLIES ELEMENTS OF A REAL VECTOR TO BOTH REAL AND IMAGINARY PARTS
"OF THE CORRESPONDING ELEMENTS OF A COMPLEX VECTOR.
"
"FORMULA:  C(MK)+IC(MK+1) = (A(MI)*B(MJ))+I(A(MI+1)*B(MJ)) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 14 LOCATIONS
"SPEED: BEST (FAST): 7.5N  (A,C SAME; I,K EVEN)
"          (STANDARD): 11N
"     TYPICAL (FAST): 7.5N
"         (STANDARD): 11N
"      WORST  (FAST): 8N
"         (STANDARD): 13N
"       COLUMNS/LOOP: 2
"SUBROUTINES USED: NONE
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL CRVMUL(A,I,B,J,C,K,N)
"APAL:    JSR CRVMUL
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR (COMPLEX)
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "BASE ADDRESS OF SOURCE VECTOR (REAL)
     J  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF B
     C  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  6                 "NUMBER OF COMPLEX ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4,6),DPX(0),FM,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCRVMU,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FCRVMU: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CRVMUL: MOV B,B;SETMA           "GET B(0) REAL
        NOP
         MOV A,A; SETMA          "GET A(0) REAL
        INCMA;                  "GET A(1) IMAG
            DPX<MD              "SAVE B(0)
            SUB K,C             "BACK UP POINTER
        FMUL DPX,MD;            "A(0)*B(0)
            MOV N,N             "TEST FOR N=0
LOOP:   ADD J,B; SETMA;         "GET B(M) REAL
            BEQ DONE            "QUIT IF DONE
            FMUL DPX,MD         "B * IMAGS
        ADD I,A; SETMA          "GET A(M) REAL
        INCMA;                  "GET A(M) IMAG
            DPX<MD              "SAVE B(M) IMAG
            FMUL                "PUSH
        FMUL DPX,MD;            "B * REALS
            ADD K,C; SETMA; MI<FM  "STORE REAL
            INCMA; MI<FM;       "STORE IMAGS
            DEC N; BR LOOP      "DECREMENT COUNT AND GO LOOP
DONE:   RETURN                  "EXIT
        $END
"****** CRVDIV = COMPLEX AND REAL VECTOR DIVIDE /COMMON/ = REL 3.0, NOV 78 *****
"       FOR EITHER MEMORY
        $TITLE CRVDIV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CRVDIV,7                          "USER-DIRECTED-CALL ENTRY
        $EXT VDIV
"
"       ---ABSTRACT---
"DIVIDES ELEMENTS OF A REAL VECTOR INTO BOTH REAL AND IMAGINARY PARTS
"OF THE CORRESPONDING ELEMENTS OF A COMPLEX VECTOR.
"
"FORMULA:  C(MK)+IC(MK+1) = (A(MI)/B(MJ))+I(A(MI+1)/B(MJ)) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 17 + VDIV (75) = 92 LOCATIONS
"SPEED: BEST (FAST): 20N  (A,C SAME; I,K EVEN)
"          (STANDARD): 20N
"     TYPICAL (FAST): 20N
"         (STANDARD): 20N
"      WORST  (FAST): 20N
"         (STANDARD): 20N
"SUBROUTINES USED: VDIV
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL CRVDIV(A,I,B,J,C,K,N)
"APAL:    JSR CRVDIV
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR (COMPLEX)
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "BASE ADDRESS OF SOURCE VECTOR (REAL)
     J  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF B
     C  $EQU  4                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  5                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  6                 "NUMBER OF COMPLEX ELEMENTS IN C
"
"SCRATCH:  SP(0,2,4,6-15),DPX(-2 TO 3),DPY(-4 TO 2),FA,FM,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCRVDI,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FCRVDI: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CRVDIV: MOV N,N;DPX(-2)<SPFN    "SAVE N
        MOV A,13                "SAVE A
        MOV B,12                "SAVE B
        MOV 13,B                "WE WANT A/B NOT B/A
        MOV 12,A
        MOV I,14                "SWITCH INCREMENTS TOO
        MOV J,I
        MOV 14,J
        MOV C,14                "SAVE C
        JSR VDIV                "PERFORM DIVIDE ON REALS
        MOV 12,A                "RESTORE A
        MOV 13,B                "RESTORE B
        INC B                   "POINT TO FIRST IMAG
        MOV 14,C                "RESTORE C
        INC C                   "POINT TO FIRST REAL
        LDSPI N; DB=DPX(-2)     "RESTORE N
        JMP VDIV                "PERFORM DIVIDE ON IMAGS AND EXIT
                                "THRU VDIV
        $END
"****** POLAR = RECTANGULAR TO POLAR CONVERSION /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE POLAR
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY POLAR, 5                          "USER-DIRECTED-CALL ENTRY
        $EXT SQRT,ATN2
"RECTANGULAR TO POLAR CONVERSION
"ALSO, COMPLEX VECTOR MAGNITUDE AND PHASE
"                  --- ABSTRACT ---
"       DOES RECTANGULAR TO POLAR CONVERSION ON PAIRS OF POINTS
"       IF THE PAIRS ARE COMPLEX, THIS GIVES COMPLEX MAGNITUDE AND PHASE
"       C(MK) = SQRT( A(MI)**2 + A(MI+1)**2 )
"       C(MK+1) = ATAN( A(MI+1)/A(MI) )   FOR M = 0 TO N-1
"
"                  --- STATISTICS ---
"LANGUAGE:   APAL
"EQUIPMENT:  AP-120B WITH EITHER MEMORY
"SIZE        17 LOCATIONS
"SPEED:       1.2 + (1.83 + SQRT + ATN2) N  = 1.2 + 19.4 N  US.
"SUBROUTINES USED:   SQRT,  ATN2
"
"    --- HISTORY ---
"ORIGINAL:  DEC 75  A.E. CHARLESWORTH
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                  --- USEAGE ---
"S-PAD PARAMETERS:
"     NAME       NUMBER
        A   $EQU   0            "BASE ADDRESS OF VECTOR A
        I   $EQU   1            "INCREMENT BETWEEN ELEMENT PAIRS OF A
        C   $EQU   2            "BASE ADDRESS OF VECTOR C
        K   $EQU   3            "INCREMENT BETWEEN ELEMENT PAIRS OF C
        N   $EQU   4            "NUMBER OF ELEMENT PAIRS IN C
"FOR VECTORS WHERE THE ELEMENTS ARE CONTIGUOUS, THE INCREMENTS
"       SHOULD BE 2
"                  --- SCRATCH ---
"SP          0,2,4,12-17   (OCTAL)
"DPX         -2 TO +1  (RELATIVE TO DPA)
"DPY         -3 TO +1   (RELATIVE TO DPA)
"DATA PAD X NAMES:
        AR1   $EQU -1
        T   $EQU -2
"DATA PAD Y NAMES:
        AR   $EQU   -1
        AI $EQU   -2
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FPOLAR,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FPOLAR: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
POLAR:  MOV A,A; SETMA                  "FETCH AR(0)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        INCMA; SUB K,C;                 "FETCH AI(0)
          BEQ DONE              "EXIT IF COUNT = 0
        DPY(AR)<MD                      "SAVE AR(0)
        FMUL DPY(AR),DPY(AR)            "AR(0)**2
        DPY(AI)<MD                      "SAVE AI(0)
LOOP:   FMUL DPY(AI),DPY(AI)            "AI(M)**2
        FMUL; ADD I,A; SETMA;           "FETCH AR(M+1)
          DPX(AR1)<DPY(AR)              "  KEEP AR(M) AROUND
        FMUL; DPX(T)<FM                 "SAVE AR(M)**2
        FADD FM,DPX(T);                 "AR(M)**2 + AI(M)**2
          INCMA                         "  FETCH AI(M+1)
        FADD; DPY(AR)<MD                "SAVE AR(M+1)
        JSR SQRT; DPX(0)<FA             "DO SQRT(AR(M)**2 + AI(M)**2)
        MI<DPX(0); ADD K,C; SETMA       "STORE CR(M)
        DPY(0)<DPY(AI)                  "SET UP FOR ATAN
        JSR ATN2; DPX(0)<DPX(AR1)       "DO ATAN(AI(M)/AR(M))
        MI<DPX(0); INCMA;               "STORE CI(M)
          DEC N                         "  SEE IF DONE?????
        BGT LOOP;                       "BRANCH IF NOT DONE
           DPY(AI)<MD;                  "  SAVE AI(M+1)
          FMUL DPY(AR),DPY(AR)          "  AR(M+1)**2
DONE:   RETURN                  "EXIT
        $END
"****** RECT = POLAR TO RECTANGULAR CONVERSION /COMMON/ = REL 3.3, DEC 80 *****
        $TITLE RECT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY RECT,5                          "USER-DIRECTED-CALL ENTRY
"
"               ---ABSTRACT---
"TRANSFORMS POLAR TO RECTANGULAR COORDINATES  (ANGLES IN RADIANS)
"DOES  C( MK ) = A(MI) * COS ( A(MI+1) )   FOR M = 0 TO N-1
"AND  C( MK+1 ) = A(MI) * SIN ( A(MI+1) )   FOR M = 0 TO N-1
"
"               ---STATISTICS---
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH EITHER MEMORY
"SIZE: 58. LOCATIONS
"EXECUTION       BEST     TYPICAL     WORST     SETUP
"TIME/LOOP:       2.3       2.3        2.3       10.7   (167 NS MEMORY)
"(US)             2.3       2.3        2.3       10.7   (333 NS MEMORY)
"
"               ---HISTORY---
"AUTHOR:  H. WILLIAMS           (MAY 78)  ORIGINAL VCOS AND VSIN
"         D. DAVIS              (AUG 78)  MODIFIED FOR COORDINATE TRANSFORMATION
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2:  MAR 80  R.S. NORIN   COMBINES 2K AND 4K TMROM VERSIONS
" REV 3.3 AND 2A.3:  DEC 80  D. DAVIS  INITIALIZES VECTOR C CORRECTLY
"
"               ---USAGE---
"FORTRAN  CALL: CALL RECT (A, I, C, K, N)
"APAL CALL:    JSR RECT
"SCRATCH: SP(0,2,4,12.-15.),DPX(-4 TO +3),DPY(-4 TO +2),FA,FM,MD,TM
"SUBROUTINES USED: NONE
"
"S-PAD PARAMETERS:
A $EQU 0
I $EQU 1                                     "AT LEAST INCREMENT 2
C $EQU 2
K $EQU 3                                     "AT LEAST INCREMENT 2
N $EQU 4
"
"               ---ALGORITHM---
"RECT IS COMPUTED BY LOOKUP FROM TM ROM COSINE TABLE, FOLLOWED
"BY INTERPOLATION USING SIN(A) = SIN(W+E) = SIN(W)COS(E) + COS(W)SIN(E),
"                   AND COS(A) = COS(W+E) = COS(W)COS(E) - SIN(W)SIN(E)
"WHERE SIN(E) AND COS(E) ARE APPROXIMATED BY TAYLOR SERIES
"AND SIN(W) AND COS(W) ARE FROM TABLE LOOKUP.
"
"               ---SCRATCH---
"S-PAD:
STATUS $EQU 17
TABLE $EQU 17
MASK $EQU 16
TABLE1 $EQU 16
NINTRO $EQU 15
B $EQU 14
"
"DPX:
Q $EQU -4
S $EQU -3
R $EQU -2
SCALE $EQU -1
V $EQU 0
RES1 $EQU 1
DPREV $EQU 2
RESULT $EQU 2
"AND OTHER TEMPORARY
"DPY:
P $EQU -1
U $EQU 0
D $EQU 1
D2 $EQU 2
RES2 $EQU 2
"
"..........START OF CODE..........
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FRECT,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FRECT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
RECT:   MOV A,B                         "SHIFT A ADDRESS TO B
        LDTMA; DB=4371;                 "THIS TM LOCATION IS ZERO FOR
                                        "2.5K TMROM, NONZERO FOR 4.5K
         SUB K,C                          "BACKUP OUTPUT POINTER
         INC C
        LDSPI MASK; DB=30               "GET MASK FOR STATUS REGISTER
        INC A; SETMA;                   "FETCH A(1)
         DB=TM                          "TEST TM LOCATION 4371
        LDTMA; DB=!ONE;                 "FETCH 1.0
         BDBZ TWOK                      "BRANCH IF 2.5K TMROM
"HERE IF 4K COSINE TABLE
        RPSF SCLC4K; DPX(SCALE)<DB      "GET SCALE FACTOR
        RPSF PCON4K; DPY(P)<DB          "GET P
        RPSF QCON4K; DPX(Q)<DB          "GET Q
        RPSF SCON4K; DPX(S)<DB;         "GET S
         BR CONT                        "PROCEED TO COMMON CODE
"HERE IF 2K COSINE TABLE
TWOK:   RPSF SCLC2K; DPX(SCALE)<DB      "GET SCALE FACTOR
        RPSF PCON2K; DPY(P)<DB          "GET P
        RPSF QCON2K; DPX(Q)<DB          "GET Q
        RPSF SCON2K; DPX(S)<DB          "GET S
"SET APSTATUS SO THAT IFFT=1, FFT=1  (TO ACCESS TM ROM COSINE TABLE)
CONT:   RAPS; LDSPNL STATUS;            "GET APSTATUS
           FMUL DPX(SCALE),MD;          "   A(1) * SCALE-FACTOR
           DPX(R)<TM                    "   SAVE 1.0
           FMUL; SUB I,B                "INITIALIZE B
        OR MASK,STATUS;
           LDAPS; DB=SPFN;              "SET STATUS
              FMUL
             DPX(V)<FM;                 "SAVE V=A*SCALE AGAIN
        LDSPI NINTRO; DB=3              "SET LOOP COUNTER FOR INTRO
                DPY(-2)<DPX(V)                  "SAVE V=A*SCALE AGAIN
"..........INTRO LOOP..........
"THIS LOOP IS THE SAME AS MAIN LOOP, BUT THE STORE INTO C(K) HAS BEEN
"ELIMINATED.
"........................INTROLOOP................................
INTROLOOP:                      INC TABLE1;SETTMA;      "FETCH SIN=SIN(W)
                                FADD FM,DPX(R);DPY(-4)<FA; "R+SD2,SAVE QD2+P
                                DPX(DPREV)<DPY(D)       "SAVE D AGAIN
                        LDSPI TABLE;DB=DPY(U);          "COS TABLE ADDRESS
                        DPY(D)<FA;                      "SAVE D
                                        FMUL TM,DPX(3)  "COS*(SD2+R)
                FIXT DPX(V);                            "FIXT V
                        FMUL DPY(D),DPY(D);             "D2=D*D
                                        DPY(RES2)<FM    "SAVE COS*(QD3+PD)
                                FMUL DPX(DPREV),DPY(-4); "D*(QD2+P)
                                DEC TABLE1;SETTMA       "FETCH COS=COS(W)
                        MOVL TABLE,TABLE1;              "SET UP FOR SINCOS FETCH
                                DPY(-4)<TM;             "SAVE SIN
                                DPX(3)<FA;              "SAVE SD2+R
                                FMUL TM,FA;             "SIN*(SD2+R)
                                        FADD FM,ZERO    "SAVE COS*(SD2+R)
        ADD I,A;SETMA;                                  "FETCH A
                DPY(U)<FA;                              "U=FIXT V
                                        DPX(2)<MD;      "NON FUNTIONAL IN INTRO
                                        FADD DPX(RES1),DPY(RES2)
                                                        "SIN*(SD2+R)+COS*(QD3+PD
                        FMUL FM,DPX(Q);                 "D2*Q
                        DPY(D2)<FM;                     "SAVE D2
                                        FSUBR DPY(-3),FA
                                                  "-SIN*(QD3+PD)+COS*(SD2+R)
                                FMUL FM,DPY(-4);        "(QD3+PD)*SIN
                                FADD FM,ZERO;           "SAVE QD3+PD
                                        DPY(-4)<FA  "SAVE SIN(A) = SIN(W+E)
                                DPX(RES1)<FM;           "SAVE SIN*(SD2+R)
                                        FMUL DPX(2),DPY(-4)  "R*SIN(A)
        FMUL DPX(SCALE),MD;                             "SCALE*A
                FADD ZERO,DPY(U);                       "NORMALIZE U
                        DPX(0)<FM;                      "SAVE QD2
                                        DPY(-4)<FA      "SAVE COS(A)=COS(W+E)
                                DPY(-3)<FM;             "SAVE SIN*(QD3+PD)
                                        FMUL DPX(2),DPY(-4)
                                                        "R*COS(A)
                        FMUL DPX(S),DPY(D2)             "SD2
        DPX(V)<FM;                                      "SAVE V=SCALE*A
                        FADD DPX(0),DPY(P);             "QD2+P
                                FMUL TM,FA;             "COS*(QD3+PD)
                                        DEC NINTRO      "DECREMENT COUNT
        DPY(-2)<DPX(V);                                 "SAVE V AGAIN
                FSUB DPY(-2),FA;                        "D=V-U
                        FMUL;
                                        BNE INTROLOOP
"...................................LOOP.....................................
LOOP:                           INC TABLE1;SETTMA;      "FETCH SIN=SIN(W)
                                FADD FM,DPX(R);DPY(-4)<FA; "SD2+R,SAVE QD2+P
                                DPX(DPREV)<DPY(D)       "SAVE D AGAIN
                        LDSPI TABLE;DB=DPY(U);          "COS TABLE ADDRESS
                        DPY(D)<FA;                      "SAVE D=V-U
                                        FMUL TM,DPX(3)  "COS*(SD2+R)
                FIXT DPX(V);                            "FIXT V
                        FMUL DPY(D),DPY(D);             "D2=D*D
                                        DPY(RES2)<FM;   "SAVE COS*(QD3+PD)
                                        ADD I,B;SETMA   "FETCH B
                                FMUL DPX(DPREV),DPY(-4);"D*(QD2+P)
                                DEC TABLE1;SETTMA       "FETCH COS=COS(W)
                        MOVL TABLE,TABLE1;              "SET UP FOR SINCOS FETCH
                                DPY(-4)<TM;             "SAVE SIN
                                DPX(3)<FA;              "SAVE SD2+R
                                FMUL TM,FA;             "SIN*(SD2+R)
                                        FADD FM,ZERO    "SAVE COS*(SD2+R)
        ADD I,A;SETMA;                                  "FETCH A
                DPY(U)<FA;                              "U=FIXT V
                                        DPX(2)<MD;      "SAVE B
                                        FADD DPX(RES1),DPY(RES2)
                                                        "SIN*(SD2+R)+COS*(QD3+PD
                        FMUL FM,DPX(Q);                 "D2+Q
                        DPY(D2)<FM;                     "SAVE D2
                                        FSUBR DPY(-3),FA
                                                      "-SIN*(QD3+PD)+COS*(SD2+R)
                                FMUL FM,DPY(-4);        "(QD3+PD)*SIN
                                FADD FM,ZERO;           "SAVE QD3+PD
                                        DPY(-4)<FA      "SAVE SIN(A)=SIN(W+E)
                                DPX(RES1)<FM;           "SAVE SIN*(SD2+R)
                                        FMUL DPX(2),DPY(-4); "R*SIN(A)
                                  MOV N,N               "IS ELEMENT COUNT = 0?
        FMUL DPX(SCALE),MD;                             "SCALE*A
                FADD ZERO,DPY(U);                       "NORMALIZE U
                        DPX(0)<FM;                      "SAVE QD2
                                        DPY(-4)<FA;     "SAVE COS(A)=COS(W+E)
                                  BEQ DONE              "EXIT IF COUNT = 0
                                DPY(-3)<FM;             "SAVE SIN*(QD3+PD)
                                        FMUL DPX(2),DPY(-4)
                                                        "R*COS(A)
                        FMUL DPX(S),DPY(D2);            "SD2
                                        ADD K,C;SETMA;MI<FM
                                                        "STORE R*SIN(A)
        DPX(V)<FM;                                      "SAVE V=SCALE*A
                        FADD DPX(0),DPY(P);             "QD2+P
                                FMUL TM,FA;             "COS*(QD3+PD)
                                        DEC N           "DECREMENT COUNT
        DPY(-2)<DPX(V);                                 "SAVE V AGAIN
                FSUB DPY(-2),FA;                        "D=V-U
                        FMUL;
                                        DECMA;MI<FM;BNE LOOP    "STORE R*COS(A)
"..........WRAP UP..........
"CLEAR APSTATUS OF FFT BITS
DONE:   RAPS; LDSPNL STATUS             "GET APSTATUS
        LDSPI MASK; DB=177740           "GET MASK
        AND MASK,STATUS;                "MASK OUT UNWANTED BITS
        LDAPS; DB=SPFN;                 "RESET STATUS
        RETURN
"CONSTANTS (DEPENDENT ON SIZE OF TMROM COSINE TABLE)
"HERE ARE CONSTANTS FOR 2K COSINE TABLE
PCON2K: $FP     .7669903939E-3
QCON2K: $FP    -.7520011830E-10
SCON2K: $FP    -.2941371322E-6
SCLC2K: $FP     .1303797294E4           "(2/PI)*TABLE-SIZE
"HERE ARE CONSTANTS FOR 4K COSINE TABLE
PCON4K: $FP     .3834951970E-3
QCON4K: $FP    -.9400014788E-11
SCON4K: $FP    -.7353428305E-7
SCLC4K: $FP     .2607594588E4
        $END
"****** CVEXP = COMPLEX VECTOR EXPONENTIAL /COMMON/ = REL 3.3, DEC 80 *****
        $TITLE CVEXP
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVEXP,5                          "USER-DIRECTED-CALL ENTRY
"
"               ---ABSTRACT---
"VECTOR CVEXP  (ANGLES IN RADIANS)  EXP(IX)=COS(X)+ISIN(X)
"DOES C( MK ) = COS ( A(MI) )   FOR M = 0 TO N-1
"AND  C( MK+1 ) = SIN ( A(MI) )   FOR M = 0 TO N-1
"
"               ---STATISTICS---
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH EITHER MEMORY
"SIZE: 52. LOCATIONS
"EXECUTION       BEST     TYPICAL     WORST     SETUP
"TIME/LOOP:       2.0       2.0        2.0       9.2   (167 NS MEMORY)
"(US)             2.0       2.0        2.0       9.2   (333 NS MEMORY)
"
"               ---HISTORY---
"AUTHOR:  H. WILLIAMS           (MAY 78)        VSIN AND VCOS SEPARATELY
"         D. DAVIS              (AUG 78)        VECTOR(COS + ISIN)
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2:  MAR 80  R.S. NORIN   COMBINES 2K AND 4K TMROM VERSIONS
" REV 3.3 AND 2A.3:  DEC 80  D. DAVIS  INITIALIZES VECTOR C CORRECTLY
"
"               ---USAGE---
"FORTRAN CALL: CALL CVEXP (A, I, C, K, N)
"APAL CALL:    JSR CVEXP
"SCRATCH: SP(0,2,4,13.-15.),DPX(-4 TO +3),DPY(-4,-3,-1 TO +2),FA,FM,MD,TM
"SUBROUTINES USED: NONE
"
"S-PAD PARAMETERS:
A $EQU 0
I $EQU 1
C $EQU 2
K $EQU 3                                     "INCREMENT AT LEAST 2
N $EQU 4
"
"               ---ALGORITHM---
"CVEXP IS COMPUTED BY LOOKUP FROM TM ROM COSINE TABLE, FOLLOWED
"BY INTERPOLATION USING SIN(A) = SIN(W+E) = SIN(W)COS(E) + COS(W)SIN(E),
"AND                    COS(A) = COS(W+E) = COS(W)COS(E) - SIN(W)SIN(E)
"WHERE SIN(E) AND COS(E) ARE APPROXIMATED BY TAYLOR SERIES
"AND SIN(W) AND COS(W) ARE FROM TABLE LOOKUP.
"
"               ---SCRATCH---
"S-PAD:
STATUS $EQU 17
TABLE $EQU 17
MASK $EQU 16
TABLE1 $EQU 16
NINTRO $EQU 15
"
"DPX:
Q $EQU -4
S $EQU -3
R $EQU -2
SCALE $EQU -1
V $EQU 0
RES1 $EQU 1
DPREV $EQU 2
RESULT $EQU 2
"AND OTHER TEMPORARY
"DPY:
P $EQU -1
U $EQU 0
D $EQU 1
D2 $EQU 2
RES2 $EQU 2
"
"..........START OF CODE..........
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVEXP,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FCVEXP: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVEXP:  LDTMA; DB=4371;                 "THIS TM LOCATION IS ZERO FOR
                                        "2.5K TMROM, NONZERO FOR 4.5K
         SUB K,C                          "BACKUP OUTPUT POINTER
         INC C
        LDSPI MASK; DB=30               "GET MASK FOR STATUS REGISTER
        MOV A,A; SETMA;                 "FETCH A(1)
         DB=TM                          "TEST TM LOCATION 4371
        LDTMA; DB=!ONE;                 "FETCH 1.0
         BDBZ TWOK                      "BRANCH IF 2.5K TMROM
"HERE IF 4K COSINE TABLE
        RPSF SCLC4K; DPX(SCALE)<DB      "GET SCALE FACTOR
        RPSF PCON4K; DPY(P)<DB          "GET P
        RPSF QCON4K; DPX(Q)<DB          "GET Q
        RPSF SCON4K; DPX(S)<DB;         "GET S
         BR CONT                        "PROCEED TO COMMON CODE
"HERE IF 2K COSINE TABLE
TWOK:   RPSF SCLC2K; DPX(SCALE)<DB      "GET SCALE FACTOR
        RPSF PCON2K; DPY(P)<DB          "GET P
        RPSF QCON2K; DPX(Q)<DB          "GET Q
        RPSF SCON2K; DPX(S)<DB          "GET S
"SET APSTATUS SO THAT IFFT=1, FFT=1  (TO ACCESS TM ROM COSINE TABLE)
CONT:   RAPS; LDSPNL STATUS;            "GET APSTATUS
           FMUL DPX(SCALE),MD;          "   A(1) * SCALE-FACTOR
           DPX(R)<TM                    "   SAVE 1.0
           FMUL
        OR MASK,STATUS;
           LDAPS; DB=SPFN;              "SET STATUS
              FMUL
             DPX(V)<FM;                 "SAVE A*SCALE
        LDSPI NINTRO; DB=3              "SET LOOP COUNTER FOR INTRO
"..........INTRO LOOP..........
"THIS LOOP IS THE SAME AS MAIN LOOP, BUT THE STORE INTO C(K) HAS BEEN
"ELIMINATED.
"........................INTROLOOP................................
INTROLOOP:                       INC TABLE1;SETTMA;      "FETCH SIN=SIN(W)
                                FADD FM,DPX(R);DPY(-4)<FA;   "SD2+R,SAVE QD2+P
                                DPX(DPREV)<DPY(D)        "SAVE D AGAIN
                        LDSPI TABLE;DB=DPY(U);          "SINCOS TABLE ADDRESS
                        DPY(D)<FA;                      "SAVE D
                                        FMUL TM,DPX(3)  "COS*(SD2+R)
                FIXT DPX(V);                            "FIXT V
                        FMUL DPY(D),DPY(D);             "D2=D*D
                                        DPY(RES2)<FM    "SAVE COS*(QD3+PD)
                                FMUL DPX(DPREV),DPY(-4); "D*(QD2+P)
                                DEC TABLE1;SETTMA       "FETCH COS=COS(W)
        ADD I,A;SETMA;                                  "FETCH A
                                DPY(-4)<TM;             "SAVE SIN
                                DPX(3)<FA;              "SAVE SD2+R
                                FMUL TM,FA;             "SIN*(SD2+R)
                                        FADD FM,ZERO    "SAVE COS*(SD2+R)
                DPY(U)<FA;                              "SAVE U=FIXT V
                        MOVL TABLE,TABLE1;              "SETUP FOR SINCOS FETCH
                                        FADD DPX(RES1),DPY(RES2)
                                                        "SIN*(SD2+R)+COS*(QD3+PD
                        FMUL FM,DPX(Q);                 "D2*Q
                        DPY(D2)<FM;                     "SAVE D2
                                        FSUBR DPY(-3),FA
                                                      "-SIN*(QD3+PD)+COS*(SD2+R)
                                FMUL FM,DPY(-4);        "(QD3+PD)*SIN
                                FADD FM,ZERO           "SAVE (QD3+PD)
        FMUL DPX(SCALE),MD;                             "SCALE*A
                FADD ZERO,DPY(U);                       "NORMALIZE U
                                DPX(RES1)<FM;           "SAVE SIN*(SD2+R)
                                        DPY(-4)<FA      "SAVE COS(A)
                                                "=COS*(SD2+R)-SIN*(QD3+PD)
                        FMUL DPX(S),DPY(D2);            "SD2
                        DPX(2)<FM;                      "SAVE QD2
                                MOV N,N               "IS ELEMENT COUNT = 0?
                        FADD DPX(2),DPY(P);             "QD2+P
                                FMUL TM,FA;             "COS*(QD3+PD)
                                DPY(-3)<FM;             "SAVE SIN*(QD3+PD)
                                        DEC NINTRO;     "DECREMENT COUNT
                                BEQ DONE              "EXIT IF COUNT = 0
        DPX(V)<FM;                                      "SAVE V=SCALE*A
                FSUB DPX(V),FA;                         "D=V-U
                        FMUL;
                                        BNE INTROLOOP
"...................MAIN LOOP.................................
LOOP:                           INC TABLE1;SETTMA;      "FETCH SIN=SIN(W)
                                FADD FM,DPX(R);DPY(-4)<FA;   "SD2+R,SAVE QD2+P
                                DPX(DPREV)<DPY(D)        "SAVE D AGAIN
                        LDSPI TABLE;DB=DPY(U);          "SINCOS TABLE ADDRESS
                        DPY(D)<FA;                      "SAVE D
                                        FMUL TM,DPX(3)  "COS*(SD2+R)
                FIXT DPX(V);                            "FIXT V
                        FMUL DPY(D),DPY(D);             "D2=D*D
                                        DPY(RES2)<FM    "SAVE COS*(QD3+PD)
                                FMUL DPX(DPREV),DPY(-4); "D*(QD2+P)
                                DEC TABLE1;SETTMA       "FETCH COS=COS(W)
        ADD I,A;SETMA;                                  "FETCH A
                                DPY(-4)<TM;             "SAVE SIN
                                DPX(3)<FA;              "SAVE SD2+R
                                FMUL TM,FA;             "SIN*(SD2+R)
                                        FADD FM,ZERO    "SAVE COS*(SD2+R)
                DPY(U)<FA;                              "SAVE U=FIXT V
                        MOVL TABLE,TABLE1;              "SETUP FOR SINCOS FETCH
                                        FADD DPX(RES1),DPY(RES2)
                                                        "SIN*(SD2+R)+COS*(QD3+PD
                        FMUL FM,DPX(Q);                 "D2*Q
                        DPY(D2)<FM;                     "SAVE D2
                                        FSUBR DPY(-3),FA
                                                      "-SIN*(QD3+PD)+COS*(SD2+R)
                                FMUL FM,DPY(-4);        "(QD3+PD)*SIN
                                FADD FM,ZERO;           "SAVE (QD3+PD)
                                        ADD K,C;SETMA;MI<FA
                                         "STORE SIN(A)=SIN*(SD2+R)+COS*(QD3+PD)
        FMUL DPX(SCALE),MD;                             "SCALE*A
                FADD ZERO,DPY(U);                       "NORMALIZE U
                                DPX(RES1)<FM;           "SAVE SIN*(SD2+R)
                                        DPY(-4)<FA      "SAVE COS(A)
                                                "=COS*(SD2+R)-SIN*(QD3+PD)
                        FMUL DPX(S),DPY(D2);            "SD2
                        DPX(2)<FM                       "SAVE QD2
                        FADD DPX(2),DPY(P);             "QD2+P
                                FMUL TM,FA;             "COS*(QD3+PD)
                                DPY(-3)<FM;             "SAVE SIN*(QD3+PD)
                                        DEC N           "DECREMENT COUNT
        DPX(V)<FM;                                      "SAVE V=SCALE*A
                FSUB DPX(V),FA;                         "D=V-U
                        FMUL;
                                        DECMA;MI<DPY(-4);
                                          "STORE COS(A)=COS*(SD2+R)-SIN*(QD3+PD)
                                        BNE LOOP
"..........WRAP UP..........
"CLEAR APSTATUS OF FFT BITS
DONE:   RAPS; LDSPNL STATUS             "GET APSTATUS
        LDSPI MASK; DB=177740           "GET MASK
        AND MASK,STATUS;                "MASK OUT UNWANTED BITS
        LDAPS; DB=SPFN;                 "RESET STATUS
        RETURN
"CONSTANTS (DEPENDENT ON SIZE OF TMROM COSINE TABLE)
"HERE ARE CONSTANTS FOR 2K COSINE TABLE
PCON2K: $FP     .7669903939E-3
QCON2K: $FP    -.7520011830E-10
SCON2K: $FP    -.2941371322E-6
SCLC2K: $FP     .1303797294E4           "(2/PI)*TABLE-SIZE
"HERE ARE CONSTANTS FOR 4K COSINE TABLE
PCON4K: $FP     .3834951970E-3
QCON4K: $FP    -.9400014788E-11
SCON4K: $FP    -.7353428305E-7
SCLC4K: $FP     .2607594588E4
        $END
"****** CVMEXP = COMPLEX VECTOR MULTIPLY EXPONENTIAL /COMMON/ = REL 3.3, DEC 80
        $TITLE CVMEXP
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CVMEXP,7                          "USER-DIRECTED-CALL ENTRY
"
"               ---ABSTRACT---
"DOES  C( MK ) = B(MJ) * COS ( A(MI) )   FOR M = 0 TO N-1
"AND  C( MK+1 ) = B(MJ) * SIN ( A(MI) )   FOR M = 0 TO N-1
"                  (ANGLES IN RADIANS)
"
"               ---STATISTICS---
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH EITHER MEMORY
"SIZE: 57. LOCATIONS
"EXECUTION       BEST     TYPICAL     WORST     SETUP
"TIME/LOOP:       2.3       2.3        2.3       10.3   (167 NS MEMORY)
"(US)             2.3       2.3        2.3       10.3   (333 NS MEMORY)
"
"               ---HISTORY---
"AUTHOR:  H. WILLIAMS  (MAY 78)  ORIGINAL VCOS AND VSIN
"         D. DAVIS     (AUG 78)  MODIFIED FOR COMPLEX EXPONENRIAL MULTIPLICATION
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2:  MAR 80  R.S. NORIN   COMBINES 2K AND 4K TMROM VERSIONS
" REV 3.3 AND 2A.3:  DEC 80  D. DAVIS  INITIALIZES VECTOR C CORRECTLY
"
"               ---USAGE---
"FORTRAN  CALL: CALL CVMEXP (A, I, B, J, C, K, N)
"APAL CALL:    JSR CVMEXP
"SCRATCH: SP(0,2,4,6,13.-15.),DPX(-4 TO +3),DPY(-4 TO +2),FA,FM,MD,TM
"SUBROUTINES USED: NONE
"
"S-PAD PARAMETERS:
A $EQU 0
I $EQU 1
B $EQU 2
J $EQU 3
C $EQU 4
K $EQU 5
N $EQU 6
"
"               ---ALGORITHM---
"CVMEXP IS COMPUTED BY LOOKUP FROM TM ROM COSINE TABLE, FOLLOWED
"BY INTERPOLATION USING SIN(A) = SIN(W+E) = SIN(W)COS(E) + COS(W)SIN(E),
"                   AND COS(A) = COS(W+E) = COS(W)COS(E) - SIN(W)SIN(E)
"WHERE SIN(E) AND COS(E) ARE APPROXIMATED BY TAYLOR SERIES
"AND SIN(W) AND COS(W) ARE FROM TABLE LOOKUP AND THEN
"MULTIPLICATION B*COS(A) AND B*SIN(A).
"
"               ---SCRATCH---
"S-PAD:
STATUS $EQU 17
TABLE $EQU 17
MASK $EQU 16
TABLE1 $EQU 16
NINTRO $EQU 15
"
"DPX:
Q $EQU -4
S $EQU -3
R $EQU -2
SCALE $EQU -1
V $EQU 0
RES1 $EQU 1
DPREV $EQU 2
RESULT $EQU 2
"AND OTHER TEMPORARY
"DPY:
P $EQU -1
U $EQU 0
D $EQU 1
D2 $EQU 2
RES2 $EQU 2
"
"..........START OF CODE..........
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCVMEX,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FCVMEX: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVMEXP: LDTMA; DB=4371;                 "THIS TM LOCATION IS ZERO FOR
                                        "2.5K TMROM, NONZERO FOR 4.5K
         SUB K,C                          "BACKUP OUTPUT POINTER
         INC C
        LDSPI MASK; DB=30               "GET MASK FOR STATUS REGISTER
        MOV A,A; SETMA;                 "FETCH A(1)
         DB=TM                          "TEST TM LOCATION 4371
        LDTMA; DB=!ONE;                 "FETCH 1.0
         BDBZ TWOK                      "BRANCH IF 2.5K TMROM
"HERE IF 4K COSINE TABLE
        RPSF SCLC4K; DPX(SCALE)<DB      "GET SCALE FACTOR
        RPSF PCON4K; DPY(P)<DB          "GET P
        RPSF QCON4K; DPX(Q)<DB          "GET Q
        RPSF SCON4K; DPX(S)<DB;         "GET S
         BR CONT                        "PROCEED TO COMMON CODE
"HERE IF 2K COSINE TABLE
TWOK:   RPSF SCLC2K; DPX(SCALE)<DB      "GET SCALE FACTOR
        RPSF PCON2K; DPY(P)<DB          "GET P
        RPSF QCON2K; DPX(Q)<DB          "GET Q
        RPSF SCON2K; DPX(S)<DB          "GET S
"SET APSTATUS SO THAT IFFT=1, FFT=1  (TO ACCESS TM ROM COSINE TABLE)
CONT:   RAPS; LDSPNL STATUS;            "GET APSTATUS
           FMUL DPX(SCALE),MD;          "   A(1) * SCALE-FACTOR
           DPX(R)<TM                    "   SAVE 1.0
           FMUL; SUB J,B                "INITIALIZE B
        OR MASK,STATUS;
           LDAPS; DB=SPFN;              "SET STATUS
              FMUL
             DPX(V)<FM;                 "SAVE V=A*SCALE
        LDSPI NINTRO; DB=3              "SET LOOP COUNTER FOR INTRO
                DPY(-2)<DPX(V)                  "SAVE V=A*SCALE AGAIN
"..........INTRO LOOP..........
"THIS LOOP IS THE SAME AS MAIN LOOP, BUT THE STORE INTO C(K) HAS BEEN
"ELIMINATED.
"........................INTROLOOP................................
INTROLOOP:                      INC TABLE1;SETTMA;      "FETCH SIN=SIN(W)
                                FADD FM,DPX(R);DPY(-4)<FA; "R+SD2,SAVE QD2+P
                                DPX(DPREV)<DPY(D)       "SAVE D AGAIN
                        LDSPI TABLE;DB=DPY(U);          "COS TABLE ADDRESS
                        DPY(D)<FA;                      "SAVE D
                                        FMUL TM,DPX(3)  "COS*(SD2+R)
                FIXT DPX(V);                            "FIXT V
                        FMUL DPY(D),DPY(D);             "D2=D*D
                                        DPY(RES2)<FM    "SAVE COS*(QD3+PD)
                                FMUL DPX(DPREV),DPY(-4); "D*(QD2+P)
                                DEC TABLE1;SETTMA       "FETCH COS=COS(W)
                        MOVL TABLE,TABLE1;              "SET UP FOR SINCOS FETCH
                                DPY(-4)<TM;             "SAVE SIN
                                DPX(3)<FA;              "SAVE SD2+R
                                FMUL TM,FA;             "SIN*(SD2+R)
                                        FADD FM,ZERO    "SAVE COS*(SD2+R)
        ADD I,A;SETMA;                                  "FETCH A
                DPY(U)<FA;                              "U=FIXT V
                                        DPX(2)<MD;      "NON FUNTIONAL IN INTRO
                                        FADD DPX(RES1),DPY(RES2)
                                                        "SIN*(SD2+R)+COS*(QD3+PD
                        FMUL FM,DPX(Q);                 "D2*Q
                        DPY(D2)<FM;                     "SAVE D2
                                        FSUBR DPY(-3),FA
                                                  "-SIN*(QD3+PD)+COS*(SD2+R)
                                FMUL FM,DPY(-4);        "(QD3+PD)*SIN
                                FADD FM,ZERO;           "SAVE QD3+PD
                                        DPY(-4)<FA  "SAVE SIN(A) = SIN(W+E)
                                DPX(RES1)<FM;           "SAVE SIN*(SD2+R)
                                        FMUL DPX(2),DPY(-4)  "R*SIN(A)
        FMUL DPX(SCALE),MD;                             "SCALE*A
                FADD ZERO,DPY(U);                       "NORMALIZE U
                        DPX(0)<FM;                      "SAVE QD2
                                        DPY(-4)<FA      "SAVE COS(A)=COS(W+E)
                                DPY(-3)<FM;             "SAVE SIN*(QD3+PD)
                                        FMUL DPX(2),DPY(-4)
                                                        "R*COS(A)
                        FMUL DPX(S),DPY(D2)             "SD2
        DPX(V)<FM;                                      "SAVE V=SCALE*A
                        FADD DPX(0),DPY(P);             "QD2+P
                                FMUL TM,FA;             "COS*(QD3+PD)
                                        DEC NINTRO      "DECREMENT COUNT
        DPY(-2)<DPX(V);                                 "SAVE V AGAIN
                FSUB DPY(-2),FA;                        "D=V-U
                        FMUL;
                                        BNE INTROLOOP
"...................................LOOP.....................................
LOOP:                           INC TABLE1;SETTMA;      "FETCH SIN=SIN(W)
                                FADD FM,DPX(R);DPY(-4)<FA; "SD2+R,SAVE QD2+P
                                DPX(DPREV)<DPY(D)       "SAVE D AGAIN
                        LDSPI TABLE;DB=DPY(U);          "COS TABLE ADDRESS
                        DPY(D)<FA;                      "SAVE D=V-U
                                        FMUL TM,DPX(3)  "COS*(SD2+R)
                FIXT DPX(V);                            "FIXT V
                        FMUL DPY(D),DPY(D);             "D2=D*D
                                        DPY(RES2)<FM;   "SAVE COS*(QD3+PD)
                                        ADD J,B;SETMA   "FETCH B
                                FMUL DPX(DPREV),DPY(-4);"D*(QD2+P)
                                DEC TABLE1;SETTMA       "FETCH COS=COS(W)
                        MOVL TABLE,TABLE1;              "SET UP FOR SINCOS FETCH
                                DPY(-4)<TM;             "SAVE SIN
                                DPX(3)<FA;              "SAVE SD2+R
                                FMUL TM,FA;             "SIN*(SD2+R)
                                        FADD FM,ZERO    "SAVE COS*(SD2+R)
        ADD I,A;SETMA;                                  "FETCH A
                DPY(U)<FA;                              "U=FIXT V
                                        DPX(2)<MD;      "SAVE B
                                        FADD DPX(RES1),DPY(RES2)
                                                        "SIN*(SD2+R)+COS*(QD3+PD
                        FMUL FM,DPX(Q);                 "D2+Q
                        DPY(D2)<FM;                     "SAVE D2
                                        FSUBR DPY(-3),FA
                                                      "-SIN*(QD3+PD)+COS*(SD2+R)
                                FMUL FM,DPY(-4);        "(QD3+PD)*SIN
                                FADD FM,ZERO;           "SAVE QD3+PD
                                        DPY(-4)<FA;     "SAVE SIN(A)=SIN(W+E)
                                  MOV N,N               "IS ELEMENT COUNT = 0?
                                DPX(RES1)<FM;           "SAVE SIN*(SD2+R)
                                        FMUL DPX(2),DPY(-4); "R*SIN(A)
                                  BEQ DONE              "EXIT IF COUNT = 0
        FMUL DPX(SCALE),MD;                             "SCALE*A
                FADD ZERO,DPY(U);                       "NORMALIZE U
                        DPX(0)<FM;                      "SAVE QD2
                                        DPY(-4)<FA      "SAVE COS(A)=COS(W+E)
                                DPY(-3)<FM;             "SAVE SIN*(QD3+PD)
                                        FMUL DPX(2),DPY(-4)
                                                        "R*COS(A)
                        FMUL DPX(S),DPY(D2);            "SD2
                                        ADD K,C;SETMA;MI<FM
                                                        "STORE R*SIN(A)
        DPX(V)<FM;                                      "SAVE V=SCALE*A
                        FADD DPX(0),DPY(P);             "QD2+P
                                FMUL TM,FA;             "COS*(QD3+PD)
                                        DEC N           "DECREMENT COUNT
        DPY(-2)<DPX(V);                                 "SAVE V AGAIN
                FSUB DPY(-2),FA;                        "D=V-U
                        FMUL;
                                        DECMA;MI<FM;BNE LOOP    "STORE R*COS(A)
"..........WRAP UP..........
"CLEAR APSTATUS OF FFT BITS
DONE:   RAPS; LDSPNL STATUS             "GET APSTATUS
        LDSPI MASK; DB=177740           "GET MASK
        AND MASK,STATUS;                "MASK OUT UNWANTED BITS
        LDAPS; DB=SPFN;                 "RESET STATUS
        RETURN
"CONSTANTS (DEPENDENT ON SIZE OF TMROM COSINE TABLE)
"HERE ARE CONSTANTS FOR 2K COSINE TABLE
PCON2K: $FP     .7669903939E-3
QCON2K: $FP    -.7520011830E-10
SCON2K: $FP    -.2941371322E-6
SCLC2K: $FP     .1303797294E4           "(2/PI)*TABLE-SIZE
"HERE ARE CONSTANTS FOR 4K COSINE TABLE
PCON4K: $FP     .3834951970E-3
QCON4K: $FP    -.9400014788E-11
SCON4K: $FP    -.7353428305E-7
SCLC4K: $FP     .2607594588E4
        $END
"****** VCLR = VECTOR CLEAR /FAST/ = REL 3.2, AUG 80 *****
       $TITLE VCLR
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY VCLR,3                          "USER-DIRECTED-CALL ENTRY
       $EXT SPUFLT
"
"                               --- STATISTICS ---
"EQUIPMENT:  AP-120B WITH FAST MEMORY
"
"     ---HISTORY---
"ORIGINAL:  SEP 76  A.E. CHARLESWORTH
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80  R.D. GELLER    CORRECTED ADC LINKAGE
"
"SIZE:  8 + SPUFLT (8) = 16 LOCATIONS
"
"
       "S-PAD NAMES
       C $EQU 0                 "BASE ADDRESS OF C
       K $EQU 1                 "INCREMENT FOR C
       N $EQU 2                 "NUMBER OF ELEMENTS IN C
"
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVCLR,3                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  6
        $PARAM  3 , P1(#2,#3)/R/OP, P2/I/IP, P3/I/IP
FVCLR: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VCLR:   MOV N,17
                                "FETCH 1.0 FROM TM
        JSR SPUFLT               "FLOAT N AND LEAVE IN DPX(1)
        BFEQ DONE;              "EXIT IF COUNT = 0
        LDTMA; DB=!TWO          "FETCH 2.0
        FSUBR TM,DPX(1)         "DECREMENT COUNT ONCE FOR C(0)
        FSUBR TM,DPX(1)         "DECREMENT COUNT TWICE FOR C(1)
        FSUBR TM,FA;
          SUB K,C
LOOP:   MI<ZERO; ADD K,C; SETMA; "STORE ZERO
          FSUBR TM,FA;          "DECREMENT COUNT BY TWO
          BFGT LOOP             "BRANCH BACK IF NOT DONE
DONE:   RETURN                  "EXIT
        $END
"****** VMOV = VECTOR MOVE /FAST/ = REL 3.1, SEP 79 *****
       $TITLE VMOV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY VMOV, 5                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE:  8 LOCATIONS + SPUFLT (8) = 16 LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REV 2.0:  AUG 77  R.S. NORIN      ALLOWS N>32767
" REV 2.1:  JUN 78  R.S. NORIN      NO LONGER NORMALIZES NUMBERS WHILE MOVING
" REV 2.2:  SEP 78  R.S. NORIN      HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"VECTOR MOVE
"VECTOR MOVE, I.E. C(MK) = A(MI)   FOR I=0 TO N-1
"LOOP CONTROL IS DONE IN THE FLOATING ADDER.  A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"SCRATCH:
"S-PADS:    0,2,17
"      DPX:   1.
"S-PAD PARAMETERS:
"    NAME      REG NUMBER               MEANING
        A $EQU 0                        "BASE ADDRESS OF VECTOR A
        I $EQU 1                        "INCREMENT FOR A
        C $EQU 2                        "BASE ADDRESS OF VECTOR C
        K $EQU 3                        "INCREMENT FOR C
        N $EQU 4                        "ELEMENT OUUNT FOR C
       NM $EQU 17
"DATA PAD PARAMETERS:
       NN $EQU 1                       "FLOATED VECTOR LENGTH
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVMOV,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVMOV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VMOV:  MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                 MOV A,A;SETMA         "FETCH A(0)
                 SUB K,C;              "BACK UP POINTER
                  FSUBR TM,DPX(NN)     "INITIALIZE COUNTER
                 FADD
LOOP:  ADD I,A;SETMA;                   "FETCH A(M+1)
            FSUBR TM,FA                "DECREMENT COUNTER
            FADD;                      "PUSH COUNT
                 ADD K,C;SETMA;MI<MD;  "STORE RESULT
                 BFGT LOOP             "BRANCH IF NOT DONE
DONE:   RETURN                  "EXIT
       $END
"****** VSWAP = VECTOR SWAP /FAST/ = REL 3.2, MAR 80 *****
        $TITLE VSWAP
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSWAP,5.                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "THIS ALGORITHM SWAPS THE CORRESPONDING COMPONENTS OF
        "VECTORS A AND C WHICH ARE INCREMENTED BY I AND K RESP.
        "THE NUMBER OF COMPONENTS IS GIVEN BY N.
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST MEMORY
        "SIZE:      13. + SPUFLT (8) = 21. LOCATIONS
        "TIME:      WORST CASE:  8*N+13.
        "           BEST CASE:   4*N+13.
"
"     ---HISTORY---
"ORIGINAL:  JUL 77  STUART BERKOWITZ
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REVISED:  MAR 80  D.GANGULY.     $PARAM MODIFIED TO REFLECT THE
"                                  FACT THAT THE ARRAYS A & C
"                                  ARE BOTH INPUT/OUTPUT ARRAYS.
"
        A $EQU 0                                "BASE ADDR OF A
        I $EQU 1                                "INCREMENT FOR A
        C $EQU 2                                "BASE ADDR OF C
        K $EQU 3                                "INCREMENT OF C
        N $EQU 4                                "LENGTH OF VECTORS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSWAP,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP/OP, P2/I/IP,
                    P3(#4,#5)/R/IP/OP, P4/I/IP,
                    P5/I/IP
FVSWAP: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSWAP:  MOV N,17                                        "FLOAT N INTO DPX(1)
        JSR SPUFLT
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV A,A;SETMA                           "3,FETCH A
        MOV C,C;SETMA                           "4,FETCH C
                NOP
                FADD ZERO,MD                    "2,RECYCLE A
        ADD I,A;SETMA;                          "3,FETCH A
                FADD ZERO,MD                    "3,RECYCLE B
        ADD K,C;SETMA;                          "4,FETCH B
                FADD ZERO,FA                    "4,RECYCLE A
LOOP:                   SUB# I,A;SETMA;MI<FA;   "1,STORE A
                        FSUBR TM,DPX(1)         "1,N-1
                FADD ZERO,MD;                   "2,RECYCLE A
                        SUB# K,C;SETMA;MI<FA    "2,STORE C
        ADD I,A;SETMA;                          "3,FETCH A
                FADD ZERO,MD;                   "3,RECYCLE C
                        DPX(1)<FA               "3
        ADD K,C;SETMA;                          "4,FETCH C
                FADD ZERO,FA;                   "4,RECYCLE A
                        BFGT LOOP               "4
DONE:   RETURN                  "EXIT
        $END
"****** VNEG = VECTOR NEGATE /FAST/ = REL 3.1, SEP 79 *****
       $TITLE VNEG
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY VNEG, 5                          "USER-DIRECTED-CALL ENTRY
       $EXT SPUFLT
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE:  10 + SPUFLT (8) = 18 LOCATIONS
"
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN     ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"VECTOR NEGATE
"          DOES C(MK) = - A(MI)
"LOOP CONTROL IS DONE IN THE FLOATING ADDER.  A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"S-PAD PARAMETERS:
"     NAME    REGISTER                  PURPOSE
        A $EQU 0                        "BASE ADDRESS OF VECTOR A
        I $EQU 1                        "INCREMENT FOR VECTOR A
        C $EQU 2                        "BASE ADDRESS FOR VECTOR C
        K $EQU 3                        "INCREMENT FOR VECTOR C
        N $EQU 4                        "ELEMENT COUNT OF VECTOR C
       NM $EQU 17
"DATA PAD PARAMETERS:
           NN $EQU 1                   "FLOATED VECTOR LENGTH
"SCRATCH:         S-PADS:  0,2,4,17
"          DPX: 1.
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVNEG,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVNEG: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VNEG:  MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                 MOV A,A;SETMA         "FETCH A(0)
                 FSUBR TM,DPX(NN)      "INITIALIZE COUNTER
                 SUB K,C               "BACK UP C POINTER
             ADD I,A;SETMA;            "FETCH A(1)
                 FSUBR TM,FA           "DECREMENT COUNTER
                 FSUB ZERO,MD          "ZERO - A(0)
LOOP:  ADD I,A;SETMA;                  "FETCH A(M)
            FSUBR TM,FA                "DECREMENT COUNTER
            FSUB  ZERO,MD;             "ZERO - A(M+1)
                 ADD K,C;SETMA;MI<FA;  "C(M+2)<-A(M+2)
                 BFGT LOOP
DONE:   RETURN                  "EXIT
       $END
"****** VADD = VECTOR ADD /FAST/ = REL 3.1, SEP 79 *****
       $TITLE VADD
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY VADD, 7                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"VECTOR ADD
"       --- ABSTRACT ---
"ADDS VECTOR A TO VECTOR B AND PUTS THE RESULT INTO VECTOR C
"C(MK) = B(MJ) + A(MI)     FOR M = 0 TO N-1
"LOOP CONTROL IS DONE IN THE FLOATING ADDER. A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE:  12  + SPUFLT (8) = 20 LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN     ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                  --- USEAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        B   $EQU   2                    "BASE ADDRESS OF VECTOR B
        J   $EQU   3                    "INDEX BETWEEN ELEMENTS OF B
        C   $EQU 4                      "BASE ADDRESS OF C
        K   $EQU   5                    "INDEX BETWEEN ELEMENTS OF C
        N   $EQU 6                      "NUMBER OF ELEMENTS IN C
       NM $EQU 17
"DATA PAD PARAMETERS:
       NN $EQU 1                       "FLOATED VECTOR LENGTH
"                  --- SCRATCH ---
"S-PADS:     0,2,4,17
"DPX:   0,1    (RELATIVE TO DPA)
"DPY:   0
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVADD,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVADD: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VADD:  MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                 MOV A,A;SETMA         "FETCH A(0)
                 MOV B,B;SETMA         "FETCH B(0)
                 SUB K,C
           ADD I,A;SETMA;              "FETCH A(1)
                 DPX<MD                "STORE A(0)
            ADD J,B;SETMA;             "FETCH B(1)
                 DPY<MD;               "STORE B(0)
                 FSUBR TM,DPX(NN)      "INITIALIZE COUNTER
                 FADD DPX,DPY          "A(0) + B(0)
LOOP:  ADD I,A;SETMA;                   "FETCH A(M)
            DPX<MD                     "STORE A(M+1)
       ADD J,B;SETMA;                  "FETCH B(M)
            DPY<MD;                    "STORE B(M+1)
            FSUBR TM,FA                "DECREMENT COUNTER
            FADD DPX,DPY;              "A(M+1) + B(M+1)
                 ADD K,C;SETMA;MI<FA;  "STORE A(M+2)+B(M+2)
                 BFGT LOOP             "BRANCH IF NOT DONE
DONE:   RETURN                  "EXIT
       $END
"****** VSUB = VECTOR SUBTRACT /FAST/ = REL 3.1, SEP 79 *****
       $TITLE VSUB
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY VSUB, 7                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"VECTOR SUBTRACT
"       --- ABSTRACT ---
"SUBTRACTS  VECTOR B FROM VECTOR A AND PUTS RESULT IN VECTOR C
"C(M) = B(M) - A(M)   FOR M = 0 TO N-1
"LOOP CONTROL IS DONE IN THE FLOATING ADDER. A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE:   12 + SPUFLT (8) = 20 LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN     ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                  --- USEAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        B   $EQU   2                    "BASE ADDRESS OF VECTOR B
        J   $EQU   3                    "INDEX BETWEEN ELEMENTS OF B
        C   $EQU 4                      "BASE ADDRESS OF C
        K   $EQU   5                    "INDEX BETWEEN ELEMENTS OF C
        N   $EQU 6                      "NUMBER OF ELEMENTS IN C
       NM $EQU 17
"DATA-PAD PARAMETERS:
       NN $EQU 1                       "FLOATED VECTOR LENGTH
"                  --- SCRATCH ---
"S-PADS:   0,2,4,17
"DPX:      0, 1   (RELATIVE TO DPA)
"DPY:      0
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSUB,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVSUB: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSUB:  MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                 MOV A,A;SETMA         "FETCH A(0)
                 MOV B,B;SETMA         "FETCH B(0)
                 SUB K,C
           ADD I,A;SETMA;              "FETCH A(1)
                 DPX<MD                "STORE A(0)
            ADD J,B;SETMA;             "FETCH B(1)
                 DPY<MD;               "STORE B(0)
                 FSUBR TM,DPX(NN)      "INITIALIZE COUNTER
                 FSUB DPY,DPX          "B(0) - A(0)
LOOP:  ADD I,A;SETMA;                   "FETCH A(M)
            DPX<MD                     "STORE A(M+1)
       ADD J,B;SETMA;                  "FETCH B(M)
            DPY<MD;                    "STORE B(M+1)
            FSUBR TM,FA                "DECREMENT COUNTER
            FSUB DPY,DPX;              "B(M+1) - A(M+1)
                 ADD K,C;SETMA;MI<FA;  "STORE A(M+2) - B(M+2)
                 BFGT LOOP             "BRANCH IF NOT DONE
DONE:   RETURN                  "EXIT
       $END
"****** VMUL = VECTOR MULTIPLY /FAST/ = REL 3.1, SEP 79 *****
       $TITLE VMUL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY VMUL, 7                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"REAL VECTOR ELEMENT/ELEMENT MULTIPLY
"DOES C(MK) = A(MI) * B(MJ),   FOR M = 0 TO N-1
"LOOP CONTROL IS DONE IN THE FLOATING ADDER. A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"                  --- STATISTICS ---
"SIZE:  12 + SPUFLT (8) = 20 LOCATIONS
"SPEED: 3 MEMORY REFERENCES PER POINT
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN     ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"S-PAD PARAMETERS
        A $EQU 0        "BASE ADDRESS OF A
        I $EQU 1        "INCREMENT FOR A
        B $EQU 2        "BASE ADDRESS OF B
        J $EQU 3        "INCREMENT FOR B
        C $EQU 4        "BASE ADDRESS OF C
        K $EQU 5        "INCREMENT FOR C
        N $EQU 6        "ELEMENT COUNT FOR C
       NM $EQU 17
"DATA-PAD PARAMETERS:
       NN $EQU 1                       "FLOATED VECTOR LENGTH
"SCRATCH:
       "S-PADS:   0,2,4,17
"      DPX:  0,1       DPY: 0.
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVMUL,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVMUL: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VMUL:  MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                 MOV A,A;SETMA         "FETCH A(0)
                 MOV B,B;SETMA         "FETCH B(0)
                 SUB K,C
            ADD I,A;SETMA;             "FETCH A(1)
                 DPX<MD;               "STORE A(0)
                 FSUBR TM,DPX(NN)      "INITIALIZE COUNTER
            ADD J,B; SETMA;            "FETCH B(1)
                 FMUL DPX,MD           "A(0)*B(0)
                 FSUBR TM,FA; FMUL     "DECREMENT COUNTER
LOOP:  ADD I,A;SETMA;                   "FETCH A(M)
            DPX<MD; FMUL; FADD         "STORE A(M+1)
       ADD J,B;SETMA;                   "FETCH B(M)
            FMUL DPX,MD;               "A(M+1)*B(M+1)
                 FSUBR TM,FA;          "DECREMENT COUNTER
                 DPY<FM                "STORE A(M+2)*B(M+2)
            FMUL; ADD K,C;SETMA;MI<DPY; "C(M)<A(M+2)*B(M+2)
                 BFGT LOOP             "BRANCH IF NOT DONE
DONE:   RETURN                  "EXIT
       $END
"****** VSADD = VECTOR-SCALAR ADD /FAST/ = REL 3.1, SEP 79 *****
       $TITLE VSADD
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY VSADD, 6                          "USER-DIRECTED-CALL ENTRY
       $EXT SPUFLT
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE:  11 + SPUFLT (8) = 19 LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN     ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"
"
"VECTOR SCALER ADD
"DOES C(M) = A(M) + B   FOR M = 0 TO N - 1
"LOOP CONTROL IS DONE IN THE FLOATING ADDER.  A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"S-PAD PARAMETERS:
       A $EQU 0                        "VECTOR A ORIGIN
       I $EQU 1                        "VECTOR A INCREMENT
       B $EQU 2                        "CONSTANT VECTOR B
       C $EQU 3                        "VECTOR C ORIGIN
       K $EQU 4                        "VECTOR C INCREMENT
       N $EQU 5                        "VECTOR LENGTH
       NM $EQU 17
"DATA-PAD PARAMETERS:
       NN $EQU 1                       "FLOATED VECTOR LENGTH
"SCRATCH:
"          S-PADS:     0,2,17
"          DPX:O,1.
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSADD,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  62
        $PARAM  6 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3/R/IP,
                    P4(#5,#6)/R/OP, P5/I/IP,
                    P6/I/IP
FVSADD: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSADD: MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
               MOV B,B;SETMA           "FETCH B
               SUB K,C
               MOV A,A;SETMA           "FETCH A(0)
               DPX<MD                  "SAVE B
           ADD I,A;SETMA;              "FETCH A(1)
           FSUBR TM,DPX(NN)            "INITIALIZE COUNTER
               FADD DPX,MD             "A(0) + B
LOOP:  ADD I,A;SETMA;                  "FETCH A(M)
           FSUBR TM,FA                 "DECREMENT COUNTER
           FADD DPX,MD;                "A(M+1) + B
               ADD K,C;SETMA;MI<FA;    "C(M+2)<A(M+2) + B
               BFGT LOOP               "BRANCH IF NOT DONE
DONE:   RETURN                  "EXIT
       $END
"****** VSMUL = VECTOR-SCALAR MULTIPLY /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VSMUL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSMUL, 6                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH ONE CYCLE MEMORY
"SIZE:  12 + SPUFLT (8) = 20 LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN     ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"VECTOR SCALER MULTIPLY
"DOES C(MK) = A(MI)*B FOR M = 0 TO N - 1
"LOOP CONTROL IS DONE IN THE FLOATING ADDER.  A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"S-PAD PARAMETERS
       A $EQU 0                        "VECTOR A ORIGIN
       I $EQU 1                        "VECTOR A INCREMENT
       B $EQU 2                        "CONSTANT VECTOR B
       C $EQU 3                        "VECTOR C ORIGIN
       K $EQU 4                        "VECTOR C INCREMENT
       N $EQU 5                        "VECTOR LENGTH
        NM $EQU 17
"DATA-PAD PARAMETERS:
       NN $EQU 1                       "FLOATED VECTOR LENGTH
"SCRATCH:
"        S-PADS: 0,3,17
"      DPX: 0,1.     DPY: 0.
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSMUL,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  62
        $PARAM  6 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3/R/IP,
                    P4(#5,#6)/R/OP, P5/I/IP,
                    P6/I/IP
FVSMUL: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSMUL: MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM) AND
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV B,B;SETMA           "FETCH B
                   MOV A,A;SETMA       "FETCH A(0)
                   SUB K,C
               ADD I,A;SETMA;          "FETCH A(1)
                   DPX<MD              "STORE B
                   FMUL DPX,MD         "B*A(0)
           ADD I,A;SETMA;              "FETCH A(2)
               FSUBR TM,DPX(NN);       "INITIALIZE COUNTER
                   FMUL                "PUSH PRODUCT
               FMUL DPX,MD;            "B*A(1)
                   FADD                "PUSH COUNTER
LOOP:  ADD I,A;SETMA;                  "FETCH A(M)
               FMUL;                   "PUSH B*A(M + 2)
               FSUBR TM,FA;            "DECREMENT COUNTER
                   DPY<FM              "SAVE B*A(M+3)
           FMUL DPX,MD;                "B*A(M+1)
               FADD;                   "PUSH COUNTER
                   ADD K,C;SETMA;MI<DPY; "C(M+3)<B*A(M+3)
                   BFGT LOOP           "BRANCH IF NOT DONE
DONE:   RETURN                  "EXIT
       $END
"****** VTSADD = VECTOR TABLE SCALAR ADDITION /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VTSADD
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VTSADD,6                          "USER-DIRECTED-CALL ENTRY
"
"---ABSTRACT---
"ADDS TO EACH ELEMENT OF VECTOR A THE TABLE MEMORY SCALAR B, AND
"STORES THE RESULT IN C
"       C(MK) = A(MI) + B, FOR M = 0 TO N-1
"
"---STATISTICS---
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH STANDARD OR FAST MEMORY
"SIZE: 9
"EXECUTION      BEST    TYPICAL   WORST    SETUP
"TIME/LOOP       .5        .5       .67     .83    (167 NS MEMORY)
"  (US)          .83       .83     1.0      .83    (333 NS MEMORY)
"SUBROUTINES USED: NONE
"
"    --- HISTORY ---
"ORIGINAL:  DEC 77  H. WILLIAMS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"---USAGE---
"FORTRAN: CALL VTSADD (A, I, B, C, K, N)
"APAL:    JSR VTSADD
"S-PAD PARAMETERS:
        A = 0           "BASE ADDRESS OF A
        I = 1           "INCREMENT OF A
        B = 2           "ADDRESS OF SCALAR IN TABLE MEMORY
        C = 3           "BASE ADDRESS OF C
        K = 4           "INCREMENT OF C
        N = 5           "NUMBER OF ELEMENTS IN A & C
"
"---SCRATCH---
"SP(0,3,5),FA,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVTSAD,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  66
        $PARAM  6 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3/I/IP,
                    P4(#5,#6)/R/OP, P5/I/IP,
                    P6/I/IP
FVTSAD: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VTSADD: MOV A,A; SETMA                  "GET A(0)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        MOV B,B; SETTMA;                "FETCH B FROM TM
          BEQ DONE              "EXIT IF COUNT = 0
        ADD I,A; SETMA                  "GET A(1)
        SUB K,C;                        "INITIALIZE C
        FADD TM,MD                      "A(0)+B
LOOP:   ADD I,A; SETMA                  "1.  GET A(M+2)
            FADD TM,MD;                 "2.      A(M+1)+B
                DEC N                   "2.          DECREMENT LOOP COUNTER
                ADD K,C; SETMA; MI<FA;  "3.          STORE C(M)
                BNE LOOP                "3.          TEST COUNTER
DONE:   RETURN                  "EXIT
        $END
"****** VSSQ = VECTOR SIGNED SUM OF SQUARES /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VSSQ
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSSQ, 5                          "USER-DIRECTED-CALL ENTRY
       $EXT SPUFLT
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE:  13 + SPUFLT (8) = 21 LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN     ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"VECTOR SIGNED SQUARE
"DOES C(K) = A(I) * ABS(A(I)),  FOR M = 0 TO N-1
"LOOP CONTROL IS DONE IN THE FLOATING ADDER.  A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"S-PAD PARAMETERS:
        A $EQU 0                        "BASE ADDRESS OF VECTOR A
        I $EQU 1                        "INCREMENT FOR VECTOR A
        C $EQU 2                        "BASE ADDRESS OF VECTOR C
        K $EQU 3                        "INCREMENT FOR C
        N $EQU 4                        "LENGTH OF C
        NM $EQU 17
"DATA-PAD PARAMETERS:
           NN $EQU 1                   "FLOATED VECTOR LENGTH
"                  --- SCRATCH ---
"S-PADS:  0,2,4,17
"          DPX:  0, 1.
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSSQ,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVSSQ: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSSQ:  MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM) AND
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                   MOV A,A;SETMA       "FETCH A(0)
                   SUB K,C
                ADD I,A;SETMA          "FETCH A(1)
                   FABS MD;            "ABS(A(0))
                   FMUL TM,MD          "SAVE A(0) IN FM
             ADD I,A;SETMA;            "FETCH A(2)
                   FADD;               "PUSH ABS(A(0))
                   FMUL                "PUSH A(0) IN FM
                FABS MD;               "ABS(A(1))
                FMUL TM,MD;            "STORE A(1) IN FM
                   DPY<FA              "STORE ABS(A(0))
          ADD I,A;SETMA;                "FETCH A(3)
                FSUBR TM,DPX(NN);      "INITIALIZE COUNTER
                   FMUL FM,DPY         "A(0)*ABS(A(0))
             FABS MD;                  "ABS(A(3))
             FMUL TM,MD;               "STORE A(3) IN FM
                DPY<FA                 "STORE ABS(A(2))
LOOP:  ADD I,A;SETMA;                  "FETCH A(M)
                FMUL FM,DPY;           "A(M+3)*ABS(A(M+3))
                FSUBR TM,FA            "DECREMENT COUNTER
          FABS MD;                     "ABS(A(M+1))
          FMUL TM,MD;                  "STORE A(M+1) IN FM
             DPY<FA;                   "STORE ABS(A(M+2))
                   ADD K,C;SETMA;MI<FM; "C(M+4)<A(M+4)*ABS(A(M+4))
                   BFGT LOOP           "BRANCH IF NOT DONE
DONE:   RETURN                  "EXIT
       $END
"****** VABS = VECTOR ABSOLUTE VALUE /FAST/ = REL 3.1, SEP 79 *****
         $TITLE VABS
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VABS, 5                          "USER-DIRECTED-CALL ENTRY
       $EXT SPUFLT
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE:   9 + SPUFLT (8) = 17 LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN     ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"VECTOR ABSOLUTE VALUE FUNCTION
"DOES C(MK) = ABS(A(MI)),   FOR M = 0 TO N-1
"LOOP CONTROL IS DONE IN THE FLOATING ADDER.  A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"S-PAD PARAMETERS:
A       $EQU 0          "A VECTOR ORIGIN
I       $EQU 1          "A VECTOR INCREMENT
C       $EQU 2          "C VECTOR ORIGIN
K       $EQU 3          "C VECTOR INCREMENT
N       $EQU 4                          "LENGTH OF C
       NM $EQU 17
"DATA-PAD PARAMETERS:
       NN $EQU 1                       "FLOATED VECTOR LENGTH
"SCRATCH:
"        S-PADS:  0,2,17
"          DPX:   1.
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVABS,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVABS: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VABS:  MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                 MOV A,A;SETMA         "FETCH A(0)
                 SUB K,C
            ADD I,A;SETMA;             "FETCH A(1)
                 FSUBR TM,DPX(NN)      "INITIALIZE COUNTER
                 FABS MD               "ABS A(0)
LOOP:  ADD I,A;SETMA;                  "FETCH A(M)
            FSUBR TM,FA                "DECREMENT COUNTER
            FABS MD;                   "ABS A(M+1)
                 ADD K,C;SETMA;MI<FA;  "C(M+2)<ABS A(M+2)
                 BFGT LOOP             "BRANCH IF NOT DONE
DONE:   RETURN                  "EXIT
       $END
"****** VMA = VECTOR MULTIPLY AND ADD /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VMA
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VMA,9.                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "THIS ALGORITHM DOES D <= A*B+C COMPONENT-WISE
        "THE NUMBER OF COMPONENTS IS GIVEN BY N
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST MEMORY
        "SIZE:      15 + SPUFLT (8) = 23 LOCATIONS
        "TIME:      WORST:  20.+6*N
        "           BEST:   16.+4*N
"
"     ---HISTORY---
"ORIGINAL:  FEB 77  S. BERKOWITZ
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
        "DPX(0),DPX(1)      --  TEMPORARY STORAGE
        A $EQU 0                                "BASE ADDR FOR A
        I $EQU 1                                "INCREMENT FOR A
        B $EQU 2                                "BASE ADDR FOR B
        J $EQU 3                                "INCREMENT FOR B
        C $EQU 4                                "BASE ADDR FOR C
        K $EQU 5                                "INCREMENT FOR C
        D $EQU 6                                "BASE ADDR FOR D
        L $EQU 7                                "INCREMENT FOR D
        N $EQU 8.                          "NUMBER OF COMPONENTS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVMVA,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  652
        $PARAM  9., P1(#2,#11)/R/IP, P2/I/IP,
                    P3(#4,#11)/R/IP, P4/I/IP,
                    P5(#6,#11)/R/IP, P6/I/IP,
                    P7(#10,#11)/R/OP, P8/I/IP,
                    P9/I/IP
FVMVA: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VMA:    MOV N,17
        JSR SPUFLT                                   "FLOAT N INTO DPX(1)
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV A,A;SETMA;                          "1,FETCH A
        FADD ZERO,DPX(1)
        MOV B,B;SETMA                           "2,FETCH B
        MOV C,C;SETMA                           "3,FETCH C
        DPX<MD;SUB L,D
        ADD I,A;SETMA;                          "1,FETCH A
                FMUL DPX,MD                     "1,A*B
        ADD J,B;SETMA;                          "2,FETCH B
                FMUL;
                DPX<MD
        ADD K,C;SETMA;                          "3,FETCH C
                FMUL
        DPX<MD;                                 "4
                FADD FM,DPX                     "4,A*B+C
LOOP:   ADD I,A;SETMA;                          "1,FETCH A
                FMUL DPX,MD;                    "1,A*B
                        FSUBR TM,FA             "1,N=N-1
        ADD J,B;SETMA;                          "2,FETCH B
                FMUL;
                DPX<MD;
                        FADD ZERO,FA            "2,HOLD ANSWER
        ADD K,C;SETMA;                          "3,FETCH C
                FMUL;
                        FADD ZERO,FA            "3,HOLD COUNTER
        DPX<MD;                                 "4
                FADD FM,DPX;                    "4,A*B+C
                        BFGT LOOP;              "4,TEST&BRANCH
                        ADD L,D;SETMA;MI<FA     "4,STORE D
DONE:   RETURN                  "EXIT
        $END
"****** VMSB = VECTOR MULTIPLY AND SUBTRACT /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VMSB
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VMSB,9.                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "THIS ALGORITHM DOES D <= A*B-C COMPONENT-WISE
        "THE NUMBER OF COMPONENTS IS GIVEN BY N
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST MEMORY
        "SIZE:      15 + SPUFLT (8) = 23 LOCATIONS
        "TIME:      WORST:  20.+6*N
        "           BEST:   16.+4*N
"
"    --- HISTORY ---
"ORIGINAL:  JUL 77  S. BERKOWITZ, R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
        "DPX(0),DPX(1)      --  TEMPORARY STORAGE
        A $EQU 0                                "BASE ADDR FOR A
        I $EQU 1                                "INCREMENT FOR A
        B $EQU 2                                "BASE ADDR FOR B
        J $EQU 3                                "INCREMENT FOR B
        C $EQU 4                                "BASE ADDR FOR C
        K $EQU 5                                "INCREMENT FOR C
        D $EQU 6                                "BASE ADDR FOR D
        L $EQU 7                                "INCREMENT FOR D
        N $EQU 8.                          "NUMBER OF COMPONENTS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVMSB,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  652
        $PARAM  9., P1(#2,#11)/R/IP, P2/I/IP,
                    P3(#4,#11)/R/IP, P4/I/IP,
                    P5(#6,#11)/R/IP, P6/I/IP,
                    P7(#10,#11)/R/OP, P8/I/IP,
                    P9/I/IP
FVMSB: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VMSB:    MOV N,17
        JSR SPUFLT                                   "FLOAT N INTO DPX(1)
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV A,A;SETMA;                          "1,FETCH A
        FADD ZERO,DPX(1)
        MOV B,B;SETMA                           "2,FETCH B
        MOV C,C;SETMA                           "3,FETCH C
        DPX<MD;SUB L,D
        ADD I,A;SETMA;                          "1,FETCH A
                FMUL DPX,MD                     "1,A*B
        ADD J,B;SETMA;                          "2,FETCH B
                FMUL;
                DPX<MD
        ADD K,C;SETMA;                          "3,FETCH C
                FMUL
        DPX<MD;                                 "4
                FSUB FM,DPX                     "4,A*B-C
LOOP:   ADD I,A;SETMA;                          "1,FETCH A
                FMUL DPX,MD;                    "1,A*B
                        FSUBR TM,FA             "1,N=N-1
        ADD J,B;SETMA;                          "2,FETCH B
                FMUL;
                DPX<MD;
                        FADD ZERO,FA            "2,HOLD ANSWER
        ADD K,C;SETMA;                          "3,FETCH C
                FMUL;
                        FADD ZERO,FA            "3,HOLD COUNTER
        DPX<MD;                                 "4
                FSUB FM,DPX;                    "4,A*B-C
                        BFGT LOOP;              "4,TEST&BRANCH
                        ADD L,D;SETMA;MI<FA     "4,STORE D
DONE:   RETURN                  "EXIT
        $END
"****** VMSA = VECTOR MULTIPLY AND SCALAR ADD /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VMSA
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VMSA,8.                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"THIS ALGORITHM DOES D(M)<=A(M)*B(M)+C FOR N ELEMENTS
"--------- STATISTICS ---------
"LANGUAGE: AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH FAST MEMORY
"SIZE: 15. + SPUFLT (8) = 23 WORDS
"
"    --- HISTORY ---
"ORIGINAL:  AUG 78  L. TARVESTAD
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"---------- S-PAD PARAMETERS ----------
        A $EQU 0                "BASE ADDR FOR A
        I $EQU 1                "INCREMENT FOR A
        B $EQU 2                "BASE ADDR FOR B
        J $EQU 3                "INCREMENT FOR B
        C $EQU 4                "ADDR FOR C
        D $EQU 5                "BASE ADDR FOR D
        L $EQU 6                "INCREMENT FOR D
        N $EQU 7                "VECTOR LENGTH
"--------- SCRATCH ----------
"       DPX(1),DPY(0,1),SP(0,2,5,17),FA,FM,MD
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVMSA,8.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  312
        $PARAM  8., P1(#2,#10)/R/IP, P2/I/IP,
                    P3(#4,#10)/R/IP, P4/I/IP,
                    P5/R/IP,
                    P6(#7,#10)/R/OP, P7/I/IP,
                    P8/I/IP
FVMSA: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VMSA:   MOV N,17                        "FLOAT VECTOR LENGTH
         JSR SPUFLT
        BFEQ DONE;              "EXIT IF COUNT = 0
         MOV A,A; SETMA                "1,FETCH A(0)
         MOV B,B; SETMA                "2,FETCH B(0)
         MOV C,C; SETMA                "  FETCH SCALAR C
         ADD I,A; SETMA;               "1,FETCH A(1)
              DB=MD; DPY(1)<DB         "1,SAVE A(0)
         ADD J,B; SETMA;               "2,FETCH B(1)
              FMUL DPY(1),MD           "2,A(0)*B(0)
         DB=MD; DPY(0)<DB;             "  SAVE C ON DPY(0)
              FMUL                     "3,PUSH FM
         ADD I,A; SETMA;               "1,FETCH A(2)
              DB=MD; DPY(1)<DB;        "1,SAVE A(1)
                   FMUL                "1,PUSH FM
         ADD J,B; SETMA;               "2,FETCH B(2)
              FMUL DPY(1),MD;           "2,A(1)*B(1)
                   DPX(1)<FM; FSUBR TM,DPX(1)  "2,SAVE A(0)*B(0) & DEC COUNTER
        SUB L,D;                        " INITIALIZE D
              FMUL                     "3,PUSH FM
LOOP:    ADD I,A; SETMA;               "1,FETCH A(M+3)
              DB=MD; DPY(1)<DB;        "1,SAVE A(M+2)
                   FMUL;               "1,PUSH FM
                        FADD DPX(1),DPY(0)  "1,A(M)*B(M)+C
         ADD J,B; SETMA;               "2,FETCH B(M+3)
              FMUL DPY(1),MD;          "2,A(M+2)*B(M+2)
                   DPX(1)<FM; FSUBR TM,FA  "2,SAVE A(M+1)*B(M+1) & DEC COUNTER
              FMUL;                    "3,PUSH FM
                        ADD L,D; SETMA; MI<FA; BFGT LOOP  "3,STORE D(M) & BRANCH
DONE:   RETURN                  "EXIT
         $END
"****** VSMA = VECTOR SCALAR MULTIPLY AND ADD /FAST/ = REL 3.1, SEP 79 *****
"
"
         $TITLE VSMA
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
         $ENTRY VSMA,8.                          "USER-DIRECTED-CALL ENTRY
         $EXT SPUFLT
"
"       THIS ALGORITHM DOES D<=A*B+C WHERE B IS A SCALAR
" AND A AND C ARE VECTORS WHOSE DIMENSION IS GIVEN BY N.
"       --------STATISTICS--------
"        LANGUAGE:  AP-120B ASSEMBLER
"        EQUIPMENT: AP-120B WITH FAST MEMORY
"        SIZE:      13. LOCATIONS + SPUFLT (8) = 21. LOCATIONS
"        SPEED:   BEST    (2.50 + 0.50*N) USEC
"                 TYPICAL (3.00 + 0.83*N) USEC
"                 WORST   (3.33 + 1.00*N) USEC
"
"    --- HISTORY ---
"ORIGINAL:  JUN 78  D. DAVIS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"        --------SCRATCH--------
"        DPX(0),DPX(1),DPY(0)       ---  TEMPORARY
"
"
        A $EQU 0
        I $EQU 1
        B $EQU 2
        C $EQU 3
        J $EQU 4
        D $EQU 5
        K $EQU 6
        N $EQU 7
"--------------------------------------------------------
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSMA,8.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  322
        $PARAM  8., P1(#2,#10)/R/IP, P2/I/IP,
                    P3/R/IP,
                    P4(#5,#10)/R/IP, P5/I/IP,
                    P6(#7,#10)/R/OP, P7/I/IP,
                    P8/I/IP
FVSMA: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSMA:   MOV N,17
        JSR SPUFLT                               "FLOAT INTEGER
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV B,B;SETMA                           "FETCH SCALAR B
        MOV A,A;SETMA                           "1. FETCH FIRST ELEMENT A(1)
        MOV C,C;SETMA                           "2. FETCH FIRST ELEMENT C(1)
        DPX<MD;SUB K,D                          "STORE B IN DPX(0)
        ADD I,A;SETMA;                          "1. FETCH NEXT ELEMENT A(2)
                FMUL DPX,MD                     "MULTIPLY FIRST A(1)*B
        ADD J,C;SETMA;                          "2. FETCH NEXT ELEMENT C(2)
                FMUL;FSUBR TM,DPX(1)            "DECREMENT COUNTER
                FMUL;DPY<MD                     "3. STORE C(1) IN DPY(0)
LOOP:   ADD I,A;SETMA;                          "1. FETCH NEXT ELEMENT A(M+2)
                FMUL DPX,MD;                    " MULTIPLY A(M+1)*B
                        FADD FM,DPY             " ADD A(M)*B+C(M)
        ADD J,C;SETMA;                          "2.  FETCH NEXT ELEMENT C(M+2)
                FMUL; FSUBR TM,FA               " DECREMENT COUNTER
                FMUL; DPY<MD;                    "3. STORE C(M+1) IN DPY(0)
                        ADD K,D;SETMA;MI<FA;BFGT LOOP   " STORE D(M) AND BRANCH
"---------------------------------------------------------------------
DONE:   RETURN                  "EXIT
        $END
"****** VSMSB = VECTOR SCALAR MULTIPLY AND SUB /FAST/ = REL 3.1, SEP 79 *****
"
"
         $TITLE VSMSB
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
         $ENTRY VSMSB,8.                          "USER-DIRECTED-CALL ENTRY
         $EXT SPUFLT
"
"       THIS ALGORITHM DOES D<=A*B-C WHERE B IS A SCALAR
" AND A AND C ARE VECTORS WHOSE DIMENSION IS GIVEN BY N.
"       --------STATISTICS--------
"        LANGUAGE:  AP-120B ASSEMBLER
"        EQUIPMENT: AP-120B WITH FAST MEMORY
"        SIZE:      13. LOCATIONS + SPUFLT (8) = 21. LOCATIONS
"        SPEED:   BEST    (2.50 + 0.50*N) USEC
"                 TYPICAL (3.00 + 0.83*N) USEC
"                 WORST   (3.33 + 1.00*N) USEC
"
"    --- HISTORY ---
"ORIGINAL:  JUN 78  D. DAVIS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"        --------SCRATCH--------
"        DPX(0),DPX(1),DPY(0)       ---  TEMPORARY
"
"
        A $EQU 0
        I $EQU 1
        B $EQU 2
        C $EQU 3
        J $EQU 4
        D $EQU 5
        K $EQU 6
        N $EQU 7
"--------------------------------------------------------
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSMB,8.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  322
        $PARAM  8., P1(#2,#10)/R/IP, P2/I/IP,
                    P3/R/IP,
                    P4(#5,#10)/R/IP, P5/I/IP,
                    P6(#7,#10)/R/OP, P7/I/IP,
                    P8/I/IP
FVSMB: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSMSB:  MOV N,17
        JSR SPUFLT                               "FLOAT INTEGER
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV B,B;SETMA                           "FETCH SCALAR B
        MOV A,A;SETMA                           "1. FETCH FIRST ELEMENT A(1)
        MOV C,C;SETMA                           "2. FETCH FIRST ELEMENT C(1)
        DPX<MD;SUB K,D                          "STORE B IN DPX(0)
        ADD I,A;SETMA;                          "1. FETCH NEXT ELEMENT A(2)
                FMUL DPX,MD                     "MULTIPLY FIRST A(1)*B
        ADD J,C;SETMA;                          "2. FETCH NEXT ELEMENT C(2)
                FMUL;FSUBR TM,DPX(1)            "DECREMENT COUNTER
                FMUL;DPY<MD                     "3. STORE C(1) IN DPY(0)
LOOP:   ADD I,A;SETMA;                          "1. FETCH NEXT ELEMENT A(M+2)
                FMUL DPX,MD;                    " MULTIPLY A(M+1)*B
                        FSUB FM,DPY             " ADD A(M)*B-C(M)
        ADD J,C;SETMA;                          "2.  FETCH NEXT ELEMENT C(M+2)
                FMUL; FSUBR TM,FA               " DECREMENT COUNTER
                FMUL; DPY<MD;                    "3. STORE C(M+1) IN DPY(0)
                        ADD K,D;SETMA;MI<FA;BFGT LOOP   " STORE D(M) AND BRANCH
"---------------------------------------------------------------------
DONE:   RETURN                  "EXIT
        $END
"****** VAM = VECTOR ADD AND MULTIPLY /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VAM
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VAM,9.                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "THIS ALGORITHM DOES D <=(A+B)*C
        "WITH THE NUMBER OF COMPONENTS GIVEN BY N
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST MEMORY
          "SIZE:      15 + SPUFLT (8) = 23 WORDS
        "TIME:      WORST: 8+12*N
        "           BEST:  8+7*N
"
"     ---HISTORY---
"ORIGINAL:  FEB 77  S. BERKOWITZ
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
            "DPY,DPX,DPX(1)      -TEMPORARY STORAGE
        A $EQU 0                                "BASE ADDR FOR A
        I $EQU 1                                "INCREMENT FOR A
        B $EQU 2                                "BASE ADDR FOR B
        J $EQU 3                                "INCREMENT FOR B
        C $EQU 4                                "BASE ADDR FOR C
        K $EQU 5                                "INCREMENT FOR C
        D $EQU 6                                "BASE ADDR FOR D
        L $EQU 7                                "INCREMENT FOR D
        N $EQU 8.                               "LENGTH OF VECTORS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVAM,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  652
        $PARAM  9., P1(#2,#11)/R/IP, P2/I/IP,
                    P3(#4,#11)/R/IP, P4/I/IP,
                    P5(#6,#11)/R/IP, P6/I/IP,
                    P7(#10,#11)/R/OP, P8/I/IP,
                    P9/I/IP
FVAM: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VAM:    MOV N,17
        JSR SPUFLT
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV A,A;SETMA                           "1,FETCH A
        MOV B,B;SETMA                           "2,FETCH B
        MOV C,C;SETMA                           "3,FETCH C
        DPX<MD;
        SUB L,D
        ADD I,A;SETMA;                          "1,FETCH A
                DPY<MD
        ADD J,B;SETMA;                          "2,FETCH B
                FADD DPX,DPY;
                DPX<MD
        ADD K,C;SETMA;                          "3,FETCH C
                FADD
        DPX<MD;
                FMUL DPX,FA
LOOP:   ADD I,A;SETMA;                          "1,FETCH A
                DPY<MD;
                        FMUL;
                        FSUBR TM,DPX(1)         "1,N=N-1
        ADD J,B;SETMA;                          "2,FETCH B
                FADD DPX,DPY;                   "2,A+B
                DPX<MD;
                        FMUL
        ADD K,C;SETMA;                          "3,FETCH C
                FADD;
                        DPX(1)<FA
        DPX<MD;
                FMUL DPX,FA;                    "4,(A+B)*C
                        BFGT LOOP;              "4,TEST&BRANCH
                        ADD L,D;SETMA;MI<FM     "4,STORE D
DONE:   RETURN                  "EXIT
        $END
"****** VSBM = VECTOR SUBTRACT AND MULTIPLY /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VSBM
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSBM,9.                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "THIS ALGORITHM DOES D <=(A-B)*C
        "WITH THE NUMBER OF COMPONENTS GIVEN BY N
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST MEMORY
          "SIZE:      15 + SPUFLT (8) = 23 WORDS
        "TIME:      WORST: 8+12*N
        "           BEST:  8+7*N
"
"     ---HISTORY---
"ORIGINAL:  JUL 77  S. BERKOWITZ, R.S. NORIN
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
            "DPY,DPX,DPX(1)      -TEMPORARY STORAGE
        A $EQU 0                                "BASE ADDR FOR A
        I $EQU 1                                "INCREMENT FOR A
        B $EQU 2                                "BASE ADDR FOR B
        J $EQU 3                                "INCREMENT FOR B
        C $EQU 4                                "BASE ADDR FOR C
        K $EQU 5                                "INCREMENT FOR C
        D $EQU 6                                "BASE ADDR FOR D
        L $EQU 7                                "INCREMENT FOR D
        N $EQU 8.                               "LENGTH OF VECTORS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSBM,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  652
        $PARAM  9., P1(#2,#11)/R/IP, P2/I/IP,
                    P3(#4,#11)/R/IP, P4/I/IP,
                    P5(#6,#11)/R/IP, P6/I/IP,
                    P7(#10,#11)/R/OP, P8/I/IP,
                    P9/I/IP
FVSBM: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSBM:    MOV N,17
        JSR SPUFLT
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV A,A;SETMA                           "1,FETCH A
        MOV B,B;SETMA                           "2,FETCH B
        MOV C,C;SETMA                           "3,FETCH C
        DPX<MD;
        SUB L,D
        ADD I,A;SETMA;                          "1,FETCH A
                DPY<MD
        ADD J,B;SETMA;                          "2,FETCH B
                FSUB DPX,DPY;
                DPX<MD
        ADD K,C;SETMA;                          "3,FETCH C
                FADD
        DPX<MD;
                FMUL DPX,FA
LOOP:   ADD I,A;SETMA;                          "1,FETCH A
                DPY<MD;
                        FMUL;
                        FSUBR TM,DPX(1)         "1,N=N-1
        ADD J,B;SETMA;                          "2,FETCH B
                FSUB DPX,DPY;                   "2,A-B
                DPX<MD;
                        FMUL
        ADD K,C;SETMA;                          "3,FETCH C
                FADD;
                        DPX(1)<FA
        DPX<MD;
                FMUL DPX,FA;                    "4,(A-B)*C
                        BFGT LOOP;              "4,TEST&BRANCH
                        ADD L,D;SETMA;MI<FM     "4,STORE D
DONE:   RETURN                  "EXIT
        $END
"****** VSMSA = VECTOR-SCALAR MULTIPLY, SCALAR ADD /FAST/ = REL 3.1, SEP 79 ****
        $TITLE VSMSA
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSMSA,7.                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "THIS ALGORITHM COMPUTES  D <= A*B+C WHERE B,C ARE SCALARS
        "AND A AND D ARE VECTORS WHOSE DIMENSION IS GIVEN BY N.
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST MEMORY
        "SIZE:      15 + SPUFLT (8) = 23 WORDS
        "TIME:      WORST:  19.+4*N
        "           BEST:   18.+2*N
"
"     ---HISTORY---
"ORIGINAL:  JUL 77  S. BERKOWITZ, R.S. NORIN
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
        "DPX,DPX(1),DPY,DPY(1) -- TEMPORARY STORAGE
        A $EQU 0                                "BASE ADDR OF A
        I $EQU 1                                "INCREMENT OF A
        B $EQU 2                                "BASE ADDR OF B
        C $EQU 3                                "BASE ADDR OF C
        D $EQU 4                                "BASE ADDR OF D
        L $EQU 5                                "INCREMENT OF D
        N $EQU 6                                "SIZE OF VECTORS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSMSA,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  142
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3/R/IP, P4/R/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVSMSA: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSMSA:  MOV N,17
        JSR SPUFLT                               "FLOAT N INTO DPX(1)
        BFEQ DONE;              "EXIT IF COUNT = 0
        MOV B,B;SETMA                           "FETCH SCALAR B
        MOV C,C;SETMA                           "FETCH SCALAR C
        SUB L,D
        DPY<MD;                                 "FLOAT N INTO DPX(1)
        MOV A,A; SETMA                          "1,FETCH A
        DPX<MD
        ADD I,A;SETMA                                   "1,FETCH A
        ADD I,A;SETMA;                                  "1,FETCH A
                        FMUL DPY,MD                     "1,A*B
                        FMUL                            "2,PUSH
        ADD I,A;SETMA;                                  "1,FETCH A
                        FMUL DPY,MD;                    "1,A*B
                                FSUBR TM,DPX(1)         "1,N=N-1
                        FMUL;
                                FADD FM,DPX             "2,A*B+C
LOOP:   ADD I,A;SETMA;                                  "1,FETCH A
                        FMUL DPY,MD;                    "1,A*B
                                FSUBR TM,FA             "1,N=N-1
                        FMUL;
                                FADD FM,DPX;            "2,A*B+C
                                        ADD L,D;SETMA;MI<FA;  "STORE D
                                        BFGT LOOP       "2,TEST&BRANCH
DONE:   RETURN                  "EXIT
        $END
"****** VMMA = VECTOR MULTIPLY, MULTIPLY, ADD /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VMMA
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VMMA,11.                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "THIS ALGORITHM DOES E<= A*B+C*D
        "WHERE A,B,C,D,E ARE VECTORS OF LENGTH N
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST MEMORY
        "SIZE:      19 + SPUFLT (8) = 27 WORDS
        "TIME:      WORST: 25. +10*N
        "           BEST:  18+5*N
"
"     ---HISTORY---
"ORIGINAL:  FEB 77  S. BERKOWITZ
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
       "DPX,DPY,DPX(1)  --  TEMPORARY STORAGE
        A $EQU 0                                        "BASE ADDR FOR A
        I $EQU 1                                        "INCREMENT FOR A
        B $EQU 2                                        "BASE ADDR FOR B
        J $EQU 3                                        "INCREMENT FOR B
        C $EQU 4                                        "BASE ADDR FOR C
        K $EQU 5                                        "INCREMENT FOR C
        D $EQU 6                                        "BASE ADDR FOR D
        L $EQU 7                                        "INCREMENT FOR D
        E $EQU 8.                                       "BASE ADDR FOR E
        M $EQU 9.                                       "INCREMENT FOR E
        N $EQU 10.                                      "SIZE OF VECTORS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVMMA,11.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  3252
        $PARAM 11., P1(#2,#13)/R/IP, P2/I/IP,
                    P3(#4,#13)/R/IP, P4/I/IP,
                    P5(#6,#13)/R/IP, P6/I/IP,
                    P7(#10,#13)/R/IP, P8/I/IP,
                    P9(#12,#13)/R/OP, P10/I/IP,
                    P11/I/IP
FVMMA: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VMMA:   MOV N,17                                        "READY SPUFLT
        JSR SPUFLT                                       "FLOAT N INTO DPX(1)
        FADD ZERO,DPX(1);                               "COUNT IN ADDER
        SUB M,E                                        "INITIALIZE E
        MOV A,A;SETMA                                   "1,FETCH A
        MOV B,B;SETMA                                   "2,FETCH B
        MOV C,C;SETMA                                   "3,FETCH C
        MOV D,D;SETMA;                                  "4,FETCH D
        DPX<MD
        FMUL DPX,MD;                                    "5,A*B
          MOV N,N               "IS ELEMENT COUNT = 0?
        ADD I,A;SETMA;                                  "1,FETCH A
        BEQ DONE;               "EXIT IF COUNT = 0
                FMUL;
                DPX<MD
        ADD J,B;SETMA;                                  "2,FETCH B
                FMUL DPX,MD                             "2,C*D
        ADD K,C;SETMA;                                  "3,FETCH C
                FMUL;
                DPY<FM
        ADD L,D;SETMA;                                  "4,FETCH D
        DPX<MD;
                FMUL
        FMUL DPX,MD;                                    "5,A*B
                FADD FM,DPY                             "5,A*B+C*D
LOOP:   ADD I,A;SETMA;                                  "1,FETCH A
                FMUL;
                DPX<MD;
                        FSUBR TM,FA                     "1,N=N-1
        ADD J,B;SETMA;                                  "2,FETCH B
                FMUL DPX,MD                             "2,C*D
        ADD K,C;SETMA;                                  "3,FETCH C
                  FMUL;
                DPY<FM;
                        FADD ZERO,FA
        ADD L,D;SETMA;                                  "4,FETCH D
        DPX<MD;
                FMUL;
                        FADD ZERO,FA                    "4,PUT FA IN ADD PIPE
        FMUL DPX,MD;                                    "5,A*B
                FADD FM,DPY;                            "5,A*B+C*D
                        ADD M,E;SETMA;MI<FA;            "5,STORE E
                        BFGT LOOP                       "5,TEST&BRANCH
DONE:   RETURN                  "EXIT
        $END
"****** VMMSB = VECTOR MULTIPLY, MULTIPLY, SUBTRACT /FAST/ = REL 3.1, SEP 79 ***
        $TITLE VMMSB
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VMMSB,11.                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "THIS ALGORITHM DOES E<= A*B-C*D
        "WHERE A,B,C,D,E ARE VECTORS OF LENGTH N
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST MEMORY
        "SIZE:      19 + SPUFLT (8) = 27 WORDS
        "TIME:      WORST: 25. +10*N
        "           BEST:  18+5*N
"
"     ---HISTORY---
"ORIGINAL:  JUL 77  S. BERKOWITZ, R.S. NORIN
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
       "DPX,DPY,DPX(1)  --  TEMPORARY STORAGE
        A $EQU 0                                        "BASE ADDR FOR A
        I $EQU 1                                        "INCREMENT FOR A
        B $EQU 2                                        "BASE ADDR FOR B
        J $EQU 3                                        "INCREMENT FOR B
        C $EQU 4                                        "BASE ADDR FOR C
        K $EQU 5                                        "INCREMENT FOR C
        D $EQU 6                                        "BASE ADDR FOR D
        L $EQU 7                                        "INCREMENT FOR D
        E $EQU 8.                                       "BASE ADDR FOR E
        M $EQU 9.                                       "INCREMENT FOR E
        N $EQU 10.                                      "SIZE OF VECTORS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVMMSB,11.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  3252
        $PARAM 11., P1(#2,#13)/R/IP, P2/I/IP,
                    P3(#4,#13)/R/IP, P4/I/IP,
                    P5(#6,#13)/R/IP, P6/I/IP,
                    P7(#10,#13)/R/IP, P8/I/IP,
                    P9(#12,#13)/R/OP, P10/I/IP,
                    P11/I/IP
FVMMSB: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VMMSB:   MOV N,17                                        "READY SPUFLT
        JSR SPUFLT                                       "FLOAT N INTO DPX(1)
        FADD ZERO,DPX(1);                               "COUNT IN ADDER
        SUB M,E                                        "INITIALIZE E
        MOV A,A;SETMA                                   "1,FETCH A
        MOV B,B;SETMA                                   "2,FETCH B
        MOV C,C;SETMA                                   "3,FETCH C
        MOV D,D;SETMA;                                  "4,FETCH D
        DPX<MD
        FMUL DPX,MD;                                    "5,A*B
          MOV N,N               "IS ELEMENT COUNT = 0?
        ADD I,A;SETMA;                                  "1,FETCH A
        BEQ DONE;               "EXIT IF COUNT = 0
                FMUL;
                DPX<MD
        ADD J,B;SETMA;                                  "2,FETCH B
                FMUL DPX,MD                             "2,C*D
        ADD K,C;SETMA;                                  "3,FETCH C
                FMUL;
                DPY<FM
        ADD L,D;SETMA;                                  "4,FETCH D
        DPX<MD;
                FMUL
        FMUL DPX,MD;                                    "5,A*B
                FSUBR FM,DPY                            "5,A*B-C*D
LOOP:   ADD I,A;SETMA;                                  "1,FETCH A
                FMUL;
                DPX<MD;
                        FSUBR TM,FA                     "1,N=N-1
        ADD J,B;SETMA;                                  "2,FETCH B
                FMUL DPX,MD                             "2,C*D
        ADD K,C;SETMA;                                  "3,FETCH C
                  FMUL;
                DPY<FM;
                        FADD ZERO,FA
        ADD L,D;SETMA;                                  "4,FETCH D
        DPX<MD;
                FMUL;
                        FADD ZERO,FA                    "4,PUT FA IN ADD PIPE
        FMUL DPX,MD;                                    "5,A*B
                FSUBR FM,DPY;                           "5,A*B-C*D
                        ADD M,E;SETMA;MI<FA;            "5,STORE E
                        BFGT LOOP                       "5,TEST&BRANCH
DONE:   RETURN                  "EXIT
        $END
"****** VAAM = VECTOR ADD, ADD, MULTIPLY /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VAAM
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VAAM,11.                          "USER-DIRECTED-CALL ENTRY
        " A,B,C,D,E ARE VECTORS WITH INCREMENTS I,J,K,L,M (NOT INDICIES).
        " THIS ALGORITHM PERFORMS THE FOLLOWIMG OPERATIONS  FOR THE 0TH
        "TO THE (N-1)TH COMPONENT:
        " (A+B)*(C+D)=>E
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST MEMORY
        "SIZE:      13 LOCATIONS
        "TIME:      WORST CASE: 8+10*N  .167 CYCLES
        "           BEST CASE: 6*(N+1)  .167 CYCLES
"
"    --- HISTORY ---
"ORIGINAL:  FEB 77  S. BERKOWITZ
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
        "DPX  -- TEMPORARY STORAGE
        "S-PAD - LOCATIONS 0 THROUGH 10.
        A $EQU 0.                           "BASE ADDRESS OF VECTOR A
        I $EQU 1.                           "INCREMENT BETWEEN ELEMENTS OF A
        B $EQU 2.                           "BASE ADDRESS OF VECTOR B
        J $EQU 3.                           "INCREMENT BETWEEN ELEMENTS OF B
        C $EQU 4.                           "BASE ADDRESS OF VECTOR C
        K $EQU 5.                           "INCREMENT BETWEEN ELEMENTS OF C
        D $EQU 6.                           "BASE ADDRESS OF VECTOR D
        L $EQU 7.                           "INCREMENT BETWEEN ELEMENTS OF D
        E $EQU 8.                           "BASE ADDRESS OF VECTOR E
        M $EQU 9.                           "INCREMENT BETWEEN ELEMENTS OF E
        N $EQU 10.          "LOOP COUNTER FOR THE NUMBER OF COMPONENTS DESIRED
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVAAM,11.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  3252
        $PARAM 11., P1(#2,#13)/R/IP, P2/I/IP,
                    P3(#4,#13)/R/IP, P4/I/IP,
                    P5(#6,#13)/R/IP, P6/I/IP,
                    P7(#10,#13)/R/IP, P8/I/IP,
                    P9(#12,#13)/R/OP, P10/I/IP,
                    P11/I/IP
FVAAM: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VAAM:   MOV A,A;SETMA                                     "FETCH A(0)
        MOV B,B;SETMA                                   "FETCH B(0)
        MOV C,C;SETMA                                   "FETCH C(0)
        MOV D,D;SETMA;                                  "FETCH D(0)
        DPX<MD
        FADD DPX,MD;                                    "A(0)+B(0)
          MOV N,N               "IS ELEMENT COUNT = 0?
        DPX<MD;
        FADD;
        SUB M,E;                                        "INITIALIZE E
          BEQ DONE              "EXIT IF COUNT = 0
LOOP:   ADD I,A;SETMA;                                  "FETCH A(P+1)
                                FADD DPX,MD;            "C(P)+D(P)
                                DPX<FA
        ADD J,B;SETMA;                                  "FETCH B(P+1)
                                FADD
        ADD K,C;SETMA;                                  "FETCH C(P+1)
                                FMUL DPX,FA             "(A(P)+B(P))*(C(P)+D(P))
        ADD L,D;SETMA;                                  "FETCH D(P+1)
                                DPX<MD;
                                FMUL
        FADD DPX,MD;                                    "A(P+1)+B(P+1)
                                FMUL;
                                DEC N                   "N=N-1
        DPX<MD;
        FADD;
                                ADD M,E;SETMA;MI<FM;    "STORE E(P)
                                BNE LOOP                "TEST&BRANCH
DONE:   RETURN                  "EXIT
        $END
"****** VSBSBM = VECTOR SUBTRACT, SUBTRACT, MULTIPLY /FAST/ = REL 3.1, SEP 79 **
        $TITLE VSBSBM
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSBSBM,11.                          "USER-DIRECTED-CALL ENTRY
        " A,B,C,D,E ARE VECTORS WITH INCREMENTS I,J,K,L,M (NOT INDICIES).
        " THIS ALGORITHM PERFORMS THE FOLLOWIMG OPERATIONS  FOR THE 0TH
        "TO THE (N-1)TH COMPONENT:
        " (A-B)*(C-D)=>E
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST MEMORY
        "SIZE:      13 LOCATIONS
        "TIME:      WORST CASE: 8+10*N  .167 CYCLES
        "           BEST CASE: 6*(N+1)  .167 CYCLES
"
"    --- HISTORY ---
"ORIGINAL:  FEB 77  S. BERKOWITZ
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
        "DPX  -- TEMPORARY STORAGE
        "S-PAD - LOCATIONS 0 THROUGH 10.
        A $EQU 0.                           "BASE ADDRESS OF VECTOR A
        I $EQU 1.                           "INCREMENT BETWEEN ELEMENTS OF A
        B $EQU 2.                           "BASE ADDRESS OF VECTOR B
        J $EQU 3.                           "INCREMENT BETWEEN ELEMENTS OF B
        C $EQU 4.                           "BASE ADDRESS OF VECTOR C
        K $EQU 5.                           "INCREMENT BETWEEN ELEMENTS OF C
        D $EQU 6.                           "BASE ADDRESS OF VECTOR D
        L $EQU 7.                           "INCREMENT BETWEEN ELEMENTS OF D
        E $EQU 8.                           "BASE ADDRESS OF VECTOR E
        M $EQU 9.                           "INCREMENT BETWEEN ELEMENTS OF E
        N $EQU 10.          "LOOP COUNTER FOR THE NUMBER OF COMPONENTS DESIRED
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSB2M,11.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  3252
        $PARAM 11., P1(#2,#13)/R/IP, P2/I/IP,
                    P3(#4,#13)/R/IP, P4/I/IP,
                    P5(#6,#13)/R/IP, P6/I/IP,
                    P7(#10,#13)/R/IP, P8/I/IP,
                    P9(#12,#13)/R/OP, P10/I/IP,
                    P11/I/IP
FVSB2M: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSBSBM:   MOV A,A;SETMA                                     "FETCH A(0)
        MOV B,B;SETMA                                   "FETCH B(0)
        MOV C,C;SETMA                                   "FETCH C(0)
        MOV D,D;SETMA;                                  "FETCH D(0)
        DPX<MD
        FSUB DPX,MD;                                    "A(0)-B(0)
          MOV N,N               "IS ELEMENT COUNT = 0?
        DPX<MD;
        FADD;
        SUB M,E;                                        "INITIALIZE E
          BEQ DONE              "EXIT IF COUNT = 0
LOOP:   ADD I,A;SETMA;                                  "FETCH A(P+1)
                                FSUB DPX,MD;            "C(P)-D(P)
                                DPX<FA
        ADD J,B;SETMA;                                  "FETCH B(P+1)
                                FADD
        ADD K,C;SETMA;                                  "FETCH C(P+1)
                                FMUL DPX,FA             "(A(P)-B(P))*(C(P)-D(P))
        ADD L,D;SETMA;                                  "FETCH D(P+1)
                                DPX<MD;
                                FMUL
        FSUB DPX,MD;                                    "A(P+1)-B(P+1)
                                FMUL;
                                DEC N                   "N=N-1
        DPX<MD;
        FADD;
                                ADD M,E;SETMA;MI<FM;    "STORE E(P)
                                BNE LOOP                "TEST&BRANCH
DONE:   RETURN                  "EXIT
        $END
"****** VAND = VECTOR LOGICAL AND /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VAND
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VAND,7                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"
"       --- ABSTRACT ---
"LOGICALLY ANDS VECTOR A TO VECTOR B AND PUTS THE RESULT
"INTO VECTOR C.  SEQUENCE IS TO ALIGN EXPONENTS, PERFORM THE
"LOGICAL AND, NORMALIZE, AND CONVERGENTLY ROUND.
"
"FORMULA: C(MK) = B(MJ) AND A(MI)     FOR M = 0 TO N-1
"           TRUTH TABLE:
"           0 AND 0 = 0
"           0 AND 1 = 0
"           1 AND 0 = 0
"           1 AND 1 = 1
"
"LOOP CONTROL IS DONE IN THE FLOATING ADDER. A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH FAST MEMORY
"SIZE:    12 LOCATIONS + SPUFLT (8) = 20 LOCATIONS
"SPEED: BEST:  13+3N (A,C EVEN; B,I,J,K ODD)
"       WORST: 15+6N
"       TYPICAL: 15+5N (A,B,C EVEN; I,J,K ODD)
"
"     ---HISTORY---
"ORIGINAL:  MAR 77  R.S NORIN
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                  --- USAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        B   $EQU   2                    "BASE ADDRESS OF VECTOR B
        J   $EQU   3                    "INDEX BETWEEN ELEMENTS OF B
        C   $EQU 4                      "BASE ADDRESS OF C
        K   $EQU   5                    "INDEX BETWEEN ELEMENTS OF C
        N   $EQU 6                      "NUMBER OF ELEMENTS IN C
"OTHER S-PAD PARAMETERS:
        NM $EQU 17
"DATA PAD PARAMETERS:
        NN $EQU 1  "FLOATED VECTOR LENGTH
"
"SCRATCH: SP(0,2,4,14,15), DPX(0-1),DPY(0), FA,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVAND,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVAND: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VAND:  MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                 MOV A,A;SETMA         "FETCH A(0)
                 MOV B,B;SETMA         "FETCH B(0)
                 SUB K,C
           ADD I,A;SETMA;              "FETCH A(1)
                 DPX<MD                "STORE A(0)
            ADD J,B;SETMA;             "FETCH B(1)
                 DPY<MD;               "STORE B(0)
                 FSUBR TM,DPX(NN)      "INITIALIZE COUNTER
                 FAND DPX,DPY          "A(0) AND B(0)
LOOP:  ADD I,A;SETMA;                   "FETCH A(M)
            DPX<MD                     "STORE A(M+1)
       ADD J,B;SETMA;                  "FETCH B(M)
            DPY<MD;                    "STORE B(M+1)
            FSUBR TM,FA                "DECREMENT COUNTER
            FAND DPX,DPY;              "A(M+1) AND B(M+1)
                 ADD K,C;SETMA;MI<FA;  "STORE A(M+2)+B(M+2)
                 BFGT LOOP             "BRANCH IF NOT DONE
DONE:   RETURN                  "EXIT
        $END
"****** VEQV = VECTOR LOGICAL EQUIVALENCE /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VEQV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VEQV,7                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"
"       --- ABSTRACT ---
"LOGICALLY EQUIVALENCES VECTOR A TO VECTOR B AND PUTS THE RESULT
"INTO VECTOR C.  SEQUENCE IS TO ALIGN EXPONENTS, PERFORM THE
"LOGICAL EQUIVALENCE, NORMALIZE, AND CONVERGENTLY ROUND.
"
"FORMULA: C(MK) = B(MJ) EQV A(MI)     FOR M = 0 TO N-1
"           TRUTH TABLE:
"           0 EQV 0 = 1
"           0 EQV 1 = 0
"           1 EQV 0 = 0
"           1 EQV 1 = 1
"
"LOOP CONTROL IS DONE IN THE FLOATING ADDER. A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH FAST MEMORY
"SIZE:    12 LOCATIONS + SPUFLT (8) = 20 LOCATIONS
"SPEED: BEST:  13+3N (A,C EVEN; B,I,J,K ODD)
"       WORST: 15+6N
"       TYPICAL: 15+5N (A,B,C EVEN; I,J,K ODD)
"
"     ---HISTORY---
"ORIGINAL:  MAR 77  R.S. NORIN
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                  --- USAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        B   $EQU   2                    "BASE ADDRESS OF VECTOR B
        J   $EQU   3                    "INDEX BETWEEN ELEMENTS OF B
        C   $EQU 4                      "BASE ADDRESS OF C
        K   $EQU   5                    "INDEX BETWEEN ELEMENTS OF C
        N   $EQU 6                      "NUMBER OF ELEMENTS IN C
"OTHER S-PAD PARAMETERS:
        NM $EQU 17
"DATA PAD PARAMETERS:
        NN $EQU 1  "FLOATED VECTOR LENGTH
"
"SCRATCH: SP(0,2,4,14,15), DPX(0-1),DPY(0), FA,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVEQV,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVEQV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VEQV:  MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                 MOV A,A;SETMA         "FETCH A(0)
                 MOV B,B;SETMA         "FETCH B(0)
                 SUB K,C
           ADD I,A;SETMA;              "FETCH A(1)
                 DPX<MD                "STORE A(0)
            ADD J,B;SETMA;             "FETCH B(1)
                 DPY<MD;               "STORE B(0)
                 FSUBR TM,DPX(NN)      "INITIALIZE COUNTER
                 FEQV DPX,DPY          "A(0) EQV B(0)
LOOP:  ADD I,A;SETMA;                   "FETCH A(M)
            DPX<MD                     "STORE A(M+1)
       ADD J,B;SETMA;                  "FETCH B(M)
            DPY<MD;                    "STORE B(M+1)
            FSUBR TM,FA                "DECREMENT COUNTER
            FEQV DPX,DPY;              "A(M+1) EQV B(M+1)
                 ADD K,C;SETMA;MI<FA;  "STORE A(M+2)+B(M+2)
                 BFGT LOOP             "BRANCH IF NOT DONE
DONE:   RETURN                  "EXIT
        $END
"****** VOR = VECTOR LOGICAL OR /FAST/ = REL 3.1, SEP 79 *****
        $TITLE VOR
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VOR,7                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
"
"       --- ABSTRACT ---
"LOGICALLY ORS VECTOR A TO VECTOR B AND PUTS THE RESULT
"INTO VECTOR C.  SEQUENCE IS TO ALIGN EXPONENTS, PERFORM THE
"LOGICAL OR, NORMALIZE, AND CONVERGENTLY ROUND.
"
"FORMULA: C(MK) = B(MJ) OR A(MI)     FOR M = 0 TO N-1
"           TRUTH TABLE:
"           0 OR 0 = 0
"           0 OR 1 = 1
"           1 OR 0 = 1
"           1 OR 1 = 1
"
"LOOP CONTROL IS DONE IN THE FLOATING ADDER. A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH FAST MEMORY
"SIZE:    12 LOCATIONS + SPUFLT (8) = 20 LOCATIONS
"SPEED: BEST:  13+3N (A,C EVEN; B,I,J,K ODD)
"       WORST: 15+6N
"       TYPICAL: 15+5N (A,B,C EVEN; I,J,K ODD)
"
"     ---HISTORY---
"ORIGINAL:  MAR 77  R.S. NORIN
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                  --- USAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        B   $EQU   2                    "BASE ADDRESS OF VECTOR B
        J   $EQU   3                    "INDEX BETWEEN ELEMENTS OF B
        C   $EQU 4                      "BASE ADDRESS OF C
        K   $EQU   5                    "INDEX BETWEEN ELEMENTS OF C
        N   $EQU 6                      "NUMBER OF ELEMENTS IN C
"OTHER S-PAD PARAMETERS:
        NM $EQU 17
"DATA PAD PARAMETERS:
        NN $EQU 1  "FLOATED VECTOR LENGTH
"
"SCRATCH: SP(0,2,4,15), DPX(0-1),DPY(0), FA,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVOR,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVOR: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VOR:  MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                 MOV A,A;SETMA         "FETCH A(0)
                 MOV B,B;SETMA         "FETCH B(0)
                 SUB K,C
           ADD I,A;SETMA;              "FETCH A(1)
                 DPX<MD                "STORE A(0)
            ADD J,B;SETMA;             "FETCH B(1)
                 DPY<MD;               "STORE B(0)
                 FSUBR TM,DPX(NN)      "INITIALIZE COUNTER
                 FOR DPX,DPY          "A(0) OR B(0)
LOOP:  ADD I,A;SETMA;                   "FETCH A(M)
            DPX<MD                     "STORE A(M+1)
       ADD J,B;SETMA;                  "FETCH B(M)
            DPY<MD;                    "STORE B(M+1)
            FSUBR TM,FA                "DECREMENT COUNTER
            FOR DPX,DPY;              "A(M+1) OR B(M+1)
                 ADD K,C;SETMA;MI<FA;  "STORE A(M+2)+B(M+2)
                 BFGT LOOP             "BRANCH IF NOT DONE
DONE:   RETURN                  "EXIT
        $END
"****** VINDEX = VECTOR INDEX /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE VINDEX
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VINDEX,6.                          "USER-DIRECTED-CALL ENTRY
        $EXT SPUFLT
        "THIS ALGORITHM USES B AS THE INDIRECT ADDRESS MAILBOX,
        "A AS THE RECIEPIENT, AND N AS THE VECTOR LENGTH.
        "
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH EITHER MEMORY
        "SIZE:      16. + SPUFLT (8) = 24. WORDS
        "TIME:      WORST: 16.+6*N  (FAST MEM)      16.+9*N  (STD MEM)
        "           BEST: 16.+4*N                   16.+6*N
"
"     ---HISTORY---
"ORIGINAL:  FEB 77  S. BERKOWITZ
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0.
"                                  ALSO REWRITTEN TO ADD WRTLMN TO LDMA
"                                  TO AVOID PAGE CHANGE.  THE REWRITTEN ROUTINE
"                                  WORKS FOR BOTH SPEEDS OF MEMORY
"
        "---------- SCRATCH ----------
        "DPX,DPY,DPX(1)   -- TEMPORARY STORAGE
        A $EQU 0                                        "BASE ADDR OF A
        B $EQU 1                                        "BASE ADDR OF B
        J $EQU 2                                        "INCREMENT OF B
        C $EQU 3                                        "BASE ADDR OF C
        K $EQU 4                                        "INCREMENT OF C
        N $EQU 5                                        "SIZE OF VECTORS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVINDX,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  64
        $PARAM  6 , P1(#6)/R/IP,
                    P2(#3,#6)/R/IP, P3/I/IP,
                    P4(#5,#6)/R/OP, P5/I/IP,
                    P6/I/IP
FVINDX: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VINDEX: MOV B,B;SETMA
        MOV A,17
        JSR SPUFLT
        ADD J,B;SETMA;                                   "1,FETCH B
                FADD DPX(1),MD                            "1,COMPUTE ADDRESS
        SUB K,C;                                        "2,BACK UP POINTER
                FADD                                    "2,PUSH
        MOV N,N;                                 "IS ELEMENT COUNT = 0?
                FIXT FA                                    "3,FIX ADDRESS
        FADD DPX(1),MD;                            "4,COMPUTE ADDRESS
          BEQ DONE                                  "EXIT IF COUNT = 0
        ADD J,B; SETMA;                             "1,GET INDEX
                FADD;                               "1,PUSH
                        DPX<FA                      "1,SAVE ADDRESS
                        LDMA; DB=DPX;WRTLMN         "2,FETCH VALUE
                FIXT FA                             "3,FIX ADDRESS
        FADD DPX(1),MD                              "4,COMPUTE ADDRESS
"HERE IS LOOP
LOOP:   ADD J,B; SETMA;                             "1, GET INDEX
                FADD;                               "1, PUSH
                        DPX<FA;                     "1, SAVE ADDRESS
                                DPY<MD              "1, SAVE VALUE
                        LDMA; DB=DPX; WRTLMN        "2, FETCH VALUE
                FIXT FA;                            "3, FIX ADDRESS
                                DEC N               "3, DECREMENT COUNT
        FADD DPX(1),MD;                             "4, COMPUTE ADDRESS
                                ADD K,C; SETMA;MI<DPY; "4, STORE VALUE
                                BNE LOOP            "4, BACK IF MORE VALUES
DONE:   RETURN                                        "EXIT
        $END
"
"****** VRVRS = VECTOR REVERSER, IN PLACE /COMMON/ = REL 3.1, AUG 80 ********
        $TITLE VRVRS
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC.
        $ENTRY VRVRS,3
        $EXT  SPMUL
"-------------------------------------------------------------------------
"
"---- ABSTRACT ------
"
"  THIS ROUTINE REVERSES THE ORDERING OF THE ELEMENTS OF A VECTOR,IN PLACE.
"
"    FORMULA:
"            COUT(MK) = CIN((N-1-M)K)  FOR M = 0 TO N-1.
"            NOTE: COUT & CIN PHYSICALLY OCCUPY THE SAME MD LOCATIONS.
"            HOWEVER, COUT IS THE VECTOR THAT IS AVAILABLE AS AN OUTPUT
"            AND CIN IS THE INPUT.
"
"
"---- STATISTICS -----
"
"LANGUAGE :  APAL
"EQUIPMENT:  AP 120B WITH EITHER MEMORY.
"SAMPLE
"FORTRAN
"CALL     :  CALL VRVRS (C,K,N)
"SIZE     :  19 + 14 APAL WORDS.
"SPEED    :    BEST     TYPICAL      WORST      SETUP (US)
"TIME/LOOP:     0.8      1.2          1.3         3.5  (167 NS MEM.)
"               1.5      1.8          2.0         3.5  (333 NS MEM.)
"EXTERNALS:  SPMUL
"SCRATCH  :  SP(0,2,16,17),FA,FM,MD
"
"  ---- HISTORY ----
"ORIGINAL:  SEP 79   D. GANGULY, R.S. NORIN
" REV 3.1:  AUG 80   D. GANGULY, R. GELLER
"                        1) ROUTINE NOW EXITS IF N IS NOT >1.
"                        2) CU IS NOW PROPERLY INIATIALIZED
"                           FOR K>1
"                        3) ADC LINKAGE CORRECTED
"
"
"--------------------------------------------------------------------------
"
" S-PAD ASSIGNMENTS.
"
        C = 0               "BASE ADDRESS OF C.
        K = 1               "ADDRESS INCREMENT OF C.
        N = 2               "ELEMENT COUNT OF C.
"
"       S-PADS USED FOR TEMPORARY STORAGE.
"
        CL = 16
        CU = 17
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
"  THIS SECTION IS TO BE ASSEMBLED CONDITIONALLY.
"
        $IF XADC = 1
        $SUBR FVRVRS,3
        $EXT RESLVE
        BITMAP $EQU 6
        $PARAM 3 ,P1(#2,#3)/R/IP/OP,P2/I/IP,P3/I/IP
FVRVRS: LDSPI 17;DB = BITMAP
        JSR RESLVE
        $ENDIF
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
VRVRS:  MOV C,CL                "SAVE C.
        MOV N,C
        BNE .+2                 "IS N = 0 ?
ZDONE:  RETURN                  "YUP! RETURN.
        JSR SPMUL               "DO N*K = <SP(0)>.
        MOV 0,CU                "SET CU = ADDR.OF A(N) + K
        SUB K, CU               "SET CU = ADDR. OF A(N).
        ADD CL,CU               "COMPUTE THE RELATIVE ADDR.OF A(N)
        MOVR N,N                "SET LOOP COUNT AT N/2
        SUB K,CL;               "OFFSET LOWER PNTR.
          BEQ ZDONE             "IF INT (N/2)=0, RETRN.
        ADD K,CU                "OFFSET UPPER PNTR.
LOOP:   ADD K,CL;SETMA          "1.GET A(I)
        SUB K,CU;SETMA          "2.GET A((N-1)-I)
        DEC N                   "3.DEC LOOP CNTR.
        MOV CU,CU;SETMA;MI<MD;  "4.STORE A(I) -> A((N-1)-I)
           BEQ DONE             "    EXIT IF DONE.
        MOV CL,CL;SETMA;MI<MD;  "5.STORE A((N-1)-I) -> A(I).
           BR LOOP              "    CONTINUE.
DONE:   MOV CL,CL;SETMA;MI<MD;  "STORE THE LAST A(I) AND EXIT.
           RETURN
        $END
"****** VFILL = VECTOR FILL WITH CONSTANT /COMMON/ = REL 3.2, AUG 80 *****
"       FOR EITHER MEMORY
        $TITLE VFILL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VFILL,4                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"FILLS VECTOR C WITH CONSTANT A
"
"FORMULA:  C(MK)=A,  FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 6 LOCATIONS
"SPEED: INTRO: 2 CYCLES
"       LOOP:  2-3  CYCLES
"       COLUMNS/LOOP: 1
"       (0.33-0.5)N + 0.33 USEC, FOR 167 NSEC CLOCK
"SUBROUTINES USED: NONE
"
"    --- HISTORY ---
"ORIGINAL:  JAN 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:   AUG 80  R. GELLER      CORRECTED ADC LINKAGE
"
"       ---USAGE---
"FORTRAN: CALL VFILL(A,C,K,N)
"APAL:    JSR VFILL
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "ADDRESS OF CONSTANT VALUE
     C  $EQU  1                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  2                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  3                 "NUMBER OF ELEMENTS IN C
"
"SCRATCH:  SP(1,3), DPA UNCHANGED
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVFILL,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  14
        $PARAM  4 , P1/R/IP,
                    P2(#3,#4)/R/OP, P3/I/IP,
                    P4/I/IP
FVFILL: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VFILL:  MOV A,A; SETMA          "FETCH THE CONSTANT
        MOV N,N                 "IS ELEMENT COUNT = 0?
        SUB K,C;                "BACK UP OUTPUT ADDRESS
          BEQ DONE              "EXIT IF COUNT = 0
LOOP:   DEC N                   "DECREMENT COUNT
        ADD K,C; SETMA; MI<MD;  "STORE CONSTANT
            BNE LOOP             "LOOP UNTIL
DONE:   RETURN                  "DONE. THEN EXIT
        $END
"****** VRAMP = VECTOR FILL WITH RAMP /COMMON/ = REL 3.1, SEP 79 *****
"       FOR EITHER MEMORY
        $TITLE VRAMP
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VRAMP,5                          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"FILLS A VECTOR C WITH A RAMP WHOSE INITIAL VALUE IS A
"AND INCREMENT IS B.
"
"FORMULA:  C(MK)=M*B+A,  FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 12 LOCATIONS
"SPEED: INTRO: 9-10 CYCLES
"       LOOP:  2-3  CYCLES
"       COLUMNS/LOOP: 4
"       FLOPS/LOOP:   3
"       (0.33-0.5)N + (1.5-1.67) USEC, FOR 167 NSEC CLOCK
"       MEGAFLOPS: 6.0-9.0
"SUBROUTINES USED: NONE
"
"    --- HISTORY ---
"ORIGINAL:  NOV 76  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"       ---USAGE---
"FORTRAN: CALL VRAMP(A,B,C,K,N)
"APAL:    JSR VRAMP
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "ADDRESS OF INITIAL RAMP VALUE
     B  $EQU  1                 "ADDRESS OF STEP INCREMENT
     C  $EQU  2                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  3                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  4                 "NUMBER OF ELEMENTS IN C
"TABLE MEMORY
 ONE  $EQU  !ONE
"
"SCRATCH:  SP(2,4), DPX(0), DPY(0), DPA UNCHANGED
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVRAMP,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  30
        $PARAM  5 , P1/R/IP, P2/R/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVRAMP: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VRAMP:  MOV B,B; SETMA              "FETCH B, THE INCREMENT
        LDTMA; DB=ONE                "FETCH 1.0 FROM TABLE MEMORY
        MOV A,A; SETMA               "FETCH A, THE INITIAL VALUE
PREP3:  FADD TM,ZERO;              "INCREMENT M
            DPX<MD;                  "SAVE B
          MOV N,N               "IS ELEMENT COUNT = 0?
        FADD;                       "PUSH
            DEC N;                  "DECREMENT COUNT
          BEQ DONE              "EXIT IF COUNT = 0
PREP2:  FADD TM,FA;             "INCREMENT M
            FMUL DPX,FA;            "1*B
            MOV C,C;SETMA;MI<MD;    "STORE C(0)=A
            DPY<MD;                 "SAVE A
            BEQ DONE                 "EXIT IF DONE
        FADD;                       "PUSHERS
            FMUL
PREP1:  FADD TM,FA;             "INCREMENT M
            FMUL DPX,FA             "2*B
            FMUL;                   "PUSH
                FADD FM,DPY         "1*B+A
LOOP:   FADD TM,FA;             "1. INCREMENT M
            FMUL DPX,FA;            "    (M+2)*B
                    DEC N           "    DECREMENT COUNT
            FMUL;                   "2. PUSH
                FADD FM,DPY;        "    (M+1)*B+A
                    ADD K,C;SETMA;MI<FA; "STORE M*B+A
                    BNE LOOP        "    CONTINUE UNTIL
DONE:   RETURN                  "DONE. THEN EXIT
        $END
"****** VDIV = VECTOR DIVIDE FOR EITHER MEMORY /COMMON/ = REL 3.1, SEP 79 ***
        $TITLE VDIV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VDIV,7                          "USER-DIRECTED-CALL ENTRY
"VECTOR DIVIDE
"               ---ABSTRACT---
"THIS DIVIDES THE ELEMENTS OF VECTOR Y BY THE ELEMENTS OF VECTOR X,
"AND PUTS THE QUOTIENTS IN VECTOR C.  IT ALSO KEEPS A COUNT IN S-PAD 17
"OF THE NUMBER OF TIMES A DIVIDE BY ZERO WAS ATTEMPTED.
"
"    C(M)=Y(M)/X(M)       FOR M= 1 TO N
"               ---STATISTICS---
"LANGUAGE:      AP-120B ASSEMBLER
"EQUIPMENT:     AP-120B WITH EITHER MEMORY
"SIZE:          76. LOCATIONS
"
"      ---HISTORY---
"ORIGINAL:  FEB 76  S. CAMLEY
"REV 2.1:   AUG 77  R.S. NORIN           ALLOWS FOR N>32767
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC        MEANING
"0           X               BASE ADDRESS OF VECTOR X
"1           I               INCREMENT FOR X
"2           Y               BASE ADDRESS FOR VECTOR Y
"3           J               INCREMENT FOR Y
"4           C               BASE ADDRESS OF ANSWER VECTOR
"5           K               INCREMENT FOR C
"6           N               NUMBER OF ELEMENTS IN C
"               ---SCRATCH---
"S-PAD:         ALL EXCEPT 12, 13, 14 (OCTAL).
"DATA PAD:      DPX(-1 TO +3), DPY(-4 TO +2), DPA UNCHANGED
"               ---ALGORITHM---
"SEE SCALAR DIVIDE FOR BASIC DESCRIPTION AND MEANING OF MI AND R.
"
"C=Y/X=((2*MI)(1-A+A**2-A**3))((SIGN X)*Y*2**(-E-1))
"
"    WHERE A=MI*R      AND
"    WHERE 1-A+A**2-A**3 IS FACTORED INTO (1-A)(1+A**2)
"NOTE:          THE CODE HAS BEEN TYPED WITH DIFFERENT INDENTATIONS
"               TO REFLECT THE 4-COLUMN STRUCTURE OF THE LOOP.
"S-PAD PARAMETERS
X = 0
I = 1
Y = 2
J = 3
C = 4
K = 5
N = 6
"THE FOLLOWING ARE NOT PARAMETERS:
ADR = 7
TBLADR = 10
E = 11
"S-PADS 15, 16, 17 ARE ALSO USED
"DATA PAD INITIALIZATIONS:
"DPY=MASK
"DPY(1)=1
"DPX(1)=-1
"WILL BE STORED INTO DATA PADS:
"DPY(2)=1-A
"DPY(-1)=(SIGN X)*Y
"DPY(-2)=A
"DPY(-3)=DPY(-4)=MI*2
"DPX(3)=ANSWER
"DPX(2)=(SIGN X)*Y*2**(-E-1)
"DPX=X
"DPX(-1)=2**(-E-1)
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVDIV,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVDIV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VDIV:   MOV X,X; SETMA                 "GET FIRST X
        LDSPI TBLADR; DB=!DIV; LDTMA   "GET DIV MASK
        INC TBLADR; SETTMA             "GET 1.0
        F2CSM MD;                      "CONVERT X(1) TO SIGN. MAG.
        MOV Y,Y; SETMA;                "GET Y(1)
        DPY<TM                         "STORE MASK
        DPY(1)<TM;                     "STORE 1.0
        INC TBLADR;                    "TBLADR=BEGINNING OF TABLE
        FSUBR TM,ZERO                  "MAKE -1.0
        DPX<FA;                        "STORE X(1)
        FADD
        BFGE .+2;                      "TEST SIGN OF X(1)
        LDSPT ADR; DB=DPX;             "GET TABLE BITS        X(1)
        DPX(1)<FA                      "STORE -1.0
        FSUB ZERO,MD;                  "IF X(1) WAS NEG,
        MOV N,N;                "IS ELEMENT COUNT = 0?
        BR .+2                         "  NEGATE Y(1)
        FADD ZERO,MD;                  "OTHERWISE, DON'T
          MOV N,N               "IS ELEMENT COUNT = 0?
        FADD; SUB K,C;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        FADD DPY(1),DPY(1);            "MAKE 2.0
        DPY(-1)<FA;                    "STORE +-Y(1)
        ADD ADR,TBLADR; SETTMA         "GET INV OF TABLE BITS   X(1)
        ADD I,X; SETMA;                "GET X(2)
            FADD
            FMUL TM,FA;                "DO 2*MI     X(1)
            FAND DPY,MDPX;             "MAKE R       X(1)
            CLR 17                     "INIT S-PAD 17 =0
            FMUL; FADD;
            LDSPE E; DB=DPX            "GET EXPONENT      X(1)
        F2CSM MD;                      "CONVERT X(2) TO SIGN. MAG.
        ADD J,Y; SETMA;                "GET Y(2)
            FMUL TM,FA                 "DO MI*R      X(1)
            DPY(-3)<FM;                "STORE 2*MI        X(1)
            FADD ZERO,DPX;             "X(1) IN ADDER
            FMUL;
            SUB ADR,TBLADR
        DPX<FA;                        "STORE X(2)
            FMUL;
            FSUB ZERO,MDPX(1); COM E   "CREATE 2**(-E-1)    X(1)
        BFGE POS1;                     "TEST SIGN OF X(2)
        LDSPT ADR; DB=DPX;             "GET TABLE BITS     X(2)
            FSUBR FM,DPY(1);           "DO 1-A       X(1)
            DPY(-2)<FM                 "STORE A        X(1)
"IF X(2) WAS NEG:
        FSUB ZERO,MD;                  "NEGATE Y(2)
            DPX(-1)<FA;                "STORE 2**(-E-1)    X(1)
            BFEQ DIVZ1;                "TEST IF DIV BY 0    X(1)
            FMUL DPY(-2),DPY(-2)       "DO A**2      X(1)
        FADD;
            FMUL DPY(-1),DPX(-1);      "DO +-Y(1)*2**(-E-1) =Y1T
            DPY(2)<FA;                 "STORE 1-A      X(1)
                    DEC N
        FADD DPY(1),DPY(1);            "MAKE 2.0
        DPY(-1)<FA;                    "STORE +-Y(2)
        ADD ADR,TBLADR; SETTMA;        "GET INV OF TABLE BITS    X(2)
            FMUL; BNE CONT1            "TEST IF N=1
            JMP PT1                    "IF SO, GO TO SPECIAL CASE
                                       "OTHERWISE, CONTINUE AT CONT1
"PROGRAM CAME HERE IF X(2) WAS POSITIVE.
"THIS DOESN'T NEGATE Y(2).  OTHERWISE, SAME CODE AS ABOVE.
POS1:   FADD ZERO,MD;
            DPX(-1)<FA;
            BFEQ DIVZ1;
            FMUL DPY(-2),DPY(-2)
        FADD;
            FMUL DPY(-1),DPX(-1);
            DPY(2)<FA;
                    DEC N;
                    BR POS1 - 2
"PROGRAM CAME HERE IF X(1) WAS ZERO.
"THIS CREATES POS. OR NEG. INFINITY WHEN GO BACK TO DO +-Y(1)*2**(-E-1)
DIVZ1:      DPY(-1)<DPY(-1);
            DPX(-1)<FA;
            INC 17
            WRTEXP;
            DPY(-1)<1777;
            DPX(-1)<1777;
            BR POS1 - 3
"CONTINUING ONWARD...
CONT1:  ADD I,X; SETMA;                "GET X(3)
                FADD FM,DPY(1); FMUL   "DO 1+A**2      X(1)
            FMUL TM,FA;                "DO 2*MI     X(2)
            FAND DPY,MDPX; CLR# X;     "MAKE R         X(2)
                DPX(2)<FM              "STORE Y1T
            FADD;
            LDSPE E; DB=DPX;           "GET EXPONENT     X(2)
                FMUL DPY(2),FA         "DO (1-A)(1+A**2) =PA   X(1)
        F2CSM MD;                      "CONVERT X(3) TO SIGN. MAG.
        ADD J,Y; SETMA;                "GET Y(3)
            FMUL TM,FA;                "DO MI*R     X(2)
                DPY(-4)<DPY(-3)
            DPY(-3)<FM;                "STORE 2*MI     X(2)
            FADD ZERO,DPX;             "X(2) IN ADDER
            FMUL;
            SUB ADR,TBLADR
        DPX<FA;                        "STORE X(3)
            FSUB ZERO,MDPX(1); COM E;  "CREATE 2**(-E-1)     X(2)
                FMUL FM,DPY(-4)        "DO PA*(2*MI)      X(1)
        BFGE POS2;                     "TEST SIGN OF X(3)
        LDSPT ADR; DB=DPX;             "GET TABLE BITS    X(3)
            FSUBR FM,DPY(1);           "DO 1-A    X(2)
            DPY(-2)<FM                 "STORE A      X(2)
"IF X(3) WAS NEG:
        FSUB ZERO,MD;                  "NEGATE Y(3)
            DPX(-1)<FA;                "STORE 2**(-E-1)     X(2)
            BFEQ DIVZ2;                "TEST IF DIV BY 0     X(2)
            FMUL DPY(-2),DPY(-2)       "DO A**2      X(2)
        FADD;
            FMUL DPY(-1),DPX(-1);      "DO +-Y(2)*2**(-E-1) =Y2T
            DPY(2)<FA;                 "STORE 1-A      X(2)
                    DEC N
        FADD DPY(1),DPY(1);            "MAKE 2.0
        DPY(-1)<FA;                    "STORE +-Y(3)
        ADD ADR,TBLADR; SETTMA;        "GET INV OF TABLE BITS   X(3)
                FMUL FM,DPX(2);        "DO Y1T*PA*(2*MI)    X(1)
                    BNE LOOP           "TEST IF N=2
            JMP PT2                    "IF SO, GO PAST LOOP
                                       "OTHERWISE, CONTINUE AT LOOP
"PROGRAM CAME HERE IF X(3) WAS POS.
"THIS DOESN'T NEGATE Y(3).  OTHERWISE, SAME CODE AS ABOVE.
POS2:   FADD ZERO,MD;
            DPX(-1)<FA;
            BFEQ DIVZ2;
            FMUL DPY(-2),DPY(-2)
        FADD;
            FMUL DPY(-1),DPX(-1);
            DPY(2)<FA;
                    DEC N;
                    BR POS2 - 2
"PROGRAM CAME HERE IF X(2)=0
"THIS CREATES POS. OR NEG. INFINITY WHEN GO BACK TO DO +-Y(2)*2**(-E-1)
DIVZ2:      DPY(-1)<DPY(-1);
            DPX(-1)<FA;
            INC 17
            WRTEXP;
            DPY(-1)<1777;
            DPX(-1)<1777;
            BR POS2 - 3
"ONWARD...TO THE LOOP AT LAST
LOOP:   ADD I,X; SETMA;                "GET X(L)
                FADD FM,DPY(1); FMUL   "DO 1+A**2   X(L-2)
            FMUL TM,FA;                "DO 2*MI     X(L-1)
            FAND DPY,MDPX; CLR# X;     "MAKE R      X(L-1)
                DPX(2)<FM              "STORE Y(L-2)T
            FADD;
            LDSPE E; DB=DPX;           "GET EXPONENT     X(L-1)
                FMUL DPY(2),FA;        "DO (1-A)(1+A**2) =PA   X(L-2)
                    DPX(3)<FM          "SAVE C(L-3)
        F2CSM MD;                      "CONVERT X(L) TO SIGN. MAG.
        ADD J,Y; SETMA;                "GET Y(L)
            FMUL TM,FA;                "DO MI*R     X(L-1)
                DPY(-4)<DPY(-3)
            DPY(-3)<FM;                "STORE 2*MI     X(L-1)
            FADD ZERO,DPX;             "X(L-1) IN ADDER
            FMUL;
            SUB ADR,TBLADR
        DPX<FA;                        "STORE X(L)
            FSUB ZERO,MDPX(1); COM E;  "CREATE 2**(-E-1)   X(L-1)
                FMUL FM,DPY(-4)        "DO PA*(2*MI)     X(L-2)
        BFGE POS;                      "TEST SIGN OF X(L)
        LDSPT ADR; DB=DPX;             "GET TABLE BITS     X(L)
            FSUBR FM,DPY(1);           "DO 1-A    X(L-1)
            DPY(-2)<FM                 "STORE A    X(L-1)
"IF X(L) WAS NEG.:
        FSUB ZERO,MD;                  "NEGATE Y(L)
            DPX(-1)<FA;                "STORE 2**(-E-1)    X(L-1)
            BFEQ DIVZ;                 "TEST IF DIV BY 0   X(L-1)
            FMUL DPY(-2),DPY(-2);      "DO A**2       X(L-1)
                    ADD K,C; SETMA; MI<DPX(3) "STORE C(L-3)
SPOT1:  FADD;
            FMUL DPY(-1),DPX(-1);      "DO +-Y(L-1)*2**(-E-1) =Y(L-1)T
            DPY(2)<FA;                 "STORE 1-A    X(L-1)
                    DEC N
SPOT2:  FADD DPY(1),DPY(1);            "MAKE 2.0
        DPY(-1)<FA;                    "STORE +-Y(L)
        ADD ADR,TBLADR; SETTMA;        "GET INV OF TABLE BITS    X(L)
                FMUL FM,DPX(2);        "DO Y(L-2)T*PA*(2*MI)   X(L-2)
                    BNE LOOP           "TEST IF DONE
"IF DONE, FINISH LAST COUPLE POINTS.
PT2:        FADD FM,DPY(1);            "DO 1+A**2       X(N)
                FMUL
            FADD; DPX(2)<FM;           "STORE YNT
                FMUL
            FMUL DPY(2),FA;            "DO (1-A)(1+A**2) =PA    X(N)
                ADD K,C; SETMA; MI<FM; "STORE C(N-1)
                BR PTCONT              "CONTINUE ELSEWHERE
"PROGRAM CAME HERE IF X(L) WAS POS.
"THIS DOESN'T NEGATE Y(L).  OTHERWISE, SAME CODE AS IN LOOP.
POS:    FADD ZERO,MD;
            DPX(-1)<FA;
            BFEQ DIVZ;
            FMUL DPY(-2),DPY(-2);
                    ADD K,C; SETMA; MI<DPX(3)
        FADD;
            FMUL DPY(-1),DPX(-1);
            DPY(2)<FA;
                    DEC N;
                    BR SPOT2
"PROGRAM CAME HERE IF X(L-1)=0
"THIS CREATES POS OR NEG INFINITY WHEN GO BACK TO DO +-Y(L-1)*2**(-E-1)
DIVZ:       DPY(-1)<DPY(-1);
            DPX(-1)<FA;
            INC 17
            WRTEXP;
            DPY(-1)<1777;
            DPX(-1)<1777;
            BR SPOT1
"SPECIAL CASE FOR N=1:
PT1:        FADD FM,DPY(1); FMUL       "DO 1+A**2     X(1)
            FADD; DPX(2)<FM            "STORE Y1T
            FMUL DPY(2),FA             "DO (1-A)(1+A**2) =PA     X(1)
PTCONT:     FMUL
            FMUL
            FMUL FM,DPY(-3)            "DO PA*(2*MI)     X(N)
            FMUL
            FMUL
            FMUL FM,DPX(2)             "DO YNT*PA*(2*MI)    X(N)
                    FMUL
                    FMUL
                    ADD K,C; SETMA; MI<FM "STORE C(N)
"THIS WILL TURN ON HARDWARE DIVIDE-BY-ZERO BIT IN APSTATUS IF ANY SUCH
"WERE ATTEMPTED.
HARDWR: MOV 17,17
        RAPS; LDSPNL 16;
        BEQ DONE
        LDSPI 15; DB=20000
        OR 15,16; DB=SPFN; LDAPS
DONE:   RETURN
        $END
"****** VTSMUL = VECTOR TABLE SCALAR MULTIPLY /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE VTSMUL
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VTSMUL,6.                          "USER-DIRECTED-CALL ENTRY
"       ---ABSTRACT----
"MULTIPLIES EACH ELEMENT OF VECTOR A BY THE TABLE MEMORY SCALAR B,
"AND STORES THE RESULT IN C.
"
"FORMULA:  C(MK) = A(MI) * B    FOR M=0 TO N-1
        "
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST OR STANDARD MEMORY
        "SIZE:      9. LOCATIONS
        "TIME:       BEST     TYPICAL     WORST      SETUP(US)
        "  167 NS    0.5         0.5        0.67        0.83
        "  333 NS    0.83        0.83       1.0         0.83
"
"    --- HISTORY ---
"ORIGINAL:  JUL 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
        "SP(0,3,5),FM,MD,TM
        A $EQU 0                                        "BASE ADDR OF A
        I $EQU 1                                        "INCREMENT OF A
        B $EQU 2                                    "TABLE MEMORY ADDR OF SCALAR
        C $EQU 3                                        "BASE ADDR OF C
        K $EQU 4                                        "INCREMENT OF C
        N $EQU 5                                       "SIZE OF VECTORS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVTSMU,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  66
        $PARAM  6 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3/I/IP,
                    P4(#5,#6)/R/OP, P5/I/IP,
                    P6/I/IP
FVTSMU: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VTSMUL: MOV A,A; SETMA          "GET A(0)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        MOV B,B; SETTMA;        "GET B FROM TABLE MEMORY
          BEQ DONE              "EXIT IF COUNT = 0
        ADD I,A; SETMA          "GET A(1)
        SUB K,C;                "BACK UP POINTER
            FMUL TM,MD          "B * A(0)
LOOP:   ADD I,A; SETMA;         "1. GET A(M+2)
                FMUL
            FMUL TM,MD;         "2. B * A(M+1)
                DEC N           "DECREMENT COUNTER
                ADD K,C; SETMA; MI<FM; "3. STORE C(M)
                BNE LOOP        "LOOP UNTIL DONE
DONE:   RETURN                  "EXIT
        $END
"****** VSQ = VECTOR SQUARE /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE VSQ
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSQ, 5                          "USER-DIRECTED-CALL ENTRY
"
"       --- ABSTRACT ---
"SQUARES EACH ELEMENT OF VECTOR A AND PUTS RESULT INTO
"VECTOR C.
"
"FORMULA: C(MK) = A(MI) * A(MI)     FOR M = 0 TO N-1
"
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH EITHER MEMORY
"SIZE:    9 LOCATIONS
"SPEED: BEST (FAST):  5+3N (A,C EVEN; I,K ODD)
"        (STANDARD):  5+4N (A,I,K EVEN; C ODD)
"       WORST (FAST): 5+4N
"         (STANDARD): 6+6N
"       TYPICAL (FAST): 5+4N (A,C EVEN; I,K ODD)
"           (STANDARD): 5+5N (A,C EVEN; I,K ODD)
"
"    --- HISTORY ---
"ORIGINAL:  MAR 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                  --- USAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        C   $EQU   2                    "BASE ADDRESS OF C
        K   $EQU   3                    "INDEX BETWEEN ELEMENTS OF C
        N   $EQU   4                    "NUMBER OF ELEMENTS IN C
"
"SCRATCH: SP(0,2,4), DPX(0), FM,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSQ,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVSQ: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSQ:   MOV A,A; SETMA                  "FETCH A(0)
        SUB K,C                 "BACK UP OUTPUT POINTER
        ADD I,A;SETMA           "FETCH A(1)
        MOV N,N;                "IS ELEMENT COUNT = 0?
            DPX<MD               "SAVE A(0)
        BEQ DONE;               "EXIT IF COUNT = 0
            FMUL DPX,DPX        "SQUARE A(0)
LOOP:   ADD I,A; SETMA;         "1. FETCH A(M+2)
            DPX<MD;             "   SAVE A(M+1)
                FMUL
            FMUL DPX,DPX;       "2. SQUARE A(M+1)
                DEC N           "DECREMENT COUNTER
                ADD K,C;SETMA;MI<FM; "3. STORE C(M)
                BNE LOOP        "   CONTINUE UNTIL
DONE:   RETURN                  "EXIT
        $END
"****** VSQRT = VECTOR SQUARE ROOT FOR EITHER MEMORY /COMMON= REL 3.1, SEP 79 **
$TITLE VSQRT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
 $ENTRY VSQRT,5                          "USER-DIRECTED-CALL ENTRY
"VECTOR SQUARE ROOT
"               ---ABSTRACT---
"THIS TAKES THE SQUARE ROOT OF EACH ELEMENT OF VECTOR A,
"AND FORMS VECTOR C (ANSWERS), BOTH VECTORS OF LENGTH N.
"FOR NEGATIVE NUMBERS, IT TAKES THE SQUARE ROOT AS THOUGH
"POSITIVE, AND KEEPS A COUNT IN S-PAD 17 OF THE NUMBER
"OF TIMES A SQUARE ROOT OF A NEGATIVE NUMBER WAS REQUESTED.
"C(M)=SQRT(A(M)) FOR M= 1 TO N
"               ---STATISTICS---
"LANGUAGE:      AP-120B ASSEMBLER
"EQUIPMENT:     AP-120B WITH EITHER MEMORY
"SIZE:          80. LOCATIONS
"
"       ---HISTORY---
"ORIGINAL:  FEB 76  S. CAMLEY
"REV 2.1:   AUG 77  R.S. NORIN      ALLOWS N>32767
" REVISED:  NOV 78  R.S. NORIN   USES TM ADDR LABEL !DIVD2 IN PLACE
"                                OF !DIV/2 FOR APAL3 COMPATIBILITY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REG #   MNEMONIC    MEANING
" 0        A         BASE ADDRESS OF VECTOR A
" 1        I         INCREMENT FOR A
" 2        C         BASE ADDRESS OF VECTOR C
" 3        K         INCREMENT FOR C
" 4        N         NUMBER OF ELEMENTS IN C
"               ---SCRATCH---
"S-PAD:         0-8, AND 15 (DECIMAL)
"DATA PAD:      DPX(-4 TO -2, 0 TO 3), DPY(-4 TO +3), DPA UNCHANGED
"               ---ALGORITHM---
"SEE DOCUMENTATION ON SCALAR SQUARE ROOT.
"THIS BASICALLY MULTIPLIES SEVERAL FACTORS TOGETHER,THE
"FACTORS HAVING BEEN DERIVED AS FOLLOWS:
"SQRT(X)=SQRT(2**E * F)=2**(E/2) * SQRT(F)
"AS (E/2) IS AN INTEGER, 2**(E/2) IS FACTORED INTO
"
"2**(E/2)=Q * 2**(E/2)
"    WHERE Q=1 IF E IS EVEN
"    AND    =SQRT(2) IF E IS ODD
"    (AND   =0, CONVENIENTLY, IF X=0)
"F IS ALSO FACTORED INTO TABLE LOOKUP BITS AND REMAINDER:
"
"SQRT(F)=SQRT(M+R)=SQRT(M(1+R/M))=
"  SQRT(M) * SQRT(1+MI*R)=  MS * SQRT(1+A)
"
"MI IS AN INDEX INTO THE INVERSE TABLE, MS INTO THE SQRT TABLE.
"SQRT(1+A) IS APPROXIMATED BY THE SERIES:
"
"1+ A/2 - A**2/8 + A**3/16
"
"WHICH, FOR VARIOUS REASONS, IS FACTORED INTO:
"
"1/2 * (4 + (A/2 - 1)*((A/2)**2 + 2) )
"THE FINAL ALGORITHM BECOMES:
"
"SQRT(X)=Q * 1/2 * 2**(E/2) * MS * (4+ (A/2 -1)*((A/2)**2 +2) )
"NOTE:  THIS PROGRAM HAS A 4-COLUMN LOOP, AND THE CODE HAS BEEN
"       TYPED TO REFLECT THIS STRUCTURE BY INDENTATION OF
"       SEPARATE COLUMNS.
"S-PAD PARAMETERS:
A = 0
I = 1
C = 2
K = 3
N = 4
"THE FOLLOWING ARE NOT PARAMETERS:
ADR = 5
E = 6
SQRTBL = 7
INVTBL = 10
"(ALSO USES S-PAD 17)
"DATA PAD INITIALIZATIONS:
"DPX(3)=1/2
"DPX(2)=2
"DPX(-4)=4
"DPY(2)=MASK
"DPY(1)=SQRT OF 2
"DPY=1
"DPY(-1)=0
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSQRT,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVSQRT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSQRT:  LDSPI E; DB=!HALF              "ADDRESS OF 0.5
        DB=!SQRT + 3; LDTMA            "GET 2.0
        DECTMA;                        "GET 1.0
          MOV N,N               "IS ELEMENT COUNT = 0?
                                       "STORE 2.0
        DPX(2)<TM; DECTMA;             "GET SQRT(2)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
                                       "STORE 1.0
        DPY<TM; DECTMA;                "GET MASK
        FADD DPX(2),DPX(2)             "MAKE 4.0
        DPY(1)<TM; FADD                "STORE SQRT(2)
        DPY(2)<TM;                     "STORE MASK
        DPX(-4)<FA                     "STORE 4.0
        MOV A,A; SETMA;                "GET A(1)
        DPY(-1)<ZERO                   "STORE 0.0
        LDSPI SQRTBL; DB=!SQRT + 4     "BASE ADDRESS OF SQRT TABLE
                                       "BASE ADDRESS OF DIV TABLE,
                                       "  SHIFTED RIGHT FOR
        LDSPI INVTBL; DB=!DIVD2 + 1    "  LATER TRICK
        F2CSM MD;                      "SIGN MAG OF A(1)
        CLR 17                         "INIT S-PAD 17 =0
        FADD;
        SUB K,C
        DPX<FA;                        "STORE A(1)
        LDSPI ADR; DB=-1
"IN THE FOLLOWING INSTRUCTION, THE "FLOATING AND" IS USING
"THE MASK TO GET THE REMAINDER BITS, AND THE EXPONENT OF -1
"USED BY MDPX PRODUCES A FACTOR OF 1/2.
        LDSPT ADR; DB=DPX;             "TABLE BITS OF A(1)
        FAND DPY(2),MDPX               "MAKE 1/2 R                  A(1)
        MOVR ADR,ADR;                  "GET RID OF EXTRA TABLE BIT  A(1)
        FADD
        FADD ZERO,MD;                  "FOR LATER TEST
        ADDL# ADR,INVTBL; SETTMA;      "GET MI                      A(1)
        DPY(-4)<FA                     "STORE 1/2 R                 A(1)
        FADD; MOV E,E; SETTMA          "GET 0.5
"FOR FUTURE COMMENTS, DO NOT CONFUSE "A"  (=MI*R)
"WITH AN ELEMENT OF VECTOR A,  A(M).
        FMUL TM,DPY(-4);               "MI * R/2 = A/2              A(1)
        LDSPE E; DB=DPX                "EXP OF A(1)
        ADD I,A; SETMA;                "GET A(2)
            FMUL;
            FADD ZERO,MD;              "FOR LATER TEST
            BFGE .+2;                  "TEST IF A(1)>0
            DPX(3)<TM                  "STORE 0.5
                                       "IF A(1) IS NEG,
            INC 17                     "  ADD 1 TO S-PAD 17
            FMUL;
            MOVR E,E; FADD ZERO,MDPX(3) "1/2 * 2**(E/2)             A(1)
            FSUB FM,DPY;               "A/2 -1                      A(1)
            DPX(-2)<FM;                "STORE A/2                   A(1)
            BNC ODDQ1                  "TEST IF E WAS ODD           A(1)
"IF E WAS EVEN...
        F2CSM MD;                      "SIGN MAG OF A(2)
            FMUL DPX(-2),DPX(-2);      "(A/2)**2                    A(1)
            DPX(-3)<FA;                "STORE 1/2 * 2**(E/2)        A(1)
            BFEQ ZILCH1                "TEST IF A(1)=0
"IF A(1) NOT = 0...
        FADD;
            FMUL DPY,DPX(-3);          "1 * 1/2 * 2**(E/2)          A(1)
            ADD# ADR,SQRTBL; SETTMA;   "GET MS                      A(1)
            DPX(1)<FA                  "STORE A/2 -1                A(1)
        DPX<FA;                        "STORE A(2)
        LDSPI ADR; DB=-1
SPOT1:  LDSPT ADR; DB=DPX;             "TABLE BITS OF A(2)
        FAND DPY(2),MDPX;              "MAKE 1/2 R                  A(2)
            FMUL
        MOVR ADR,ADR;                  "GET RID OF EXTRA TABLE BIT  A(2)
            FADD FM,DPX(2);            "(A/2)**2 +2                 A(1)
            FMUL; DPY(-3)<TM           "STORE MS                    A(1)
        FADD ZERO,MD;                  "FOR LATER TEST
        ADDL# ADR,INVTBL; SETTMA;      "GET MI                      A(2)
        DPY(-4)<FA;                    "STORE 1/2 R                 A(2)
            FMUL FM,DPY(-3)            "Q * 1/2 * 2**(E/2) * MS     A(1)
"THE ABOVE PRODUCT WILL BE REFERRED TO AS Q2MS IN FURTHER COMMENTS
        FADD;
            FMUL DPX(1),FA;            "(A/2 -1)((A/2)**2 +2)       A(1)
                    DEC N
"THE ABOVE PRODUCT WILL BE REFERRED TO AS A2F IN FURTHER COMMENTS
        FMUL TM,DPY(-4);               "MI * R/2 = A/2              A(2)
        LDSPE E; DB=DPX;               "EXP OF A(2)
                    BNE CONT1          "TEST IF N=1
"THE LOOP DROPS OUT 2 TIMES EARLY, SO N=1 AND N=2 ARE SPECIAL CASES,
"FITTING INTO THE FINISHING CODE AFTER THE LOOP.
                                       "IF N=1, GO TO SPECIAL CASE.
                                       "  OTHERWISE, WILL HAVE BRANCHED
        JMP ONE                        "  TO CONTINUING POINT.
"PROGRAM CAME HERE IF E OF A(1) WAS ODD.  CODE IS SAME AS ABOVE
"EXCEPT AS NOTED.
ODDQ1:  F2CSM MD;
            FMUL DPX(-2),DPX(-2);
            DPX(-3)<FA;
            BFEQ ZILCH1
        FADD;
            FMUL DPY(1),DPX(-3);       "SQRT(2) * 1/2 * 2**(E/2)    A(1)
            ADD# ADR,SQRTBL; SETTMA;
            DPX(1)<FA
        DPX<FA;
        LDSPI ADR; DB=-1;
        BR SPOT1
"PROGRAM CAME HERE IF A(1)=0.  CODE IS SAME AS ABOVE, EXCEPT
"AS NOTED.
ZILCH1: FADD;
            FMUL DPY(-1),DPX(-3);      "0 * 1/2 * 2**(E/2)          A(1)
            ADD# ADR,SQRTBL; SETTMA;
            DPX(1)<FA
        DPX<FA;
        LDSPI ADR; DB=-1;
        BR SPOT1
"ONWARD...
CONT1:  ADD I,A; SETMA;                "GET A(3)
            FMUL;
            FADD ZERO,MD;              "FOR LATER TEST
            BFGE .+2;                  "TEST IF A(2)>0
                DPY(-2)<FM             "STORE Q2MS                  A(1)
                                       "IF A(2) IS NEG,
            INC 17                     "  ADD 1 TO S-PAD 17
            FMUL;
            MOVR E,E; FADD ZERO,MDPX(3); "1/2 * 2**(E/2)            A(2)
                DPY(3)<FM              "STORE A2F                   A(1)
            FSUB FM,DPY;               "A/2 -1                      A(2)
            DPX(-2)<FM;                "STORE A/2                   A(2)
            BNC ODDQ2                  "TEST IF E WAS ODD           A(2)
"IF E WAS EVEN...
        F2CSM MD;                      "SIGN MAG OF A(3)
            FMUL DPX(-2),DPX(-2);      "(A/2)**2                    A(2)
            DPX(-3)<FA;                "STORE 1/2 * 2**(E/2)        A(2)
            BFEQ ZILCH2                "TEST IF A(2)=0
"IF A(2) NOT = 0...
        FADD;
            FMUL DPY,DPX(-3);          "1 * 1/2 * 2**(E/2)          A(2)
            ADD# ADR,SQRTBL; SETTMA;   "GET MS                      A(2)
            DPX(1)<FA                  "STORE A/2 -1                A(2)
        DPX<FA;                        "STORE A(3)
        LDSPI ADR; DB=-1;
                FADD DPY(3),DPX(-4)    "4+A2F                       A(1)
SPOT2:  LDSPT ADR; DB=DPX;             "TABLE BITS OF A(3)
        FAND DPY(2),MDPX;              "MAKE 1/2 R                  A(3)
            FMUL
        MOVR ADR,ADR;                  "GET RID OF EXTRA TABLE BIT  A(3)
            FADD FM,DPX(2);            "(A/2)**2 +2                 A(2)
            DPY(-3)<TM;                "STORE MS                    A(2)
                FMUL DPY(-2),FA        "Q2MS * (4+A2F)              A(1)
        FADD ZERO,MD;                  "FOR LATER USE
        ADDL# ADR,INVTBL; SETTMA;      "GET MI                      A(3)
        DPY(-4)<FA;                    "STORE 1/2 R                 A(3)
            FMUL FM,DPY(-3)            "Q * 1/2 * 2**(E/2) * MS     A(2)
        FADD;
            FMUL DPX(1),FA;            "(A/2 -1)((A/2)**2 +2)       A(2)
                    DEC N
        FMUL TM,DPY(-4);               "MI * R/2 = A/2              A(3)
        LDSPE E; DB=DPX;               "EXP OF A(3)
                DPY(-3)<FM;            "SAVE C(1)
                    BNE LOOP           "TEST IF N=2
                                       "IF N=2, GO PAST THE LOOP.
                                       "  OTHERWISE WILL HAVE
        JMP EARLY                      "  BRANCHED TO LOOP.
"PROGRAM CAME HERE IF E OF A(2) WAS ODD.  CODE IS
"SAME AS ABOVE EXCEPT AS NOTED.
ODDQ2:  F2CSM MD;
            FMUL DPX(-2),DPX(-2);
            DPX(-3)<FA;
            BFEQ ZILCH2
        FADD;
            FMUL DPY(1),DPX(-3);       "SQRT(2) * 1/2 * 2**(E/2)    A(2)
            ADD# ADR,SQRTBL; SETTMA;
            DPX(1)<FA
        DPX<FA;
        LDSPI ADR; DB=-1;
                FADD DPY(3),DPX(-4);
                BR SPOT2
"PROGRAM CAME HERE IF A(2)=0.  CODE IS SAME AS ABOVE
"EXCEPT AS NOTED.
ZILCH2: FADD;
            FMUL DPY(-1),DPX(-3);      "0 * 1/2 * 2**(E/2)          A(2)
            ADD# ADR,SQRTBL; SETTMA;
            DPX(1)<FA
        DPX<FA;
        LDSPI ADR; DB=-1;
                FADD DPY(3),DPX(-4);
                BR SPOT2
"FINALLY...
LOOP:   ADD I,A; SETMA;                "GET A(M+3)
            FMUL;
            FADD ZERO,MD;              "FOR LATER TEST
            BFGE .+2;                  "TEST IF A(M+2)>0
                DPY(-2)<FM             "STORE Q2MS                A(M+1)
                                       "IF A(M+2) IS NEG,
            INC 17                     "  ADD 1 TO S-PAD 17
            FMUL;
            MOVR E,E; FADD ZERO,MDPX(3); "1/2 * 2**(E/2)          A(M+2)
                DPY(3)<FM              "STORE A2F                 A(M+1)
            FSUB FM,DPY;               "A/2 -1                    A(M+2)
            DPX(-2)<FM;                "STORE A/2                 A(M+2)
            BNC ODDQ                   "TEST IF E WAS ODD         A(M+2)
"IF E WAS EVEN...
        F2CSM MD;                      "SIGN MAG OF A(M+3)
            FMUL DPX(-2),DPX(-2);      "(A/2)**2                  A(M+2)
            DPX(-3)<FA;                "STORE 1/2 * 2**(E/2)      A(M+2)
            BFEQ ZILCH;                "TEST IF A(M+2)=0
                    ADD K,C; SETMA; MI<DPY(-3) "STORE C(M)
"IF A(M+2) NOT = 0...
        FADD;
            FMUL DPY,DPX(-3);          "1 * 1/2 * 2**(E/2)        A(M+2)
            ADD# ADR,SQRTBL; SETTMA;   "GET MS                    A(M+2)
            DPX(1)<FA                  "STORE A/2 -1              A(M+2)
        DPX<FA;                        "STORE A(M+3)
        LDSPI ADR; DB=-1;
                FADD DPY(3),DPX(-4)    "4+A2F                     A(M+1)
SPOT:   LDSPT ADR; DB=DPX;             "TABLE BITS OF A(M+3)
        FAND DPY(2),MDPX;              "MAKE 1/2 R                A(M+3)
            FMUL
        MOVR ADR,ADR;                  "GET RID OF EXTRA TBL BIT  A(M+3)
            FADD FM,DPX(2);            "(A/2)**2 +2               A(M+2)
            DPY(-3)<TM;                "STORE MS                  A(M+2)
                FMUL DPY(-2),FA        "Q2MS * (4+A2F)            A(M+1)
        FADD ZERO,MD;                  "FOR LATER TEST
        ADDL# ADR,INVTBL; SETTMA;      "GET MI                    A(M+3)
        DPY(-4)<FA;                    "STORE 1/2 R               A(M+3)
            FMUL FM,DPY(-3)            "Q * 1/2 * 2**(E/2) * MS   A(M+2)
        FADD;
            FMUL DPX(1),FA;            "(A/2 -1)((A/2)**2 +2)     A(M+2)
                    DEC N
        FMUL TM,DPY(-4);               "MI * R/2 = A/2            A(M+3)
        LDSPE E; DB=DPX;               "EXP OF A(M+3)
                DPY(-3)<FM;            "SAVE C(M+1)
                    BNE LOOP           "TEST IF TIME TO DROP OUT
"IF DROPPED OUT OF LOOP OR N=2, NEED TO FINISH UP
"LAST 2 POINTS...
EARLY:          FMUL;
                DPY(-2)<FM;            "STORE Q2MS                A(N)
                    ADD K,C; SETMA; MI<DPY(-3); "STORE C(N-1)
                    BR FINISH          "GO FINISH UP
"PROGRAM CAME HERE FOR N=1...
ONE:            FMUL;
                DPY(-2)<FM;            "STORE Q2MS                A(N)
                BR FINISH              "GO FINISH UP
"PROGRAM CAME HERE IF E OF A(M+2) WAS ODD.  CODE IS SAME
"AS ABOVE EXCEPT AS NOTED.
ODDQ:   F2CSM MD;
            FMUL DPX(-2),DPX(-2);
            DPX(-3)<FA;
            BFEQ ZILCH;
                    ADD K,C; SETMA; MI<DPY(-3)
        FADD;
            FMUL DPY(1),DPX(-3);       "SQRT(2) * 1/2 * 2**(E/2)  A(M+2)
            ADD# ADR,SQRTBL; SETTMA;
            DPX(1)<FA
        DPX<FA;
        LDSPI ADR; DB=-1;
                FADD DPY(3),DPX(-4);
                BR SPOT
"PROGRAM CAME HERE IF A(M+2)=0.  CODE IS SAME AS ABOVE EXCEPT
"AS NOTED.
ZILCH:  FADD;
            FMUL DPY(-1),DPX(-3);      "0 * 1/2 * 2**(E/2)        A(M+2)
            ADD# ADR,SQRTBL; SETTMA;
            DPX(1)<FA
        DPX<FA;
        LDSPI ADR; DB=-1;
                FADD DPY(3),DPX(-4);
                BR SPOT
"THE END...
FINISH:         FADD FM,DPX(-4)        "4+A2F                     A(N)
                FADD
                FMUL DPY(-2),FA        "Q2MS * (4+A2F)            A(N)
                FMUL
                FMUL
                    ADD K,C; SETMA; MI<FM; "STORE C(N)
                    RETURN
 $END
"****** VLOG = VECTOR LOGARITHM (BASE 10) /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE VLOG
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VLOG,5                          "USER-DIRECTED-CALL ENTRY
"
"               --- ABSTRACT ---
"COMPUTES NATURAL LOGARITHM OF ELEMENTS OF A VECTOR.
"
"FORMULA:  C(MK) = LOG (ABS(A(MI))   FOR M=0 TO N-1
"
"LOG(0) RETURNS -2**511
"
"
"               --- STATISTICS ---
"LANGUAGE:      AP 120B ASSEMBLER
"EQUIPMENT:     AP 120B WITH EITHER MEMORY
"SIZE:  62 LOCATIONS
"EXECUTION       BEST    TYPICAL       WORST       SETUP(US)
"TIME/LOOP        2.7       2.7         2.7          6.0       167 NS MEMORY
" (US)            2.7       2.7         2.7          6.0       333 NS MEMORY
"
"(NOTE: TIMES ASSUME NONZERO ARGUMENT AND MAX NO. OF TESTS TO DETERMINE
" RANGE OF U)
"
"               --- HISTORY ---
"ORIGINAL: DEC 75  A.E. CHARLESWORTH
"          JUL 77  R.S. NORIN      JMP VFCL1 REPLACES JSR VFCL1, RETURN
"          SEP 77  R.S. NORIN      SCALAR LN ROUTINE VECTORIZED, SAVING TIME
"          JAN 78  H. WILLIAMS     REWRITTEN TO SAVE MORE TIME
"          FEB 79  H. WILLIAMS     ELIMINATES OVERFLOW IN INTRODUCTION
"          APR 79  P. PINCUS       FIXES BUGS TO GENERATE CORRECT
"                                       OVERFLOW DATA AND STATUS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"
"               --- USEAGE ---
"FORTRAN CALL:  CALL VLOG (A,I,C,K,N)
"APAL CALL:     JSR VLOG
"SCRATCH:       SP(0,2,4,13-17), DPX(0-3), DPY(-1 TO 3), FA, FM, MD, TM
"
"S-PAD PARAMETERS:
"  NAME       NUMBER
    A  $EQU     0       "BASE ADDRESS OF SOURCE VECTOR
    I  $EQU     1       "ADDRESS INCREMENT FOR A
    C  $EQU     2       "BASE ADDRESS OF DESTINATION VECTOR
    K  $EQU     3       "ADDRESS INCREMENT FOR C
    N  $EQU     4       "ELEMENT COUNT
"
"
"               --- ALGORITHM ---
"
"1.     X=U*2**S, 1/2<U<1
"       THEREFORE: LN(X) = LN(U)+S*LN(2)
"                  LOG(X) = LN(X)*LOG(E)
"
"2.     LN(U) IS APPROXIMATED BY A DEGREE 6 POLYNOMIAL IN V=1-U
"               THE RANGE OF U (.5-1) IS SPLIT INTO
"               THREE SMALLER INTERVALS:
"               1.  (2**-1/3,1)
"               2.  (2**-2/3,2**-1/3)
"               3.  (2**-1,2**-2/3)
"       AN APPROPRIATE BATCH OF COEFFICIENTS IS USED
"               CORRESPONDING TO THE RANGE OF U
"3.     THE POLYNOMIAL IS FACTORED:
"       (((S*LN(2)+(A+BV))+DV3)+CV2)+V4((E+FV)+GV2)
"THE TABLE IN TM IS AS FOLLOWS:
"
"LOGTBL:ONE     1.0
"       2**-1/3  .79370 05260
"       2**-2/3  .62996 05249
"       LN(2)    .69314 71806
"       LOG(E)   .43429 44819
"INT1:  F1      -.14825 42157
"       B1      -.99999 97290
"       D1      -.33274 95766
"       A1      -.57905 56132  E -9
"       G1      -.32673 03578
"       E1      -.25777 00332
"       C1      -.50002 06172
"INT2:  F2       .11470 25427  E 1
"       B2      -.99591 78076
"       D2      -.10032 29591
"       A2      -.16725 61518  E -3
"       G2      -.13069 21431  E 1
"       E2      -.99836 51833
"       G2      -.54190 43800
"INT3:  F3       .10112 39163  E 2
"       B3      -.79241 73643
"       D3       .43431 41103  E 1
"       A3      -.13525 63592  E -1
"       G3      -.52276 85725  E 1
"       E3      -.96093 14753  E 1
"       C3      -.18402 11907  E 1
"
"DOCUMENTATION NOTE: WHEN X=0 OCCURS IN THE LOOP, BIT 15 OF SP(ZEROFLAG)
"IS SET TO 1.  EACH COLUMN SHIFTS THE FLAG 1 LEFT.  IN COLUMN 3,
"THE FLAG, NOW AT BIT 13, IS TESTED.  "-INFINITY" IS STORED.
"
"S-PAD MNEMONICS:
        MASK $EQU 13
        ZEROFLAG $EQU 14
"
"DATA PAD MNEMONICS:
"DPX:
        X $EQU 0
        U $EQU 0
        V $EQU 0
        XTEMP $EQU 1
        XTEMP1 $EQU 2
        S $EQU 3
"DPY:
        NEGINF $EQU -1
        V2 $EQU 0
        YTEMP $EQU 1
        YTEMP1 $EQU 2
        LN2 $EQU 2              "(NOTE: USES SAME STORAGE AS YTEMP1)
        LOGE $EQU 3
"LOCATION OF THE LOG TABLE
        LOGTBL $EQU !LOG
        LOGTB1 $EQU LOGTBL+4
        INT2 $EQU LOGTBL+12.
        INT3 $EQU LOGTBL+19.
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVLOG,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVLOG: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VLOG:   MOV A,A; SETMA                  "1.  GET A(0)
        SUB K,C; LDTMA; DB=LOGTB1       "2.  C(-1); TMA=LOG(E)
        DPX(XTEMP)<1777;                "3.  TO SETUP DPY(NEGINF)
        CLR MASK                        "    BEGIN SETUP OF MASK
        FABS MD;                        "4.  GET ABS(A(0))
        LDSPI 16; DB=27.                "    SP16=EXPON FOR FLOATING
        LDSPI 17;DB=2                   "4A.  SET SO SPFN = 2 FOR FLOAT
        DPY(LOGE)<TM;                   "5.  DPY(LOGE)=LOG(E)
        MOVL ZEROFLAG,ZEROFLAG          "SET BIT 15=0
        FADD ZERO,EDPX(XTEMP);          "5A. GENERATES -INFINITY
        MOV 17,17
        DPX(X)<FA;                      "6.  SAVE ABS(A)
        LDTMA; DB=LOGTBL;               "    TMA=LOG
        INCL MASK                       "    CONTINUE SETUP OF MASK
        LDSPE 17; DB=DPX(X);            "7.  GET S INTO SP17
        FADD;
        INCTMA;                         "    TMA=2**(-1/3)
        BFNE A1                         "    SKIP IF A(0).NE.0
        INC ZEROFLAG                    "7A. SET FLAG FOR A(0)=0
A1:     FSUB TM,MDPX(U); CLR 15;        "8.  V=1.0-U
        DPY(NEGINF)<FA;                 "    -INFINITY (LARGEST NEGATIVE)
        INCTMA                          "    TMA=2**(-2/3)
        FSUBR TM,NC;                    "9.  DO U-2**(-1/3)
        INCTMA;                         "    TMA=LN(2)
        MOVL MASK,MASK                  "    MASK=000004
        FSUBR TM,NC;                    "10. DO U-2**(-2/3)
        LDSPI 15; DB=LOGTBL;            "    SP15=TM ADR OF LOG
        DPX(V)<FA                       "    SAVE V
        MOV 17,17; DPX(S)<SPFN;         "11. PUT S INTO DPX
        FADD; INCTMA                    "    ADVANCE TMA
        FMUL DPX(V),DPX(V);             "12. V*V
        DPY(LN2)<TM;                    "    SAVE LN(2)
        BFGE POLY1;                     "    START POLY IF U.GE.2**(-1/3)
        INCTMA                          "    AND FETCH F1
        BFGE POLY1;                     "12A.START POLY IF U.GE.2**(-2/3)
        LDTMA; DB=INT2                  "    AND FETCH F2
        LDTMA; DB=INT3                  "12B.ELSE FETCH F3
POLY1:  INCTMA; FMUL;                   "13. FETCH B
          MOV N,N               "IS ELEMENT COUNT = 0?
        FMUL TM,DPX(V);                 "14. F*V
        INCTMA;                         "    FETCH D
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
    ADD I,A; SETMA;                     "15. GET A(1)
        FMUL TM,DPX(V);                 "    B*V
        INCTMA;                         "    FETCH A
        DPY(V2)<FM                      "    SAVE V2
        FMUL TM,DPY(V2);                "16. D*V2
        FADD ZERO,MDPX(S);MOV 16,16     "    FLOAT S
        DPX(XTEMP)<TM; DPY(YTEMP)<FM;    "17. SAVE A,FV
        FADD;
        INCTMA                          "    FETCH G
    FABS MD;                            "18. ABS(A)
        FMUL DPY(LN2),FA;               "    LN2*S
        INCTMA                          "    FETCH E
        MOVL ZEROFLAG,ZEROFLAG;         "19. LEFTSHIFT FLAG. CLEAR A(1)=0 FLAG (
            FMUL TM,DPY(V2);            "    G*V2
            FADD FM,DPX(XTEMP);         "    A+BV
            INCTMA                      "    FETCH C
        DPX(X)<FA;                      "20. SAVE ABS(A)
        MOV 15,15; SETTMA;              "    TMA=LOG
            FADD TM,DPY(YTEMP);         "       E+FV
            FMUL FM,DPX(V)              "       DV2*V
        LDSPE 17; DB=DPX(X);            "21. GET S INTO SP17
        INCTMA;                         "    TMA=2**(-1/3)
        BFNE A2;                        "    SKIP IF A(1).NE.0
            FMUL TM,DPY(V2);            "       C*V2
            FADD FM,FA                  "       SLN2+(A+BV)
        INC ZEROFLAG                    "    SET FLAG FOR A(1)=0
A2:     FSUB TM,MDPX(U); CLR 15;        "22. V=1.0-U
        INCTMA;                         "    TMA=2**(-2/3)
            FMUL DPY(V2),DPY(V2);       "       V2*V2
            DPX(XTEMP1)<FA;             "       SAVE E+FV
            DPY(YTEMP1)<FM              "       SAVE G*V2
        FSUBR TM,NC; FMUL;              "23. DO U-2**(-1/3)
        INCTMA;                         "    TMA=LN(2)
            DPX(XTEMP)<FA;              "       SAVE SLN2+A+BV
            DPY(YTEMP)<FM               "       SAVE DV3
        FSUBR TM,NC;                    "24. DO U-2**(-2/3)
        LDSPI 15; DB=LOGTBL;            "    SP15=TM ADR OF LOG
        DPX(V)<FA                       "    SAVE V
        MOV 17,17; DPX(S)<SPFN;         "25. PUT S INTO DPX
        INCTMA;                         "    ADVANCE TMA
            FADD DPX(XTEMP1),DPY(YTEMP1)"       (E+FV)+GV2
        FMUL DPX(V),DPX(V);             "26. V*V
        DPY(LN2)<TM;                    "    SAVE LN(2)
        BFGE POLY2;                     "    START POLY IF U.GE.2**(-1/3)
        INCTMA;                         "    AND FETCH F1
            FADD FM,ZERO                "       SAVE CV2 IN FA
        BFGE POLY2;                     "26A. START POLY IF U.GE.2**(-2/3)
        LDTMA; DB=INT2                  "    AND FETCH F2
        LDTMA; DB=INT3                  "26B. ELSE FETCH F3
POLY2:  INCTMA;                         "27. FETCH B
            FMUL FM,FA;                 "       V4*(E+FV+GV2)
            FADD DPX(XTEMP),DPY(YTEMP)  "       (SLN2+A+BV)+DV3
        FMUL TM,DPX(V);                 "28. F*V
        INCTMA;                         "    FETCH D
            DPY(YTEMP)<FA;              "        SAVE CV2
            FADD
    ADD I,A; SETMA;                     "29. GET A(2)
        FMUL TM,DPX(V);                 "    B*V
        INCTMA;                         "    FETCH A
        DPY(V2)<FM;                     "    SAVE V2
            FADD DPY(YTEMP),FA          "       CV2+(SLN2+A+BV+DV3)
        FMUL TM,DPY(V2);                "30. D*V2
        FADD ZERO,MDPX(S);MOV 16,16;    "    FLOAT S
            DPX(XTEMP)<FM               "       SAVE (EV4+FV5+...)
        DPX(XTEMP)<TM; DPY(YTEMP)<FM;    "31. SAVE A,FV
        INCTMA;                         "    FETCH G
            FADD DPX(XTEMP),FA          "       (SLN2+A+BV+...)+(EV4+...)
    FABS MD;                            "32. ABS(A)
        FMUL DPY(LN2),FA;               "    LN2*S
        INCTMA;                         "    FETCH E
        BR LOOP                         "    SKIP A=0 CODE
"--------------------
"LOG(0) IN MAIN LOOP HANDLED HERE.
"
"NOTE THAT FOLLOWING BRANCH OUT OF LOOP SCREWS UP TM FETCH AT 8.  HOWEVER,
"THIS DOESN'T MATTER, SINCE ARG IS 0 ANYWAY.
ZERO0:  INC ZEROFLAG; BR AMAIN          "8A.  SET FLAG FOR A=0 (BIT 15=1)
"
"NEGATIVE 'INFINITY' IS STORED INTO C (VIA DPX(XTEMP1))
ZERO:   ADD I,A; SETMA;                 "     GET A(I)
            FMUL TM,DPX(V);             "     B*V
            DPY(V2)<FM;                 "     SAVE V2
                FADD DPY(YTEMP),FA      "       CV2+(SLN2+A+BV+DV3)
         LDAPS;DB=100000                "SET OVERFLOW BIT IN STATUS REG
                DPX(XTEMP1)<DPY(NEGINF);"           STORE NEG INFINITY
                INCTMA;                 "           FETCH A
                BR BMAIN                "           RETURN TO LOOP
"-------------------- MAIN LOOP --------------------
LOOP:   MOVL ZEROFLAG,ZEROFLAG;         "1.  LEFT SHIFT A=0 FLAG.  BIT 15=0.
            FMUL TM,DPY(V2);            "    G*V2
            FADD FM,DPX(XTEMP);         "    A+BV
            INCTMA;                     "    FETCH C
                DPX(XTEMP)<FA           "        SAVE RESULT
        DPX(X)<FA;                      "2.  SAVE ABS(A)
        MOV 15,15; SETTMA;              "    TMA=LOG
            FADD TM,DPY(YTEMP);         "       E+FV
            FMUL FM,DPX(V)              "       DV2*V
        LDSPE 17; DB=DPX(X);            "3.  GET S INTO SP17
        INCTMA;                         "    TMA=2**(-1/3)
        BFEQ ZERO0;                     "    IF A=0, BRANCH TO SPECIAL CODE
            FMUL TM,DPY(V2);            "       C*V2
            FADD FM,FA                  "       SLN2+(A+BV)
AMAIN:  FSUB TM,MDPX(U); CLR 15;        "4.  V=1.0-U
        INCTMA;                         "    TMA=2**(-2/3)
            FMUL DPY(V2),DPY(V2);       "       V2*V2
            DPX(XTEMP1)<FA;             "       SAVE E+FV
            DPY(YTEMP1)<FM              "       SAVE G*V2
        FSUBR TM,NC;                    "5.  DO U-2**(-1/3)
        INCTMA;                         "    TMA=LN(2)
            DPX(XTEMP)<FA;              "       SAVE SLN2+A+BV
            DPY(YTEMP)<FM;              "       SAVE DV3
                FMUL DPX(XTEMP),DPY(LOGE)"          LN(X)*LOG(E)
        FSUBR TM,NC;                    "6.  DO U-2**(-2/3)
        LDSPI 15; DB=LOGTBL;            "    SP15=TM ADR OF LOG
        DPX(V)<FA                       "    SAVE V
        MOV 17,17; DPX(S)<SPFN;         "7.  PUT S INTO DPX
        INCTMA;                         "    ADVANCE TMA
            FADD DPX(XTEMP1),DPY(YTEMP1)"       (E+FV)+GV2
        FMUL DPX(V),DPX(V);             "8.  V*V
        DPY(LN2)<TM;                    "    SAVE LN(2)
        BFGE POLY;                      "    START POLY IF U.GE.2**(-1/3)
        INCTMA;                         "    AND FETCH F1
            FADD FM,ZERO                "       SAVE CV2 IN FA
        BFGE POLY;                      "8A. START POLY IF U.GE.2**(-2/3)
        LDTMA; DB=INT2                  "    AND FETCH F2
        LDTMA; DB=INT3                  "8B. ELSE FETCH F3
POLY:   INCTMA;                         "9.  FETCH B
            FMUL FM,FA;                 "       V4*(E+FV+GV2)
            FADD DPX(XTEMP),DPY(YTEMP); "       (SLN2+A+BV)+DV3
                AND# ZEROFLAG,MASK      "           NEXT INSTR TESTS BIT 13
        FMUL TM,DPX(V);                 "10. F*V
        INCTMA;                         "    FETCH D
            DPY(YTEMP)<FA;              "        SAVE CV2
            FADD;
                DPX(XTEMP1)<FM;         "           SAVE RESULT
                BNE ZERO                "           BRANCH IF A=0
    ADD I,A; SETMA;                     "11. GET A(I)
        FMUL TM,DPX(V);                 "    B*V
        INCTMA;                         "    FETCH A
        DPY(V2)<FM;                     "    SAVE V2
            FADD DPY(YTEMP),FA          "       CV2+(SLN2+A+BV+DV3)
BMAIN:  FMUL TM,DPY(V2);                "12. D*V2
        FADD ZERO,MDPX(S);MOV 16,16;    "    FLOAT S
            DPX(XTEMP)<FM               "       SAVE (EV4+FV5+...)
        DPX(XTEMP)<TM; DPY(YTEMP)<FM;    "13.SAVE A,FV
        INCTMA;                         "    FETCH G
            FADD DPX(XTEMP),FA;         "       (SLN2+A+BV+...)+(EV4+...)
                DEC N                   "       DECREMENT LOOP COUNTER
    FABS MD;                            "14. ABS(A)
        FMUL DPY(LN2),FA;               "    LN2*S
        INCTMA;                         "    FETCH E
                ADD K,C; SETMA; MI<DPX(XTEMP1);"STORE RESULT
                BNE LOOP                "       TEST COUNTER
"
        RETURN
        $END
"****** VLN = VECTOR LOGARITHM (NATURAL) /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE VLN
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VLN,5                          "USER-DIRECTED-CALL ENTRY
"
"               --- ABSTRACT ---
"COMPUTES NATURAL LOGARITHM OF ELEMENTS OF A VECTOR.
"
"FORMULA:  C(MK) = LN (ABS(A(MI))   FOR M=0 TO N-1
"
"LN(0) RETURNS -2**511
"
"
"               --- STATISTICS ---
"LANGUAGE:      AP 120B ASSEMBLER
"EQUIPMENT:     AP 120B WITH EITHER MEMORY
"SIZE:  45 LOCATIONS
"EXECUTION       BEST    TYPICAL       WORST       SETUP(US)
"TIME/LOOP        2.7       2.7         2.7          3.5       167 NS MEMORY
" (US)            2.7       2.7         2.7          3.5       333 NS MEMORY
"
"(NOTE: TIMES ASSUME NONZERO ARGUMENT AND MAX NO. OF TESTS TO DETERMINE
" RANGE OF U)
"
"               --- HISTORY ---
"ORIGINAL: DEC 75  A.E. CHARLESWORTH
" REV 2.1: JUL 77  R.S. NORIN      JMP VFCL1 REPLACES JSR VFCL1, RETURN
" REVISED: SEP 77  R.S. NORIN      SCALAR LN ROUTINE VECTORIZED, SAVING TIME
" REVISED: JAN 78  H. WILLIAMS     REWRITTEN TO SAVE MORE TIME
" REVISED: FEB 79  H. WILLIAMS     PATCH TO AVOID OVERFLOW IF 0 STORED
"                                  1 ELEMENT BEYOND A(N) (SEE "NULL:")
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"
"               --- USEAGE ---
"FORTRAN CALL:  CALL VLN(A,I,C,K,N)
"APAL CALL:     JSR VLN
"SCRATCH:       SP(0,2,4,15-17), DPX(0-3), DPY(0-2), FA, FM, MD, TM
"
"S-PAD PARAMETERS:
"  NAME       NUMBER
    A  $EQU     0       "BASE ADDRESS OF SOURCE VECTOR
    I  $EQU     1       "ADDRESS INCREMENT FOR A
    C  $EQU     2       "BASE ADDRESS OF DESTINATION VECTOR
    K  $EQU     3       "ADDRESS INCREMENT FOR C
    N  $EQU     4       "ELEMENT COUNT
"
"
"               --- ALGORITHM ---
"
"1.     X=U*2**S, 1/2<U<1
"       THEREFORE: LN(X) = LN(U)+S*LN(2)
"
"2.     LN(U) IS APPROXIMATED BY A DEGREE 6 POLYNOMIAL IN V=1-U
"               THE RANGE OF U (.5-1) IS SPLIT INTO
"               THREE SMALLER INTERVALS:
"               1.  (2**-1/3,1)
"               2.  (2**-2/3,2**-1/3)
"               3.  (2**-1,2**-2/3)
"       AN APPROPRIATE BATCH OF COEFFICIENTS IS USED
"               CORRESPONDING TO THE RANGE OF U"
"3.     THE POLYNOMIAL IS FACTORED:
"       (((S*LN(2)+(A+BV))+DV3)+CV2)+V4((E+FV)+GV2)
"THE TABLE IN TM IS AS FOLLOWS:
"
"LOGTBL:ONE     1.0
"       2**-1/3  .79370 05260
"       2**-2/3  .62996 05249
"       LN(2)    .69314 71806
"       LOG(E)   .43429 44819
"INT1:  F1      -.14825 42157
"       B1      -.99999 97290
"       D1      -.33274 95766
"       A1      -.57905 56132  E -9
"       G1      -.32673 03578
"       E1      -.25777 00332
"       C1      -.50002 06172
"INT2:  F2       .11470 25427  E 1
"       B2      -.99591 78076
"       D2      -.10032 29591
"       A2      -.16725 61518  E -3
"       G2      -.13069 21431  E 1
"       E2      -.99836 51833
"       G2      -.54190 43800
"INT3:  F3       .10112 39163  E 2
"       B3      -.79241 73643
"       D3       .43431 41103  E 1
"       A3      -.13525 63592  E -1
"       G3      -.52276 85725  E 1
"       E3      -.96093 14753  E 1
"       C3      -.18402 11907  E 1
"DATA PAD MNEMONICS:
"DPX:
        X $EQU 0
        U $EQU 0
        V $EQU 0
        XTEMP $EQU 1
        XTEMP1 $EQU 2
        S $EQU 3
"DPY:
        V2 $EQU 0
        YTEMP $EQU 1
        YTEMP1 $EQU 2
        LN2 $EQU 2              "(NOTE: USES SAME STORAGE AS YTEMP1)
"LOCATION OF THE LOG TABLE
        LOGTBL $EQU !LOG
        INT2 $EQU LOGTBL+12.
        INT3 $EQU LOGTBL+19.
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVLN,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVLN: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VLN:    MOV A,A; SETMA                  "GET A(0)
        SUB K,C                         "C(-1)
        NOP
        FABS MD; LDSPI 16; DB=27.       "GET ABS (A(0)), SP16=EXPON FOR FLOATING
        FADD; LDSPI 15; DB=LOGTBL       "SP15 = TM ADR OF LOG
        DPX(X)<FA; MOV 15,15; SETTMA    "SAVE ABS(A); TMA = LOG
        LDSPE 17; DB=DPX(X); INCTMA;    "SP17 = S; TMA = 2**(-1/3)
        BFEQ NULL1                      "TEST FOR A(0)=0
        FSUB TM,MDPX(U); CLR 15; INCTMA;"V = 1.0-U; TMA = 2**(-2/3)
        BR A2                           "SKIP OVER A(0)=0 CODE
"LN(0) HANDLED HERE.  SEE 'NULL' BELOW FOR EXPLANATION.
NULL1:  DPX(U)<101777                   "GENERATE LARGE NEGATIVE
        FSUB ZERO,DPX(U); INCTMA        "V=LARGE POSITIVE, TMA = 2**(-2/3)
A2:     FSUBR TM,NC; INCTMA             "U-2**(-1/3); TMA = LN(2)
        FSUBR TM,NC;                    "U-2**(-2/3)
        LDSPI 15; DB=LOGTBL;            "SP15 = TM ADR OF LOG
        DPX(V)<FA                       "SAVE V
        FADD; MOV 17,17; DPX(S)<SPFN;   "DPX(S) = S
        INCTMA                          "ADVANCE TMA
        FMUL DPX(V),DPX(V);             "V*V
        DPY(LN2)<TM;                    "SAVE LN(2)
        BFGE POLY1;                     "START POLY1 IF U.GE.2**(-1/3)
        INCTMA                          "AND FETCH F1
        BFGE POLY1;                     "START POLY1 IF U.GE.2**(-2/3)
        LDTMA; DB=INT2                  "AND FETCH F2
        LDTMA; DB=INT3                  "ELSE FETCH F3
POLY1:  INCTMA; FMUL;                   "FETCH B
          MOV N,N               "IS ELEMENT COUNT = 0?
        FMUL TM,DPX(V); INCTMA;         "F*V; FETCH D
        FADD;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        ADD I,A; SETMA;                 "A(1)
        FMUL TM,DPX(V); INCTMA;         "B*V, FETCH A
        DPY(V2)<FM                      "SAVE V2
        FMUL TM,DPY(V2);                "D*V2
        FADD ZERO,MDPX(S); MOV 16,16    "FLOAT S
        DPX(XTEMP)<TM; DPY(YTEMP)<FM;   "SAVE A,FV
        INCTMA; FADD                    "FETCH G
        FABS MD;                        "ABS(A(1))
        FMUL DPY(LN2),FA;               "LN(2)*S
        INCTMA                          "FETCH E
        FMUL TM,DPY(V2);                "G*V2
        FADD FM,DPX(XTEMP);             "BV+A
        INCTMA;                         "FETCH C
        BR LOOP                         "SKIP OVER CODE TO HANDLE A=0
"--------------------
"LN(0) IN MAIN LOOP IS HANDLED HERE:  SET U TO LARGE NEGATIVE.  V WILL BE
"LARGE POSITIVE.  F3,A3,... COEFFICIENT VALUES WILL BE USED.  POLYNOMIAL
"WILL GENERATE -2**511.  (NOTE: NEED TO CHECK LAST TIME THROUGH LOOP
"TO AVOID OVERFLOW FROM 0 AT LOC(A(N)) + I.)
NULL:   DEC# N                          "    IF LAST TIME THROUGH LOOP,
        BEQ NU1                         "     THEN U=0 AND V=0.
        DPX(U)<101777                   "2A. U=LARGE NEGATIVE
NU1:    FSUB ZERO,DPX(U);               "3A. V=LARGE POSITIVE
        INCTMA;                         "    TMA=2**(-2/3)
        BR A1;                          "    RETURN TO MAIN LOOP
            FMUL DPY(V2),DPY(V2);       "        V2*V2
            DPX(XTEMP1)<FA;             "        SAVE E+FV
            DPY(YTEMP1)<FM              "        SAVE G*V2
"--------------------
LOOP:   DPX(X)<FA;                      "1.  SAVE ABS(A)
        MOV 15,15; SETTMA;              "    TMA=LOG
            FADD TM,DPY(YTEMP);         "       E+FV
            FMUL FM,DPX(V)              "       DV2*V
        LDSPE 17; DB=DPX(X);            "2.  GET S INTO SP17
        INCTMA;                         "    TMA=2**(-1/3)
        BFEQ NULL;                      "    TEST FOR A=0
            FMUL TM,DPY(V2);            "       C*V2
            FADD FM,FA                  "       SLN2+(A+BV)
        FSUB TM,MDPX(U); CLR 15;        "3.  V=1.0-U
        INCTMA;                         "    TMA=2**(-2/3)
            FMUL DPY(V2),DPY(V2);       "       V2*V2
            DPX(XTEMP1)<FA;             "       SAVE E+FV
            DPY(YTEMP1)<FM              "       SAVE G*V2
A1:     FSUBR TM,NC;                    "4.  DO U-2**(-1/3)
        INCTMA;                         "    TMA=LN(2)
            DPX(XTEMP)<FA;              "       SAVE SLN2+A+BV
            DPY(YTEMP)<FM               "       SAVE DV3
        FSUBR TM,NC;                    "5.  DO U-2**(-2/3)
        LDSPI 15; DB=LOGTBL;            "    SP15=TM ADR OF LOG
        DPX(V)<FA                       "    SAVE V
        MOV 17,17; DPX(S)<SPFN;         "6.  PUT S INTO DPX
        INCTMA;                         "    ADVANCE TMA
            FADD DPX(XTEMP1),DPY(YTEMP1);"      (E+FV)+GV2
            FMUL
        FMUL DPX(V),DPX(V);             "7.  V*V
        DPY(LN2)<TM;                    "    SAVE LN(2)
        BFGE POLY;                      "    START POLY IF U.GE.2**(-1/3)
        INCTMA;                         "    AND FETCH F1
            FADD FM,ZERO                "       SAVE CV2 IN FA
        BFGE POLY;                      "7A. START POLY IF U.GE.2**(-2/3)
        LDTMA; DB=INT2                  "    AND FETCH F2
        LDTMA; DB=INT3                  "7B. ELSE FETCH F3
POLY:   INCTMA;                         "8.  FETCH B
            FMUL FM,FA;                 "       V4*(E+FV+GV2)
            FADD DPX(XTEMP),DPY(YTEMP)  "       (SLN2+A+BV)+DV3
        FMUL TM,DPX(V);                 "9.  F*V
        INCTMA;                         "    FETCH D
            DPY(YTEMP)<FA;              "        SAVE CV2
            FADD
    ADD I,A; SETMA;                     "10. GET A(I)
        FMUL TM,DPX(V);                 "    B*V
        INCTMA;                         "    FETCH A
        DPY(V2)<FM;                     "    SAVE V2
            FADD DPY(YTEMP),FA          "       CV2+(SLN2+A+BV+DV3)
        FMUL TM,DPY(V2);                "11. D*V2
        FADD ZERO,MDPX(S);MOV 16,16;    "    FLOAT S
            DPX(XTEMP)<FM               "       SAVE (EV4+FV5+...)
        DPX(XTEMP)<TM; DPY(YTEMP)<FM;   "12. SAVE A,FV
        INCTMA;                         "    FETCH G
            FADD DPX(XTEMP),FA          "       (SLN2+A+BV+...)+(EV4+...)
    FABS MD;                            "13. ABS(A)
        FMUL DPY(LN2),FA;               "    LN2*S
        INCTMA;                         "    FETCH E
            DEC N                       "    DECREMENT LOOP COUNTER
        FMUL TM,DPY(V2);                "14. G*V2
        FADD FM,DPX(XTEMP);             "    A+BV
        INCTMA;                         "    FETCH C
            ADD K,C; SETMA; MI<FA;      "    STORE RESULT
            BNE LOOP                    "    TEST COUNTER
"
        RETURN
        $END
"****** VALOG = VECTOR ANTILOGARITHM (BASE 10) = REL 3.1, SEP 79 *****
"
         $TITLE VALOG
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
         $ENTRY VALOG, 5                          "USER-DIRECTED-CALL ENTRY
"
"VECTOR ANTILOGARITHM FOR EITHER MEMORY
"
"FORMULA: C(MK) = 10. ** A(M(I))  FOR M = 0 TO N-1
"
"                  --- STATISTICS ---
"EQUIPMENT:  AP-120B WITH EITHER MEMORY
"SIZE:  59 LOCATIONS
"EXECUTION      BEST    TYPICAL       WORST        SETUP
"TIME/LOOP       2.3        2.3         2.3         4.7     167 NS MEMORY
"(US)            2.3        2.3         2.3         4.7     333 NS MEMORY
"
"(NOTE: EXECUTION TIMES ASSUME THAT ARGUMENTS ARE WITHIN RANGE.
" AN ARGUMENT THAT IS TOO LARGE WILL TAKE .17 US. LONGER IN THE LOOP.
" AN ARGUMENT THAT IS TOO SMALL WILL TAKE .5 US. LONGER.)
"
"
"    --- HISTORY ---
"ORIGINAL:  MAR 78  H. WILLIAMS         ADAPTED FROM VEXP
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"               --- USEAGE ---
"FORTRAN CALL:  CALL VALOG (A, I, C, K, N)
"APAL CALL:     JSR VALOG
"
"SCRATCH:       SP(0,2,4,15-17),DPX(-3 TO +2),DPY(0-2),FA,FM,MD,TM
"EXTERNALS:     NONE
"
"               --- ERROR CONDITIONS ---
"IF X IS GREATER THAN 153.82, 2**511 * (1-2**-27) IS RETURNED.
"IF X IS LESS THAN -154.42, 0 IS RETURNED.
"(NOTE: THE MAX, MIN FOR VALOG ARE THOSE FOR VEXP DIVIDED BY LN(10) )
"
"SCRATCH PAD PARAMETERS:
        A $EQU 0                     "BASE ADDRESS FOR SOURCE VECTOR A
        I $EQU 1                     "ADDRESS INCREMENT FOR A
        C $EQU 2                     "BASE ADDRESS FOR DESTINATION VECTOR C
        K $EQU 3                     "ADDRESS INCREMENT FOR C
        N $EQU 4                     "ELEMENT COUNT
"
"               --- ALGORITHM ---
"
"       THIS ROUTINE IS ADAPTED FROM THE VECTORIZED VERSION OF VEXP (Q.V.).
"(A(I) IS MULTIPLIED BY LN(10.) AND THEN HANDLED BY THE VEXP CODE, SLIGHTLY
"MODIFIED.)
"
"1.     THE BASE IS CHANGED FROM 10.TO 2 BY DOING:
"               Y=X * LOG2(10.) = (X*LOG2(E)) * LN(10.)
"2.     Y IS EXPRESSED AS Y=I+F, WHERE:
"               I IS AN INTEGER, AND F A POSITIVE FRACTION
"                       BETWEEN 0 AND 1
"3.     THEN EXP(X)=2**I * 2**F
"4.     2**F IS APPROXIMATED VIA A POLYNOMIAL IN F: (HART #1043)
"               RANGE: (0,1), PRECISION: 8.73, ORDER: 6
"5.     THE POLYNOMIAL: P+QF+RF**2+SF**3+TF**4+UF**5+V*F**6
"               IS FACTORED AS :
"               (P+QF)+(F**2)(R+SF)+(F**4)(T+UF+VF**2)
"
"
"THE TABLE IN TM IS AS FOLLOWS:
"!EXP:  LOG2(E)= .14426 95040 9  E 1
"       MAX =    354.19
"       FRAC =  1000,3777,177777  FRACTION MASK
"       INT =   1000,4000,0  INTEGER MASK
"       MIN =   -355.58
"       U =      .12439 68782 1  E -2
"       S =      .55483 34198 4  E -1
"       T =      .96788 40997 3  E -2
"       V =      .21702 25547 0  E -3
"       R =      .24022 98362 7  E 0
"       Q =      .69314 69838 4  E 0
"       P =      .10000 00007 0  E 1
"
"DATA PAD MNEMONICS:
"DPX:
        ONE $EQU -3
        XTEMP $EQU -2
        XTEMP1 $EQU -1
        ISAVE $EQU -1
        X $EQU 0
        F $EQU 0
        F2 $EQU 1
        SCALE $EQU 2
"DPY:
        YTEMP $EQU 0
        YTEMP1 $EQU 1
        LN10 $EQU 2
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVALOG,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVALOG: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VALOG:  MOV A,A; SETMA                          "FETCH A(0)
        SUB K,C;                                "INITIALIZE C
        LDTMA; DB=!LN10                         "FETCH LN(10.)
        LDTMA; DB=!ONE;                         "TO SET UP DPX(ONE)
          MOV N,N               "IS ELEMENT COUNT = 0?
        FMUL TM,MD;                             "A(0) * LN(10.)
        DPY(LN10)<DB; DB=TM;                    "DPY(LN10) = LN(10.)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        LDTMA; DB=!EXP;                         "FETCH LOG2(E)
        LDSPI 15                                "SP15 = EXP TABLE ADDRESS
        FMUL;
        DPX(ONE)<TM                             "DPX(ONE) = 1.0
        FMUL;
        DPX(XTEMP)<TM;                          "SAVE LOG2(E)
        INCTMA                                  "FETCH MAX
        FMUL FM,DPX(XTEMP);                     "Y = X*LOG2(E)
        DPX(X)<FM;                              "SAVE X
        INCTMA;                                 "FETCH FRACTION MASK
        CLR 16                                  "SET SP16 TO 1 IN NEXT INSTR
        FSUB TM,DPX(X); FMUL;                   "SEE IF TOO BIG
        INCTMA;                                 "FETCH INTEGER MASK
        INC 16                                  "SP16=1
        FMUL; FADD;
        DPY(YTEMP)<DB; DB=TM;                   "SAVE FRACTION MASK
        INCTMA                                  "FETCH MIN
        ADD I,A; SETMA;                         "GET A(1)
        FAND FM,DPY(YTEMP);                     "GET FRACTION PART
        DPY(YTEMP)<DB; DB=TM;                   "SAVE INTEGER MASK
        INCTMA                                  "FETCH U
        FAND NC,DPY(YTEMP);                     "GET INTEGER PART
        DPY(YTEMP)<DB; DB=TM;                   "SAVE MIN
        INCTMA; BFGT I1                         "FETCH S; BRANCH IF NOT BIG
"SPECIAL CODE WHEN X IS TOO LARGE (INTRO)--
        FSUB DPX(X),DPY(YTEMP);                 "SEE IF TOO SMALL
        FMUL TM,FA;                             "F*U
        INCTMA                                  "FETCH T
        DPX(F)<1777                             "F=LARGE POSITIVE
        FADD ZERO,ZERO;                         "I=0
        FMUL DPX(F),DPX(F);                     "F**2
        DPY(YTEMP)<DPX(F);                      "S=LARGE POSITIVE
        INCTMA;                                 "FETCH V
        BR I2
I1:     FSUB DPX(X),DPY(YTEMP);                 "SEE IF TOO SMALL
        FMUL TM,FA;                             "F*U
        DPX(F)<FA; INCTMA                       "SAVE F; FETCH T
            FIX FA;                             "FIX INTEGER PART
            FMUL DPX(F),DPX(F);                 "F**2
            DPY(YTEMP)<DB; DB=TM;               "SAVE S
            INCTMA                              "FETCH V
I2:         FMUL DPY(YTEMP),DPX(F); FADD;       "S*F
            DPX(XTEMP1)<DB; DB=TM;              "SAVE T
            INCTMA                              "FETCH R
        FMUL DPY(LN10),MD;                      "A(1) * LN(10)
            FADD FM,DPX(XTEMP1);                "T+UF
            DPX(ISAVE)<FA;                      "SAVE I
            DPY(YTEMP)<DB; DB=TM; INCTMA;       "SAVE V; FETCH Q
            BFGT I3                             "BRANCH IF NOT SMALL
"
"SPECIAL CODE WHEN X IS TOO SMALL (INTRO)--
        FMUL FM,DPY(YTEMP); FADD;               "V*F2
        DPX(F2)<ZERO;                           "F2=0
        DPY(YTEMP)<ZERO                         "R=0 (NOT ESSENTIAL)
        RPSF CONST; DPX(F)<DB                   "F=SPECIAL CONST (2 CYCLES)
        DPX(ISAVE)<-513.;                       "I=-513
        BR I4
I3:         FMUL FM,DPY(YTEMP); FADD;           "V*F2
            DPX(F2)<FM;                         "SAVE F2
            DPY(YTEMP)<TM                       "SAVE R
I4:         FMUL TM,DPX(F);                     "Q*F
            FADD FM,DPY(YTEMP);                 "R+SF
            INCTMA;                             "FETCH P
            DPY(YTEMP)<FA                       "SAVE T+UF
        DPY(YTEMP1)<FM;                         "X = A(1)*LN(10)
            FMUL DPX(F2),DPX(F2); FADD          "F**4
        MOV 15,15; SETTMA;                      "FETCH LOG2(E)
            FMUL DPX(F2),FA;                    "F**2*(R+SF)
            FADD FM,DPY(YTEMP);                 "VF2+(T+UF)
            DPY(YTEMP)<DB; DB=TM                "SAVE P
        INCTMA;                                 "FETCH MAX
            FADD FM,DPY(YTEMP);                 "P+QF
            LDSPI 17; DB=DPX(ISAVE)             "PUT I INTO S-PAD
        FMUL TM,DPY(YTEMP1);                    "Y = X*LOG2(E)
        DPX(X)<DB; DB=DPY(YTEMP1);
        FADD;
        INCTMA;                                 "FETCH FRACTION MASK
            DPY(YTEMP)<FA                       "SAVE (T+UF+VF2)
        FSUB TM,DPX(X);                         "SEE IF TOO BIG
        INCTMA;                                 "FETCH INTEGER MASK
            FMUL FM,DPY(YTEMP);                 "F4*(T+UF+VF2)
            DPX(SCALE)<SPFN; INC 17;            "DPX(SCALE) = I+1
            DPY(YTEMP)<FA                       "SAVE P+QF
        FMUL;
        DPY(YTEMP)<DB; DB=TM;                   "SAVE FRACTION MASK
        INCTMA;                                 "FETCH MIN
            FADD FM,DPY(YTEMP)                  "(P+QF)+(RF2+SF3)
    ADD I,A; SETMA;                             "GET A(2)
        FAND FM,DPY(YTEMP);                     "GET FRACTION PART
        DPY(YTEMP)<DB; DB=TM;                   "SAVE INTEGER MASK
        INCTMA;                                 "FETCH U
            FMUL
        FAND NC,DPY(YTEMP);                     "GET INTEGER PART
        DPY(YTEMP)<DB; DB=TM;                   "SAVE MIN
        INCTMA; BFGT I5;                        "FETCH S; BRANCH IF NOT BIG
            DPX(XTEMP)<FM;                      "SAVE (TF4+UF5+...)
            FMUL DPX(ONE),FA                    "SAVE (P+QF+RF2+SF3) IN FM
"SPECIAL CODE WHEN X IS TOO LARGE (INTRO)--
        FSUBR DPX(X),DPY(YTEMP);                "SEE IF TOO SMALL
        FMUL TM,FA;                             "F*U
        INCTMA                                  "FETCH T
        DPX(F)<1777                             "F=LARGE POSITIVE
        FADD ZERO,ZERO;                         "I=0
        FMUL DPX(F),DPX(F);                     "F**2
        DPY(YTEMP)<DPX(F);                      "S=LARGE POSITIVE
        INCTMA;                                 "FETCH V
        BR L1
I5:     FSUBR DPX(X),DPY(YTEMP);                "SEE IF TOO SMALL
        FMUL TM,FA;                             "F*U
        DPX(F)<FA; INCTMA;                      "SAVE F; FETCH T
        BR LOOP                                 "SKIP OVER ERROR HANDLING CODE
"-----------------------MAIN LOOP (3+ COLUMNS)-------------------------
"SPECIAL CODE WHEN X IS TOO SMALL--
"SET F2 TO 0, REDUCING POLY TO P+QF.  CHOOSE F SO THAT P+QF APPROX. 0.
"SET I=-513, RESULTING IN 2**(I+1)*.5 * POLY(F) = 0
CONST:  $FP -1.442695454
TOOSMALL:FMUL FM,DPY(YTEMP);                    "4A. V*F2
        DPX(F2)<ZERO;                           "    F2=0
        DPY(YTEMP)<ZERO;                        "    R=0 (NOT ESSENTIAL)
            FADD DPX(XTEMP),FA                  "       (P+QF+...)+(TF4+UF5+...)
        RPSF CONST; DPX(F)<DB                   "    F=SPECIAL CONST (2 CYCLES)
        DPX(ISAVE)<-513.;                       "    I=-513
        BR L2                                   "    RETURN TO LOOP
LOOP:       FIX FA;                             "1.     FIX INTEGER PART
            FMUL DPX(F),DPX(F);                 "       F**2
            DPY(YTEMP)<DB; DB=TM;               "       SAVE S
            INCTMA                              "       FETCH V
L1:         FMUL DPY(YTEMP),DPX(F);             "2.     S*F
            DPX(XTEMP1)<DB; DB=TM;              "       SAVE T
            INCTMA;                             "       FETCH R
                FADD FM,ZERO                    "           SAVE (P+QF+..) IN FA
        FMUL DPY(LN10),MD;                      "3. A(I-1) * LN(10.)
            FADD FM,DPX(XTEMP1);                "       T+UF
            DPX(ISAVE)<FA;                      "       SAVE I
            DPY(YTEMP)<DB; DB=TM; INCTMA;       "       SAVE V; FETCH Q
            BFGT TOOSMALL                       "       BRANCH IF TOO SMALL
            FMUL FM,DPY(YTEMP);                 "4.     V*F2
            DPX(F2)<FM;                         "       SAVE F2
            DPY(YTEMP)<TM;                      "       SAVE R
                FADD DPX(XTEMP),FA              "           (P+QF+...)+(TF4+...)
L2:         FMUL TM,DPX(F);                     "5.     Q*F
            FADD FM,DPY(YTEMP);                 "       R+SF
            INCTMA;                             "       FETCH P
            DPY(YTEMP)<FA                       "       SAVE T+UF
        DPY(YTEMP1)<FM;                         "6. SAVE A(I-1)*LN(10.)
            FMUL DPX(F2),DPX(F2); FADD;         "       F**4
                DPX(XTEMP)<FA                   "           SAVE POLY(F)
        MOV 15,15; SETTMA;                      "7. FETCH LOG2(E)
            FMUL DPX(F2),FA;                    "       F**2*(R+SF)
            FADD FM,DPY(YTEMP);                 "       VF2+(T+UF)
            DPY(YTEMP)<DB; DB=TM                "       SAVE P
        INCTMA;                                 "8. FETCH MAX
            FADD FM,DPY(YTEMP);                 "       P+QF
            LDSPI 17; DB=DPX(ISAVE)             "       PUT I INTO S-PAD
        FMUL TM,DPY(YTEMP1); DPX(X)<DPY(YTEMP1);"9. Y = X*LOG2(E)
        INCTMA;                                 "   FETCH FRACTION MASK
            DPY(YTEMP)<FA;                      "       SAVE (T+UF+VF2)
                FADD ZERO,EDPX(SCALE);          "           DO .5 * 2**(I+1)
                MOV 16,16                       "           ( SP16=1 )
        FSUBR TM,DPX(X);                        "10.SEE IF TOO BIG
        INCTMA;                                 "   FETCH INTEGER MASK
            FMUL FM,DPY(YTEMP);                 "       F4*(T+UF+VF2)
            DPX(SCALE)<SPFN; INC 17;            "       DPX(SCALE) = I+1
            DPY(YTEMP)<FA                       "       SAVE P+QF
        DPY(YTEMP)<DB; DB=TM;                   "11.SAVE FRACTION MASK
        INCTMA;                                 "   FETCH MIN
            FADD FM,DPY(YTEMP);                 "       (P+QF)+(RF2+SF3)
                FMUL DPX(XTEMP),FA              "           2**I * POLY(F)
    ADD I,A; SETMA;                             "12.FETCH A(I)
        FAND FM,DPY(YTEMP);                     "   GET FRACTION PART
        DPY(YTEMP)<DB; DB=TM;                   "   SAVE INTEGER MASK
        INCTMA;                                 "   FETCH U
            FMUL
        FAND NC,DPY(YTEMP);                     "13.GET INTEGER PART
        DPY(YTEMP)<DB; DB=TM;                   "   SAVE MIN
        INCTMA; BFGT TOOBIG;                    "   FETCH S; BRANCH IF TOO BIG
            DPX(XTEMP)<FM;                      "       SAVE (TF4+UF5+...)
            FMUL DPX(ONE),FA;                   "       SAVE (P+QF+RF2+SF3) IN F
                DEC N                           "           DECREMENT LOOP COUNT
        FSUBR DPX(X),DPY(YTEMP);                "14.SEE IF TOO SMALL
        FMUL TM,FA;                             "   F*U
        DPX(F)<FA; INCTMA;                      "   SAVE F; FETCH T
                ADD K,C; SETMA; MI<FM;          "           STORE RESULT
                BNE LOOP                        "           TEST LOOP COUNTER
DONE:   RETURN
"
"SPECIAL CODE WHEN X IS TOO LARGE--
"FORCE F TO LARGE POSITIVE.  FORCE S TO LARGE POSITIVE.  WILL CAUSE
"POLY(F)=LARGEST POSITIVE.  SET I=0, CAUSING 2**I=1, HENCE RESULT
"IS 1*(LARGEST POSITIVE)=LARGEST POSITIVE.
TOOBIG: FSUBR DPX(X),DPY(YTEMP);                "14A.SEE IF TOO SMALL
        FMUL TM,FA;                             "    F*U
        INCTMA;                                 "    FETCH T
                ADD K,C; SETMA; MI<FM;          "            STORE RESULT
                BEQ DONE                        "            TEST LOOP COUNTER
        DPX(F)<1777                             "    F=LARGE POSITIVE
        FADD ZERO,ZERO;                         "1A. I=0
        FMUL DPX(F),DPX(F);                     "    F**2
        DPY(YTEMP)<DPX(F);                      "    S=LARGE POSITIVE
        INCTMA;                                 "    FETCH V
        BR L1                                   "    RETURN TO LOOP
        $END
"****** VEXP = VECTOR EXPONENTIAL /COMMON/ = REL 3.1, SEP 79 *****
"
         $TITLE VEXP
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
         $ENTRY VEXP, 5                          "USER-DIRECTED-CALL ENTRY
"
"VECTOR EXPONENTIAL FOR EITHER MEMORY
"
"FORMULA: C(MK) = EXP ( A(MI) )   FOR M = 0 TO N-1
"
"                  --- STATISTICS ---
"EQUIPMENT:  AP-120B WITH EITHER MEMORY
"SIZE:  56 LOCATIONS
"EXECUTION      BEST    TYPICAL       WORST        SETUP
"TIME/LOOP       2.3        2.3         2.3         4.2     167 NS MEMORY
"(US)            2.3        2.3         2.3         4.2     333 NS MEMORY
"
"(NOTE: EXECUTION TIMES ASSUME THAT ARGUMENTS ARE WITHIN RANGE.
" AN ARGUMENT THAT IS TOO LARGE WILL TAKE .17 US. LONGER IN THE LOOP.
" AN ARGUMENT THAT IS TOO SMALL WILL TAKE .5 US. LONGER.)
"
"      --- HISTORY ---
"ORIGINAL:  DEC 75, A.E. CHARLESWORTH
" REV 2.1:  JUL 77, R.S. NORIN          JMP VFCL1  REPLACES  JSR VFCL1, NOP, RET
" REVISED:  FEB 78, H. WILLIAMS         VECTORIZED VERSION OF SCALAR ROUTINE
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"               --- USEAGE ---
"FORTRAN CALL:  CALL VEXP (A, I, C, K, N)
"APAL CALL:     JSR VEXP
"
"SCRATCH:       SP(0,2,4,15-17),DPX(-3 TO +2),DPY(0),FA,FM,MD,TM
"EXTERNALS:     NONE
"
"               --- ERROR CONDITIONS ---
"IF X IS GREATER THAN 354.19, 2**511 * (1-2**-27) IS RETURNED.
"IF X IS LESS THAN -355.58, 0 IS RETURNED.
"
"SCRATCH PAD PARAMETERS:
        A $EQU 0                     "BASE ADDRESS FOR SOURCE VECTOR A
        I $EQU 1                     "ADDRESS INCREMENT FOR A
        C $EQU 2                     "BASE ADDRESS FOR DESTINATION VECTOR C
        K $EQU 3                     "ADDRESS INCREMENT FOR C
        N $EQU 4                     "ELEMENT COUNT
"
"               --- ALGORITHM ---
"
"1.     THE BASE IS CHANGED FROM E TO 2 BY DOING:
"               Y=X*LOG2(E)
"2.     Y IS EXPRESSED AS Y=I+F, WHERE:
"               I IS AN INTEGER, AND F A POSITIVE FRACTION
"                       BETWEEN 0 AND 1
"3.     THEN EXP(X)=2**I * 2**F
"4.     2**F IS APPROXIMATED VIA A POLYNOMIAL IN F: (HART #1043)
"               RANGE: (0,1), PRECISION: 8.73, ORDER: 6
"5.     THE POLYNOMIAL: P+QF+RF**2+SF**3+TF**4+UF**5+V*F**6
"               IS FACTORED AS :
"               (P+QF)+(F**2)(R+SF)+(F**4)(T+UF+VF**2)
"
"
"THE TABLE IN TM IS AS FOLLOWS:
"!EXP:  LOG2(E)= .14426 95040 9  E 1
"       MAX =    354.19
"       FRAC =  1000,3777,177777  FRACTION MASK
"       INT =   1000,4000,0  INTEGER MASK
"       MIN =   -355.58
"       U =      .12439 68782 1  E -2
"       S =      .55483 34198 4  E -1
"       T =      .96788 40997 3  E -2
"       V =      .21702 25547 0  E -3
"       R =      .24022 98362 7  E 0
"       Q =      .69314 69838 4  E 0
"       P =      .10000 00007 0  E 1
"
"DATA PAD MNEMONICS:
"DPX:
        ONE $EQU -3
        XTEMP $EQU -2
        ISAVE $EQU -1
        X $EQU 0
        F $EQU 0
        F2 $EQU 1
        SCALE $EQU 2
"DPY:
        YTEMP $EQU 0
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVEXP,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVEXP: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VEXP:   LDTMA; DB=!ONE;                         "TO SET UP DPX(ONE)
          MOV N,N               "IS ELEMENT COUNT = 0?
        MOV A,A; SETMA;                         "GET A(0)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        LDTMA; DB=!EXP;                           "FETCH LOG2(E)
        SUB K,C                                 "INITIALIZE C INDEX
        INCTMA;                                 "FETCH MAX
        DPX(ONE)<DB; DB=TM;                     "DPX(ONE)=1.0
        RTMA; LDSPNL 15                         "SP15=EXP TABLE ADDRESS
        FMUL TM,MD; DPX(X)<DB; DB=MD;           "Y = X*LOG2(E)
        INCTMA;                                 "FETCH FRACTION MASK
        CLR 16                                  "SET SP16 TO 1 IN NEXT INSTR
        FSUB TM,DPX(X); FMUL;                   "SEE IF TOO BIG
        INCTMA;                                 "FETCH INTEGER MASK
        INC 16                                  "SP16=1
        FMUL; FADD;
        DPY(YTEMP)<DB; DB=TM;                   "SAVE FRACTION MASK
        INCTMA                                  "FETCH MIN
        FAND FM,DPY(YTEMP);                     "GET FRACTION PART
        DPY(YTEMP)<DB; DB=TM;                   "SAVE INTEGER MASK
        INCTMA                                  "FETCH U
        FAND NC,DPY(YTEMP);                     "GET INTEGER PART
        DPY(YTEMP)<DB; DB=TM;                   "SAVE MIN
        INCTMA; BFGT I1                         "FETCH S; BRANCH IF NOT BIG
"SPECIAL CODE WHEN X IS TOO LARGE (INTRO)--
        FSUB DPX(X),DPY(YTEMP);                 "SEE IF TOO SMALL
        FMUL TM,FA;                             "F*U
        INCTMA                                  "FETCH T
        DPX(F)<1777                             "F=LARGE POSITIVE
        FADD ZERO,ZERO;                         "I=0
        FMUL DPX(F),DPX(F);                     "F**2
        DPY(YTEMP)<DPX(F);                      "S=LARGE POSITIVE
        INCTMA;                                 "FETCH V
        BR I2
I1:     FSUB DPX(X),DPY(YTEMP);                 "SEE IF TOO SMALL
        FMUL TM,FA;                             "F*U
        DPX(F)<FA; INCTMA                       "SAVE F; FETCH T
            FIX FA;                             "FIX INTEGER PART
            FMUL DPX(F),DPX(F);                 "F**2
            DPY(YTEMP)<DB; DB=TM;               "SAVE S
            INCTMA                              "FETCH V
I2:         FMUL DPY(YTEMP),DPX(F); FADD;       "S*F
            DPY(YTEMP)<DB; DB=TM;               "SAVE T
            INCTMA                              "FETCH R
            FADD FM,DPY(YTEMP); FMUL;           "T+UF
            DPX(ISAVE)<FA;                      "SAVE I
            DPY(YTEMP)<DB; DB=TM; INCTMA;       "SAVE V; FETCH Q
            BFGT I3                             "BRANCH IF NOT SMALL
"
"SPECIAL CODE WHEN X IS TOO SMALL (INTRO)--
        FMUL FM,DPY(YTEMP); FADD;               "V*F2
        DPX(F2)<ZERO;                           "F2=0
        DPY(YTEMP)<ZERO                         "R=0 (NOT ESSENTIAL)
        RPSF CONST; DPX(F)<DB                   "F=SPECIAL CONST (2 CYCLES)
        DPX(ISAVE)<-513.;                       "I=-513
        BR I4
I3:         FMUL FM,DPY(YTEMP); FADD;           "V*F2
            DPX(F2)<FM;                         "SAVE F2
            DPY(YTEMP)<TM                       "SAVE R
I4:         FMUL TM,DPX(F);                     "Q*F
            FADD FM,DPY(YTEMP);                 "R+SF
            INCTMA;                             "FETCH P
            DPY(YTEMP)<FA                       "SAVE T+UF
        ADD I,A; SETMA;                         "GET A(1)
            FMUL DPX(F2),DPX(F2); FADD          "F**4
        MOV 15,15; SETTMA;                      "FETCH LOG2(E)
            FMUL DPX(F2),FA;                    "F**2*(R+SF)
            FADD FM,DPY(YTEMP);                 "VF2+(T+UF)
            DPY(YTEMP)<DB; DB=TM                "SAVE P
        INCTMA;                                 "FETCH MAX
            FADD FM,DPY(YTEMP);                 "P+QF
            LDSPI 17; DB=DPX(ISAVE)             "PUT I INTO S-PAD
        FMUL TM,MD; DPX(X)<DB; DB=MD; FADD;     "Y = X*LOG2(E)
        INCTMA;                                 "FETCH FRACTION MASK
            DPY(YTEMP)<FA                       "SAVE (T+UF+VF2)
        FSUB TM,DPX(X);                         "SEE IF TOO BIG
        INCTMA;                                 "FETCH INTEGER MASK
            FMUL FM,DPY(YTEMP);                 "F4*(T+UF+VF2)
            DPX(SCALE)<SPFN; INC 17;            "DPX(SCALE) = I+1
            DPY(YTEMP)<FA                       "SAVE P+QF
        FMUL;
        DPY(YTEMP)<DB; DB=TM;                   "SAVE FRACTION MASK
        INCTMA;                                 "FETCH MIN
            FADD FM,DPY(YTEMP)                  "(P+QF)+(RF2+SF3)
        FAND FM,DPY(YTEMP);                     "GET FRACTION PART
        DPY(YTEMP)<DB; DB=TM;                   "SAVE INTEGER MASK
        INCTMA;                                 "FETCH U
            FMUL
        FAND NC,DPY(YTEMP);                     "GET INTEGER PART
        DPY(YTEMP)<DB; DB=TM;                   "SAVE MIN
        INCTMA; BFGT I5;                        "FETCH S; BRANCH IF NOT BIG
            DPX(XTEMP)<FM;                      "SAVE (TF4+UF5+...)
            FMUL DPX(ONE),FA                    "SAVE (P+QF+RF2+SF3) IN FM
"SPECIAL CODE WHEN X IS TOO LARGE (INTRO)--
        FSUBR DPX(X),DPY(YTEMP);                "SEE IF TOO SMALL
        FMUL TM,FA;                             "F*U
        INCTMA                                  "FETCH T
        DPX(F)<1777                             "F=LARGE POSITIVE
        FADD ZERO,ZERO;                         "I=0
        FMUL DPX(F),DPX(F);                     "F**2
        DPY(YTEMP)<DPX(F);                      "S=LARGE POSITIVE
        INCTMA;                                 "FETCH V
        BR L1
I5:     FSUBR DPX(X),DPY(YTEMP);                "SEE IF TOO SMALL
        FMUL TM,FA;                             "F*U
        DPX(F)<FA; INCTMA;                      "SAVE F; FETCH T
        BR LOOP                                 "SKIP OVER ERROR HANDLING CODE
"----------MAIN LOOP----------
"SPECIAL CODE WHEN X IS TOO SMALL--
"SET F2 TO 0, REDUCING POLY TO P+QF.  CHOOSE F SO THAT P+QF APPROX. 0.
"SET I=-513, RESULTING IN 2**(I+1)*.5 * POLY(F) = 0
CONST:  $FP -1.442695454
TOOSMALL:FMUL FM,DPY(YTEMP);                    "4A. V*F2
        DPX(F2)<ZERO;                           "    F2=0
        DPY(YTEMP)<ZERO;                        "    R=0 (NOT ESSENTIAL)
            FADD DPX(XTEMP),FA                  "       (P+QF+...)+(TF4+UF5+...)
        RPSF CONST; DPX(F)<DB                   "    F=SPECIAL CONST (2 CYCLES)
        DPX(ISAVE)<-513.;                       "    I=-513
        BR L2                                   "    RETURN TO LOOP
LOOP:       FIX FA;                             "1.     FIX INTEGER PART
            FMUL DPX(F),DPX(F);                 "       F**2
            DPY(YTEMP)<DB; DB=TM;               "       SAVE S
            INCTMA                              "       FETCH V
L1:         FMUL DPY(YTEMP),DPX(F);             "2.     S*F
            DPY(YTEMP)<DB; DB=TM;               "       SAVE T
            INCTMA;                             "       FETCH R
                FADD FM,ZERO                    "           SAVE (P+QF+...) IN F
            FADD FM,DPY(YTEMP); FMUL;           "3.     T+UF
            DPX(ISAVE)<FA;                      "       SAVE I
            DPY(YTEMP)<DB; DB=TM; INCTMA;       "       SAVE V; FETCH Q
            BFGT TOOSMALL                       "       BRANCH IF TOO SMALL
            FMUL FM,DPY(YTEMP);                 "4.     V*F2
            DPX(F2)<FM;                         "       SAVE F2
            DPY(YTEMP)<TM;                      "       SAVE R
                FADD DPX(XTEMP),FA              "           (P+QF+...)+(TF4+...)
L2:         FMUL TM,DPX(F);                     "5.     Q*F
            FADD FM,DPY(YTEMP);                 "       R+SF
            INCTMA;                             "       FETCH P
            DPY(YTEMP)<FA                       "       SAVE T+UF
        ADD I,A; SETMA;                         "6. GET A
            FMUL DPX(F2),DPX(F2); FADD;         "       F**4
                DPX(XTEMP)<FA                   "           SAVE POLY(F)
        MOV 15,15; SETTMA;                      "7. FETCH LOG2(E)
            FMUL DPX(F2),FA;                    "       F**2*(R+SF)
            FADD FM,DPY(YTEMP);                 "       VF2+(T+UF)
            DPY(YTEMP)<DB; DB=TM                "       SAVE P
        INCTMA;                                 "8. FETCH MAX
            FADD FM,DPY(YTEMP);                 "       P+QF
            LDSPI 17; DB=DPX(ISAVE)             "       PUT I INTO S-PAD
        FMUL TM,MD; DPX(X)<DB; DB=MD;           "9. Y = X*LOG2(E)
        INCTMA;                                 "   FETCH FRACTION MASK
            DPY(YTEMP)<FA;                      "       SAVE (T+UF+VF2)
                FADD ZERO,EDPX(SCALE);          "           DO .5 * 2**(I+1)
                MOV 16,16                       "           ( SP16=1 )
        FSUBR TM,DPX(X);                        "10.SEE IF TOO BIG
        INCTMA;                                 "   FETCH INTEGER MASK
            FMUL FM,DPY(YTEMP);                 "       F4*(T+UF+VF2)
            DPX(SCALE)<SPFN; INC 17;            "       DPX(SCALE) = I+1
            DPY(YTEMP)<FA                       "       SAVE P+QF
        DPY(YTEMP)<DB; DB=TM;                   "11.SAVE FRACTION MASK
        INCTMA;                                 "   FETCH MIN
            FADD FM,DPY(YTEMP);                 "       (P+QF)+(RF2+SF3)
                FMUL DPX(XTEMP),FA              "           2**I * POLY(F)
        FAND FM,DPY(YTEMP);                     "12.GET FRACTION PART
        DPY(YTEMP)<DB; DB=TM;                   "   SAVE INTEGER MASK
        INCTMA;                                 "   FETCH U
            FMUL
        FAND NC,DPY(YTEMP);                     "13.GET INTEGER PART
        DPY(YTEMP)<DB; DB=TM;                   "   SAVE MIN
        INCTMA; BFGT TOOBIG;                    "   FETCH S; BRANCH IF TOO BIG
            DPX(XTEMP)<FM;                      "       SAVE (TF4+UF5+...)
            FMUL DPX(ONE),FA;                   "       SAVE (P+QF+RF2+SF3) IN F
                DEC N                           "           DECREMENT LOOP COUNT
        FSUBR DPX(X),DPY(YTEMP);                "14.SEE IF TOO SMALL
        FMUL TM,FA;                             "   F*U
        DPX(F)<FA; INCTMA;                      "   SAVE F; FETCH T
                ADD K,C; SETMA; MI<FM;          "           STORE RESULT
                BNE LOOP                        "           TEST LOOP COUNTER
DONE:   RETURN
"
"SPECIAL CODE WHEN X IS TOO LARGE--
"FORCE F TO LARGE POSITIVE.  FORCE S TO LARGE POSITIVE.  WILL CAUSE
"POLY(F)=LARGEST POSITIVE.  SET I=0, CAUSING 2**I=1, HENCE RESULT
"IS 1*(LARGEST POSITIVE)=LARGEST POSITIVE.
TOOBIG: FSUBR DPX(X),DPY(YTEMP);                "14A.SEE IF TOO SMALL
        FMUL TM,FA;                             "    F*U
        INCTMA;                                 "    FETCH T
                ADD K,C; SETMA; MI<FM;          "            STORE RESULT
                BEQ DONE                        "            TEST LOOP COUNTER
        DPX(F)<1777                             "    F=LARGE POSITIVE
        FADD ZERO,ZERO;                         "1A. I=0
        FMUL DPX(F),DPX(F);                     "    F**2
        DPY(YTEMP)<DPX(F);                      "    S=LARGE POSITIVE
        INCTMA;                                 "    FETCH V
        BR L1                                   "    RETURN TO LOOP
        $END
"****** VSIN = VECTOR SINE /COMMON/ = REL 3.2, MAR 80 *****
        $TITLE VSIN
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VSIN,5                          "USER-DIRECTED-CALL ENTRY
"
"               ---ABSTRACT---
"VECTOR SIN  (ANGLES IN RADIANS)
"DOES C( MK ) = SIN ( A(MI) )   FOR M = 0 TO N-1
"
"               ---STATISTICS---
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH EITHER MEMORY
"SIZE: 42. LOCATIONS
"EXECUTION       BEST     TYPICAL     WORST     SETUP
"TIME/LOOP:       1.3       1.3        1.3       7.0   (167 NS MEMORY)
"(US)             1.3       1.3        1.3       7.0   (333 NS MEMORY)
"
"
"    --- HISTORY ---
"ORIGINAL:  MAY 78  H. WILLIAMS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2:  MAR 80  R.S. NORIN   COMBINES 2K AND 4K TMROM VERSIONS
"
"               ---USAGE---
"FORTRAN CALL: CALL VSIN (A, I, C, K, N)
"APAL CALL:    JSR VSIN
"SCRATCH: SP(0,2,4,13.-15.),DPX(-4 TO +2),DPY(-1 TO +2),FA,FM,MD,TM
"SUBROUTINES USED: NONE
"
"S-PAD PARAMETERS:
A $EQU 0
I $EQU 1
C $EQU 2
K $EQU 3
N $EQU 4
"
"               ---ALGORITHM---
"SIN(X) IS COMPUTED BY LOOKUP FROM TM ROM COSINE TABLE, FOLLOWED
"BY INTERPOLATION USING SIN(X) = SIN(W+E) = SIN(W)COS(E) + COS(W)SIN(E),
"WHERE SIN(E) AND COS(E) ARE APPROXIMATED BY TAYLOR SERIES.
"IN DETAIL,
"(1)    U = X * SCALE, WHERE SCALE = (2/PI) * COSINE-TABLE-SIZE
"       (NOTE: IF X IS IN RANGE 0 TO PI/2, U IS IN RANGE 0 TO TABLE-SIZE)
"(2)    V = FIXT (U)
"(3)    D = U - V
"(4)    LOOKUP SIN(W), COS(W) FROM COSINE TABLE BY ADDRESSING ON V, WHERE
"       W = V / SCALE
"(5)    SUPPOSE E = D / SCALE.
"       APPROXIMATELY, SIN(E) = E - E**3/6
"                             = PD + QD**3, WHERE P = 1 / SCALE AND
"                                                 Q = -1 / (6 * SCALE**3)
"       APPROXIMATELY, COS(E) = 1 - E**2/2
"                             = R + SD**2, WHERE R = 1 AND
"                                                S = -1 / (2 * SCALE**2)
"(6)    SIN(X) = SIN(W)*COS(E) + COS(W)*SIN(E)
"
"               ---SCRATCH---
"S-PAD:
STATUS $EQU 17
TABLE $EQU 17
MASK $EQU 16
TABLE1 $EQU 16
NINTRO $EQU 15
"
"DPX:
Q $EQU -4
S $EQU -3
R $EQU -2
SCALE $EQU -1
V $EQU 0
RES1 $EQU 1
DPREV $EQU 2
RESULT $EQU 2
"
"DPY:
P $EQU -1
U $EQU 0
D $EQU 1
D2 $EQU 2
RES2 $EQU 2
"
"..........START OF CODE..........
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVSIN,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVSIN: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VSIN:   LDTMA; DB=4371;                 "THIS TM LOCATION IS ZERO FOR
                                        "2.5K TMROM, NONZERO FOR 4.5K
         SUB K,C                        "BACKUP OUTPUT POINTER
        LDSPI MASK; DB=30               "GET MASK FOR STATUS REGISTER
        MOV A,A; SETMA;                 "FETCH A(1)
         DB=TM                          "TEST TM LOCATION 4371
        LDTMA; DB=!ONE;                 "FETCH 1.0
         BDBZ TWOK                      "BRANCH IF 2.5K TMROM
"HERE IF 4K COSINE TABLE
        RPSF SCLC4K; DPX(SCALE)<DB      "GET SCALE FACTOR
        RPSF PCON4K; DPY(P)<DB          "GET P
        RPSF QCON4K; DPX(Q)<DB          "GET Q
        RPSF SCON4K; DPX(S)<DB;         "GET S
         BR CONT                        "PROCEED TO COMMON CODE
"HERE IF 2K COSINE TABLE
TWOK:   RPSF SCLC2K; DPX(SCALE)<DB      "GET SCALE FACTOR
        RPSF PCON2K; DPY(P)<DB          "GET P
        RPSF QCON2K; DPX(Q)<DB          "GET Q
        RPSF SCON2K; DPX(S)<DB          "GET S
"SET APSTATUS SO THAT IFFT=1, FFT=1  (TO ACCESS TM ROM COSINE TABLE)
CONT:   RAPS; LDSPNL STATUS;            "GET APSTATUS
           FMUL DPX(SCALE),MD;          "   A(1) * SCALE-FACTOR
           DPX(R)<TM                    "   SAVE 1.0
        OR MASK,STATUS;
           LDAPS; DB=SPFN;              "SET STATUS
              FMUL
"..........INTRO LOOP..........
"THIS LOOP IS THE SAME AS MAIN LOOP, BUT THE STORE INTO C(K) HAS BEEN
"ELIMINATED.
        LDSPI NINTRO; DB=3              "SET LOOP COUNTER FOR INTRO
INTROLOOP: FMUL;
            DPY(D)<FA;                  "       D=U-V
                INC TABLE1; SETTMA;     "           FETCH SIN(V)
                FADD FM,DPX(R);         "           R+SD2
                DPX(DPREV)<DB; DB=DPY(D)"           SAVE D (FROM PREV. COLUMN)
        DPY(U)<FM;                      "    U = A(I)*(2/PI...)
            FMUL DPY(D),DPY(D);         "       D*D
            LDSPI TABLE; DB=DPX(V)      "       SP(TABLE)=COS TABLE ADDRESS
        FIXT DPY(U);                    "    FIXT (U)
                FMUL DPX(DPREV),FA;     "           D*(P+QD2)
                DEC TABLE1; SETTMA;     "           FETCH COS(V)
                    DPY(RES2)<FM        "               SAVE COS(V)*(PD+QD3)
    ADD I,A; SETMA;                     "FETCH A(I)
                FMUL TM,FA;             "           SIN(V)*(R+SD2)
                    FADD DPX(RES1),DPY(RES2) "          (SIN(V)...)+(COS(V)...)
        DPX(V)<FA;                      "    V=FIXT(U) (UNNORMALIZED)
        FADD ZERO,FA;                   "    NORMALIZE V
            FMUL FM,DPX(Q);             "       Q*D2
            DPY(D2)<FM;                 "       SAVE D2
            MOVL TABLE,TABLE1           "       SET UP FOR COS TABLE FETCH
        MOV N,N;                "IS ELEMENT COUNT = 0?
            FMUL DPX(S),DPY(D2);        "       S*D2
                FADD FM,ZERO;           "           SAVE PD+QD3
                    DPX(RESULT)<FA      "               SAVE FINAL RESULT
    FMUL DPX(SCALE),MD;                 "A(I)*( (2/PI)*COS-TABLE-SIZE)
        FSUB DPY(U),FA;                 "    U-V
        BEQ DONE;               "EXIT IF COUNT = 0
                DPX(RES1)<FM;           "           SAVE SIN(V)*(R+SD2)
                    DEC NINTRO          "               DECREMENT LOOP COUNTER
            FADD FM,DPY(P);             "       P+QD2
                FMUL TM,FA;             "           COS*(PD+QD3)
                    BNE INTROLOOP       "               TEST  COUNTER
"...................MAIN LOOP.................................
LOOP:   FMUL;
            DPY(D)<FA;                  "       D=U-V
                INC TABLE1; SETTMA;     "           FETCH SIN(V)
                FADD FM,DPX(R);         "           R+SD2
                DPX(DPREV)<DB; DB=DPY(D)"           SAVE D (FROM PREV. COLUMN)
        DPY(U)<FM;                      "    U = A(I)*(2/PI...)
            FMUL DPY(D),DPY(D);         "       D*D
            LDSPI TABLE; DB=DPX(V)      "       SP(TABLE)=COS TABLE ADDRESS
        FIXT DPY(U);                    "    FIXT (U)
                FMUL DPX(DPREV),FA;     "           D*(P+QD2)
                DEC TABLE1; SETTMA;     "           FETCH SIN(V)
                    DPY(RES2)<FM        "               SAVE COS(V)*(PD+QD3)
    ADD I,A; SETMA;                     "FETCH A(I)
                FMUL TM,FA;             "           SIN(V)*(R+SD2)
                    FADD DPX(RES1),DPY(RES2) "          (SIN(V)...)+(COS(V)...)
        DPX(V)<FA;                      "    V=FIXT(U) (UNNORMALIZED)
        FADD ZERO,FA;                   "    NORMALIZE V
            FMUL FM,DPX(Q);             "       Q*D2
            DPY(D2)<FM;                 "       SAVE D2
            MOVL TABLE,TABLE1           "       SET UP FOR COS TABLE FETCH
            FMUL DPX(S),DPY(D2);        "       S*D2
                FADD FM,ZERO;           "           SAVE PD+QD3
                    DPX(RESULT)<FA      "               SAVE FINAL RESULT
    FMUL DPX(SCALE),MD;                 "A(I)*( (2/PI)*COS-TABLE-SIZE)
        FSUB DPY(U),FA;                 "    U-V
                DPX(RES1)<FM;           "           SAVE SIN(V)*(R+SD2)
                    DEC N               "               DECREMENT LOOP COUNTER
            FADD FM,DPY(P);             "       P+QD2
                FMUL TM,FA;             "           COS*(PD+QD3)
                    ADD K,C; SETMA;     "               STORE RESULT IN C(I-4)
                    MI<DB; DB=DPX(RESULT);
                    BNE LOOP            "               TEST  COUNTER
"..........WRAP UP..........
"CLEAR APSTATUS OF FFT BITS
DONE:   RAPS; LDSPNL STATUS             "GET APSTATUS
        LDSPI MASK; DB=177740           "GET MASK
        AND MASK,STATUS;                "MASK OUT UNWANTED BITS
        LDAPS; DB=SPFN;                 "RESET STATUS
        RETURN
"CONSTANTS (DEPENDENT ON SIZE OF TMROM COSINE TABLE)
"HERE ARE CONSTANTS FOR 2K COSINE TABLE
PCON2K: $FP     .7669903939E-3
QCON2K: $FP    -.7520011830E-10
SCON2K: $FP    -.2941371322E-6
SCLC2K: $FP     .1303797294E4           "(2/PI)*TABLE-SIZE
"HERE ARE CONSTANTS FOR 4K COSINE TABLE
PCON4K: $FP     .3834951970E-3
QCON4K: $FP    -.9400014788E-11
SCON4K: $FP    -.7353428305E-7
SCLC4K: $FP     .2607594588E4
        $END
"****** VCOS = VECTOR COSINE /COMMON/ = REL 3.2, MAR 80 *****
        $TITLE VCOS
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VCOS,5                          "USER-DIRECTED-CALL ENTRY
"
"               ---ABSTRACT---
"VECTOR COS  (ANGLES IN RADIANS)
"DOES C( MK ) = COS ( A(MI) )   FOR M = 0 TO N-1
"
"               ---STATISTICS---
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH EITHER MEMORY
"SIZE: 42. LOCATIONS
"EXECUTION       BEST     TYPICAL     WORST     SETUP
"TIME/LOOP:       1.3       1.3        1.3       7.0   (167 NS MEMORY)
"(US)             1.3       1.3        1.3       7.0   (333 NS MEMORY)
"
"
"    --- HISTORY ---
"ORIGINAL:  MAY 78  H. WILLIAMS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2:  MAR 80  R.S. NORIN   COMBINES 2K AND 4K TMROM VERSIONS
"
"               ---USAGE---
"FORTRAN CALL: CALL VCOS (A, I, C, K, N)
"APAL CALL:    JSR VCOS
"SCRATCH: SP(0,2,4,13.-15.),DPX(-4 TO +2),DPY(-1 TO +2),FA,FM,MD,TM
"SUBROUTINES USED: NONE
"
"S-PAD PARAMETERS:
A $EQU 0
I $EQU 1
C $EQU 2
K $EQU 3
N $EQU 4
"
"               ---ALGORITHM---
"COS(X) IS COMPUTED BY LOOKUP FROM TM ROM COSINE TABLE, FOLLOWED
"BY INTERPOLATION USING COS(X) = COS(W+E) = COS(W)COS(E) - SIN(W)SIN(E),
"WHERE SIN(E) AND COS(E) ARE APPROXIMATED BY TAYLOR SERIES.
"THIS ROUTINE USES THE SAME CODE AS VSIN, WITH MINOR CHANGES.
"IN DETAIL,
"(1)    U = X * SCALE, WHERE SCALE = (2/PI) * COSINE-TABLE-SIZE
"       (NOTE: IF X IS IN RANGE 0 TO PI/2, U IS IN RANGE 0 TO TABLE-SIZE)
"(2)    V = FIXT (U)
"(3)    D = U - V
"(4)    LOOKUP SIN(W), COS(W) FROM COSINE TABLE BY ADDRESSING ON V, WHERE
"       W = V / SCALE
"(5)    SUPPOSE E = D / SCALE.
"       APPROXIMATELY, SIN(E) = E - E**3/6
"                             = PD + QD**3, WHERE P = 1 / SCALE AND
"                                                 Q = -1 / (6 * SCALE**3)
"       APPROXIMATELY, COS(E) = 1 - E**2/2
"                             = R + SD**2, WHERE R = 1 AND
"                                                S = -1 / (2 * SCALE**2)
"(6)    COS(X) = COS(W)*COS(E) - SIN(W)*SIN(E)
"
"               ---SCRATCH---
"S-PAD:
STATUS $EQU 17
TABLE $EQU 17
MASK $EQU 16
TABLE1 $EQU 16
NINTRO $EQU 15
"
"DPX:
Q $EQU -4
S $EQU -3
R $EQU -2
SCALE $EQU -1
V $EQU 0
RES1 $EQU 1
DPREV $EQU 2
RESULT $EQU 2
"
"DPY:
P $EQU -1
U $EQU 0
D $EQU 1
D2 $EQU 2
RES2 $EQU 2
"
"..........START OF CODE..........
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVCOS,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVCOS: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VCOS:   LDTMA; DB=4371;                 "THIS TM LOCATION IS ZERO FOR
                                        "2.5K TMROM, NONZERO FOR 4.5K
         SUB K,C                        "BACKUP OUTPUT POINTER
        LDSPI MASK; DB=30               "GET MASK FOR STATUS REGISTER
        MOV A,A; SETMA;                 "FETCH A(1)
         DB=TM                          "TEST TM LOCATION 4371
        LDTMA; DB=!ONE;                 "FETCH 1.0
         BDBZ TWOK                      "BRANCH IF 2.5K TMROM
"HERE IF 4K COSINE TABLE
        RPSF SCLC4K; DPX(SCALE)<DB      "GET SCALE FACTOR
        RPSF PCON4K; DPY(P)<DB          "GET P
        RPSF QCON4K; DPX(Q)<DB          "GET Q
        RPSF SCON4K; DPX(S)<DB;         "GET S
         BR CONT                        "PROCEED TO COMMON CODE
"HERE IF 2K COSINE TABLE
TWOK:   RPSF SCLC2K; DPX(SCALE)<DB      "GET SCALE FACTOR
        RPSF PCON2K; DPY(P)<DB          "GET P
        RPSF QCON2K; DPX(Q)<DB          "GET Q
        RPSF SCON2K; DPX(S)<DB          "GET S
"SET APSTATUS SO THAT IFFT=1, FFT=1  (TO ACCESS TM ROM COSINE TABLE)
CONT:   RAPS; LDSPNL STATUS;            "GET APSTATUS
           FMUL DPX(SCALE),MD;          "   A(1) * SCALE-FACTOR
           DPX(R)<TM                    "   SAVE 1.0
        OR MASK,STATUS;
           LDAPS; DB=SPFN;              "SET STATUS
              FMUL
"..........INTRO LOOP..........
"THIS LOOP IS THE SAME AS MAIN LOOP, BUT THE STORE INTO C(K) HAS BEEN
"ELIMINATED.
        LDSPI NINTRO; DB=3              "SET LOOP COUNTER FOR INTRO
INTROLOOP: FMUL;
            DPY(D)<FA;                  "       D=U-V
                MOVL TABLE,TABLE1; SETTMA; "        FETCH COS(V)
                FADD FM,DPX(R);         "           R+SD2
                DPX(DPREV)<DB; DB=DPY(D)"           SAVE D (FROM PREV. COLUMN)
        DPY(U)<FM;                      "    U = A(I)*(2/PI...)
            FMUL DPY(D),DPY(D);         "       D*D
            LDSPI TABLE; DB=DPX(V)      "       SP(TABLE)=COS TABLE ADDRESS
        FIXT DPY(U);                    "    FIXT (U)
                FMUL DPX(DPREV),FA;     "           D*(P+QD2)
                INC TABLE1; SETTMA;     "           FETCH SIN(V)
                    DPY(RES2)<FM        "               SAVE SIN(V)*(PD+QD3)
    ADD I,A; SETMA;                     "FETCH A(I)
                FMUL TM,FA;             "           COS(V)*(R+SD2)
                    FSUB DPX(RES1),DPY(RES2) "          (COS(V)...)-(SIN(V)...)
        DPX(V)<FA;                      "    V=FIXT(U) (UNNORMALIZED)
        FADD ZERO,FA;                   "    NORMALIZE V
            FMUL FM,DPX(Q);             "       Q*D2
            DPY(D2)<FM                  "       SAVE D2
        MOV N,N;                "IS ELEMENT COUNT = 0?
            FMUL DPX(S),DPY(D2);        "       S*D2
                FADD FM,ZERO;           "           SAVE PD+QD3
                    DPX(RESULT)<FA      "               SAVE FINAL RESULT
    FMUL DPX(SCALE),MD;                 "A(I)*( (2/PI)*COS-TABLE-SIZE)
        FSUB DPY(U),FA;                 "    U-V
        BEQ DONE;               "EXIT IF COUNT = 0
                DPX(RES1)<FM;           "           SAVE COS(V)*(R+SD2)
                    DEC NINTRO          "               DECREMENT LOOP COUNTER
            FADD FM,DPY(P);             "       P+QD2
                FMUL TM,FA;             "           SIN*(PD+QD3)
                    BNE INTROLOOP       "               TEST  COUNTER
"...................MAIN LOOP.................................
LOOP:   FMUL;
            DPY(D)<FA;                  "       D=U-V
                MOVL TABLE,TABLE1; SETTMA; "        FETCH COS(V)
                FADD FM,DPX(R);         "           R+SD2
                DPX(DPREV)<DB; DB=DPY(D)"           SAVE D (FROM PREV. COLUMN)
        DPY(U)<FM;                      "    U = A(I)*(2/PI...)
            FMUL DPY(D),DPY(D);         "       D*D
            LDSPI TABLE; DB=DPX(V)      "       SP(TABLE)=COS TABLE ADDRESS
        FIXT DPY(U);                    "    FIXT (U)
                FMUL DPX(DPREV),FA;     "           D*(P+QD2)
                INC TABLE1; SETTMA;     "           FETCH SIN(V)
                    DPY(RES2)<FM        "               SAVE SIN(V)*(PD+QD3)
    ADD I,A; SETMA;                     "FETCH A(I)
                FMUL TM,FA;             "           COS(V)*(R+SD2)
                    FSUB DPX(RES1),DPY(RES2) "          (COS(V)...)-(SIN(V)...)
        DPX(V)<FA;                      "    V=FIXT(U) (UNNORMALIZED)
        FADD ZERO,FA;                   "    NORMALIZE V
            FMUL FM,DPX(Q);             "       Q*D2
            DPY(D2)<FM                  "       SAVE D2
            FMUL DPX(S),DPY(D2);        "       S*D2
                FADD FM,ZERO;           "           SAVE PD+QD3
                    DPX(RESULT)<FA      "               SAVE FINAL RESULT
    FMUL DPX(SCALE),MD;                 "A(I)*( (2/PI)*COS-TABLE-SIZE)
        FSUB DPY(U),FA;                 "    U-V
                DPX(RES1)<FM;           "           SAVE COS(V)*(R+SD2)
                    DEC N               "               DECREMENT LOOP COUNTER
            FADD FM,DPY(P);             "       P+QD2
                FMUL TM,FA;             "           SIN*(PD+QD3)
                    ADD K,C; SETMA;     "               STORE RESULT IN C(I-4)
                    MI<DB; DB=DPX(RESULT);
                    BNE LOOP            "               TEST  COUNTER
"..........WRAP UP..........
"CLEAR APSTATUS OF FFT BITS
DONE:   RAPS; LDSPNL STATUS             "GET APSTATUS
        LDSPI MASK; DB=177740           "GET MASK
        AND MASK,STATUS;                "MASK OUT UNWANTED BITS
        LDAPS; DB=SPFN;                 "RESET STATUS
        RETURN
"CONSTANTS (DEPENDENT ON SIZE OF TMROM COSINE TABLE)
"HERE ARE CONSTANTS FOR 2K COSINE TABLE
PCON2K: $FP     .7669903939E-3
QCON2K: $FP    -.7520011830E-10
SCON2K: $FP    -.2941371322E-6
SCLC2K: $FP     .1303797294E4           "(2/PI)*TABLE-SIZE
"HERE ARE CONSTANTS FOR 4K COSINE TABLE
PCON4K: $FP     .3834951970E-3
QCON4K: $FP    -.9400014788E-11
SCON4K: $FP    -.7353428305E-7
SCLC4K: $FP     .2607594588E4
        $END
"****** VATAN = VECTOR ARC-TANGENT /COMMON/ = REL 3.1, SEP 79 *****
"  FOR EITHER MEMORY
         $TITLE VATAN
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
         $ENTRY VATAN, 5                          "USER-DIRECTED-CALL ENTRY
         $EXT VFCL1,ATAN
"VECTOR ARCTANGENT  (ANSWERS IN RADIANS, BETWEEN -PI/2 AND PI/2)
"DOES C(MK) = ATAN ( A(MI) )
"                  --- STATISTICS ---
"EQUIPMENT:  AP-120B WITH EITHET MEMORY
"SIZE:  3 LOCATIONS + VFCL1 (11) + ATAN (74 INCLUDING DIV) = 88
"USES "VFCL1" AND "ATAN" SUBROUTINES
"
"      --- HISTORY ---
"ORIGINAL:  DEC 75, A.E. CHARLESWORTH
" REV 2.1:  JUL 77, R.S. NORIN        JMP VFCL1  REPLACES  JSR VFCL1, NOP, RETUR
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"S-PAD PARAMETERS:
"        0     A             ADDRESS OF A
"        1     I             INCREMENT FOR A
"        2     C             BASE ADDRESS FOR C
"        3     K             INCREMENT FOR C
"        4     N             ELEMENT COUNT FOR C
"S-PAD DEFINITIONS:
         ADR $EQU 5          "RELATIVE ADDRESS OF FUNCTION
         LOC $EQU 6          "BASE LOCATION TO WHICH ADR IS RELATIVE
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVATAN,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVATAN: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VATAN:   RPSA; LDSPNL LOC    "PUT PSA INTO LOC
         LDSPI ADR; DB=ATAN  "GET RELATIVE ADDRESS OF ATAN
         JMP VFCL1           "GO DO IT AND EXIT THRU VFCL1
         $END
"****** VATN2 = VECTOR ARC-TANGENT OF 2 ARGUEMENTS /COMMO= REL 3.1, SEP 79 *****
"   FOR EITHER MEMORY
         $TITLE VATN2
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
         $ENTRY VATN2, 7                          "USER-DIRECTED-CALL ENTRY
         $EXT VFCL2,ATN2
"VECTOR ARCTANGENT OF TWO ARGUMENTS
"GIVES ANSWERS IN RADIANS AROUND A FULL CIRCLE
"        DOES C(M) = ARCTANGENT ( B(M) / A(M) ) FOR M = 0 TO N-1
"                  --- STATISTICS ---
"EQUIPMENT:  AP-120B WITH EITHER MEMORY
"SIZE:  3 LOCATIONS + VFCL2 (12) + ATN2 (74 INCLUDING DIV) = 89
"
"      --- HISTORY ---
"ORIGINAL:  DEC 75, A.E. CHARLESWORTH
" REV 2.1:  JUL 77, R.S. NORIN        JMP VFCL2  REPLACES  JSR VFCL2, NOP, RETUR
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"S-PAD PARAMETERS:
"        0     A             ADDRESS OF A
"        1     I             INCREMENT FOR A
"        2     B             BASE ADDRESS OF B
"        3     J             INCREMENT FOR J
"        4     C             BASE ADDRESS FOR C
"        5     K             INCREMENT FOR C
"        6     N             ELEMENT COUNT FOR C
"S-PAD DEFINITIONS:
         ADR $EQU 7          "RELATIVE ADDRESS OF FUNCTION
         LOC $EQU 10         "BASE LOCATION TO WHICH ADR IS RELATIVE
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVATN2,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  152
        $PARAM  7 , P1(#2,#7)/R/IP, P2/I/IP,
                    P3(#4,#7)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP
FVATN2: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VATN2:   RPSA; LDSPNL LOC    "PUT PSA INTO LOC
         LDSPI ADR; DB=ATN2  "GET RELATIVE ADDRESS OF ATN2
         JMP VFCL2           "GO DO IT AND EXIT THRU VFCL2
       $END
"****** VRAND = VECTOR RANDOM NUMBERS /COMMON/ = REL 3.2, MAR 80
"       FOR EITHER MEMORY
        $TITLE VRAND
        $RADIX 8
   XADC $EQU 1                  "CONDITIONAL ASSEMBLY PARAMETER
        $ENTRY VRAND,4          "USER-DIRECTED-CALL ENTRY
"
"       ---ABSTRACT---
"FILLS VECTOR C WITH A SEQUENCE OF FLOATING POINT RANDOM NUMBERS
"UNIFORMLY DISTRIBUTED BETWEEN 0.0 AND 1.0.  SEQUENCE IS GENERATED
"USING A SEED S.  FOLLOWING GENERATION THE SEED IS SET TO THE LAST
"RANDOM NUMBER GENERATED, THUS ALLOWING THE SEQUENCE TO BE CONTINUED
"IN THE NEXT CALL TO VRAND.  ANY SEED CAN BE USED INCLUDING ZERO.
"
"
"THE TECHNIQUE USED IS THE LINEAR CONGRUENTIAL METHOD (SEE
"KNUTH, VOLUME 2).  IT IS BASED ON THE RECURSIVE FORMULA
"
"                             26
"               (A*X+B) (MOD 2  )  =>  X
"
"WHERE A AND B ARE CONSTANTS.  THE RANDOM NUMBER IS
"
"                     -26
"               RN = 2   *X
"
"EACH OF THE VARIABLES A,B, AND X IS TREATED AS A 26 BIT
"INTEGER.  THIS IS DONE BY WRITING THEM AS
"
"                    13          13
"               A = 2  *A1+A2 = 2  *DPY(1)+DPY(2)
"
"                    13          13
"               B = 2  *B1+B2 = 2  *DPY(-1)+DPY(-2)
"
"                    13          13
"               X = 2  *X1+X2 = 2  *DPX(1)+DPX(2)
"
"THE ITERATION ALGORITHM THEN BECOMES
"
"               A1*X2+A2*X1  =>  L
"
"               A2*X2  =>  R
"
"                      13
"               INT(R/2  )  =>  R1
"
"                               13
"               (L+R1+B1) (MOD 2  )  =>  X1
"
"                            13
"               (R+B2) (MOD 2  ) => X2
"
"                -13     -26
"               2   *X1+2   *X2  =>  RN
"
"
"THE CONSTANTS A AND B ARE STORED (IN TERMS OF A1, A2, B1, AND
"B2) IN THE PROGRAM BELOW.  A HAS BEEN CHOSEN TO SATISFY:
"
"               A = 5 (MOD 8)
"
"                         26     13
"               A > SQRT(2  ) = 2   = 8192
"
"                    26
"               A > 2  /100 > 671088
"
"                    26       26
"               A < 2  -SQRT(2  ) = 67100672
"
"B HAS BEEN CHOSEN ODD AND APPROXIMATELY EQUAL TO
"
"                26
"               2  *(3-SQRT(3))/6
"
"OTHER VALUES OF A AND B MIGHT BE CHOSEN AS LONG AS THEY SATISFY
"THESE CONDITIONS AND ALLOW THE GENERATOR TO PASS SOME TESTS OF
"RANDOMNESS.  THE CONSTANTS BELOW HAVE BEEN SUBJECTED TO CHI-SQUARE
"TESTS ON EQUIDISTRIBUTION, EQUIDISTRIBUTION OF PAIRS, EQUIDISTRIBUTION
"OF TRIPLETS, AND EXPECTED DISTRIBUTION OF INCREASING SEQUENCES OF
"CONSEQUTIVELY GENERATED NUMBERS.
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 57 LOCATIONS
"SPEED: INTRO: 37 CYCLES
"       LOOP: 12 CYCLES
"       COLUMNS/LOOP: 2
"
"       ---HISTORY---
"ORIGINAL:      JAN 77  R.S. NORIN
"REVISED:       JUL 78  R.S. NORIN     FETCHES 1.0 PROPERLY FROM TM
"REVISED:       SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"REWRITTEN:     MAR 80  H. SEDINGER    INTEGER ARITMETIC METHOD IMPLEMENTED
"
"       ---USAGE---
"FORTRAN: CALL VRAND(S,C,K,N)
"APAL:    JSR VRAND
"S-PAD PARAMETERS
"
      S $EQU 0                                   "ADDRESS OF SEED
      C $EQU 1                                   "BASE ADDRESS OF C
      K $EQU 2                                   "INCREMENT FOR C
      N $EQU 3                                   "DIMENSION OF C
"
"SCRATCH:  SP(1,3), DPX(0 TO 3), DPY(-4 TO 3), DPA UNCHANGED
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVRAND,4                          "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP $EQU 14
        $PARAM 4, P1/R/IP/OP,
                  P2(#3,#4)/R/OP, P3/I/IP,
                  P4/I/IP
FVRAND: LDSPI 17; DB=BITMAP
        JSR RESLVE
        $ENDIF
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
 VRAND: MOV N,N
        MOV S,S; SETMA; BNE .+2                 "FETCH SEED;QUIT IF N=0
        RETURN
        RPSF SHFTL; DPY(3)<DB                   "DPY(3)=LEFT SHIFT MULTIPLIER
        RPSF SHFTR; DPX(3)<DB                   "DPX(3)=RIGHT SHIFT MULTIPLIER
        RPSF B1; DPY(-1)<DB                     "DPY(-1)=B1
        RPSF B2; DPY(-2)<DB                     "DPY(-2)=B2
        RPSF MASKR; DPY(-3)<DB                  "DPY(-3)=RIGHT MASK MULTIPLIER
        RPSF MASKL; DPY(-4)<DB                  "DPY(-4)=LEFT MASK MULTIPLIER
        FMUL DPY(3),MD; SUB K,C                 "SHIFT LEFT
        FMUL
        FMUL; DPX<DPY(3)
        FAND FM,DPY(-3); FMUL FM,DPX            "MASK X1;SHIFT LEFT
        FMUL; FADD
        DPX(1)<FA; FMUL                         "STORE X1
        FAND FM,DPY(-3); RPSF A1; DPY(1)<DB     "MASK X2;DPY(1)=A1
        FADD; RPSF A2; DPY(2)<DB                "DPY(2)=A2
"
        FMUL DPY(2),FA                          "A2*X2
        FMUL DPY(1),FA                          "A1*X2
        FMUL DPY(2),DPX(1)                      "A2*X1
        FADD FM,DPY(-2); DPX<FM; FMUL           "R+B2;DPX=R
        DPY<FM; FAND DPY(-4),DPX; FMUL          "DPY=A1*X2;MASK R1
        FADD FM,DPY; DPX<FA                     "FIND L;DPX=R+B2
        FMUL DPX(3),FA; FADD                    "SHIFT RIGHT
        FADD DPY(-1),FA; FMUL                   "B1+L
        FAND DPY(-3),DPX; FMUL                  "MASK R+B2
        FADD FM,FA                              "R1+B1+L
        DPX(2)<FA; FMUL DPX(3),FA; FADD; DEC N  "STORE X2; SHIFT RIGHT
        FAND DPY(-3),FA; FMUL; BEQ DONE         "MASK R1+B1+L;QUIT IF N=1
"
  LOOP: FMUL DPY(2),DPX(2);                     "A2*X2
              FADD
        FMUL DPY(1),DPX(2);                     "A1*X2
              DPX(1)<FA; FADD FM,FA             "STORE X1;8192*RN
        FMUL DPY(2),DPX(1);                     "A2*X1
              FADD
        FADD FM,DPY(-2); DPX<FM;                "R+B2;DPX=R
              FMUL DPX(3),FA                    "SHIFT RIGHT
        DPY<FM; FAND DPY(-4),DPX; FMUL          "DPY=A1*X2;MASK R1
        FADD FM,DPY; DPX<FA;                    "FIND L;DPX=R+B2
              FMUL
        FMUL DPX(3),FA; FADD;                   "SHIFT RIGHT
              ADD K,C; SETMA; MI<FM             "STORE RN
        FADD DPY(-1),FA; FMUL                   "B1+L
        FAND DPY(-3),DPX; FMUL                  "MASK R+B2
        FADD FM,FA                              "R1+B1+L
        DPX(2)<FA; FMUL DPX(3),FA; FADD;        "STORE X2;SHIFT RIGHT
              DEC N
        FAND DPY(-3),FA; FMUL;                  "MASK R1+B1+L
              BNE LOOP
"
  DONE:       FADD;FMUL
              DPX(1)<FA; FADD FM,FA             "STORE X1;8192*RN
              FADD
              FMUL DPX(3),FA                    "SHIFT RIGHT
              FMUL
              FMUL
              ADD K,C; SETMA; MI<FM             "STORE RN
"
        MOV S,S; SETMA; MI<FM; RETURN           "STORE SEED
    A1: $FP 8188.                               "LEFT PART OF A=67081293
    A2: $FP 5197.                               "RIGHT PART OF A=67081293
 SHFTR: $FP .1220703125E-03                     "RIGHT SHIFT MULTIPLIER
 SHFTL: $FP 8192.                               "LEFT SHIFT MULTIPLIER
    B1: $FP 1731.                               "LEFT PART OF B=14181771
    B2: $FP 1419.                               "RIGHT PART OF B=14181771
 MASKR: $FP 8191.                               "RIGHT MASK MULTIPLIER
 MASKL: $FP 67100672.                           "LEFT MASK MULTIPLIER
        $END
"****** VINT = VECTOR TRUNCATE TO INTEGER (WHOLE NUM) /COMMON= REL 3.1, SEP 79 *
        $TITLE VINT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VINT,5.                          "USER-DIRECTED-CALL ENTRY
        "THIS ALGORITHM,COMPONENTWISE, FINDS  THE INTEGER PART OF A
        "AND STORE IN C.
        "
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST OR STANDARD MEMORY
        "SIZE:      9. LOCATIONS
        "TIME:       BEST     TYPICAL     WORST      SETUP(US)
        "  167 NS    0.5         0.5        0.67        1.0
        "  333 NS    0.83        0.83       1.0         1.0
"
"    --- HISTORY ---
"ORIGINAL:  FEB 77  S. BERKOWITZ
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        "---------- SCRATCH ----------
        "SP(0,2,4),FA,MD
        A $EQU 0                                        "BASE ADDR OF A
        I $EQU 1                                        "INCREMENT OF A
        C $EQU 2                                        "BASE ADDR OF B
        K $EQU 3                                        "INCREMENT OF B
        N $EQU 4                                       "SIZE OF VECTORS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVINT,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVINT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VINT:   MOV A,A; SETMA          "GET A(0)
        SUB K,C                 "BACK UP POINTER
        ADD I,A; SETMA          "GET A(1)
        MOV N,N;                "IS ELEMENT COUNT = 0?
            FIXT MD             "FIX TO INTEGER PART
        BEQ DONE;               "EXIT IF COUNT = 0
            FADD
LOOP:   ADD I,A; SETMA;         "1. GET A(M+2)
                FADD ZERO,FA    "FLOAT THE INTEGER PART OF A(M)
            FIXT MD;            "2. FIX A(M+1)
                DEC N           "DECREMENT COUNT
            FADD;                 "3.
                ADD K,C; SETMA; MI<FA; "STORE A(M)
                BNE LOOP
DONE:   RETURN                  "EXIT
        $END
"****** VFRAC = VECTOR TRUNCATE TO FRACTION /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE VFRAC
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VFRAC,5.                          "USER-DIRECTED-CALL ENTRY
        "THIS ALGORITHM TRUNCATES THE FRACTION OF FLOATING PT
        "NUMBERS WHICH ARE STORED IN VECTOR A . IT PUTS THESE
        "INTEGER FLOATING POINT NUMBERS IN C WHOSE SIZE IS N
        "---------- STATISTICS ----------
        "LANGUAGE:  AP-120B ASSEMBLER
        "EQUIPMENT: AP-120B WITH FAST OR STANDARD MEMORY
        "SIZE:      7. LOCATIONS
        "TIME:      WORST:  5+6*N
        "           BEST:   4+3*N
"
"    --- HISTORY ---
"ORIGINAL:  FEB 77  S. BERKOWITZ
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
        A $EQU 0                                        "BASE ADDR FOR A
        I $EQU 1                                        "INCREMENT FOR A
        C $EQU 2                                        "BASE ADDR FOR C
        K $EQU 3                                        "INCREMENT FOR C
        N $EQU 4                                       "SIZE OF VECTORS
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVFRAC,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  5 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP
FVFRAC: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VFRAC:  MOV A,A;SETMA                                   "1,FETCH A
        MOV N,N                 "IS ELEMENT COUNT = 0?
        SUB K,C;                                "INITIALIZE C
          BEQ DONE              "EXIT IF COUNT = 0
        ADD I,A;SETMA;                                  "1,FETCH A
                FIXT MD                                 "1,TRUNCATE FRACTION PAR
                FADD;                                    "2
                DPY<MD
                FADD ZERO,FA                            "3,NORMALIZE FIXT(A)
        ADD I,A;SETMA;                                  "1,FETCH A
                FIXT MD                                 "1,TRUNCATE FRACTION PAR
                DPY<MD;
                        FSUB DPY,FA                     "2,A-FIXT(A)
                FADD ZERO,FA                            "3,NORMALIZE FIXT(A)
LOOP:   ADD I,A;SETMA;                                  "1,FETCH A
                FIXT MD;                                "1,GET INTEGER PART
                                DPX<FA
                DPY<MD;
                        FSUB DPY,FA;                    "2,A-FIXT(A)
                                DEC N                   "2,N=N-1
                FADD ZERO,FA;                           "3,NORMALIZE FIXT(A)
                                ADD K,C;SETMA;MI<DPX;   "3,STORE C
                                BNE LOOP                "3,TEST&BRANCH
DONE:   RETURN                  "EXIT
        $END
"
"****** DOTPR = DOT-PRODUCT /FAST/ = REL 3.2, AUG 80 *****
       $TITLE DOTPR
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
       $ENTRY DOTPR, 6                          "USER-DIRECTED-CALL ENTRY
       $EXT SPUFLT
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH ONE CYCLE MEMORY
"SIZE:  13 + SPUFLT (8) = 21 WORDS
"
"     ---HISTORY---
"ORIGINAL:  JUL 76  J. THROOP
" REVISED:  AUG 77  R.S. NORIN     ALLOWS N>32767
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2:  AUG 80. D.GANGULY.     CORRECTED ADC LINKAGE
"
"VECTOR DOT PRODUCT
"DOES C = SUM ( A(MI) * B(MJ) ) FOR M = 0 TO N-1
"LOOP CONTROL IS DONE IN THE FLOATING ADDER.  A JUMP TO SUBROUTINE
"SPUFLT FLOATS THE VECTOR LENGTH "N" AND STORES  IT IN DPX(NN).
"THE FLOATING CONSTANT "ONE" IS CALLED FROM TABLE MEMORY AND IS
"THE DECREMENT FOR LOOP CONTROL.
"S PAD PARAMETERS
       A $EQU 0                        "VECTOR A ORIGIN
       I $EQU 1                        "VECTOR A INCREMENT
       B $EQU 2                        "VECTOR B ORIGIN
       J $EQU 3                        "VECTOR B INCREMENT
       C $EQU 4                        "VECTOR C ORIGIN
       N $EQU 5                        "VECTOR LENGTH
       NM $EQU 17
"DATA PAD PARAMETERS
       NN $EQU 1                       "FLOATED VECTOR LENGTH
"SCRATCH:
"        S-PADS:  0,2,4,17
"          DPX:  0, 1.     DPY:  0.
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FDOTPR,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  52
        $PARAM  6 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3(#4,#6)/R/IP, P4/I/IP,
                    P5/R/OP,
                    P6/I/IP
FDOTPR: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
DOTPR: MOV N,NM                        "MOVE VECTOR LENGTH TO S-PAD(NM)
       JSR SPUFLT                       "FLOAT VECTOR LENGTH
        BFEQ DONE;              "EXIT IF COUNT = 0
                   MOV A,A;SETMA       "FETCH A(0)
                   MOV B,B;SETMA       "FETCH B(0)
               ADD I,A;SETMA           "FETCH A(1)
               ADD J,B;SETMA;          "FETCH B(1)
                   DPY<MD              "SAVE A(0)
           ADD I,A;SETMA;              "FETCH A(2)
                   FMUL DPY,MD         "A(0)*B(0)
           ADD J,B;SETMA;              "FETCH B(2)
               DPY<MD;                 "SAVE A(1)
               FSUBR TM,DPX(NN);       "INITIALIZE THE COUNTER
                   FMUL                "PUSH A(0)*B(0)
       ADD I,A;SETMA;                  "FETCH A(3)
               FMUL DPY,MD;            "A(1)*B(1)
                   FADD  ZERO,ZERO     "CLEAR THE ADDER
LOOP:  ADD J,B;SETMA;                  "FETCH B(M)
           DPY<MD;                     "STORE A(M+1)
               FMUL;                   "PUSH A(M+2)*B(M+2)
               FSUBR TM,FA;            "DECREMENT THE COUNTER
                   DPX<FM              "SAVE A(M+3)*B(M+3)
           ADD I,A;SETMA;              "FETCH A(M+1)
           FMUL DPY,MD;                "A(M+1)*B(M+1)
                                       "PUSH A(M+2)*B(M+2)
                   FADD DPX,FA;        "ADD  A(M+3)*B(M+3) TO SUM
                   BFGT LOOP           "BRANCH IF NOT DONE
                   FADD                "PUSH THE ANSWER
DONE:              MOV C,C;SETMA;MI<FA;"DOT PRODUCT INTO C
                     RETURN            "AND RETURN
       $END
"****** RMSQV = ROOT-MEAN-SQUARE VALUE OF VECTOR ELEM /COMMON= REL 3.1, SEP 79 *
        $TITLE RMSQV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY RMSQV, 4                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV,SPUFLT,SVESQ,SQRT
"
"       --- ABSTRACT ---
"COMPUTES THE SQUARE ROOT OF THE MEAN VALUE OF THE SQUARES OF THE
"ELEMENTS OF A VECTOR.
"
"FORMULA: C(0) = SQRT ( SUM ( A(MI)*A(MI) / N ) )   FOR M = 0 TO N-1
"
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH EITHER MEMORY
"SIZE:    8 + SPUFLT (8) + SVESQ (10) + DIV (28) + SQRT (28) = 82 LOCATIONS
"SPEED: BEST (FAST):  2N  (I ODD)
"        (STANDARD):  2N
"       WORST (FAST): 2N
"         (STANDARD): 3N
"       TYPICAL (FAST): 2N
"           (STANDARD): 2N
"
"     ---HISTORY---
"ORIGINAL:  APR 77  R.S. NORIN
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"SUBROUTINES USED: DIV, SPUFLT, SVESQ, SQRT
"                  --- USAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        C   $EQU   2                    "ADDRESS OF RESULT
        N   $EQU   3                    "NUMBER OF ELEMENTS IN A
"
"SCRATCH: SP(0,3,12-15),DPX(0,1),DPY(0,1),FA,FM,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FRMSQV,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3/R/OP,
                    P4/I/IP
FRMSQV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
RMSQV:  MOV N,17                "FLOAT N
        BEQ DONE                "EXIT IF COUNT = 0
        JSR SPUFLT
        JSR SVESQ                 "SUM THE ELEMENTS
        DPY<FA; DPX<DPX(1); JSR DIV "DIVIDE BY N
        JSR SQRT                "TAKE SQUARE ROOT
        MOV C,C; SETMA; MI<DPX  "SAVE ROOT-MEAN-SQUARE VALUE
DONE:   RETURN                  "EXIT
        $END
"****** MEANV = MEAN VALUE OF VECTOR ELEMENTS /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE MEANV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MEANV, 4                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV,SPUFLT,SVE
"
"       --- ABSTRACT ---
"COMPUTES THE MEAN (AVERAGE) VALUE OF THE ELEMENTS OF A VECTOR.
"
"FORMULA: C(0) = SUM ( A(MI) / N )   FOR M = 0 TO N-1
"
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH EITHER MEMORY
"SIZE:    7 + SPUFLT (8) + SVE (7) + DIV (28) = 50 LOCATIONS
"SPEED: BEST (FAST):  2N  (I ODD)
"        (STANDARD):  2N
"       WORST (FAST): 2N
"         (STANDARD): 3N
"       TYPICAL (FAST): 2N
"           (STANDARD): 2N
"
"     ---HISTORY---
"ORIGINAL:  APR 77  R.S. NORIN
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"SUBROUTINES USED: DIV, SPUFLT, SVE
"                  --- USAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        C   $EQU   2                    "ADDRESS OF RESULT
        N   $EQU   3                    "NUMBER OF ELEMENTS IN A
"
"SCRATCH: SP(0,3,13-15),DPX(0,1),DPY(0),FA,FM,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMEANV,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3/R/OP,
                    P4/I/IP
FMEANV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MEANV:  MOV N,17                "FLOAT N
        BEQ DONE                "EXIT IF COUNT = 0
        JSR SPUFLT
        JSR SVE                 "SUM THE ELEMENTS
        DPY<FA; DPX<DPX(1); JSR DIV "DIVIDE BY N
        MOV C,C; SETMA; MI<DPX  "SAVE MEAN
DONE:   RETURN                  "EXIT
        $END
"****** MEAMGV = MEAN OF VECTOR ELEMENT MAGNITUDES /COMMON/ = REL 3.1, SEP 79 **
        $TITLE MEAMGV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MEAMGV, 4                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV,SPUFLT,SVEMG
"
"       --- ABSTRACT ---
"COMPUTES THE MEAN (AVERAGE) VALUE OF THE ABSOLUTE VALUES OF
"THE ELEMENTS OF A VECTOR.
"
"FORMULA: C(0) = SUM ( ABS(A(MI)) / N )   FOR M = 0 TO N-1
"
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH EITHER MEMORY
"SIZE:    7 + SPUFLT (8) + SVEMG (10) + DIV (28) = 53 LOCATIONS
"SPEED: BEST (FAST):  2N  (I ODD)
"        (STANDARD):  2N
"       WORST (FAST): 2N
"         (STANDARD): 3N
"       TYPICAL (FAST): 2N
"           (STANDARD): 2N
"
"     ---HISTORY---
"ORIGINAL:  APR 77  R.S. NORIN
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"SUBROUTINES USED: DIV, SPUFLT, SVEMG
"                  --- USAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        C   $EQU   2                    "ADDRESS OF RESULT
        N   $EQU   3                    "NUMBER OF ELEMENTS IN A
"
"SCRATCH: SP(0,3,13-15),DPX(0,1),DPY(0),FA,FM,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMEMGV,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3/R/OP,
                    P4/I/IP
FMEMGV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MEAMGV:  MOV N,17                "FLOAT N
        BEQ DONE                "EXIT IF COUNT = 0
        JSR SPUFLT
        JSR SVEMG                 "SUM THE ELEMENTS
        DPY<FA; DPX<DPX(1); JSR DIV "DIVIDE BY N
        MOV C,C; SETMA; MI<DPX  "SAVE MEAN
DONE:   RETURN                  "EXIT
        $END
"****** MEASQV = MEAN OF VECTOR ELEMENT SQUARES /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE MEASQV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MEASQV, 4                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV,SPUFLT,SVESQ
"
"       --- ABSTRACT ---
"COMPUTES THE MEAN (AVERAGE) VALUE OF THE SQUARES OF THE
"ELEMENTS OF A VECTOR.
"
"FORMULA: C(0) = SUM ( A(MI)*A(MI) / N )   FOR M = 0 TO N-1
"
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH EITHER MEMORY
"SIZE:    7 + SPUFLT (8) + SVESQ (10) + DIV (28) = 53 LOCATIONS
"SPEED: BEST (FAST):  2N  (I ODD)
"        (STANDARD):  2N
"       WORST (FAST): 2N
"         (STANDARD): 3N
"       TYPICAL (FAST): 2N
"           (STANDARD): 2N
"
"     ---HISTORY---
"ORIGINAL:  APR 77  R.S. NORIN
" REVISED:  SEP 78  R.S. NORIN     HANDLES N>32767 PROPERLY
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"SUBROUTINES USED: DIV, SPUFLT, SVESQ
"                  --- USAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        C   $EQU   2                    "ADDRESS OF RESULT
        N   $EQU   3                    "NUMBER OF ELEMENTS IN A
"
"SCRATCH: SP(0,3,13-15),DPX(0,1),DPY(0),FA,FM,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMESQV,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3/R/OP,
                    P4/I/IP
FMESQV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MEASQV:  MOV N,17                "FLOAT N
        BEQ DONE                "EXIT IF COUNT = 0
        JSR SPUFLT
        JSR SVESQ                 "SUM THE ELEMENTS
        DPY<FA; DPX<DPX(1); JSR DIV "DIVIDE BY N
        MOV C,C; SETMA; MI<DPX  "SAVE MEAN
DONE:   RETURN                  "EXIT
        $END
"****** SVE = SUM OF VECTOR ELEMENTS /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE SVE
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY SVE, 4                          "USER-DIRECTED-CALL ENTRY
"SUM OF THE ELEMENTS OF A VECTOR
"DOES C(0) = SUM ( A(MI) )   FOR M = 0 TO N-1
"                  --- STATISTICS ---
"EQUIPMENT: AP-120B WITH EITHER MEMORY
"SIZE: 7 PROGRAM LOCATIONS
"SPEED:  1 MEMORY CYCLE PER POINT
"SCRATCH: SP: 0,2,3; DPX: 0 (RELATIVE TO DPA)
"
"    --- HISTORY ---
"ORIGINAL:  SEP 75  T. PRINTS
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"S-PAD PARAMETERS:
A       $EQU 0          "VECTOR ORIGIN
I       $EQU 1          "VECTOR INCREMENT
C       $EQU 2          "SCALAR (RESULT) ORIGIN
N       $EQU 3          "VECTOR LENGTH
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FSVE,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3/R/OP,
                    P4/I/IP
FSVE: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SVE:    MOV A,A;SETMA           "FETCH A(0)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        ADD I,A; SETMA;         "FETCH A(1)
        BEQ DONE;               "EXIT IF COUNT = 0
          FADD ZERO,ZERO        "CLEAR ADDER
LOOP:   DPX<MD;                 "SAVE A(M) IN DPX;
          FADD;DEC N            "  PUSH ADDER;DEC. COUNTER
        FADD DPX,FA;            "DO (SUM + A(M));
          ADD I,A;SETMA;        "  FETCH A(M+1)
          BNE LOOP              "  TEST FOR DONE
DONE:   FADD                    "IF DONE, PUSH ADDER, THEN
        MOV C,C;SETMA;
          MI<FA;RETURN          "  STORE RESULT IN C(0); EXIT.
       $END
"****** SVEMG = SUM OF VECTOR ELEMENT MAGNITUDES /COMMON/= REL 3.1, SEP 79 *****
        $TITLE SVEMG
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY SVEMG, 4                          "USER-DIRECTED-CALL ENTRY
"
"       --- ABSTRACT ---
"SUMS THE ABSOLUTE VALUES OF THE ELEMENTS OF A VECTOR.
"
"FORMULA: C(0) = SUM ( ABS(A(MI)))   FOR M = 0 TO N-1
"
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH EITHER MEMORY
"SIZE:    10 LOCATIONS
"SPEED: BEST (FAST):  2N  (I ODD)
"        (STANDARD):  2N
"       WORST (FAST): 2N
"         (STANDARD): 3N
"       TYPICAL (FAST): 2N
"           (STANDARD): 2N
"
"    --- HISTORY ---
"ORIGINAL:  APR 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                  --- USAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        C   $EQU   2                    "ADDRESS OF SUM
        N   $EQU   3                    "NUMBER OF ELEMENTS IN A
"
"SCRATCH: SP(0,3),DPX(0),FA,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FSVEMG,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3/R/OP,
                    P4/I/IP
FSVEMG: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SVEMG:  MOV A,A; SETMA          "GET A(0)
T1:     NOP
        ADD I,A; SETMA          "GET A(1)
T3:         FADD ZERO,ZERO      "INITIALIZE SUM
        ADD I,A; SETMA;         "GET A(2)
            FABS MD             "ABS A(0)
T4:     MOV N,N;                "IS ELEMENT COUNT = 0?
            FADD ZERO,FA        "WARM UP THE SUM
        ADD I,A; SETMA;         "GET A(3)
        BEQ DONE;               "EXIT IF COUNT = 0
            FABS MD;            "ABS A(1)
              DPX<FA            "SAVE ABS A(0)
LOOP:       FADD DPX,FA;        "ADD TO SUM
                DEC N           "DECREMENT COUNT
        ADD I,A; SETMA;         "GET A(M+4)
            FABS MD;            "ABS A(M+2)
              DPX<FA;           "SAVE ABS A(M+1)
                BNE LOOP        "LOOP UNTIL DONE
DONE:   MOV C,C; SETMA; MI<FA;  "STORE SUM
          RETURN                "EXIT
        $END
"****** SVESQ = SUM OF VECTOR ELEMENT SQUARES /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE SVESQ
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY SVESQ, 4                          "USER-DIRECTED-CALL ENTRY
"
"       --- ABSTRACT ---
"SUMS THE SQUARES OF THE ELEMENTS OF A VECTOR.
"
"FORMULA: C(0) = SUM ( A(MI) * A(MI))   FOR M = 0 TO N-1
"
"                  --- STATISTICS ---
"LANGUAGE:   AP-120B ASSEMBLER
"EQUIPMENT:   AP-120B WITH EITHER MEMORY
"SIZE:    10 LOCATIONS
"SPEED: BEST (FAST):  2N  (I ODD)
"        (STANDARD):  2N
"       WORST (FAST): 2N
"         (STANDARD): 3N
"       TYPICAL (FAST): 2N
"           (STANDARD): 2N
"
"    --- HISTORY ---
"ORIGINAL:  APR 77  R.S. NORIN
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"                  --- USAGE ---
"S-PAD PARAMETERS
        A   $EQU   0                    "BASE ADDRESS OF VECTOR A
        I   $EQU   1                    "INDEX BETWEEN ELEMENTS OF A
        C   $EQU   2                    "ADDRESS OF SUM
        N   $EQU   3                    "NUMBER OF ELEMENTS IN A
"
"SCRATCH: SP(0,3),DPX(0),FA,FM,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FSVESQ,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3/R/OP,
                    P4/I/IP
FSVESQ: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SVESQ:  MOV A,A; SETMA          "GET A(0)
T1:     NOP
        ADD I,A; SETMA          "GET A(1)
T3:         DPX<MD              "SAVE A(0)
        ADD I,A; SETMA;         "GET A(2)
            FMUL DPX,MD         "A(0)*A(0)
T4:     MOV N,N;                "IS ELEMENT COUNT = 0?
            DPX<MD;             "SAVE A(1)
              FMUL;
              FADD ZERO,ZERO    "INITIALIZE SUM
        ADD I,A; SETMA;         "GET A(3)
        BEQ DONE;               "EXIT IF COUNT = 0
            FMUL DPX,MD;        "A(1)*A(1)
              FADD              "PUSH
LOOP:       DPX<MD;             "SAVE A(M+2)
              FMUL;
                FADD FM,FA;     "ADD SQUARE TO SUM
                DEC N           "DECREMENT COUNT
        ADD I,A; SETMA;         "GET A(M+4)
            FMUL DPX,MD;        "A(M+2)*A(M+2)
                FADD;           "PUSH
                BNE LOOP        "LOOP UNTIL DONE
DONE:   MOV C,C; SETMA; MI<FA;  "STORE SUM
          RETURN                "EXIT
        $END
"****** SVS = SUM OF VECTOR SQUARES /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE SVS
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY SVS, 4                          "USER-DIRECTED-CALL ENTRY
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT:  AP-120B WITH EITHER MEMORY
"SIZE:   11 LOCATIONS
"
"    --- HISTORY ---
"ORIGINAL:  SEP 76  J. THROOP, A.E. CHARLESWORTH
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
"
"THE SUM OF THE SIGNED SQUARES OF THE ELEMENTS OF A VECTOR
"DOES C(0) = SUM ( A(MI) * ABS(A(MI)) )   FOR M = 0 TO N-1
       "TABSET 8 10 12 14 16 18 40
"S-PAD PARAMETERS:
A       $EQU 0          "A VECTOR ORIGIN
I       $EQU 1          "A VECTOR INCREMENT
C       $EQU 2          "ANSWER LOCATION
N       $EQU 3          "VECTOR LENGTH
"SCRATCH:
"        S-PADS: 0, 2, 3.
"        DPX:  0
"PHASE NUMBER
"      1 2 3 4 5
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FSVS,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3/R/OP,
                    P4/I/IP
FSVS: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SVS:   MOV A,A; SETMA                  "#1  2. FETCH A(0)
       NOP                             "#2  1. WAIT FOR A(0)
       ADD I,A; SETMA                  "2. FETCH A(1)
           DPX<MD;                     "#3  1. SAVE A(0)
           FABS MD                     "ABS(A(0))
       ADD I,A; SETMA;                 "2. FETCH A(2)
           FADD
        MOV N,N;                "IS ELEMENT COUNT = 0?
           DPX<MD;                     "#4  1. SAVE A(1)
           FABS MD;                    "ABS(A(1))
             FMUL DPX,FA               "A(0) * ABS(A(0))
       ADD I,A; SETMA;                 "2. FETCH A(3)
        BEQ DONE;               "EXIT IF COUNT = 0
             FADD ZERO,ZERO;           "INITIALIZE SUM
             FMUL
"
"
LOOP:      DPX<MD;                     "1. SAVE A(M+1)
           FABS MD;                    "ABS(A(M+1))
             FMUL DPX,FA;              "A(M+2)*ABS(A(M+2))
               DEC N                   "DONE ???
       ADD I,A;SETMA;                  "2. FETCH A(M)
             FMUL;
               FADD FM,FA;             "SUM + A(M+4)*ABS(A(M+4))
               BNE LOOP                "GO BACK IF NOT DONE
"DONE WITH LOOP, PUSH OUT SUM
DONE:  FADD
       MOV C,C;SETMA;MI<FA;            "STORE SUM INTO C(0)
       RETURN                          "AND RETURN
       $END
"****** MAXV = MAXIMUM ELEMENT OF A VECTOR /COMMON/ = REL 3.2, MAR 80 *****
        $TITLE MAXV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MAXV, 4                          "USER-DIRECTED-CALL ENTRY
"SCAN FOR MAX
"               ---ABSTRACT---
"THIS OUTPUTS THE MAX ELEMENT OF A VECTOR.  THE FIRST MAIN DATA ADDRESS AT
"WHICH IT OCCURRED IS OUTPUTTED AS AN INTEGER IN LOW MANTISSA ONE MEMORY
"LOCATION AFTER THE ANSWER, AND IN SP(17).
"               ---STATISTICS---
"LANGUAGE:      AP ASSEMBLER
"EQUIPMENT:     AP WITH EITHER MEMORY
"SIZE:          20. LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  DEC 75  S. CAMLEY
" REV 2.0:  DEC 77  R.S. NORIN    NOW ALSO STORES ADDRESS OF MAX IN SP(17)
" REVISED:  AUG 78  L. TARVESTAD  NOW RETURNS CORRECT MAX ADDR WHEN I>1
" REVISED:  APR 79  W.H.INSKEEP--INSTEAD OF RETURNING ADDRESS, NOW RETURNS
"                       INDEX OF MAX IN SP(17) AND FLOAT(INDEX) IN MD(C+1).
" REVISED:  AUG 79  D. DAVIS  FIXED BUG IN FIRST MEMORY SAVE
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2: MAR 80  R.S. NORIN  FUNCTIONALITY RETURNED TO THAT
"                                       PRIOR TO APR 79 REVISION.  I.E.,
"                                       MD ADDRESS OF EXTREMUM IS STORED
"                                       AS INTEGER IN MD(C+1) AND SP(17).
"                                       THE ROUTINE XMAXV PRESERVES THE
"                                       APR 79- FEB 80 FUNCTIONALITY. I.E.,
"                                       WHERE MD(C+1) CONTAINS THE ARRAY
"                                       INDEX OF THE EXTREMUM AS A FLOATING
"                                       POINT VALUE.
"
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC   MEANING
" 0             A       BASE ADDRESS OF VECTOR
" 1             I       INCREMENT FOR A
" 2             C       ADDRESS OF ANSWER
" 3             N       # OF ELEMENTS OF VECTOR A
"               ---SCRATCH---
"S-PAD:         0-5
"DATA PAD:      DPX(0-31.), DPY(0-31.), DPA
"               ---ALGORITHM---
"THIS UTILIZES AN UNUSUAL 2-CYCLE LOOP WHICH ASSUMES THAT THE OLD
"MAXIMUM WILL REMAIN THE MAX UNTIL PROVEN OTHERWISE, BY WHICH TIME
"DATA FOLLOWING WHAT SHOULD HAVE BEEN THE NEW MAX HAS ALREADY BEEN
"COMPARED WITH THE OLD MAX.  AT THIS POINT, THE PROGRAM BRANCHES TO
"TRADE, WHICH RE-INSTATES THE NEW MAX AND COMPARES THE ALREADY-COMPARED
"DATA FOLLOWING IT.  THEN IT GOES BACK TO  THE LOOP.
"THE ADDRESS OF THE NEW MAX IS ALSO DISCOVERED TOO LATE, SO A
"DISPLACEMENT CORRECTION IS MADE WHEN THE LOOP IS DONE.
"S-PAD PARAMETERS:
A = 0
I = 1
C = 2
N = 3
"THE FOLLOWING ARE NOT PARAMETERS:
SAVADD = 4
DISP = 5
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMAXV,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3(2)/R/OP,
                    P4/I/IP
FMAXV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MAXV:   MOV A,A; SETMA                  "GET FIRST ELEMENT
        MOVL I,DISP
        ADD I,A; SETMA                  "GET A(2)
        DPX<MD;                         "STORE A(1) IN MAX
          MOV N,N               "IS ELEMENT COUNT = 0?
        ADD I,A; SETMA;                 "GET A(3)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        FADD ZERO,MD;                    "A(2) IN ADDER
                MOVL DISP,DISP          "DISP CORR=4*I
        ADD I,A; SETMA;                 "GET A(4)
          FADD
        FADD ZERO,MD;                   "A(3) IN ADDER
          DPY<FA;                       "STORE A(2)
          DEC N                         "DECREMENT COUNT
        ADD I,A; SETMA;                 "GET A(5)
          FSUB DPY,DPX;                 "COMPARE A(2),MAX
          INCDPA                        "DPA=DPA+1
        DPX<DPX(-1);                    "MOVE UP MAX
          FADD ZERO,MD;                 "A(4) IN ADDER
          DPY<FA;                       "STORE A(3)
          MOV A,SAVADD                  "SAVE ADDRESS
        ADD I,A; SETMA;                 "GET A(6)
          FSUB DPY,DPX;                 "COMPARE A(3),MAX
          INCDPA                        "DPA=DPA+1
LOOP:   DPX<DPX(-1);                    "MOVE UP MAX
          FADD ZERO,MD;                 "A(L+1) IN ADDER
          DPY<FA;                       "STORE A(L)
          BFGT TRADE;                   "TEST IF SHOULD HAVE CHANGED MAX
          DEC N
        ADD I,A; SETMA;                 "GET A(L+3)
          FSUB DPY,DPX;                 "COMPARE A(L),MAX
          INCDPA;                       "DPA=DPA+1
          BNE LOOP                      "TEST IF DONE
"PROGRAM REACHES HERE WHEN THROUGH WITH ALL ELEMENTS
        SUB DISP,SAVADD; DPY<SPFN;      "DISP CORR TO ADDRESS
          BR DONE                       "GO STORE ANSWERS
"PROGRAM BRANCHES HERE WHEN SHOULD HAVE CHANGED MAX
TRADE:  DPX<DPY(-2)                     "PUT A(L-2) IN MAX
        FSUB DPY(-1),DPX;               "COMPARE A(L-1),MAX
          MOV A,SAVADD                  "SAVE ADDRESS
        MOV N,N;
          FADD ZERO,FA;                 "A(L+1) IN ADDER
          BR LOOP + 1
"PROGRAM BRANCHES HERE TO STORE ANSWERS
DONE:   MOV C,C; SETMA; MI<DPX(-1)      "STORE MAX
        LDSPI 17; MI<DPY; INCMA;        "STORE ADDRESS OF MAX
          RETURN
        $END
"****** MINV = MINIMUM ELEMENT OF A VECTOR /COMMON/ = REL 3.2, MAR 80 *****
        $TITLE MINV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MINV, 4                          "USER-DIRECTED-CALL ENTRY
"SCAN FOR MIN
"               ---ABSTRACT---
"THIS OUTPUTS THE MIN ELEMENT OF A VECTOR.  THE FIRST MAIN DATA ADDRESS AT
"WHICH IT OCCURRED IS OUTPUTTED AS AN INTEGER IN LOW MANTISSA ONE MEMORY
"LOCATION AFTER THE ANSWER, AND IN SP(17).
"               ---STATISTICS---
"LANGUAGE:      AP ASSEMBLER
"EQUIPMENT:     AP WITH EITHER MEMORY
"SIZE:          20. LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  DEC 75  S. CAMLEY
" REV 2.0:  DEC 77  R.S. NORIN    NOW ALSO STORES ADDRESS OF MIN IN SP(17)
" REVISED:  AUG 78  L. TARVESTAD  NOW RETURNS CORRECT MIN ADDR WHEN I>1
" REVISED:  APR 79  W.H.INSKEEP--INSTEAD OF RETURNING ADDRESS, NOW RETURNS
"                       INDEX OF MIN IN SP(17) AND FLOAT(INDEX) IN MD(C+1).
" REVISED:  AUG 79  D. DAVIS  FIXED BUG IN FIRST MEMORY SAVE
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2: MAR 80  R.S. NORIN  FUNCTIONALITY RETURNED TO THAT
"                                       PRIOR TO APR 79 REVISION.  I.E.,
"                                       MD ADDRESS OF EXTREMUM IS STORED
"                                       AS INTEGER IN MD(C+1) AND SP(17).
"                                       THE ROUTINE XMINV PRESERVES THE
"                                       APR 79- FEB 80 FUNCTIONALITY. I.E.,
"                                       WHERE MD(C+1) CONTAINS THE ARRAY
"                                       INDEX OF THE EXTREMUM AS A FLOATING
"                                       POINT VALUE.
"
"
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC   MEANING
" 0             A       BASE ADDRESS OF VECTOR
" 1             I       INCREMENT FOR A
" 2             C       ADDRESS OF ANSWER
" 3             N       # OF ELEMENTS OF VECTOR A
"               ---SCRATCH---
"S-PAD:         0-5
"DATA PAD:      DPX(0-31.), DPY(0-31.), DPA
"               ---ALGORITHM---
"THIS UTILIZES AN UNUSUAL 2-CYCLE LOOP WHICH ASSUMES THAT THE OLD
"MINIMUM WILL REMAIN THE MIN UNTIL PROVEN OTHERWISE, BY WHICH TIME
"DATA FOLLOWING WHAT SHOULD HAVE BEEN THE NEW MIN HAS ALREADY BEEN
"COMPARED WITH THE OLD MIN.  AT THIS POINT, THE PROGRAM BRANCHES TO
"TRADE, WHICH RE-INSTATES THE NEW MIN AND COMPARES THE ALREADY-COMPARED
"DATA FOLLOWING IT.  THEN IT GOES BACK TO  THE LOOP.
"THE ADDRESS OF THE NEW MIN IS ALSO DISCOVERED TOO LATE, SO A
"DISPLACEMENT CORRECTION IS MADE WHEN THE LOOP IS DONE.
"S-PAD PARAMETERS:
A = 0
I = 1
C = 2
N = 3
"THE FOLLOWING ARE NOT PARAMETERS:
SAVADD = 4
DISP = 5
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMINV,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3(2)/R/OP,
                    P4/I/IP
FMINV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MINV:   MOV A,A; SETMA                  "GET FIRST ELEMENT
        MOVL I,DISP
        ADD I,A; SETMA                  "GET A(2)
        DPX<MD;                         "STORE A(1) IN MIN
          MOV N,N               "IS ELEMENT COUNT = 0?
        ADD I,A; SETMA;                 "GET A(3)
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        FADD ZERO,MD;                    "A(2) IN ADDER
                MOVL DISP,DISP          "DISP CORR=4*I
        ADD I,A; SETMA;                 "GET A(4)
          FADD
        FADD ZERO,MD;                   "A(3) IN ADDER
          DPY<FA;                       "STORE A(2)
          DEC N                         "DECREMENT COUNT
        ADD I,A; SETMA;                 "GET A(5)
          FSUBR DPY,DPX;                "COMPARE A(2),MIN
          INCDPA                        "DPA=DPA+1
        DPX<DPX(-1);                    "MOVE UP MIN
          FADD ZERO,MD;                 "A(4) IN ADDER
          DPY<FA;                       "STORE A(3)
          MOV A,SAVADD                  "SAVE ADDRESS
        ADD I,A; SETMA;                 "GET A(6)
          FSUBR DPY,DPX;                "COMPARE A(3),MIN
          INCDPA                        "DPA=DPA+1
LOOP:   DPX<DPX(-1);                    "MOVE UP MIN
          FADD ZERO,MD;                 "A(L+1) IN ADDER
          DPY<FA;                       "STORE A(L)
          BFGT TRADE;                   "TEST IF SHOULD HAVE CHANGED MIN
          DEC N
        ADD I,A; SETMA;                 "GET A(L+3)
          FSUBR DPY,DPX;                "COMPARE A(L),MIN
          INCDPA;                       "DPA=DPA+1
          BNE LOOP                      "TEST IF DONE
"PROGRAM REACHES HERE WHEN THROUGH WITH ALL ELEMENTS
        SUB DISP,SAVADD; DPY<SPFN;      "DISP CORR TO ADDRESS
          BR DONE                       "GO STORE ANSWERS
"PROGRAM BRANCHES HERE WHEN SHOULD HAVE CHANGED MIN
TRADE:  DPX<DPY(-2)                     "PUT A(L-2) IN MIN
        FSUBR DPY(-1),DPX;              "COMPARE A(L-1),MIN
          MOV A,SAVADD                  "SAVE ADDRESS
        MOV N,N;
          FADD ZERO,FA;                 "A(L+1) IN ADDER
          BR LOOP + 1
"PROGRAM BRANCHES HERE TO STORE ANSWERS
DONE:   MOV C,C; SETMA; MI<DPX(-1)      "STORE MIN
        LDSPI 17; MI<DPY; INCMA;        "STORE ADDRESS OF MIN
          RETURN
        $END
"****** MAXMGV = MAXIMUM MAGNITUDE ELEMENT OF A VECTOR /COMMO= REL 3.2, MAR 80
        $TITLE MAXMGV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MAXMGV, 4                          "USER-DIRECTED-CALL ENTRY
"SCAN FOR MAX ABS. VALUE
"               ---ABSTRACT---
"THIS SCANS FOR THE MAXIMUM ABSOLUTE VALUE IN A VECTOR.  THE OUTPUT
"IS THE ABSOLUTE VALUE, NOT THE ACTUAL ELEMENT.  THE FIRST MD ADDRESS AT
"WHICH IT OCCURRED IS OUTPUTTED AS AN INTEGER IN LOW MANTISSA ONE MEMORY
"LOCATION AFTER THE ANSWER, AND IN SP(17).
"               ---STATISTICS---
"LANGUAGE:      AP ASSEMBLER
"EQUIPMENT:     AP WITH EITHER MEMORY
"SIZE:          20. LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  DEC 75  S. CAMLEY
" REV 2.0:  DEC 77  R.S. NORIN    NOW ALSO STORES ADDRESS OF MAX IN SP(17)
" REVISED:  AUG 78  L. TARVESTAD  NOW RETURNS CORRECT MAXMG ADDR WHEN I>1
" REVISED:  APR 79  W.H.INSKEEP--INSTEAD OF RETURNING ADDRESS, NOW RETURNS
"                       INDEX OF MAX IN SP(17) AND FLOAT(INDEX) IN MD(C+1).
" REVISED:  AUG 79  D. DAVIS  FIXED BUG IN FIRST MEMORY SAVE
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2: MAR 80  R.S. NORIN  FUNCTIONALITY RETURNED TO THAT
"                                       PRIOR TO APR 79 REVISION.  I.E.,
"                                       MD ADDRESS OF EXTREMUM IS STORED
"                                       AS INTEGER IN MD(C+1) AND SP(17).
"                                       THE ROUTINE XMAXMG PRESERVES THE
"                                       APR 79- FEB 80 FUNCTIONALITY. I.E.,
"                                       WHERE MD(C+1) CONTAINS THE ARRAY
"                                       INDEX OF THE EXTREMUM AS A FLOATING
"                                       POINT VALUE.
"
"
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC   MEANING
" 0             A       BASE ADDRESS OF VECTOR
" 1             I       INCREMENT FOR A
" 2             C       ADDRESS OF ANSWER
" 3             N       # OF ELEMENTS OF VECTOR A
"               ---SCRATCH---
"S-PAD:         0-5
"DATA PAD:      DPX(0-31.), DPY(0-31.), DPA
"               ---ALGORITHM---
"THIS UTILIZES AN UNUSUAL 2-CYCLE LOOP WHICH ASSUMES THAT THE OLD
"MAXIMUM WILL REMAIN THE MAX UNTIL PROVEN OTHERWISE, BY WHICH TIME
"DATA FOLLOWING WHAT SHOULD HAVE BEEN THE NEW MAX HAS ALREADY BEEN
"COMPARED WITH THE OLD MAX.  AT THIS POINT, THE PROGRAM BRANCHES TO
"TRADE, WHICH RE-INSTATES THE NEW MAX AND COMPARES THE ALREADY-COMPARED
"DATA FOLLOWING IT.  THEN IT GOES BACK TO  THE LOOP.
"THE ADDRESS OF THE NEW MAX IS ALSO DISCOVERED TOO LATE, SO A
"DISPLACEMENT CORRECTION IS MADE WHEN THE LOOP IS DONE.
"S-PAD PARAMETERS:
A = 0
I = 1
C = 2
N = 3
"THE FOLLOWING ARE NOT PARAMETERS:
SAVADD = 4
DISP = 5
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMXMGV,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3(2)/R/OP,
                    P4/I/IP
FMXMGV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MAXMGV:   MOV A,A; SETMA                  "GET FIRST ELEMENT
        MOVL I,DISP
        ADD I,A; SETMA                  "GET A(2)
        FABS MD;                         "DO /A(1)/
                MOVL DISP,DISP          "DISP CORR=4*I
        ADD I,A; SETMA;                 "GET A(3)
          FADD
        FABS MD;                        "DO /A(2)/
          DPX<FA;                       "STORE /A(1)/ IN MAX
          MOV N,N               "IS ELEMENT COUNT = 0?
        ADD I,A; SETMA;                 "GET A(4)
          FADD;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        FABS MD;                        "DO /A(3)/
          DPY<FA;                       "STORE /A(2)/
          DEC N                         "DECREMENT COUNT
        ADD I,A; SETMA;                 "GET A(5)
          FSUB DPY,DPX;                 "COMPARE /A(2)/,MAX
          INCDPA                        "DPA=DPA+1
        FABS MD;                        "DO /A(4)/
          DPY<FA;                       "STORE /A(3)/
          DPX<DPX(-1);                  "MOVE UP MAX
          MOV A,SAVADD                  "SAVE ADDRESS
        ADD I,A; SETMA;                 "GET A(6)
          FSUB DPY,DPX;                 "COMPARE /A(3)/,MAX
          INCDPA                        "DPA=DPA+1
LOOP:   FABS MD;                        "DO /A(L+1)/
          DPY<FA;                       "STORE /A(L)/
          DPX<DPX(-1);                  "MOVE UP MAX
          BFGT TRADE;                   "TEST IF SHOULD HAVE CHANGED MAX
          DEC N
        ADD I,A; SETMA;                 "GET A(L+3)
          FSUB DPY,DPX;                 "COMPARE /A(L)/,MAX
          INCDPA;                      "DPA=DPA+1
          BNE LOOP                      "TEST IF DONE
"PROGRAM REACHES HERE WHEN THROUGH WITH ALL ELEMENTS
        SUB DISP,SAVADD; DPY<SPFN;      "DISP CORR TO ADDRESS
          BR DONE                       "GO STORE ANSWERS
"PROGRAM BRANCHES HERE WHEN SHOULD HAVE CHANGED MAX
TRADE:  DPX<DPY(-2)                     "PUT /A(L-2)/ IN MAX
        FSUB DPY(-1),DPX;               "COMPARE /A(L-1)/,MAX
          MOV A,SAVADD                  "SAVE ADDRESS
        FADD ZERO,FA;                   "/A(L+1)/ IN ADDER
          MOV N,N;
          BR LOOP + 1
"PROGRAM BRANCHES HERE TO STORE ANSWERS
DONE:   MOV C,C; SETMA; MI<DPX(-1)      "STORE MAX
        LDSPI 17; MI<DPY; INCMA;        "STORE ADDRESS OF MAX
          RETURN
        $END
"****** MINMGV = MINIMUM MAGNITUDE ELEMENT OF A VECTOR /COMMO= REL 3.2, MAR 80
        $TITLE MINMGV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY MINMGV, 4                          "USER-DIRECTED-CALL ENTRY
"SCAN FOR MIN ABS. VALUE
"               ---ABSTRACT---
"THIS SCANS FOR THE MINIMUM ABSOLUTE VALUE IN A VECTOR.  THE OUTPUT
"IS THE ABSOLUTE VALUE, NOT THE ACTUAL ELEMENT.  THE FIRST MD ADDRESS AT
"WHICH IT OCCURRED IS OUTPUTTED AS AN INTEGER IN LOW MANTISSA ONE MEMORY
"LOCATION AFTER THE ANSWER, AND IN SP(17).
"               ---STATISTICS---
"LANGUAGE:      AP ASSEMBLER
"EQUIPMENT:     AP WITH EITHER MEMORY
"SIZE:          20. LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  DEC 75  S. CAMLEY
" REV 2.0:  DEC 77  R.S. NORIN    NOW ALSO STORES ADDRESS OF MIN IN SP(17)
" REVISED:  AUG 78  L. TARVESTAD  NOW RETURNS CORRECT MINMG ADDR WHEN I>1
" REVISED:  APR 79  W.H.INSKEEP--INSTEAD OF RETURNING ADDRESS, NOW RETURNS
"                       INDEX OF MIN IN SP(17) AND FLOAT(INDEX) IN MD(C+1).
" REVISED:  AUG 79  D. DAVIS  FIXED BUG IN FIRST MEMORY SAVE
" REVISED:  SEP 79  R.S. NORIN     EXITS PROPERLY WHEN N=0
" REV 3.2 AND 2A.2: MAR 80  R.S. NORIN  FUNCTIONALITY RETURNED TO THAT
"                                       PRIOR TO APR 79 REVISION.  I.E.,
"                                       MD ADDRESS OF EXTREMUM IS STORED
"                                       AS INTEGER IN MD(C+1) AND SP(17).
"                                       THE ROUTINE XMINMG PRESERVES THE
"                                       APR 79- FEB 80 FUNCTIONALITY. I.E.,
"                                       WHERE MD(C+1) CONTAINS THE ARRAY
"                                       INDEX OF THE EXTREMUM AS A FLOATING
"                                       POINT VALUE.
"
"
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC   MEANING
" 0             A       BASE ADDRESS OF VECTOR
" 1             I       INCREMENT FOR A
" 2             C       ADDRESS OF ANSWER
" 3             N       # OF ELEMENTS OF VECTOR A
"               ---SCRATCH---
"S-PAD:         0-5
"DATA PAD:      DPX(0-31.), DPY(0-31.), DPA
"               ---ALGORITHM---
"THIS UTILIZES AN UNUSUAL 2-CYCLE LOOP WHICH ASSUMES THAT THE OLD
"MINIMUM WILL REMAIN THE MIN UNTIL PROVEN OTHERWISE, BY WHICH TIME
"DATA FOLLOWING WHAT SHOULD HAVE BEEN THE NEW MIN HAS ALREADY BEEN
"COMPARED WITH THE OLD MIN.  AT THIS POINT, THE PROGRAM BRANCHES TO
"TRADE, WHICH RE-INSTATES THE NEW MIN AND COMPARES THE ALREADY-COMPARED
"DATA FOLLOWING IT.  THEN IT GOES BACK TO  THE LOOP.
"THE ADDRESS OF THE NEW MIN IS ALSO DISCOVERED TOO LATE, SO A
"DISPLACEMENT CORRECTION IS MADE WHEN THE LOOP IS DONE.
"S-PAD PARAMETERS:
A = 0
I = 1
C = 2
N = 3
"THE FOLLOWING ARE NOT PARAMETERS:
SAVADD = 4
DISP = 5
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FMNMGV,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3(2)/R/OP,
                    P4/I/IP
FMNMGV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MINMGV:   MOV A,A; SETMA                  "GET FIRST ELEMENT
        MOVL I,DISP
        ADD I,A; SETMA                  "GET A(2)
        FABS MD;                         "DO /A(1)/
                MOVL DISP,DISP          "DISP CORR= 4*I
        ADD I,A; SETMA;                 "GET A(3)
          FADD
        FABS MD;                        "DO /A(2)/
          DPX<FA;                       "STORE /A(1)/ IN MIN
          MOV N,N               "IS ELEMENT COUNT = 0?
        ADD I,A; SETMA;                 "GET A(4)
          FADD;
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        FABS MD;                        "DO /A(3)/
          DPY<FA;                       "STORE /A(2)/
          DEC N                         "DECREMENT COUNT
        ADD I,A; SETMA;                 "GET A(5)
          FSUBR DPY,DPX;                "COMPARE /A(2)/,MIN
          INCDPA                        "DPA=DPA+1
        FABS MD;                        "DO /A(4)/
          DPY<FA;                       "STORE /A(3)/
          DPX<DPX(-1);                  "MOVE UP MAX
          MOV A,SAVADD                  "SAVE ADDRESS
        ADD I,A; SETMA;                 "GET A(6)
          FSUBR DPY,DPX;                "COMPARE /A(3)/,MIN
          INCDPA                        "DPA=DPA+1
LOOP:   FABS MD;                        "DO /A(L+1)/
          DPY<FA;                       "STORE /A(L)/
          DPX<DPX(-1);                  "MOVE UP MAX
          BFGT TRADE;                   "TEST IF SHOULD HAVE CHANGED MIN
          DEC N
        ADD I,A; SETMA;                 "GET A(L+3)
          FSUBR DPY,DPX;                "COMPARE /A(L)/,MIN
          INCDPA;                      "DPA=DPA+1
          BNE LOOP                      "TEST IF DONE
"PROGRAM REACHES HERE WHEN THROUGH WITH ALL ELEMENTS
        SUB DISP,SAVADD; DPY<SPFN;      "DISP CORR TO ADDRESS
          BR DONE                       "GO STORE ANSWERS
"PROGRAM BRANCHES HERE WHEN SHOULD HAVE CHANGED MIN
TRADE:  DPX<DPY(-2)                     "PUT /A(L-2)/ IN MIN
        FSUBR DPY(-1),DPX;              "COMPARE /A(L-1)/,MIN
          MOV A,SAVADD                  "SAVE ADDRESS
        FADD ZERO,FA;                   "/A(L+1)/ IN ADDER
          MOV N,N;
          BR LOOP + 1
"PROGRAM BRANCHES HERE TO STORE ANSWERS
DONE:   MOV C,C; SETMA; MI<DPX(-1)      "STORE MIN
        LDSPI 17; MI<DPY; INCMA;        "STORE ADDRESS OF MIN
          RETURN
        $END
"****** XMAXV = MAXIMUM ELEMENT OF A VECTOR /COMMON/ = REL 3.0, MAR 80 ****
        $TITLE XMAXV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY XMAXV, 4
"SCAN FOR MAX
"               ---ABSTRACT---
"THIS OUTPUTS THE MAX ELEMENT OF A VECTOR.  THE FIRST INDEX AT
"WHICH IT OCCURRED IS OUTPUTTED AS A FLOATING POINT VALUE ONE MEMORY
"LOCATION AFTER THE ANSWER, AND AS AN INTEGER IN SP(17).
"               ---STATISTICS---
"LANGUAGE:      AP ASSEMBLER
"EQUIPMENT:     AP WITH EITHER MEMORY
"SIZE:          22. LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  MAR 80  R.S. NORIN    THIS ROUTINE ADDED TO PRESERVE THE
"                                 FUNCTIONALITY OF THE ROUTINE MAXV
"                                 DURING THE APR 79 - FEB 80 PERIOD.
"                                 ARRAY INDEX OF EXTREMUM IS STORED
"                                 AS FLOATING-POINT VALUE IN MD ADDR
"                                 C+1.
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC   MEANING
" 0             A       BASE ADDRESS OF VECTOR
" 1             I       INCREMENT FOR A
" 2             C       ADDRESS OF ANSWER
" 3             N       # OF ELEMENTS OF VECTOR A
"               ---SCRATCH---
"S-PAD:         0-4, 17
"DATA PAD:      DPX(0-31.), DPY(0-31.), DPA
"               ---ALGORITHM---
"THIS UTILIZES AN UNUSUAL 2-CYCLE LOOP WHICH ASSUMES THAT THE OLD
"MAXIMUM WILL REMAIN THE MAX UNTIL PROVEN OTHERWISE, BY WHICH TIME
"DATA FOLLOWING WHAT SHOULD HAVE BEEN THE NEW MAX HAS ALREADY BEEN
"COMPARED WITH THE OLD MAX.  AT THIS POINT, THE PROGRAM BRANCHES TO
"TRADE, WHICH RE-INSTATES THE NEW MAX AND COMPARES THE ALREADY-COMPARED
"DATA FOLLOWING IT.  THEN IT GOES BACK TO  THE LOOP.
"S-PAD PARAMETERS:
A = 0
I = 1
C = 2
N = 3
"THE FOLLOWING ARE NOT PARAMETERS:
NSAVE = 17
INDEX = 4
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FXMAXV,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3(2)/R/OP,
                    P4/I/IP
FXMAXV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
XMAXV:   MOV A,A; SETMA                  "GET FIRST ELEMENT
        ADD I,A; SETMA                  "GET A(2)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        ADD I,A; SETMA;                 "GET A(3)
         DPX<MD;                        "STORE A(1) IN MAX
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        FADD ZERO,MD;                    "A(2) IN ADDER
                DEC N
        ADD I,A; SETMA;                 "GET A(4)
          FADD
        FADD ZERO,MD;                   "A(3) IN ADDER
          MOV N,INDEX;
          DPY<FA                        "STORE A(2)
        ADD I,A; SETMA;                 "GET A(5)
          FSUB DPY,DPX;                 "COMPARE A(2),MAX
          INCDPA                        "DPA=DPA+1
        DPX<DPX(-1);                    "MOVE UP MAX
          FADD ZERO,MD;                 "A(4) IN ADDER
          DPY<FA;                       "STORE A(3)
          MOV N,NSAVE
        ADD I,A; SETMA;                 "GET A(6)
          FSUB DPY,DPX;                 "COMPARE A(3),MAX
          INCDPA                        "DPA=DPA+1
LOOP:   DPX<DPX(-1);                    "MOVE UP MAX
          FADD ZERO,MD;                 "A(L+1) IN ADDER
          DPY<FA;                       "STORE A(L)
          BFGT TRADE;                   "TEST IF SHOULD HAVE CHANGED MAX
          DEC N
        ADD I,A; SETMA;                 "GET A(L+3)
          FSUB DPY,DPX;                 "COMPARE A(L),MAX
          INCDPA;                       "DPA=DPA+1
          BNE LOOP                      "TEST IF DONE
"PROGRAM REACHES HERE WHEN THROUGH WITH ALL ELEMENTS
        INC NSAVE;
          BR DONE                       "GO STORE ANSWERS
"PROGRAM BRANCHES HERE WHEN SHOULD HAVE CHANGED MAX
TRADE:  DPX<DPY(-2)                     "PUT A(L-2) IN MAX
        FSUB DPY(-1),DPX                "COMPARE A(L-1),MAX
        MOV N,INDEX;
          FADD ZERO,FA;                 "A(L+1) IN ADDER
          BR LOOP + 1
"PROGRAM BRANCHES HERE TO STORE ANSWERS
DONE:   SUB INDEX,NSAVE; DPX<SPFN       "COMPUTE INDEX,N,C
        LDSPI N; DB=27.                 "FLOAT INDEX
        FADD ZERO,MDPX; MOV N,N         "
        FADD; MOV C,C;SETMA; MI<DPX(-1) "STORE MAX
        INCMA; MI<FA; RETURN            "STORE FLOAT (INDEX)
        $END
"****** XMINV = MINIMUM ELEMENT OF A VECTOR /COMMON/ = REL 3.0, MAR 80 ****
        $TITLE XMINV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY XMINV, 4
"SCAN FOR MIN
"               ---ABSTRACT---
"THIS OUTPUTS THE MIN ELEMENT OF A VECTOR.  THE FIRST INDEX AT
"WHICH IT OCCURRED IS OUTPUTTED AS A FLOATING POINT VALUE ONE MEMORY
"LOCATION AFTER THE ANSWER, AND AS AN INTEGER IN SP(17).
"               ---STATISTICS---
"LANGUAGE:      AP ASSEMBLER
"EQUIPMENT:     AP WITH EITHER MEMORY
"SIZE:          22. LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  MAR 80  R.S. NORIN    THIS ROUTINE ADDED TO PRESERVE THE
"                                 FUNCTIONALITY OF THE ROUTINE MINV
"                                 DURING THE APR 79 - FEB 80 PERIOD.
"                                 ARRAY INDEX OF EXTREMUM IS STORED
"                                 AS FLOATING-POINT VALUE IN MD ADDR
"                                 C+1.
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC   MEANING
" 0             A       BASE ADDRESS OF VECTOR
" 1             I       INCREMENT FOR A
" 2             C       ADDRESS OF ANSWER
" 3             N       # OF ELEMENTS OF VECTOR A
"               ---SCRATCH---
"S-PAD:         0-4, 17
"DATA PAD:      DPX(0-31.), DPY(0-31.), DPA
"               ---ALGORITHM---
"THIS UTILIZES AN UNUSUAL 2-CYCLE LOOP WHICH ASSUMES THAT THE OLD
"MINIMUM WILL REMAIN THE MIN UNTIL PROVEN OTHERWISE, BY WHICH TIME
"DATA FOLLOWING WHAT SHOULD HAVE BEEN THE NEW MIN HAS ALREADY BEEN
"COMPARED WITH THE OLD MIN.  AT THIS POINT, THE PROGRAM BRANCHES TO
"TRADE, WHICH RE-INSTATES THE NEW MIN AND COMPARES THE ALREADY-COMPARED
"DATA FOLLOWING IT.  THEN IT GOES BACK TO  THE LOOP.
"S-PAD PARAMETERS:
A = 0
I = 1
C = 2
N = 3
"THE FOLLOWING ARE NOT PARAMETERS:
INDEX = 4
NSAVE = 17
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FXMINV,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3(2)/R/OP,
                    P4/I/IP
FXMINV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
XMINV:   MOV A,A; SETMA                  "GET FIRST ELEMENT
        ADD I,A; SETMA                  "GET A(2)
        MOV N,N                 "IS ELEMENT COUNT = 0?
        ADD I,A; SETMA;                 "GET A(3)
         DPX<MD;                        "STORE A(1) IN MIN
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        FADD ZERO,MD;                    "A(2) IN ADDER
                DEC N
        ADD I,A; SETMA;                 "GET A(4)
          FADD
        FADD ZERO,MD;                   "A(3) IN ADDER
          MOV N,INDEX;
          DPY<FA                        "STORE A(2)
        ADD I,A; SETMA;                 "GET A(5)
          FSUBR DPY,DPX;                "COMPARE A(2),MIN
          INCDPA                        "DPA=DPA+1
        DPX<DPX(-1);                    "MOVE UP MIN
          FADD ZERO,MD;                 "A(4) IN ADDER
          DPY<FA;                       "STORE A(3)
          MOV N,NSAVE
        ADD I,A; SETMA;                 "GET A(6)
          FSUBR DPY,DPX;                "COMPARE A(3),MIN
          INCDPA                        "DPA=DPA+1
LOOP:   DPX<DPX(-1);                    "MOVE UP MIN
          FADD ZERO,MD;                 "A(L+1) IN ADDER
          DPY<FA;                       "STORE A(L)
          BFGT TRADE;                   "TEST IF SHOULD HAVE CHANGED MIN
          DEC N
        ADD I,A; SETMA;                 "GET A(L+3)
          FSUBR DPY,DPX;                "COMPARE A(L),MIN
          INCDPA;                       "DPA=DPA+1
          BNE LOOP                      "TEST IF DONE
"PROGRAM REACHES HERE WHEN THROUGH WITH ALL ELEMENTS
        INC NSAVE;
          BR DONE                       "GO STORE ANSWERS
"PROGRAM BRANCHES HERE WHEN SHOULD HAVE CHANGED MIN
TRADE:  DPX<DPY(-2)                     "PUT A(L-2) IN MIN
        FSUBR DPY(-1),DPX               "COMPARE A(L-1),MIN
        MOV N,INDEX;
          FADD ZERO,FA;                 "A(L+1) IN ADDER
          BR LOOP + 1
"PROGRAM BRANCHES HERE TO STORE ANSWERS
DONE:   SUB INDEX,NSAVE; DPX<SPFN       "COMPUTE INDEX,N,C
        LDSPI N; DB=27.                 "FLOAT INDEX
        FADD ZERO,MDPX; MOV N,N         "
        FADD; MOV C,C;SETMA; MI<DPX(-1) "STORE MIN
        INCMA; MI<FA; RETURN            "STORE FLOAT (INDEX)
        $END
"****** XMAXMG = MAXIMUM MAGNITUDE ELEMENT OF A VECTOR /COMMO= REL 3.0, MAR 80
        $TITLE XMAXMG
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY XMAXMG, 4
"SCAN FOR MAX ABS. VALUE
"               ---ABSTRACT---
"THIS SCANS FOR THE MAXIMUM ABSOLUTE VALUE IN A VECTOR.  THE OUTPUT
"IS THE ABSOLUTE VALUE, NOT THE ACTUAL ELEMENT.  THE FIRST INDEX AT
"WHICH IT OCCURRED IS OUTPUTTED AS A FLOATING POINT VALUE ONE MEMORY
"LOCATION AFTER THE ANSWER, AND AS AN INTEGER IN SP(17).
"               ---STATISTICS---
"LANGUAGE:      AP ASSEMBLER
"EQUIPMENT:     AP WITH EITHER MEMORY
"SIZE:          22. LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  MAR 80  R.S. NORIN    THIS ROUTINE ADDED TO PRESERVE THE
"                                 FUNCTIONALITY OF THE ROUTINE MAXMGV
"                                 DURING THE APR 79 - FEB 80 PERIOD.
"                                 ARRAY INDEX OF EXTREMUM IS STORED
"                                 AS FLOATING-POINT VALUE IN MD ADDR
"                                 C+1.
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC   MEANING
" 0             A       BASE ADDRESS OF VECTOR
" 1             I       INCREMENT FOR A
" 2             C       ADDRESS OF ANSWER
" 3             N       # OF ELEMENTS OF VECTOR A
"               ---SCRATCH---
"S-PAD:         0-4,17
"DATA PAD:      DPX(0-31.), DPY(0-31.), DPA
"               ---ALGORITHM---
"THIS UTILIZES AN UNUSUAL 2-CYCLE LOOP WHICH ASSUMES THAT THE OLD
"MAXIMUM WILL REMAIN THE MAX UNTIL PROVEN OTHERWISE, BY WHICH TIME
"DATA FOLLOWING WHAT SHOULD HAVE BEEN THE NEW MAX HAS ALREADY BEEN
"COMPARED WITH THE OLD MAX.  AT THIS POINT, THE PROGRAM BRANCHES TO
"TRADE, WHICH RE-INSTATES THE NEW MAX AND COMPARES THE ALREADY-COMPARED
"DATA FOLLOWING IT.  THEN IT GOES BACK TO  THE LOOP.
"S-PAD PARAMETERS:
A = 0
I = 1
C = 2
N = 3
"THE FOLLOWING ARE NOT PARAMETERS:
INDEX = 4
NSAVE = 17
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FXMXMG,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3(2)/R/OP,
                    P4/I/IP
FXMXMG: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
XMAXMG:   MOV A,A; SETMA                  "GET FIRST ELEMENT
        ADD I,A; SETMA                  "GET A(2)
        MOV N,NSAVE
        ADD I,A; SETMA;                 "GET A(3)
          FABS MD;                        "DO /A(1)/
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        FABS MD;                        "DO /A(2)/
          DEC N
        ADD I,A; SETMA;                 "GET A(4)
          DPX<FA;                       "STORE /A(1)/ IN MAX
          FADD
        FABS MD;                        "DO /A(3)/
          DPY<FA                        "STORE /A(2)/
        ADD I,A; SETMA;                 "GET A(5)
          FSUB DPY,DPX;                 "COMPARE /A(2)/,MAX
          INCDPA                        "DPA=DPA+1
        FABS MD;                        "DO /A(4)/
          DPY<FA;                       "STORE /A(3)/
          DPX<DPX(-1);                  "MOVE UP MAX
          MOV N,INDEX
        ADD I,A; SETMA;                 "GET A(6)
          FSUB DPY,DPX;                 "COMPARE /A(3)/,MAX
          INCDPA                        "DPA=DPA+1
LOOP:   FABS MD;                        "DO /A(L+1)/
          DPY<FA;                       "STORE /A(L)/
          DPX<DPX(-1);                  "MOVE UP MAX
          BFGT TRADE;                   "TEST IF SHOULD HAVE CHANGED MAX
          DEC N
        ADD I,A; SETMA;                 "GET A(L+3)
          FSUB DPY,DPX;                 "COMPARE /A(L)/,MAX
          INCDPA;                      "DPA=DPA+1
          BNE LOOP                      "TEST IF DONE
"PROGRAM REACHES HERE WHEN THROUGH WITH ALL ELEMENTS
          BR DONE                       "GO STORE ANSWERS
"PROGRAM BRANCHES HERE WHEN SHOULD HAVE CHANGED MAX
TRADE:  DPX<DPY(-2)                     "PUT /A(L-2)/ IN MAX
        FSUB DPY(-1),DPX                "COMPARE /A(L-1)/,MAX
        FADD ZERO,FA;                   "/A(L+1)/ IN ADDER
          MOV N,INDEX;
          BR LOOP + 1
"PROGRAM BRANCHES HERE TO STORE ANSWERS
DONE:   SUB INDEX,NSAVE; DPX<SPFN       "COMPUTE INDEX,N,C
        LDSPI N; DB=27.                 "FLOAT INDEX
        FADD ZERO,MDPX; MOV N,N         "
        FADD; MOV C,C;SETMA; MI<DPX(-1) "STORE MAX
        INCMA; MI<FA; RETURN            "STORE FLOAT (INDEX)
        $END
"****** XMINMG = MINIMUM MAGNITUDE ELEMENT OF A VECTOR /COMMO= REL 3.0, MAR 80
        $TITLE XMINMG
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY XMINMG, 4
"SCAN FOR MIN ABS. VALUE
"               ---ABSTRACT---
"THIS SCANS FOR THE MINIMUM ABSOLUTE VALUE IN A VECTOR.  THE OUTPUT
"IS THE ABSOLUTE VALUE, NOT THE ACTUAL ELEMENT.  THE FIRST INDEX AT
"WHICH IT OCCURRED IS OUTPUTTED AS A FLOATING POINT VALUE ONE MEMORY
"LOCATION AFTER THE ANSWER, AND AS AN INTEGER IN SP(17).
"               ---STATISTICS---
"LANGUAGE:      AP ASSEMBLER
"EQUIPMENT:     AP WITH EITHER MEMORY
"SIZE:          22. LOCATIONS
"
"     ---HISTORY---
"ORIGINAL:  MAR 80  R.S. NORIN    THIS ROUTINE ADDED TO PRESERVE THE
"                                 FUNCTIONALITY OF THE ROUTINE MINMGV
"                                 DURING THE APR 79 - FEB 80 PERIOD.
"                                 ARRAY INDEX OF EXTREMUM IS STORED
"                                 AS FLOATING-POINT VALUE IN MD ADDR
"                                 C+1.
"
"               ---USAGE---
"S-PAD PARAMETERS:
"REGISTER #  MNEMONIC   MEANING
" 0             A       BASE ADDRESS OF VECTOR
" 1             I       INCREMENT FOR A
" 2             C       ADDRESS OF ANSWER
" 3             N       # OF ELEMENTS OF VECTOR A
"               ---SCRATCH---
"S-PAD:         0-4, 17
"DATA PAD:      DPX(0-31.), DPY(0-31.), DPA
"               ---ALGORITHM---
"THIS UTILIZES AN UNUSUAL 2-CYCLE LOOP WHICH ASSUMES THAT THE OLD
"MINIMUM WILL REMAIN THE MIN UNTIL PROVEN OTHERWISE, BY WHICH TIME
"DATA FOLLOWING WHAT SHOULD HAVE BEEN THE NEW MIN HAS ALREADY BEEN
"COMPARED WITH THE OLD MIN.  AT THIS POINT, THE PROGRAM BRANCHES TO
"TRADE, WHICH RE-INSTATES THE NEW MIN AND COMPARES THE ALREADY-COMPARED
"DATA FOLLOWING IT.  THEN IT GOES BACK TO  THE LOOP.
"S-PAD PARAMETERS:
A = 0
I = 1
C = 2
N = 3
"THE FOLLOWING ARE NOT PARAMETERS:
INDEX = 4
NSAVE = 17
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FXMNMG,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  12
        $PARAM  4 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3(2)/R/OP,
                    P4/I/IP
FXMNMG: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
XMINMG:   MOV A,A; SETMA                  "GET FIRST ELEMENT
        ADD I,A; SETMA                  "GET A(2)
        MOV N,NSAVE             "SAVE ELEMENT COUNT
        ADD I,A; SETMA;                 "GET A(3)
          FABS MD;                        "DO /A(1)/
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        FABS MD;                        "DO /A(2)/
          DEC N
        ADD I,A; SETMA;                 "GET A(4)
          DPX<FA;                       "STORE /A(1)/ IN MIN
          FADD
        FABS MD;                        "DO /A(3)/
          DPY<FA                        "STORE /A(2)/
        ADD I,A; SETMA;                 "GET A(5)
          FSUBR DPY,DPX;                "COMPARE /A(2)/,MIN
          INCDPA                        "DPA=DPA+1
        FABS MD;                        "DO /A(4)/
          DPY<FA;                       "STORE /A(3)/
          DPX<DPX(-1);                  "MOVE UP MAX
          MOV N,INDEX                   "SAVE COUNTER OF TRIAL MIN
        ADD I,A; SETMA;                 "GET A(6)
          FSUBR DPY,DPX;                "COMPARE /A(3)/,MIN
          INCDPA                        "DPA=DPA+1
LOOP:   FABS MD;                        "DO /A(L+1)/
          DPY<FA;                       "STORE /A(L)/
          DPX<DPX(-1);                  "MOVE UP MAX
          BFGT TRADE;                   "TEST IF SHOULD HAVE CHANGED MIN
          DEC N
        ADD I,A; SETMA;                 "GET A(L+3)
          FSUBR DPY,DPX;                "COMPARE /A(L)/,MIN
          INCDPA;                      "DPA=DPA+1
          BNE LOOP                      "TEST IF DONE
"PROGRAM REACHES HERE WHEN THROUGH WITH ALL ELEMENTS
          BR DONE                       "GO STORE ANSWERS
"PROGRAM BRANCHES HERE WHEN SHOULD HAVE CHANGED MIN
TRADE:  DPX<DPY(-2)                     "PUT /A(L-2)/ IN MIN
        FSUBR DPY(-1),DPX               "COMPARE /A(L-1)/,MIN
        FADD ZERO,FA;                   "/A(L+1)/ IN ADDER
          MOV N,INDEX;                  "SAVE COUNTER OF CURRENT MIN
          BR LOOP + 1
"PROGRAM BRANCHES HERE TO STORE ANSWERS
DONE:   SUB INDEX,NSAVE; DPX<SPFN       "COMPUTE INDEX,N,C
        LDSPI N; DB=27.                 "FLOAT INDEX
        FADD ZERO,MDPX; MOV N,N         "
        FADD; MOV C,C;SETMA; MI<DPX(-1) "STORE MIN
        INCMA; MI<FA; RETURN            "STORE FLOAT (INDEX)
        $END
$ENDLIB
 