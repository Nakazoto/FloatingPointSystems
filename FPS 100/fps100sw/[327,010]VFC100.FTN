C+++     VFC
C****** VFC100 = VECTOR FUNCTION CHAINER = REL.  1.00 , 09/01/79
C
C       UPDATED FEB. 22, 1979 BY MONIKA HUNSCHER
C
C
C****** VFC100 = VFC100 MAINLINE = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF VFC WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:23:15
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
C       THIS PROGRAM CREATES A VECTOR FUNCTION CHAIN (VFC) MADE FROM ANY
C       NUMBER OF VECTOR FUNCTIONS CALLS, SCALER FUNCTIONS AND BRANCHES.
C       INPUT TO THE PROGRAM IS OF THE FORM:
C               DEFINE VFC(P1,P2,...,P13)
C               LOCAL L1,L2,...,LN
C        T1:    CALL VFCN(XI,XJ,...,X13)
C        T2:    VI=XJ
C        T3:    VI=XJ+XK
C        T4:    VI=XJ-XK
C        T5:    VI=XJ*XK
C        T6:    VI=XJ/XK
C        T7:    GOTO TI
C        T8:    IF XI < XJ GOTO TI
C        T9:    IF XI <= XJ GOTO TI
C        T10:   IF XI = XJ GOTO TI
C        T11:   IF XI <> XJ GOTO TI
C        T12:   IF XI >= XJ GOTO TI
C        T13:   IF XI > XJ GOTO TI
C        TN:    END
C
C               VFC IS THE VECTOR FUNCTION CHAIN NAME.
C               P1... ARE SYMBOLIC NAMES FOR UP TO 13 INITIAL SPAD VALUES.
C               L1... ARE SYMBOLIC NAMES FOR ANY NUMBER OF LOCAL VARIABLES.
C               XI... ARE INITIAL OR LOCAL VARIABLES OR CONSTANTS.
C               VI... ARE INITIAL OR LOCAL VARIABLES.
C               T1... ARE ANY NUMBER OF TAGS (STATEMENT LABELS).
C
C       THE SYMBOLS (VARIABLES AND LABELS) USED IN A VFC PROGRAM ARE FORTRAN
C       -LIKE NAMES (UP TO 6 A.N CHARACTERS WITH A LEADING ALPHABETIC).
C       PARAMETERS USED IN FUNCTION CALLS MUST BE DEFINED VARIABLES OR
C       INTEGER CONSTANTS WITH BASE 10.  NOTE: VARIABLES (PARAMETERS) ARE NOT
C       REDIFINED  DURING CALL STATEMENTS.
C
C       PROGRAMS ARE INPUT FROM THE SOURCE FILE AND MAY CONTAIN ANY NUMBER OF
C       VFC DEFINITIONS - SEPARATING EACH DEFINITION BY AN 'END' STATEMENT.
C
C       THE OUTPUT OF THE PROGRAM IS AN APAL PROGRAM WHICH EXECUTES ALL CALLED
C       VECTOR FUNCTIONS AFTER INSERTING THE PROPER VALUES INTO THE PROPER
C       S-PAD REGISTERS.
C       THE PROGRAM ALWAYS USES EXTERNAL PROGRAM SAVESP.
C       THE PROGRAM MAY ALSO USE SETSP AND SAVSP0.
C
C       A DEFINE STATEMENT IS BROKEN DOWN TO TITLE AND ENTRY STATEMENTS
C       AND 1 EXECUTABLE STATEMENT: A CALL TO SAVESP ON ENTRY TO THE PROGRAM.
C       THE LINE AFTER THE SAVESP COMMAND CONTAINS THE PARAMETERS: NUMBER OF
C       S-PADS TO SAVE AND THE ADDRESS TO WHICH THEY SHOULD BE SAVED.
C
C       A LOCAL STATEMENT PRODUCES NO EXECUTABLE CODE AND IS ONLY USED TO
C       ALLOCATE PROGRAM SOURCE WORDS FOR VARIABLE STORAGE.
C
C       HALF A PROGRAM SOURCE WORD IS ALLOCATED FOR THE VALUE OF EACH
C       DEFINITION OR LOCAL VARIABLE.
C
C       A CALL STATEMENT PRODUCES AN EXTERNAL STATEMENT, A SETSP COMMAND,
C       SETSP PARAMETERS, A JSR FLUSH TO CLEAR THE ADDER AND
C       MULTIPLIER PIPELINES, AND A JSR TO THE APPROPIATE ROUTINE. THE
C       SETSP COMMAND IS USED ONLY IF THERE ARE S-PAD PARAMETERS.
C       THE SETSP PARAMETERS ARE: A COUNT OF PARAMETERS FOLLOWED
C       BY THE ADDRESS OF EACH VARIABLE PARAMETER OR THE VALUE OF
C       CONSTANT PARAMETERS.
C
C       A SCALER FUNCTION IS REPLACED BY: A SETSP AND ITS PARAMETERS, A CALL
C       TO THE PROPER S-PAD FUNCTION (UNARY OR BINARY OPERATOR FUNCTION), AND
C       A SAVSP0 CALL WITH ITS PARAMETERS.  THE SETSP PARAMETERS ARE THE SAME
C       AS FOR CALL STATEMENTS, IE PARAMETER COUNT IN THE LEFT HALF OF THE
C       PS WORD AND EACH PARAMETER LOCATION OR VALUE IN SUBSEQUENT HALF WORDS.
C       THE PARAMETERS TO SAVE S-PAD 0 TO A PROGRAM SOURCE LOCATION IMMEDIATELY
C       FOLLOWS A JSR TO SAVSP0 IS THE PS LOCATION IN THE RIGHT HAND HALF WORD.
C
C       CONDITIONAL STATEMENTS ARE REPLACED BY A CALL TO SETSP WITH THE
C       2 PARAMETERS, A JSR TO SPSUB, A CONDITIONAL BRANCH TO .+2 ON THE
C       OPOSITE CONDITION AND AN UNCONDITIONAL BRANCH TO THE USER LABEL.
C
C       A GOTO STATEMENT PRODUCES A JMP TO THE USER LABEL.
C
C       AN END STATEMENT PRODUCES A NOP AND A RETURN.
C
C       A TEMPORARY FILE IS USED BY THE PROGRAM WHILE PROCESSING AS A SCRATCH
C       FILE AND DELETED AFTER USE. THE TEMPORARY FILE CONTAINS ALL EXECUTABLE
C       STATEMENTS.
C INIT
C               NOTE:LETTERS (INTEGERS) AND LISTS BEGIN WITH THE CHARACTER L
C               NOTE:STRINGS (VARIABLE ARRAYS) BEGIN WITH THE CHARACTER S
C               NOTE:VALUES (INTEGER VARIABLES) BEGIN WITH THE CHARACTER V
C
      INTEGER CHR,CMPSS,CNDO,CTOK,DUMMY,ERRCNT,IDX(2),EXTTOK
      INTEGER EXTCL,EXTCS,EXTSL,EXTSS,FCNO
      INTEGER FEOS,RMVTOK
      INTEGER I,IBLE,IERR,INFILE
      INTEGER INSPAD,IT,ITS,IUSERC,L
        INTEGER LEN,LENL,LENS
      INTEGER LV,MTSP0,MTSP1,PAR
        INTEGER VTTY,SFNO,OFNO,TFNO
        INTEGER MIN0,MOD
      INTEGER PARS,PSAV,PTYPE,RDLIN,RORL
      INTEGER SPCNT,SPNN,SRCCS,SRCSL,SRCSS
        INTEGER TYPC,UTAGNO
        INTEGER VL,LN
        INTEGER SF(81),OF(81),TOK(8),OPL(81),TOKS(81),TOPL(81),TF(81)
     C,FCN(7),LCALLP(99),TBUF(81),LDEFP(999),LCALLF(999),LH(82)
     C,SLEN(3),FCHNAM(7),TAG(8),LTAGUS(499),LTAGDF(499),CND(7)
        INTEGER VFIRST,VEND,VALPH,VNUM,VBEG,VALL,VEQ,LEOS
        INTEGER VR,VW,VRW,VCLOSE,VDEL,VREW,VSCR
        INTEGER EOF,DQUOTE,LPAREN,COMMA,RPAREN,COLON,V,EXCLAM
        INTEGER DASH,PERIOD,C,S,ZERO,ONE,TWO,PLUS,EQUAL,P
        INTEGER BLANK,T,SEMICO
        LOGICAL FSAVE,GETTAG,FCOND,FUOP,FSETU,FSAV0U,FSP,FSET2U
        LOGICAL FCALL,FFLUSH,FCOMMA
C
C                                                                       STARTPRE
      INTEGER SSORF(15),SOBJF(15),SDTIT(8),SDEXT(6),
     XSDENT(8),SDVAL(6),SDEND(5),SEND(4),SSET(6),SSET2(7),SSAV(7),
     XSSAV0(7),SDEF(7),SCALL(5),SJSR(5),SJMP(5),SJSRST(10),SNOP(4),
     XSRETRN(7),SPMD(7),SDP2(5),SPMPPL(5),S4S0C(8),S2SC0(5),SLEQ(9),
     XSREQ(12),SVEQ(9),SCEQ(12),UNEXPC(21),ILLPRM(18),DBLDEF(24),
     XDBLDFT(27),ILFNAM(22),ILOPDF(35),ILOPCL(33),UNDEFV(17),
     XUNDFFN(26),ILLLBL(21),UNDEFT(14),EXTRA(33),GOTORQ(15),SERRS(7),
     XSRL(3),SLOCAL(6),SIF(3),SSPSUB(6),SGOTO(5),SVPLUS(3),SBLE(5),
     XSBEQ(5),SMOV(5),SFLUSH(6),LFNSYM(22),LFNNAM(46),LUOPSY(7),
     XLUOPNM(13),LCNDSY(16),LCNDFN(25)
        COMMON /MTC/ LDEFP,LCALLF,LTAGUS,LTAGDF
C STRNG SSORF " SOURCE FILE ="
      DATA SSORF(2)/'  '/,SSORF(3)/'S '/,SSORF(4)/'O '/,SSORF(5)/'U '/
      DATA SSORF(6)/'R '/,SSORF(7)/'C '/,SSORF(8)/'E '/,SSORF(9)/'  '/
      DATA SSORF(10)/'F '/,SSORF(11)/'I '/,SSORF(12)/'L '/
      DATA SSORF(13)/'E '/,SSORF(14)/'  '/,SSORF(15)/'= '/
      DATA SSORF(1)/14/
C STRNG SOBJF " OBJECT FILE ="
      DATA SOBJF(2)/'  '/,SOBJF(3)/'O '/,SOBJF(4)/'B '/,SOBJF(5)/'J '/
      DATA SOBJF(6)/'E '/,SOBJF(7)/'C '/,SOBJF(8)/'T '/,SOBJF(9)/'  '/
      DATA SOBJF(10)/'F '/,SOBJF(11)/'I '/,SOBJF(12)/'L '/
      DATA SOBJF(13)/'E '/,SOBJF(14)/'  '/,SOBJF(15)/'= '/
      DATA SOBJF(1)/14/
C STRNG SDTIT "$TITLE "
      DATA SDTIT(2)/'$ '/,SDTIT(3)/'T '/,SDTIT(4)/'I '/,SDTIT(5)/'T '/
      DATA SDTIT(6)/'L '/,SDTIT(7)/'E '/,SDTIT(8)/'  '/
      DATA SDTIT(1)/7/
C STRNG SDEXT "$EXT "
      DATA SDEXT(2)/'$ '/,SDEXT(3)/'E '/,SDEXT(4)/'X '/,SDEXT(5)/'T '/
      DATA SDEXT(6)/'  '/
      DATA SDEXT(1)/5/
C STRNG SDENT "$ENTRY "
      DATA SDENT(2)/'$ '/,SDENT(3)/'E '/,SDENT(4)/'N '/,SDENT(5)/'T '/
      DATA SDENT(6)/'R '/,SDENT(7)/'Y '/,SDENT(8)/'  '/
      DATA SDENT(1)/7/
C STRNG SDVAL "$VAL "
      DATA SDVAL(2)/'$ '/,SDVAL(3)/'V '/,SDVAL(4)/'A '/,SDVAL(5)/'L '/
      DATA SDVAL(6)/'  '/
      DATA SDVAL(1)/5/
C STRNG SDEND "$END"
      DATA SDEND(2)/'$ '/,SDEND(3)/'E '/,SDEND(4)/'N '/,SDEND(5)/'D '/
      DATA SDEND(1)/4/
C STRNG SEND "END"
      DATA SEND(2)/'E '/,SEND(3)/'N '/,SEND(4)/'D '/
      DATA SEND(1)/3/
C STRNG SSET "SETSP"
      DATA SSET(2)/'S '/,SSET(3)/'E '/,SSET(4)/'T '/,SSET(5)/'S '/
      DATA SSET(6)/'P '/
      DATA SSET(1)/5/
C STRNG SSET2 "SET2SP"
      DATA SSET2(2)/'S '/,SSET2(3)/'E '/,SSET2(4)/'T '/,SSET2(5)/'2 '/
      DATA SSET2(6)/'S '/,SSET2(7)/'P '/
      DATA SSET2(1)/6/
C STRNG SSAV "SAVESP"
      DATA SSAV(2)/'S '/,SSAV(3)/'A '/,SSAV(4)/'V '/,SSAV(5)/'E '/
      DATA SSAV(6)/'S '/,SSAV(7)/'P '/
      DATA SSAV(1)/6/
C STRNG SSAV0 "SAVSP0"
      DATA SSAV0(2)/'S '/,SSAV0(3)/'A '/,SSAV0(4)/'V '/,SSAV0(5)/'S '/
      DATA SSAV0(6)/'P '/,SSAV0(7)/'0 '/
      DATA SSAV0(1)/6/
C STRNG SDEF "DEFINE"
      DATA SDEF(2)/'D '/,SDEF(3)/'E '/,SDEF(4)/'F '/,SDEF(5)/'I '/
      DATA SDEF(6)/'N '/,SDEF(7)/'E '/
      DATA SDEF(1)/6/
C STRNG SCALL "CALL"
      DATA SCALL(2)/'C '/,SCALL(3)/'A '/,SCALL(4)/'L '/,SCALL(5)/'L '/
      DATA SCALL(1)/4/
C STRNG SJSR "JSR "
      DATA SJSR(2)/'J '/,SJSR(3)/'S '/,SJSR(4)/'R '/,SJSR(5)/'  '/
      DATA SJSR(1)/4/
C STRNG SJMP "JMP "
      DATA SJMP(2)/'J '/,SJMP(3)/'M '/,SJMP(4)/'P '/,SJMP(5)/'  '/
      DATA SJMP(1)/4/
C STRNG SJSRST "JSR SETSP"
      DATA SJSRST(2)/'J '/,SJSRST(3)/'S '/,SJSRST(4)/'R '/
      DATA SJSRST(5)/'  '/,SJSRST(6)/'S '/,SJSRST(7)/'E '/
      DATA SJSRST(8)/'T '/,SJSRST(9)/'S '/,SJSRST(10)/'P '/
      DATA SJSRST(1)/9/
C STRNG SNOP "NOP"
      DATA SNOP(2)/'N '/,SNOP(3)/'O '/,SNOP(4)/'P '/
      DATA SNOP(1)/3/
C STRNG SRETRN "RETURN"
      DATA SRETRN(2)/'R '/,SRETRN(3)/'E '/,SRETRN(4)/'T '/
      DATA SRETRN(5)/'U '/,SRETRN(6)/'R '/,SRETRN(7)/'N '/
      DATA SRETRN(1)/6/
C STRNG SPMD ",0,P-."
      DATA SPMD(2)/', '/,SPMD(3)/'0 '/,SPMD(4)/', '/,SPMD(5)/'P '/
      DATA SPMD(6)/'- '/,SPMD(7)/'. '/
      DATA SPMD(1)/6/
C STRNG SDP2 " .+2"
      DATA SDP2(2)/'  '/,SDP2(3)/'. '/,SDP2(4)/'+ '/,SDP2(5)/'2 '/
      DATA SDP2(1)/4/
C STRNG SPMPPL "P-.+"
      DATA SPMPPL(2)/'P '/,SPMPPL(3)/'- '/,SPMPPL(4)/'. '/
      DATA SPMPPL(5)/'+ '/
      DATA SPMPPL(1)/4/
C STRNG S4S0C "0,0,0,0"
      DATA S4S0C(2)/'0 '/,S4S0C(3)/', '/,S4S0C(4)/'0 '/,S4S0C(5)/', '/
      DATA S4S0C(6)/'0 '/,S4S0C(7)/', '/,S4S0C(8)/'0 '/
      DATA S4S0C(1)/7/
C STRNG S2SC0 ",0,0"
      DATA S2SC0(2)/', '/,S2SC0(3)/'0 '/,S2SC0(4)/', '/,S2SC0(5)/'0 '/
      DATA S2SC0(1)/4/
C STRNG SLEQ "L $EQU 0"
      DATA SLEQ(2)/'L '/,SLEQ(3)/'  '/,SLEQ(4)/'$ '/,SLEQ(5)/'E '/
      DATA SLEQ(6)/'Q '/,SLEQ(7)/'U '/,SLEQ(8)/'  '/,SLEQ(9)/'0 '/
      DATA SLEQ(1)/8/
C STRNG SREQ "R $EQU 2000"
      DATA SREQ(2)/'R '/,SREQ(3)/'  '/,SREQ(4)/'$ '/,SREQ(5)/'E '/
      DATA SREQ(6)/'Q '/,SREQ(7)/'U '/,SREQ(8)/'  '/,SREQ(9)/'2 '/
      DATA SREQ(10)/'0 '/,SREQ(11)/'0 '/,SREQ(12)/'0 '/
      DATA SREQ(1)/11/
C STRNG SVEQ "V $EQU 0"
      DATA SVEQ(2)/'V '/,SVEQ(3)/'  '/,SVEQ(4)/'$ '/,SVEQ(5)/'E '/
      DATA SVEQ(6)/'Q '/,SVEQ(7)/'U '/,SVEQ(8)/'  '/,SVEQ(9)/'0 '/
      DATA SVEQ(1)/8/
C STRNG SCEQ "C $EQU 4000"
      DATA SCEQ(2)/'C '/,SCEQ(3)/'  '/,SCEQ(4)/'$ '/,SCEQ(5)/'E '/
      DATA SCEQ(6)/'Q '/,SCEQ(7)/'U '/,SCEQ(8)/'  '/,SCEQ(9)/'4 '/
      DATA SCEQ(10)/'0 '/,SCEQ(11)/'0 '/,SCEQ(12)/'0 '/
      DATA SCEQ(1)/11/
C STRNG UNEXPC "UNEXPECTED CHARACTER"
      DATA UNEXPC(2)/'U '/,UNEXPC(3)/'N '/,UNEXPC(4)/'E '/
      DATA UNEXPC(5)/'X '/,UNEXPC(6)/'P '/,UNEXPC(7)/'E '/
      DATA UNEXPC(8)/'C '/,UNEXPC(9)/'T '/,UNEXPC(10)/'E '/
      DATA UNEXPC(11)/'D '/,UNEXPC(12)/'  '/,UNEXPC(13)/'C '/
      DATA UNEXPC(14)/'H '/,UNEXPC(15)/'A '/,UNEXPC(16)/'R '/
      DATA UNEXPC(17)/'A '/,UNEXPC(18)/'C '/,UNEXPC(19)/'T '/
      DATA UNEXPC(20)/'E '/,UNEXPC(21)/'R '/
      DATA UNEXPC(1)/20/
C STRNG ILLPRM "ILLEGAL PARAMETER"
      DATA ILLPRM(2)/'I '/,ILLPRM(3)/'L '/,ILLPRM(4)/'L '/
      DATA ILLPRM(5)/'E '/,ILLPRM(6)/'G '/,ILLPRM(7)/'A '/
      DATA ILLPRM(8)/'L '/,ILLPRM(9)/'  '/,ILLPRM(10)/'P '/
      DATA ILLPRM(11)/'A '/,ILLPRM(12)/'R '/,ILLPRM(13)/'A '/
      DATA ILLPRM(14)/'M '/,ILLPRM(15)/'E '/,ILLPRM(16)/'T '/
      DATA ILLPRM(17)/'E '/,ILLPRM(18)/'R '/
      DATA ILLPRM(1)/17/
C STRNG DBLDEF "DOUBLE DEFINITION OF VF"
      DATA DBLDEF(2)/'D '/,DBLDEF(3)/'O '/,DBLDEF(4)/'U '/
      DATA DBLDEF(5)/'B '/,DBLDEF(6)/'L '/,DBLDEF(7)/'E '/
      DATA DBLDEF(8)/'  '/,DBLDEF(9)/'D '/,DBLDEF(10)/'E '/
      DATA DBLDEF(11)/'F '/,DBLDEF(12)/'I '/,DBLDEF(13)/'N '/
      DATA DBLDEF(14)/'I '/,DBLDEF(15)/'T '/,DBLDEF(16)/'I '/
      DATA DBLDEF(17)/'O '/,DBLDEF(18)/'N '/,DBLDEF(19)/'  '/
      DATA DBLDEF(20)/'O '/,DBLDEF(21)/'F '/,DBLDEF(22)/'  '/
      DATA DBLDEF(23)/'V '/,DBLDEF(24)/'F '/
      DATA DBLDEF(1)/23/
C STRNG DBLDFT "DOUBLE DEFINITION OF LABEL"
      DATA DBLDFT(2)/'D '/,DBLDFT(3)/'O '/,DBLDFT(4)/'U '/
      DATA DBLDFT(5)/'B '/,DBLDFT(6)/'L '/,DBLDFT(7)/'E '/
      DATA DBLDFT(8)/'  '/,DBLDFT(9)/'D '/,DBLDFT(10)/'E '/
      DATA DBLDFT(11)/'F '/,DBLDFT(12)/'I '/,DBLDFT(13)/'N '/
      DATA DBLDFT(14)/'I '/,DBLDFT(15)/'T '/,DBLDFT(16)/'I '/
      DATA DBLDFT(17)/'O '/,DBLDFT(18)/'N '/,DBLDFT(19)/'  '/
      DATA DBLDFT(20)/'O '/,DBLDFT(21)/'F '/,DBLDFT(22)/'  '/
      DATA DBLDFT(23)/'L '/,DBLDFT(24)/'A '/,DBLDFT(25)/'B '/
      DATA DBLDFT(26)/'E '/,DBLDFT(27)/'L '/
      DATA DBLDFT(1)/26/
C STRNG ILFNAM "ILLEGAL FUNCTION NAME"
      DATA ILFNAM(2)/'I '/,ILFNAM(3)/'L '/,ILFNAM(4)/'L '/
      DATA ILFNAM(5)/'E '/,ILFNAM(6)/'G '/,ILFNAM(7)/'A '/
      DATA ILFNAM(8)/'L '/,ILFNAM(9)/'  '/,ILFNAM(10)/'F '/
      DATA ILFNAM(11)/'U '/,ILFNAM(12)/'N '/,ILFNAM(13)/'C '/
      DATA ILFNAM(14)/'T '/,ILFNAM(15)/'I '/,ILFNAM(16)/'O '/
      DATA ILFNAM(17)/'N '/,ILFNAM(18)/'  '/,ILFNAM(19)/'N '/
      DATA ILFNAM(20)/'A '/,ILFNAM(21)/'M '/,ILFNAM(22)/'E '/
      DATA ILFNAM(1)/21/
C STRNG ILOPDF "ILLEGAL OPERATION - DEFINE ASSUMED"
      DATA ILOPDF(2)/'I '/,ILOPDF(3)/'L '/,ILOPDF(4)/'L '/
      DATA ILOPDF(5)/'E '/,ILOPDF(6)/'G '/,ILOPDF(7)/'A '/
      DATA ILOPDF(8)/'L '/,ILOPDF(9)/'  '/,ILOPDF(10)/'O '/
      DATA ILOPDF(11)/'P '/,ILOPDF(12)/'E '/,ILOPDF(13)/'R '/
      DATA ILOPDF(14)/'A '/,ILOPDF(15)/'T '/,ILOPDF(16)/'I '/
      DATA ILOPDF(17)/'O '/,ILOPDF(18)/'N '/,ILOPDF(19)/'  '/
      DATA ILOPDF(20)/'- '/,ILOPDF(21)/'  '/,ILOPDF(22)/'D '/
      DATA ILOPDF(23)/'E '/,ILOPDF(24)/'F '/,ILOPDF(25)/'I '/
      DATA ILOPDF(26)/'N '/,ILOPDF(27)/'E '/,ILOPDF(28)/'  '/
      DATA ILOPDF(29)/'A '/,ILOPDF(30)/'S '/,ILOPDF(31)/'S '/
      DATA ILOPDF(32)/'U '/,ILOPDF(33)/'M '/,ILOPDF(34)/'E '/
      DATA ILOPDF(35)/'D '/
      DATA ILOPDF(1)/34/
C STRNG ILOPCL "ILLEGAL OPERATION - CALL ASSUMED"
      DATA ILOPCL(2)/'I '/,ILOPCL(3)/'L '/,ILOPCL(4)/'L '/
      DATA ILOPCL(5)/'E '/,ILOPCL(6)/'G '/,ILOPCL(7)/'A '/
      DATA ILOPCL(8)/'L '/,ILOPCL(9)/'  '/,ILOPCL(10)/'O '/
      DATA ILOPCL(11)/'P '/,ILOPCL(12)/'E '/,ILOPCL(13)/'R '/
      DATA ILOPCL(14)/'A '/,ILOPCL(15)/'T '/,ILOPCL(16)/'I '/
      DATA ILOPCL(17)/'O '/,ILOPCL(18)/'N '/,ILOPCL(19)/'  '/
      DATA ILOPCL(20)/'- '/,ILOPCL(21)/'  '/,ILOPCL(22)/'C '/
      DATA ILOPCL(23)/'A '/,ILOPCL(24)/'L '/,ILOPCL(25)/'L '/
      DATA ILOPCL(26)/'  '/,ILOPCL(27)/'A '/,ILOPCL(28)/'S '/
      DATA ILOPCL(29)/'S '/,ILOPCL(30)/'U '/,ILOPCL(31)/'M '/
      DATA ILOPCL(32)/'E '/,ILOPCL(33)/'D '/
      DATA ILOPCL(1)/32/
C STRNG UNDEFV "UNDEFINED SYMBOL"
      DATA UNDEFV(2)/'U '/,UNDEFV(3)/'N '/,UNDEFV(4)/'D '/
      DATA UNDEFV(5)/'E '/,UNDEFV(6)/'F '/,UNDEFV(7)/'I '/
      DATA UNDEFV(8)/'N '/,UNDEFV(9)/'E '/,UNDEFV(10)/'D '/
      DATA UNDEFV(11)/'  '/,UNDEFV(12)/'S '/,UNDEFV(13)/'Y '/
      DATA UNDEFV(14)/'M '/,UNDEFV(15)/'B '/,UNDEFV(16)/'O '/
      DATA UNDEFV(17)/'L '/
      DATA UNDEFV(1)/16/
C STRNG UNDFFN "UNDEFINED FUNCTION SYMBOL"
      DATA UNDFFN(2)/'U '/,UNDFFN(3)/'N '/,UNDFFN(4)/'D '/
      DATA UNDFFN(5)/'E '/,UNDFFN(6)/'F '/,UNDFFN(7)/'I '/
      DATA UNDFFN(8)/'N '/,UNDFFN(9)/'E '/,UNDFFN(10)/'D '/
      DATA UNDFFN(11)/'  '/,UNDFFN(12)/'F '/,UNDFFN(13)/'U '/
      DATA UNDFFN(14)/'N '/,UNDFFN(15)/'C '/,UNDFFN(16)/'T '/
      DATA UNDFFN(17)/'I '/,UNDFFN(18)/'O '/,UNDFFN(19)/'N '/
      DATA UNDFFN(20)/'  '/,UNDFFN(21)/'S '/,UNDFFN(22)/'Y '/
      DATA UNDFFN(23)/'M '/,UNDFFN(24)/'B '/,UNDFFN(25)/'O '/
      DATA UNDFFN(26)/'L '/
      DATA UNDFFN(1)/25/
C STRNG ILLLBL "ILLEGAL LABEL SYMBOL"
      DATA ILLLBL(2)/'I '/,ILLLBL(3)/'L '/,ILLLBL(4)/'L '/
      DATA ILLLBL(5)/'E '/,ILLLBL(6)/'G '/,ILLLBL(7)/'A '/
      DATA ILLLBL(8)/'L '/,ILLLBL(9)/'  '/,ILLLBL(10)/'L '/
      DATA ILLLBL(11)/'A '/,ILLLBL(12)/'B '/,ILLLBL(13)/'E '/
      DATA ILLLBL(14)/'L '/,ILLLBL(15)/'  '/,ILLLBL(16)/'S '/
      DATA ILLLBL(17)/'Y '/,ILLLBL(18)/'M '/,ILLLBL(19)/'B '/
      DATA ILLLBL(20)/'O '/,ILLLBL(21)/'L '/
      DATA ILLLBL(1)/20/
C STRNG UNDEFT "UNDEFINED TAG"
      DATA UNDEFT(2)/'U '/,UNDEFT(3)/'N '/,UNDEFT(4)/'D '/
      DATA UNDEFT(5)/'E '/,UNDEFT(6)/'F '/,UNDEFT(7)/'I '/
      DATA UNDEFT(8)/'N '/,UNDEFT(9)/'E '/,UNDEFT(10)/'D '/
      DATA UNDEFT(11)/'  '/,UNDEFT(12)/'T '/,UNDEFT(13)/'A '/
      DATA UNDEFT(14)/'G '/
      DATA UNDEFT(1)/13/
C STRNG EXTRA "CHARACTERS PAST END OF STATEMENT"
      DATA EXTRA(2)/'C '/,EXTRA(3)/'H '/,EXTRA(4)/'A '/,EXTRA(5)/'R '/
      DATA EXTRA(6)/'A '/,EXTRA(7)/'C '/,EXTRA(8)/'T '/,EXTRA(9)/'E '/
      DATA EXTRA(10)/'R '/,EXTRA(11)/'S '/,EXTRA(12)/'  '/
      DATA EXTRA(13)/'P '/,EXTRA(14)/'A '/,EXTRA(15)/'S '/
      DATA EXTRA(16)/'T '/,EXTRA(17)/'  '/,EXTRA(18)/'E '/
      DATA EXTRA(19)/'N '/,EXTRA(20)/'D '/,EXTRA(21)/'  '/
      DATA EXTRA(22)/'O '/,EXTRA(23)/'F '/,EXTRA(24)/'  '/
      DATA EXTRA(25)/'S '/,EXTRA(26)/'T '/,EXTRA(27)/'A '/
      DATA EXTRA(28)/'T '/,EXTRA(29)/'E '/,EXTRA(30)/'M '/
      DATA EXTRA(31)/'E '/,EXTRA(32)/'N '/,EXTRA(33)/'T '/
      DATA EXTRA(1)/32/
C STRNG GOTORQ "GO TO REQUIRED"
      DATA GOTORQ(2)/'G '/,GOTORQ(3)/'O '/,GOTORQ(4)/'  '/
      DATA GOTORQ(5)/'T '/,GOTORQ(6)/'O '/,GOTORQ(7)/'  '/
      DATA GOTORQ(8)/'R '/,GOTORQ(9)/'E '/,GOTORQ(10)/'Q '/
      DATA GOTORQ(11)/'U '/,GOTORQ(12)/'I '/,GOTORQ(13)/'R '/
      DATA GOTORQ(14)/'E '/,GOTORQ(15)/'D '/
      DATA GOTORQ(1)/14/
C STRNG SERRS "ERRORS"
      DATA SERRS(2)/'E '/,SERRS(3)/'R '/,SERRS(4)/'R '/,SERRS(5)/'O '/
      DATA SERRS(6)/'R '/,SERRS(7)/'S '/
      DATA SERRS(1)/6/
C STRNG SRL "RL"
      DATA SRL(2)/'R '/,SRL(3)/'L '/
      DATA SRL(1)/2/
C STRNG SLOCAL "LOCAL"
      DATA SLOCAL(2)/'L '/,SLOCAL(3)/'O '/,SLOCAL(4)/'C '/
      DATA SLOCAL(5)/'A '/,SLOCAL(6)/'L '/
      DATA SLOCAL(1)/5/
C STRNG SIF "IF"
      DATA SIF(2)/'I '/,SIF(3)/'F '/
      DATA SIF(1)/2/
C STRNG SSPSUB "SPSUB"
      DATA SSPSUB(2)/'S '/,SSPSUB(3)/'P '/,SSPSUB(4)/'S '/
      DATA SSPSUB(5)/'U '/,SSPSUB(6)/'B '/
      DATA SSPSUB(1)/5/
C STRNG SGOTO "GOTO"
      DATA SGOTO(2)/'G '/,SGOTO(3)/'O '/,SGOTO(4)/'T '/,SGOTO(5)/'O '/
      DATA SGOTO(1)/4/
C STRNG SVPLUS "V+"
      DATA SVPLUS(2)/'V '/,SVPLUS(3)/'+ '/
      DATA SVPLUS(1)/2/
C STRNG SBLE "BLE "
      DATA SBLE(2)/'B '/,SBLE(3)/'L '/,SBLE(4)/'E '/,SBLE(5)/'  '/
      DATA SBLE(1)/4/
C STRNG SBEQ "BEQ "
      DATA SBEQ(2)/'B '/,SBEQ(3)/'E '/,SBEQ(4)/'Q '/,SBEQ(5)/'  '/
      DATA SBEQ(1)/4/
C STRNG SMOV "MOV "
      DATA SMOV(2)/'M '/,SMOV(3)/'O '/,SMOV(4)/'V '/,SMOV(5)/'  '/
      DATA SMOV(1)/4/
C STRNG SFLUSH "FLUSH"
      DATA SFLUSH(2)/'F '/,SFLUSH(3)/'L '/,SFLUSH(4)/'U '/
      DATA SFLUSH(5)/'S '/,SFLUSH(6)/'H '/
      DATA SFLUSH(1)/5/
C LIST LFNSYM "+"
      DATA LFNSYM(3)/'+ '/
      DATA LFNSYM(2)/1/
C     "-"
      DATA LFNSYM(5)/'- '/
      DATA LFNSYM(4)/1/
C     "*"
      DATA LFNSYM(7)/'* '/
      DATA LFNSYM(6)/1/
C     "/"
      DATA LFNSYM(9)/'/ '/
      DATA LFNSYM(8)/1/
C     "RS"
      DATA LFNSYM(11)/'R '/,LFNSYM(12)/'S '/
      DATA LFNSYM(10)/2/
C     "LS"
      DATA LFNSYM(14)/'L '/,LFNSYM(15)/'S '/
      DATA LFNSYM(13)/2/
C     "AND"
      DATA LFNSYM(17)/'A '/,LFNSYM(18)/'N '/,LFNSYM(19)/'D '/
      DATA LFNSYM(16)/3/
C     "OR"
      DATA LFNSYM(21)/'O '/,LFNSYM(22)/'R '/
      DATA LFNSYM(20)/2/,LFNSYM(1)/8/
C LIST LFNNAM "SPADD"
      DATA LFNNAM(3)/'S '/,LFNNAM(4)/'P '/,LFNNAM(5)/'A '/
      DATA LFNNAM(6)/'D '/,LFNNAM(7)/'D '/
      DATA LFNNAM(2)/5/
C     "SPSUB"
      DATA LFNNAM(9)/'S '/,LFNNAM(10)/'P '/,LFNNAM(11)/'S '/
      DATA LFNNAM(12)/'U '/,LFNNAM(13)/'B '/
      DATA LFNNAM(8)/5/
C     "SPMUL"
      DATA LFNNAM(15)/'S '/,LFNNAM(16)/'P '/,LFNNAM(17)/'M '/
      DATA LFNNAM(18)/'U '/,LFNNAM(19)/'L '/
      DATA LFNNAM(14)/5/
C     "SPDIV"
      DATA LFNNAM(21)/'S '/,LFNNAM(22)/'P '/,LFNNAM(23)/'D '/
      DATA LFNNAM(24)/'I '/,LFNNAM(25)/'V '/
      DATA LFNNAM(20)/5/
C     "SPRS"
      DATA LFNNAM(27)/'S '/,LFNNAM(28)/'P '/,LFNNAM(29)/'R '/
      DATA LFNNAM(30)/'S '/
      DATA LFNNAM(26)/4/
C     "SPLS"
      DATA LFNNAM(32)/'S '/,LFNNAM(33)/'P '/,LFNNAM(34)/'L '/
      DATA LFNNAM(35)/'S '/
      DATA LFNNAM(31)/4/
C     "SPAND"
      DATA LFNNAM(37)/'S '/,LFNNAM(38)/'P '/,LFNNAM(39)/'A '/
      DATA LFNNAM(40)/'N '/,LFNNAM(41)/'D '/
      DATA LFNNAM(36)/5/
C     "SPOR"
      DATA LFNNAM(43)/'S '/,LFNNAM(44)/'P '/,LFNNAM(45)/'O '/
      DATA LFNNAM(46)/'R '/
      DATA LFNNAM(42)/4/,LFNNAM(1)/8/
C LIST LUOPSY "-"
      DATA LUOPSY(3)/'- '/
      DATA LUOPSY(2)/1/
C     "NOT"
      DATA LUOPSY(5)/'N '/,LUOPSY(6)/'O '/,LUOPSY(7)/'T '/
      DATA LUOPSY(4)/3/,LUOPSY(1)/2/
C LIST LUOPNM "SPNEG"
      DATA LUOPNM(3)/'S '/,LUOPNM(4)/'P '/,LUOPNM(5)/'N '/
      DATA LUOPNM(6)/'E '/,LUOPNM(7)/'G '/
      DATA LUOPNM(2)/5/
C     "SPNOT"
      DATA LUOPNM(9)/'S '/,LUOPNM(10)/'P '/,LUOPNM(11)/'N '/
      DATA LUOPNM(12)/'O '/,LUOPNM(13)/'T '/
      DATA LUOPNM(8)/5/,LUOPNM(1)/2/
C LIST LCNDSY "<"
      DATA LCNDSY(3)/'< '/
      DATA LCNDSY(2)/1/
C     "<="
      DATA LCNDSY(5)/'< '/,LCNDSY(6)/'= '/
      DATA LCNDSY(4)/2/
C     "<>"
      DATA LCNDSY(8)/'< '/,LCNDSY(9)/'> '/
      DATA LCNDSY(7)/2/
C     "="
      DATA LCNDSY(11)/'= '/
      DATA LCNDSY(10)/1/
C     ">="
      DATA LCNDSY(13)/'> '/,LCNDSY(14)/'= '/
      DATA LCNDSY(12)/2/
C     ">"
      DATA LCNDSY(16)/'> '/
      DATA LCNDSY(15)/1/,LCNDSY(1)/6/
C LIST LCNDFN "BGE"
      DATA LCNDFN(3)/'B '/,LCNDFN(4)/'G '/,LCNDFN(5)/'E '/
      DATA LCNDFN(2)/3/
C     "BGT"
      DATA LCNDFN(7)/'B '/,LCNDFN(8)/'G '/,LCNDFN(9)/'T '/
      DATA LCNDFN(6)/3/
C     "BEQ"
      DATA LCNDFN(11)/'B '/,LCNDFN(12)/'E '/,LCNDFN(13)/'Q '/
      DATA LCNDFN(10)/3/
C     "BNE"
      DATA LCNDFN(15)/'B '/,LCNDFN(16)/'N '/,LCNDFN(17)/'E '/
      DATA LCNDFN(14)/3/
C     "BLT"
      DATA LCNDFN(19)/'B '/,LCNDFN(20)/'L '/,LCNDFN(21)/'T '/
      DATA LCNDFN(18)/3/
C     "BLE"
      DATA LCNDFN(23)/'B '/,LCNDFN(24)/'L '/,LCNDFN(25)/'E '/
      DATA LCNDFN(22)/3/,LCNDFN(1)/6/
C                                                                       ENDPRE
C               BLE X IS POST PROCESSED TO BLT X;BEQ X
        DATA FCOND/.FALSE./,LN/0/,SPCNT/0/
        DATA VTTY/-1/,SFNO/1/,OFNO/2/,TFNO/3/
        DATA VFIRST,VEND,VALPH,VNUM,VBEG,VALL/1,-1,-1,-2,0,-1/
        DATA VEQ,LEOS/0,0/
        DATA VR,VW,VRW,VCLOSE,VDEL,VREW,VSCR/1,2,3,4,5,6,7/
        DATA EOF,DQUOTE/8285,8226/
        DATA LPAREN,COMMA/8232,8236/
        DATA RPAREN,COLON,V/8233,8250,8278/
        DATA EXCLAM,DASH/8225,8237/
        DATA PERIOD,C,S/8238,8259,8275/
        DATA ZERO,ONE,TWO/8240,8241,8242/
        DATA PLUS,EQUAL,P/8235,8253,8272/
        DATA BLANK,T,SEMICO/8224,8276,8251/
C
C
C       GET TTY, SOURCE, OBJECT AND TEMPORARY FILES
C
        DUMMY=INFILE(VRW,0,VTTY)
        WRITE(5,9999)
9999    FORMAT (' VFC100 REL.  1.00 , 09/01/79')
1000    CALL WRTLIN(SSORF,VTTY,80)
        DUMMY=RDLIN(SF,VTTY,80)
        IF (INFILE(VR,SF,SFNO).NE.0) GO TO 1000
1010    CALL WRTLIN(SOBJF,VTTY,80)
        DUMMY=RDLIN(OF,VTTY,80)
        IF (INFILE(VW,OF,OFNO).NE.0) GO TO 1010
C    GET SCRATCH FILE '0'
        TF(1)=0
        DUMMY=INFILE(VSCR,TF,TFNO)
C
C INIT FOR NEW VECTOR FUNCTION CHAIN
C       ZERO ERROR COUNT, FUNCTION LIST,PARAMETER LIST, INPUT SPAD PARAM COUNT
C       TOKEN STRING, LIST OF DEFINED TAGS AND UNDEFINED TAGS
C
2000    ERRCNT=0
        FFLUSH=.FALSE.
        FCOMMA=.FALSE.
        CALL RMVSL(LDEFP,VBEG,VALL)
        CALL RMVSL(LCALLF,VBEG,VALL)
        CALL RMVSL(LTAGUS,VBEG,VALL)
        CALL RMVSL(LTAGDF,VBEG,VALL)
        CALL RMVCS(TAG,VBEG,VALL)
        INSPAD=0
C
C       FLAG THAT EXTERNAL PROGRAMS SET2SP AND SETSP HAVE NOT BEEN USED
C
        FSETU=.FALSE.
        FSET2U=.FALSE.
C
C       FLAG TO NOT SAVE SPAD 0
C
        FSAV0U=.FALSE.
C
C GET DEFINE STATEMENT
C
        CALL RMVCS(OPL,VBEG,VALL)
2040    CALL RMVCS(TOKS,VBEG,VALL)
        DUMMY=RDLIN(TOKS,SFNO,80)
        IF (EXTTOK(IDX,1,TOKS,1,DUMMY,10).EQ.EOF) GO TO 9000
        DUMMY=EXTSS(TOKS,VBEG,LH,VALL)
        CALL INSCS(LH,VBEG,DQUOTE)
        CALL WRTLIN(LH,OFNO,80)
        LN=LN+1
C
C       BYPASS COMMENT LINES
C
        IF (FEOS(RMVTOK(TOK,6,TOKS,10)).EQ.LEOS) GO TO 2040
C
C               FIRST PROGRAM STATEMENT MUST BE DEFINE
C
        IF (CMPSS(TOK,SDEF,VALL).NE.0) CALL WRTERR(LN,LH,ILOPDF,
     C TOK,-1,OFNO,80,ERRCNT)
C
C               GET FUNCTION NAME  SETUP PSEUDO-OPS
C
        IF (RMVTOK(FCHNAM,6,TOKS,10).NE.VALPH) CALL WRTERR(LN,LH,
     C ILFNAM,FCHNAM,-1,OFNO,80,ERRCNT)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SDTIT,VALL)
        CALL INSSS(OPL,VEND,FCHNAM,VALL)
C
C       GET PARAMETERS - IF ANY
C
        IF (FEOS(RMVTOK(TOK,6,TOKS,10)).EQ.LEOS) GO TO 2070
        IF (EXTCS(TOK,1,DUMMY).NE.LPAREN) CALL WRTERR(LN,LH,UNEXPC,
     C TOK,-1,OFNO,80,ERRCNT)
C
C               GET NEXT PARAMETER
C
2060    IF (RMVTOK(TOK,6,TOKS,10).NE.VALPH) CALL WRTERR(LN,LH,ILLPRM,
     C TOK,-1,OFNO,80,ERRCNT)
C
C               BUILD DEFINED PARAM LIST (INPUT  LOCAL PARAMS)
C
        IF (SRCSL(LDEFP,VFIRST,TOK,VALL).NE.0) CALL WRTERR(LN,LH,
     C DBLDEF,TOK,-1,OFNO,80,ERRCNT)
        CALL INSSL(LDEFP,VEND,TOK,VALL)
        INSPAD=INSPAD+1
        CTOK=RMVTOK(TOK,1,TOKS,10)
C
C        GO GET NEXT PARAMETER - IF ANY
C
        IF (CTOK.EQ.COMMA) GO TO 2060
        IF (CTOK.NE.RPAREN) CALL WRTERR(LN,LH,UNEXPC,
     C TOK,-1,OFNO,80,ERRCNT)
        IF (FEOS(RMVTOK(TOK,6,TOKS,10)).NE.LEOS) CALL WRTERR(LN,LH,
     C EXTRA,TOK,-1,OFNO,80,ERRCNT)
C
C WRITE $TITLE
C
2070    CALL WRTLIN(OPL,OFNO,80)
2080    CALL RMVCS(OPL,VBEG,VALL)
C
C       SETUP FOR NEXT PROGRAM STATEMENT
C               CLEAR CALLED FUNCTION PARAMETERS
C
        CALL RMVSL(LCALLP,VBEG,VALL)
2090    CALL RMVCS(TOKS,VBEG,VALL)
C
C GET NEXT PROGRAM STATEMENT (STRING OF TOKENS) - IF ANY
C
        DUMMY=RDLIN(TOKS,SFNO,80)
        IF (EXTTOK(IDX,1,TOKS,1,DUMMY,10).EQ.EOF) GO TO 3010
C
C       WRITE COPY OF LINE TO HOLDING (EXECUTABLES) FILE
C
        DUMMY=EXTSS(TOKS,VBEG,LH,VALL)
        CALL INSCS(LH,VBEG,DQUOTE)
        CALL WRTLIN(LH,TFNO,80)
        LN=LN+1
        IF (FEOS(RMVTOK(TOK,6,TOKS,10)).EQ.LEOS) GO TO 2090
C
C               REMOVE USER COMMENTS
C
        IUSERC=SRCCS(TOKS,2,DQUOTE)
        IF (IUSERC.EQ.0) GO TO 2150
        CALL RMVCS(TOKS,IUSERC,VALL)
C
C       REMOVE STATEMENT LABEL (TAG) IF ANY
C
2150    IF (.NOT.GETTAG(DUMMY,0,TOKS)) GO TO 2185
        DUMMY=EXTSS(TOK,VBEG,TAG,VALL)
        IF (SRCSL(LTAGDF,VFIRST,TAG,VALL).NE.0) CALL WRTERR(LN,LH,
     C DBLDFT,TAG,-1,TFNO,80,ERRCNT)
C
C               INSERT TAG ON LIST OF DEFINED TAGS
C
        CALL INSSL(LTAGDF,VEND,TAG,VALL)
C
C               REMOVE TAG FROM LIST OF UNDEFINED TAGS
C
        UTAGNO=SRCSL(LTAGUS,VFIRST,TAG,VALL)
        IF (UTAGNO.NE.0) CALL RMVSL(LTAGUS,UTAGNO,1)
        CALL INSCS(TAG,VEND,COLON)
        DUMMY=RMVTOK(TOK,6,TOKS,10)
C
C DETERMINE STATEMENT TYPE
C       PROCESS CALL STATEMENT
C
2185    CONTINUE
        FCALL=.FALSE.
        IF (CMPSS(TOK,SCALL,VALL).NE.0) GO TO 2300
        FCALL=.TRUE.
C
C              DETERMINE SETSP CALL PARAMETERS
C
2190    CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SJSRST,VALL)
C
C               GET NAME OF CALLED FUNCTION
C
        IF (RMVTOK(FCN,6,TOKS,10).NE.VALPH) CALL WRTERR(LN,LH,ILFNAM,
     C TOK,-1,TFNO,80,ERRCNT)
C
C        PROCESS FCN CALL PARAMETERS - IF ANY, PLACE IN PARAMETER LIST
C       PARAMETER LIST (LCALLP):
C               LIST(ENTRY1) : PARAMETER 1 TYPE (V OR C OR S - VARIABLE OR CONST
C               LIST(ENTRY2) : PARAMETER 1 VALUE (VARIABLE PARAM# OR LITERAL CON
C               LIST(ENTRY3) : PARAMETER 2 TYPE
C               LIST(ENTRY4) : PARAMETER 2 VALUE
C               .
C               .
C               .
C
        CTOK=RMVTOK(TOK,1,TOKS,10)
        IF (FEOS(CTOK).EQ.LEOS) GO TO 2250
        IF (CTOK.NE.LPAREN) CALL WRTERR(LN,LH,UNEXPC,
     C TOK,-1,TFNO,80,ERRCNT)
2200    CTOK=RMVTOK(TOK,6,TOKS,10)
        IF (CTOK.NE.VALPH) GO TO 2220
C
C              DETERMINE VARIABLE PARAMETERS
C
        L=SRCSL(LDEFP,VFIRST,TOK,VALL)
        IF (L.EQ.0) CALL WRTERR(LN,LH,UNDEFV,
     C TOK,-1,TFNO,80,ERRCNT)
        CALL INSCL(LCALLP,VEND,V)
        CALL INSCL(LCALLP,VEND,L)
        GO TO 2240
C
C               DETERMINE LITERALS (!XXXXXX)
C
2220    IF (CTOK.NE.EXCLAM) GO TO 2224
        CTOK=RMVTOK(TOK,6,TOKS,10)
        CALL INSCS(TOK,VBEG,EXCLAM)
        GO TO 2236
C
C               DETERMINE NEGATIVE NUMBERS
C
2224    IF (CTOK.NE.DASH) GO TO 2230
        CTOK=RMVTOK(TOK,6,TOKS,10)
        CALL INSCS(TOK,VBEG,DASH)
C
C               DETERMINE POSITIVE NUMBERS
C
2230    IF (CTOK.NE.VNUM) CALL WRTERR(LN,LH,UNEXPC,
     C TOK,-1,TFNO,80,ERRCNT)
C
        CALL INSCS(TOK,VEND,PERIOD)
C               INSERT CONSTANT-LITERAL PARAMETERS
C
2236    CALL INSCL(LCALLP,VEND,C)
        CALL INSSL(LCALLP,VEND,TOK,VALL)
2240    CTOK=RMVTOK(TOK,1,TOKS,10)
C
C              GO DETERMINE MORE PARAMETERS - IF ANY
C
        IF (CTOK.EQ.COMMA) GO TO 2200
        IF (CTOK.NE.RPAREN) CALL WRTERR(LN,LH,EXTRA,
     C TOK,-1,TFNO,80,ERRCNT)
C
C       FLAG NOT A SCALER FUNCTION (NO SAVE)
C
2250    FSAVE=.FALSE.
C
C  PROCESS FCN PARAMETERS
C     WRITE OPL (JSR SETSP OR SET0), CALL (OR SCALER) FCN PARAMETER COUNT,
C       FCN PARAMETERS AND CALL TO FCN ON TEMP FILE.
C
C
C       FORM MOVE COMANDS AND JSR SETSP, IF NEEDED
C
2255    CONTINUE
        MTSP0=-1
        MTSP1=-1
C DETERMINE # OF OPERANDS
        ITS=LENL(LCALLP)/2
C
C       DETERMINE IF AN OPERAND IS AN SPAD REGISTER
C
        DO 2258 IT=1,ITS
        IF (EXTCL(LCALLP,IT*2-1,DUMMY,VFIRST).NE.S) GO TO 2258
C GET SPAD #
        I=EXTCL(LCALLP,IT*2,DUMMY,VFIRST)
        IF (IT.EQ.1) MTSP0=I
        IF (IT.EQ.2) MTSP1=I
2258    CONTINUE
C
C       IF SP00 AND SP01 ARE ALREADY LOADED DON'T DO ANYTHING
C       AT SOME POINT CHECK FOR ILLEGAL OPERATIONS, LIKE SP01 - SP00
C
        IF (MTSP0.EQ.1.AND.MTSP1.EQ.0) GO TO 2262
        CALL RMVCS(TOPL,VBEG,VALL)
C
C       GENERATE THE MOVE INSTRUCTION FOR THE FIRST OPERAND
C       IF MTSP0 = SP00 OR NO SPAD WE DON'T HAVE TO LOAD SP00
C
        IF (MTSP0.LE.0) GO TO 2260
        CALL INSSS(TOPL,VBEG,TAG,VALL)
        CALL RMVCS(TAG,VBEG,VALL)
        CALL TABS(TOPL,8)
        CALL INSSS(TOPL,VEND,SMOV,VALL)
        CALL ITOS(MTSP0,TBUF,2,8)
        CALL INSSS(TOPL,VEND,TBUF,VALL)
        CALL INSCS(TOPL,VEND,COMMA)
        CALL INSCS(TOPL,VEND,ZERO)
        CALL WRTLIN(TOPL,TFNO,80)
        CALL RMVCS(TOPL,VBEG,VALL)
C
C       GENERATE MOVE INSTRUCTION FOR THE SECOND OPERAND
C       IF MTSP1 = SP01 OR NO SPAD WE DON'T HAVE TO LOAD SP01
C
2260    CONTINUE
        IF (MTSP1.LT.0.OR.MTSP1.EQ.1) GO TO 2262
        CALL INSSS(TOPL,VBEG,TAG,VALL)
        CALL RMVCS(TAG,VBEG,VALL)
        CALL TABS(TOPL,8)
        CALL INSSS(TOPL,VEND,SMOV,VALL)
        CALL ITOS(MTSP1,TBUF,2,8)
        CALL INSSS(TOPL,VEND,TBUF,VALL)
        CALL INSCS(TOPL,VEND,COMMA)
        CALL INSCS(TOPL,VEND,ONE)
        CALL WRTLIN(TOPL,TFNO,80)
        CALL RMVCS(TOPL,VBEG,VALL)
C
C       GENERATE JSR SETSP (MAYBE)
C
2262    CONTINUE
        IF (SPCNT.EQ.ITS) GO TO 2286
        IF (LENS(TAG).EQ.0) GO TO 2263
        CALL RMVCS(OPL,VBEG,LENS(TAG))
        CALL INSSS(OPL,VBEG,TAG,VALL)
        CALL RMVCS(TAG,VBEG,VALL)
2263    IF (ITS-SPCNT.NE.2) GO TO 2264
        RORL=1
        CALL INSCS(OPL,16,TWO)
        FSET2U=.TRUE.
        GO TO 2265
2264    CALL WRTLIN(OPL,TFNO,80)
        FSETU=.TRUE.
C
C       FILL FCN PARAMETER COUNT INTO LEFT HALF OF $VAL
C
        CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SDVAL,VALL)
        IF (MTSP0.GE.0.AND.MTSP1.LT.0) CALL INSCS(OPL,VEND,ONE)
        CALL INSCS(OPL,VEND,ZERO)
        CALL INSCS(OPL,VEND,COMMA)
        CALL ITOS(ITS-SPCNT,TBUF,2,8)
        CALL INSSS(OPL,VEND,TBUF,VALL)
C
C               FILL FCN (OR SCALER FUNCTION) CALL
C              PARAMETERS INTO  STORAGE WORDS, START ON RIGHT HALF
C
        RORL=2
2265    DO 2281 IT=1,ITS
        IF (EXTCL(LCALLP,2*IT-1,PTYPE,VFIRST).EQ.S) GO TO 2281
        IF (RORL.EQ.2) GO TO 2266
C
C                       WRITE FCN PARAMETER HOLDER ON TEMP FILE AND INIT LEFT
C
        CALL WRTLIN(OPL,TFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SDVAL,VALL)
        GO TO 2267
C
C                       POSITION FOR RIGHT HALF
C
2266    CALL INSCS(OPL,VEND,COMMA)
C
C                       FILL VARIBLE POINTER OR LITERAL INTO PARAMETER STORAGE
C
2267    CALL INSCS(OPL,VEND,PTYPE)
        IF (PTYPE.NE.V) GO TO 2270
C
C                       FLAG VARIABLE LOCATION
C
        CALL INSCS(OPL,VEND,PLUS)
C
C                               FLAG IF VARIABLE IS STORED ON R OR L
C
        CALL INSCS(OPL,VEND,EXTCS(SRL,MOD(EXTCL(LCALLP,2*IT,VL,VFIRST)
     C ,2)+1,DUMMY))
        CALL INSCS(OPL,VEND,COMMA)
        CALL INSSS(OPL,VEND,SPMPPL,VALL)
        CALL ITOS((VL-1)/2,TBUF,2,8)
        CALL INSSS(OPL,VEND,TBUF,VALL)
        GO TO 2280
C
C                               FLAG NUMERIC (LITERAL) PARAMETER
C
2270    CALL INSCS(OPL,VEND,COMMA)
        DUMMY=EXTSL(LCALLP,2*IT,TBUF,VALL)
        CALL INSSS(OPL,VEND,TBUF,VALL)
C
C              CHANGE TO OTHER SIDE OF STORAGE WORD
C
2280    RORL=3-RORL
2281    CONTINUE
        IF (RORL.EQ.2) CALL INSSS(OPL,VEND,S2SC0,VALL)
C
C              WRITE OUT LAST PARAMETER(S) TO TEMPORARY FILE
C
        CALL WRTLIN(OPL,TFNO,80)
2286    CALL RMVCS(OPL,VBEG,VALL)
        SPCNT=0
C
C              WRITE OUT JSR (CALL) TO FCN IN TEMP FILE
C
        IF (LENS(FCN).EQ.0) GO TO 2290
        IF (LENS(TAG).EQ.0) GO TO 2288
        CALL INSSS(OPL,VBEG,TAG,VALL)
        CALL RMVCS(TAG,VBEG,VALL)
2288    CALL TABS(OPL,8)
        IF (.NOT.FCALL) GO TO 2289
        FFLUSH=.TRUE.
        CALL INSSS(OPL,VEND,SJSR,VALL)
        CALL INSSS(OPL,VEND,SFLUSH,VALL)
        CALL WRTLIN(OPL,TFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
2289    CONTINUE
        CALL INSSS(OPL,VEND,SJSR,VALL)
        CALL INSSS(OPL,VEND,FCN,VALL)
        CALL WRTLIN(OPL,TFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
C
C              WRITE $EXT FCN ON OBJECT FILE UNLESS ALREADY USED
C
        IF (SRCSL(LCALLF,VFIRST,FCN,VALL).NE.0) GOTO 2290
        CALL INSSL(LCALLF,VEND,FCN,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SDEXT,VALL)
        CALL INSSS(OPL,VEND,FCN,VALL)
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(FCN,VBEG,VALL)
C
C        GO GET NEXT CALL STATEMENT OR SAVE RESULT OF SCALER FUNCTION
C               OR COMPLETE PROCESSING OF CONDITIONALS
C
2290    IF (FCOND) GO TO 2660
        IF (.NOT.FSAVE) GO TO 2080
C
C               WRITE OUT CODE TO SAVE RESULT FROM SPAD0
C
        CALL RMVCS(OPL,VBEG,VALL)
C
C                       DETERMINE NEED TO SAVE TO SPAD0
C
        IF (PSAV.EQ.0) GO TO 2080
        CALL INSSS(OPL,VBEG,TAG,VALL)
        CALL RMVCS(TAG,VBEG,VALL)
        CALL TABS(OPL,8)
        IF (PSAV.GT.0) GO TO 2298
C
C                       SAVE RESULTS TO SPAD -PSAV
C
        CALL INSSS(OPL,VEND,SMOV,VALL)
        CALL INSCS(OPL,VEND,ZERO)
        CALL INSCS(OPL,VEND,COMMA)
        CALL ITOS(-PSAV,TBUF,2,8)
        CALL INSSS(OPL,VEND,TBUF,VALL)
        CALL WRTLIN(OPL,TFNO,80)
        GO TO 2080
C
C                       SAVE RESULTS TO PS ADDR HALFWORD (PSAV)
C
2298    CALL INSSS(OPL,VEND,SJSR,VALL)
        CALL INSSS(OPL,VEND,SSAV0,VALL)
        CALL WRTLIN(OPL,TFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SDVAL,VALL)
        CALL INSSS(OPL,VEND,SVPLUS,VALL)
        CALL INSCS(OPL,VEND,EXTCS(SRL,MOD(PSAV,2)+1,DUMMY))
        CALL INSCS(OPL,VEND,COMMA)
        CALL INSSS(OPL,VEND,SPMPPL,VALL)
        CALL ITOS((PSAV-1)/2,TBUF,2,8)
        CALL INSSS(OPL,VEND,TBUF,VALL)
        CALL INSSS(OPL,VEND,S2SC0,VALL)
        CALL WRTLIN(OPL,TFNO,80)
        FSAV0U=.TRUE.
        GOTO 2080
C
C       PROCESS LOCAL STATEMENT
C
2300    IF (CMPSS(TOK,SLOCAL,VALL).NE.0) GO TO 2400
2310    IF (RMVTOK(TOK,6,TOKS,10).NE.VALPH) CALL WRTERR(LN,LH,ILLPRM,
     C TOK,-1,TFNO,80,ERRCNT)
        IF (SRCSL(LDEFP,VFIRST,TOK,VALL).NE.0) CALL WRTERR(LN,LH,
     C DBLDEF,TOK,-1,TFNO,80,ERRCNT)
        CALL INSSL(LDEFP,VEND,TOK,VALL)
        CTOK=RMVTOK(TOK,1,TOKS,10)
        IF (CTOK.EQ.COMMA) GO TO 2310
        IF (FEOS(CTOK).NE.LEOS) CALL WRTERR(LN,LH,UNEXPC,
     C TOK,-1,TFNO,80,ERRCNT)
        GO TO 2080
C
C       PROCESS SCALER FUNCTIONS
C
2400    IF (.NOT.FSP(TOK,SPNN)) GO TO 2405
C
C               RESULT ASSIGNED TO SPAD
C
        PSAV=-SPNN
        GO TO 2410
C
C               RESULT TO PS HALFWORD
C
2405    PSAV=SRCSL(LDEFP,VFIRST,TOK,VALL)
        IF (PSAV.EQ.0) GO TO 2510
2410    CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SJSRST,VALL)
        IF (RMVTOK(TBUF,6,TOKS,10).NE.EQUAL) GO TO 2500
        FUOP=.FALSE.
C
C               GET SCALER PARAMETERS
C
        DO 2450 I=1,2
        CTOK=RMVTOK(TOK,6,TOKS,10)
        IF (CTOK.NE.VALPH) GO TO 2420
        IF (.NOT.FSP(TOK,SPNN)) GO TO 2413
        SPCNT=SPCNT+1
        CALL INSCL(LCALLP,VEND,S)
        CALL INSCL(LCALLP,VEND,SPNN)
        GO TO 2440
2413    L=SRCSL(LDEFP,VFIRST,TOK,VALL)
        IF (L.EQ.0) GO TO 2434
2415    CALL INSCL(LCALLP,VEND,V)
        CALL INSCL(LCALLP,VEND,L)
        GOTO 2440
C
C                       DETERMINE LITERAL SCALER
C
2420    IF (CTOK.NE.EXCLAM) GO TO 2422
        CTOK=RMVTOK(TOK,6,TOKS,10)
        CALL INSCS(TOK,VBEG,EXCLAM)
        GO TO 2425
C
C                       DETERMINE POSITIVE NUMBERS
C
2422    IF (CTOK.NE.VNUM) GO TO 2430
2424    CALL INSCS(TOK,VEND,PERIOD)
C
C                               INSERT CONSTANT-LITERAL PARAMETER
C
2425    CALL INSCL(LCALLP,VEND,C)
        CALL INSSL(LCALLP,VEND,TOK,VALL)
        GO TO 2440
C
C                       DETERMINE NEGATIVE NUMBERS
C
2430    IF (CTOK.NE.DASH) GO TO 2434
        IF (RMVTOK(TOK,6,TOKS,10).NE.VNUM) GO TO 2432
        CALL INSCS(TOK,VBEG,DASH)
        GO TO 2424
2432    CALL INSSS(TOKS,VBEG,TOK,VALL)
        CALL RMVCS(TOK,VBEG,VALL)
        CALL INSCS(TOK,VBEG,DASH)
2434    FCNO=SRCSL(LUOPSY,VFIRST,TOK,VALL)
        IF (FCNO.NE.0) GO TO 2436
        CALL WRTERR(LN,LH,UNDEFV,
     C TOK,-1,TFNO,80,ERRCNT)
        GO TO 2415
2436    DUMMY=EXTSL(LUOPNM,FCNO,FCN,VALL)
        FUOP=.TRUE.
        GO TO 2450
2440    IF (I.NE.1) GO TO 2450
        IF (FEOS(RMVTOK(FCN,6,TOKS,10)).EQ.LEOS) GO TO 2485
2450    CONTINUE
        IF (FUOP) GO TO 2490
        FCNO=SRCSL(LFNSYM,VFIRST,FCN,VALL)
        IF (FCNO.EQ.0) CALL WRTERR(LN,LH,UNDFFN,
     C TOK,-1,TFNO,80,ERRCNT)
        DUMMY=EXTSL(LFNNAM,FCNO,FCN,VALL)
        GO TO 2490
2485    CALL RMVCS(FCN,VBEG,VALL)
2490    FSAVE=.TRUE.
        GOTO 2255
C
C       PROCESS GOTO STATEMENT
C
2500    CALL INSSS(TOKS,VBEG,TBUF,VALL)
2510    IF (CMPSS(SGOTO,TOK,VALL).NE.0) GO TO 2600
2515    IF (RMVTOK(TOK,6,TOKS,10).NE.VALPH) CALL WRTERR(LN,LH,ILLLBL,
     C TOK,-1,TFNO,80,ERRCNT)
        IF (SRCSL(LTAGDF,VFIRST,TOK,VALL).NE.0) GO TO 2517
        IF (SRCSL(LTAGUS,VFIRST,TOK,VALL).EQ.0)
     -  CALL INSSL(LTAGUS,VEND,TOK,VALL)
2517    CONTINUE
        IF (LENS(TAG).EQ.0) GO TO 2520
        CALL INSSS(OPL,VBEG,TAG,VALL)
        CALL RMVCS(TAG,VBEG,VALL)
2520    CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SJMP,VALL)
        CALL INSSS(OPL,VEND,TOK,VALL)
        CALL WRTLIN(OPL,TFNO,80)
        IF (FEOS(RMVTOK(TOK,6,TOKS,10)).NE.LEOS) CALL WRTERR(LN,LH,
     C EXTRA,TOK,-1,TFNO,80,ERRCNT)
        GO TO 2080
C
C       PROCESS IF STATEMENT
C
2600    IF (CMPSS(SIF,TOK,VALL).NE.0) GO TO 3000
C
C       SETUP FOR SETTING OF S-PAD(S)
C
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SJSRST,VALL)
C
C       PUT PARAMETERS FOR CONDITIONAL IN PARAMETER LIST (LCALLP)
C
        DO 2650 I=1,2
        CTOK=RMVTOK(TOK,6,TOKS,10)
        IF (CTOK.NE.VALPH) GO TO 2620
C
C       DETERMINE VARIABLE PARAMETERS
C
        IF (.NOT.FSP(TOK,SPNN)) GO TO 2613
        CALL INSCL(LCALLP,VEND,S)
        CALL INSCL(LCALLP,VEND,SPNN)
        SPCNT=SPCNT+1
        GO TO 2640
2613    CALL INSCL(LCALLP,VEND,V)
        L=SRCSL(LDEFP,VFIRST,TOK,VALL)
        IF (L.EQ.0) CALL WRTERR(LN,LH,UNDEFV,
     C TOK,-1,TFNO,80,ERRCNT)
        CALL INSCL(LCALLP,VEND,L)
        GOTO 2640
C
C       DETERMINE LITERAL CONDITIONAL PARAMETER
C
2620    IF (CTOK.NE.EXCLAM) GO TO 2624
        CTOK=RMVTOK(TOK,6,TOKS,10)
        CALL INSCS(TOK,VBEG,EXCLAM)
        GO TO 2636
C
C       DETERMINE NEGATIVE NUMBERS
C
2624    IF (CTOK.NE.DASH) GO TO 2630
        CTOK=RMVTOK(TOK,6,TOKS,10)
        CALL INSCS(TOK,VBEG,DASH)
C
C       DETERMINE NUMERIC PARAMETER
C
2630    IF (CTOK.NE.VNUM) CALL WRTERR(LN,LH,UNEXPC,
     C TOK,-1,TFNO,80,ERRCNT)
        CALL INSCS(TOK,VEND,PERIOD)
C
C       INSERT LITERAL (CONSTANT) PARAMETERS
C
2636    CALL INSCL(LCALLP,VEND,C)
        CALL INSSL(LCALLP,VEND,TOK,VALL)
C
C       GET CONDITION AFTER FIRST PARAMETER
C
2640    IF (I.NE.1) GO TO 2650
        IF (RMVTOK(CND,6,TOKS,10).EQ.VALPH) GO TO 2650
2645    DUMMY=TYPC(EXTCS(TOKS,VFIRST,CHR),10)
        IF (DUMMY.EQ.VNUM.OR.DUMMY.EQ.VALPH) GO TO 2650
        CALL INSCS(CND,VEND,CHR)
        CALL RMVCS(TOKS,VBEG,1)
        GO TO 2645
2650    CONTINUE
        CNDO=SRCSL(LCNDSY,VFIRST,CND,VALL)
        IF (CNDO.EQ.0) CALL WRTERR(LN,LH,UNDFFN,
     C TOK,-1,TFNO,80,ERRCNT)
        DUMMY=EXTSL(LCNDFN,CNDO,CND,VALL)
        FCOND=.TRUE.
        DUMMY=EXTSS(SSPSUB,VBEG,FCN,VALL)
C
C               GO SAVE INSTRUCTIONS TO SETSP TO CONDIT. PARAM. AND SUBTRACT
C
        GOTO 2250
C
C               SAVE INSTRUCTION TO SKIP BRANCH ON INVERSE CONDITION
C
2660    FCOND=.FALSE.
        CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,CND,VALL)
        CALL INSSS(OPL,VEND,SDP2,VALL)
        CALL WRTLIN(OPL,TFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
C
C               GO SAVE INSTRUCTIONS TO BRANCH
C
        DUMMY=RMVTOK(TOK,6,TOKS,10)
        IF (CMPSS(SGOTO,TOK,VALL).NE.VEQ) CALL WRTERR(LN,LH,GOTORQ,
     C TOK,-1,TFNO,80,ERRCNT)
        GO TO 2515
C
C       PROCESS END STATEMENT
C
3000    IF (CMPSS(TOK,SEND,VALL).NE.0) GO TO 3900
        IF (FEOS(RMVTOK(TOK,6,TOKS,10)).NE.LEOS) CALL WRTERR(LN,LH,
     C UNEXPC,TOK,-1,TFNO,80,ERRCNT)
C
C       WRITE OUT EXTERNAL SAVESP AND SETSP AND SAVSP0 IF USED.
C
3010    CONTINUE
        IF ((LENL(LDEFP).EQ.0).AND..NOT.FSETU.AND..NOT.FSAV0U
     -  .AND..NOT.FSET2U.AND..NOT.FFLUSH) GO TO 3051
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SDEXT,VALL)
        IF (LENL(LDEFP).EQ.0) GO TO 3015
        CALL INSSS(OPL,VEND,SSAV,VALL)
        FCOMMA=.TRUE.
3015    CONTINUE
        IF (.NOT.FSETU) GO TO 3020
        IF (FCOMMA) CALL INSCS(OPL,VEND,COMMA)
        CALL INSSS(OPL,VEND,SSET,VALL)
        FCOMMA=.TRUE.
3020    IF (.NOT.FSAV0U) GO TO 3030
        IF (FCOMMA) CALL INSCS(OPL,VEND,COMMA)
        CALL INSSS(OPL,VEND,SSAV0,VALL)
        FCOMMA=.TRUE.
3030    IF (.NOT.FSET2U) GO TO 3040
        IF (FCOMMA) CALL INSCS(OPL,VEND,COMMA)
        CALL INSSS(OPL,VEND,SSET2,VALL)
        FCOMMA=.TRUE.
3040    CONTINUE
        IF (.NOT.FFLUSH) GO TO 3050
        IF (FCOMMA) CALL INSCS(OPL,VEND,COMMA)
        CALL INSSS(OPL,VEND,SFLUSH,VALL)
        FCOMMA=.TRUE.
3050    CALL WRTLIN(OPL,OFNO,80)
3051    CONTINUE
        CALL RMVCS(OPL,VBEG,VALL)
C
C WRITE OUT $ENTRY AND PSEUDO-OPS
C
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SDENT,VALL)
        CALL INSSS(OPL,VEND,FCHNAM,VALL)
        CALL INSCS(OPL,VEND,COMMA)
        CALL ITOS(INSPAD,SLEN,2,8)
        CALL INSSS(OPL,VEND,SLEN,VALL)
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL INSCS(OPL,VEND,DQUOTE)
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SLEQ,VALL)
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SREQ,VALL)
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SVEQ,VALL)
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SCEQ,VALL)
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL INSCS(OPL,VEND,DQUOTE)
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
C
C       WRITE OUT DEFINED FUNCTION PARAMETER STORAGE HOLDERS
C
        IF (LENL(LDEFP).EQ.0) GO TO 3120
        CALL INSCS(OPL,VEND,P)
        CALL INSCS(OPL,VEND,COLON)
        PARS=(LENL(LDEFP)+1)/2
        DO 3100 PAR=1,PARS
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SDVAL,VALL)
        CALL INSSS(OPL,VEND,S4S0C,VALL)
        CALL TABS(OPL,8)
        CALL INSCS(OPL,VEND,DQUOTE)
        DUMMY=EXTSL(LDEFP,PAR*2-1,TBUF,VALL)
        CALL INSSS(OPL,VEND,TBUF,VALL)
        CALL TABS(OPL,8)
        DUMMY=EXTSL(LDEFP,PAR*2,TBUF,VALL)
        CALL INSSS(OPL,VEND,TBUF,VALL)
        CALL WRTLIN(OPL,OFNO,80)
3100    CALL RMVCS(OPL,VBEG,VALL)
3120    CALL INSCS(OPL,VEND,DQUOTE)
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
C
C WRITE FUNTION ENTRY POINTER AND SETUP FOR SAVESP
C
        CALL INSSS(OPL,VEND,FCHNAM,VALL)
        CALL INSCS(OPL,VEND,COLON)
        CALL TABS(OPL,8)
        IF (LENL(LDEFP).EQ.0) GO TO 3160
        CALL INSSS(OPL,VEND,SJSR,VALL)
        CALL INSSS(OPL,VEND,SSAV,VALL)
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SDVAL,VALL)
        CALL INSCS(OPL,VEND,ZERO)
        CALL INSCS(OPL,VEND,COMMA)
        CALL INSSS(OPL,VEND,SLEN,VALL)
        CALL INSSS(OPL,VEND,SPMD,VALL)
3160    CONTINUE
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL INSCS(OPL,VEND,DQUOTE)
        CALL WRTLIN(OPL,OFNO,80)
C
C COPY GENERATED OPERATIONS (EXECUTABLE OBJECT)
C (SETSP CALL, PARAMETERS AND FUNCTION CALLS) FROM TEMPORARY FILE TO OBJECT
C       CHANGE BLE X TO BEQ X;BLT X
C
        CALL RMVCS(OPL,VBEG,VALL)
C
C               WRITE EOF INDICATOR
C
        CALL INSCS(OPL,VBEG,EOF)
        CALL WRTLIN(OPL,TFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        DUMMY=INFILE(VREW,TF,TFNO)
3180    LEN=80
        DUMMY=RDLIN(TBUF,TFNO,LEN)
        IF (EXTTOK(IDX,1,TBUF,1,DUMMY,10).EQ.EOF) GO TO 3200
        IBLE=SRCSS(TBUF,VFIRST,SBLE,VALL)
        IF (IBLE-1) 3195,3190,3185
3185    IF (EXTCS(TBUF,IBLE-1,CHR).EQ.BLANK) GO TO 3190
        IF (CHR.NE.COLON) GO TO 3195
C
C               SUBSTITUTE BLT;BEQ FOR BLE
C
3190    DUMMY=EXTSS(TBUF,IBLE+3,OPL,VALL)
        CALL RMVCS(TBUF,IBLE+2,1)
        CALL INSCS(TBUF,IBLE+2,T)
        CALL INSCS(TBUF,IBLE,BLANK)
        CALL INSCS(TBUF,IBLE,SEMICO)
        CALL INSCS(TBUF,IBLE,BLANK)
        CALL INSSS(TBUF,IBLE,OPL,VALL)
        CALL INSSS(TBUF,IBLE,SBEQ,VALL)
3195    CALL WRTLIN(TBUF,OFNO,LEN)
        GO TO 3180
C
C WRITE RETURN AND $END STATEMENTS
C
3200    CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SNOP,VALL)
        CALL WRTLIN(OPL,OFNO,80)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL INSSS(OPL,VBEG,TAG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SRETRN,VALL)
        CALL WRTLIN(OPL,OFNO,80)
C
C       WRITE UNDEFINED TAGS
C
        IF (LENL(LTAGUS).EQ.0) GO TO 3208
        L=LENL(LTAGUS)
        DO 3205 I=1,L
        DUMMY=EXTSL(LTAGUS,I,TBUF,VALL)
3205    CALL WRTERR(LN,LH,UNDEFT,TBUF,-1,OFNO,80,ERRCNT)
C
C       WRITE ERROR COUNT
C
3208    CALL RMVCS(OPL,VBEG,VALL)
        CALL TABS(OPL,8)
        CALL INSSS(OPL,VEND,SDEND,VALL)
        CALL WRTLIN(OPL,OFNO,80)
C
C               FLAG LUN FOR ERROR MESSAGE WITH 0 (TO NOT PRINT ERROR MESSAGE
C               ON OUTPUT FILE) IF NO ERRORS
C
        IERR=MIN0(1,ERRCNT)
        CALL ITOS(ERRCNT,OPL,5,10)
        IF(IERR.NE.0)CALL WRTERR(LN,FCHNAM,OPL,SERRS,-1,OFNO,80,ERRCNT)
        CALL RMVCS(OPL,VBEG,VALL)
        CALL INSCS(OPL,VEND,DQUOTE)
        DO 3220 I=1,3
3220    CALL WRTLIN(OPL,OFNO,80)
C
C       RESTORE TEMP FILE FOR NEW VFC
C
        DUMMY=INFILE(VREW,TF,TFNO)
        GO TO 2000
C
C       DETERMINE ERROR TYPE FOR ILLEGAL OP
C
3900    IF (EXTCS(TOKS,1,DUMMY).EQ.EQUAL) GO TO 3910
        CALL WRTERR(LN,LH,ILOPCL,TOK,-1,TFNO,80,ERRCNT)
        GO TO 2190
3910    CALL WRTERR(LN,LH,UNDEFV,TOK,-1,TFNO,80,ERRCNT)
        GO TO 2410
C
C       TERMINATE PROGRAM
C
9000    DUMMY=INFILE(VDEL,TF,TFNO)
        DUMMY=INFILE(VCLOSE,SF,SFNO)
        DUMMY=INFILE(VCLOSE,OF,OFNO)
        DUMMY=INFILE(VCLOSE,0,VTTY)
        CALL EXIT
        END
C+++    FSP
C****** FSP = SEE IF VARIABLE NAME IS AN S-PAD = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF VFC WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:24:43
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        LOGICAL FUNCTION FSP(STR,SPNN)
        INTEGER STR(9999),SPNN
C
C       RETURN .TRUE. IFF VARIABLE NAME IN STRING 'STR' IS 'SP'NN WHERE NN
C       IS A 2 DIGIT INTEGER.  SPNN IS RETURNED WITH THE INTEGER VALUE OF NN.
C
C       ROUTINES USED:
        INTEGER EXTCS
        INTEGER IDUM,N1,N2
        INTEGER IA1
        INTEGER S,P,ZERO,NINE
        DATA S,P,ZERO,NINE/8275,8272,8240,8249/
C       STATEMENT FUNCTION
        MAKR1(IA1)=IAND16(IA1,"377)
C
        IF (LENS(STR).NE.4) GO TO 90
        IF (EXTCS(STR,1,IDUM).NE.S.OR.EXTCS(STR,2,IDUM).NE.P)
     -  GO TO 90
        IF (EXTCS(STR,3,N1).LT.ZERO.OR.EXTCS(STR,4,N2).LT.ZERO)
     -  GO TO 90
        IF (N1.GT.NINE.OR.N2.GT.NINE) GO TO 90
        IDUM=MAKR1(N1-ZERO)*10+MAKR1(N2-ZERO)
        IF (IDUM.GT.15) GO TO 90
        SPNN=IDUM
        FSP=.TRUE.
        RETURN
90      FSP=.FALSE.
        RETURN
        END
C+++    GETTAG
C****** GETTAG = GET A TAG FROM A STRING = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF VFC WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:25:23
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        LOGICAL FUNCTION GETTAG(TAG,MAXLEN,STR)
        INTEGER TAG(999),MAXLEN,STR(9999)
C
C       THIS ROUTINE CHECKS STRING STR FOR A STATEMENT LABEL (TAG).
C       A TAG BEGINS AT THE FIRST CHARACTER AND IS TERMINATED BY A COLON.
C       THE VALUE OF THE FUNCTION IS .TRUE. IF THERE IS A TAG ON STR OR
C       .FALSE. IF NOT.  THE TAG (UP TO A MAXIMUM OF MAXLEN) CHARACTERS
C       IS RETURNED IN TAG (WITHOUT THE COLON).  THE TAG AND COLON ARE
C       REMOVED FROM STR.
C
        INTEGER DUMMY,EOTAG,SRCCS,EXTSS
        INTEGER VFIRST,COLON,VBEG,VALL
        DATA VFIRST,COLON,VBEG,VALL/1,8250,0,-1/
C
C       ROUTINES USED:
C               SRCCS
C               RMVCS
C               EXTSS
C
        EOTAG=SRCCS(STR,VFIRST,COLON)-1
        IF (EOTAG.GE.0) GO TO 100
        GETTAG=.FALSE.
        CALL RMVCS(TAG,VBEG,VALL)
        RETURN
100     DUMMY=EXTSS(STR,VBEG,TAG,MIN0(EOTAG,MAXLEN))
        CALL RMVCS(STR,VBEG,EOTAG+1)
        GETTAG=.TRUE.
        RETURN
        END
C+++    FEOS
C****** FEOS = DETERMINE IF END OF STATEMENT = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF VFC WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 18:26:06
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        INTEGER FUNCTION FEOS(CHR)
        INTEGER CHR
        INTEGER DQUOTE,LEOS
        DATA DQUOTE,LEOS/8226,0/
C
C       FEOS RETURNS THE VALUE LEOS IF CHARACTER CHR IS A TERMINATION OR
C       COMMENT CHARACTER.  OTHERWISE FEOS HAS THE VALUE OF CHR.
C
        IF (CHR.EQ.DQUOTE) GO TO 10
        FEOS=CHR
        RETURN
10      FEOS=LEOS
        RETURN
        END
 