C+++ SIM100
C****** SIM100 = FPS-100 SIMULATOR = REL.  1.00 , 09/01/79
C       WITH PAGE-SELECT
C
C
C****** MAIN = DRIVER FOR SIM100 = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 19:54:18
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
        REAL RREG(3)
        INTEGER DPX(32,3),DPY(32,3),SP(16,1),SRS(16,1)
        INTEGER APREG(118),BRKTYP,BRKLOC,EXTRA(70)
        INTEGER ITTO,FP,FIE,WRK(2),REG(8)
        INTEGER DIGITS(6),DIG2(6),DIG4(5,6),WXY
        INTEGER C(26),N(2,41),F(2,41),T(41),L(33)
        INTEGER FV(24),FD(24,2),TYP,OPN,LOCV,IV,H,OFF
        INTEGER DPSIZE,SPSIZE,MEMSPD
        INTEGER NCMD
C
        DOUBLE PRECISION DECFP
        REAL FPN4(4),CYCLES,CLOCK
         INTEGER IA(2),DEC
        COMMON /Q/C,N,F,T,L
        COMMON /IDTB/ IBLNK,INSIGN,IPSIGN,IPOINT,IEXP,IDB(16)
        INTEGER IODEV(64,3),IOSIZE,INTTYP(2),IOINT(16),
     1          IOBKPT(6,2),NIOBPT,TMSPEC(6)
        COMMON /IORM/ IODEV,IOSIZE,INTTYP,IOINT,IOBKPT,NIOBPT,TMSPEC
        INTEGER IHOLD(11)
        COMMON /SPCOM/ IHOLD
        COMMON DPX,DPY,SP,SRS,APREG,BRKTYP,BRKLOC,CYCLES,CLOCK,
     1MEMSPD,DPSIZE,SPSIZE,
     2IORST,IHLT,EXTRA,IPROC,FIE,FP,H,ITTI,ITTO,OPN
     3,TYP,LOCV,OFF,MAXEX,NCMD,IPRCT,IRS
C
C        HERE WE CALL APSIM SUBROUTINE AND ALLOW IT TO LOOP
C        UNTIL A BREAKPOINT WITHOUT CAUSING OVERLAYS TO BE CALLED
C        IN ON EACH LOOP
C
         IP1=0
10       CONTINUE
         CALL APD(IP1)
20       CONTINUE
         CALL APSIM
         IORST=0
         IPRCT=IPRCT+1
         IF(IPRCT.LT.IPROC)GOTO 20
         IP1=1
         GOTO 10
         END
C+++ APDBGS = FPS100 COMMAND INTERP = &REV
C****** APDBGS = FPS100 COMMAND INTERP = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 19:55:04
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
         SUBROUTINE APD(IP1)
C       THIS MAINLINE IS THE DEBUG FOR THE AP-120B SIMULATOR
C       IT CONDUCTS CONVERSATIONAL I/O WITH THE USER, AND CALLS APSIM
C         WHEN PROGRAM EXECUTION IS DESIRED
C       THE SIMULATED MEMORIES AND REGISTERS OF THE AP-120B ARE IN
C         COMMON ARRAYS WHICH ARE SHARED BETWEEN THE DEBUG AND THE
C         SIMULATOR
C
C
C
        REAL RREG(3)
        INTEGER DPX(32,3),DPY(32,3),SP(16,1),SRS(16,1)
        INTEGER APREG(118),BRKTYP,BRKLOC,EXTRA(70)
        INTEGER ITTO,FP,FIE,WRK(2),REG(8)
        INTEGER DIGITS(6),DIG2(6),DIG4(5,6),WXY
        INTEGER C(26),N(2,41),F(2,41),T(41),L(33)
        INTEGER FV(24),FD(24,2),TYP,OPN,LOCV,IV,H,OFF
        INTEGER DPSIZE,SPSIZE,MEMSPD
        INTEGER NCMD
C
        DOUBLE PRECISION DECFP
        REAL FPN4(4),CYCLES,CLOCK
         INTEGER IA(2),DEC
        COMMON /Q/C,N,F,T,L
        INTEGER IODEV(64,3),IOSIZE,INTTYP(2),IOINT(16),
     1          IOBKPT(6,2),NIOBPT,TMSPEC(6)
        COMMON /IORM/ IODEV,IOSIZE,INTTYP,IOINT,IOBKPT,NIOBPT,TMSPEC
        INTEGER IHOLD(11)
        COMMON /SPCOM/ IHOLD
        COMMON DPX,DPY,SP,SRS,APREG,BRKTYP,BRKLOC,CYCLES,CLOCK,
     1MEMSPD,DPSIZE,SPSIZE,
     2IORST,IHLT,EXTRA,IPROC,FIE,FP,H,ITTI,ITTO,OPN
     3,TYP,LOCV,OFF,MAXEX,NCMD,IPRCT,IRS
C
C
C
C-----------------------------------------------------------------------
C
C
C
C       DPSIZE - SIZE OF DATA PADS (FIXED AT 32 IN THE HARDWARE, BUT
C         CAN, OF COURSE, BE CHANGED HERE FOR EXPERIMENTATION)
C       SPSIZE - S-PAD SIZE (16)
C       IOSIZE - NUMBER OF DUMMY I/O DEVICES (64)
C
        DPSIZE=32
        SPSIZE=16
C
C
C
C
C       MAXIMUM EXPONENT FOR TYPEOUT OF FLOATING POINT NUMBERS.  SINCE
C         THE FPS-100 FLOATING POINT HAS A LARGER DYNAMIC RANGE THAN
C         MOST HOST COMPUTERS, WE HAVE TO CHECK BEFORE TYPING OUT A
C         FLOATING POINT NUMBER, TO SEE IF WE WILL GET OVERFLOW
C         IN THE HOST FLOATING POINT FORMAT
C       1. HOST COMPUTER HAS A BINARY EXPONENT:
C         MAXEX = 2**(ONE LESS THAN THE NUMBER OF BITS IN THE EXPONENT)
C       2. HOST FLOATING POINT HAS A HEX EXPONENT:
C         MAXEX = 2**(ONE MORE THAN THE NUMBER OF BITS IN THE EXPONENT)
C
C       IBM 360 FORMAT:  7 BIT HEX EXPONENT - MAXEX=256
C       PDP-11 FORMAT: 8 BIT BINARY EXPONENT - MAXEX=128
C
C       SET FOR IBM 360 FORMAT
        MAXEX=256
C
C
C
C       DEFAULT MAIN DATA MEMORY SPEED, SET TO 1 (FOR 250 NS. MEMORY)
         MEMSPD=1
C
C---------------------------------------------------------------------
C
C
C
C       INITIALIZE THE DEBUG
C       FUNCTIONS OF THESE VARIABLES:
C
C
C       NCMD       NUMBER OF POSSIBLE USER COMMANDS
C       NMEM       NUMBER OF USER ACCESSIBLE MEMORIES
C       NREG       NUMBER OF USER ACCESSIBLE REGISTERS AND MEMORIES
C       CYCLES     COUNTS PROGRAM EXECUTION CYCLES, REINITIALIZED
C                       BY EACH NEW "R" COMMAND
C       CLOCK      NUMBER OF CYCLES PER MICROSECOND
C       CLKCYC     NUMBER OF CYCLES SINCE CLOCK STARTED OR RESET
C       FP         FLAG FOR I/O TO 38 BIT REGISTERS:
C                       0  I/O AS INTEGERS: EXPONENT, HIGH MANTISSA,
C                            LOW MANTISSA
C                       NON 0   I/O AS FLOATING POINT NUMBERS
C                       SET BY THE "F" COMMAND
C       FIE        FLAG FOR USER I/O OF PROGRAM WORDS.
C                       0   I/O AS 4 16-BIT INTEGERS
C                       NON 0   I/O AS 24 INSTRUCTION FIELDS
C                       SET BY THE "V" COMMAND
C       OFF        OFFSET REGISTER.  SUBTRACTED FROM ALL PROGRAM MEMORY
C                       ADDRESSES SO THE USER CAN WORK CONVIENENTLY WITH
C                       RELOCATABLE PROGRAMS.
C                       SET BY THE "O" COMMAND
C       OPN        POINTER TO THE CURRENTLY OPEN (I.E. LAST EXAMINED)
C                       REGISTER OR MEMORY.  "0" IF NOTHING OPEN
C       IORST      RESET FLAG, IF NON-ZERO RESET THE AP-120B BEFORE
C                       THE NEXT PROGRAM EXECUTION.  SET BY THE "I"
C                       COMMAND, CLEARED AFTER EACH EXECUTION.
C       IHLT       HALT FLAG; IF NON-ZERO THE SIMULATOR WILL HALT AFTER
C                       EXECUTING 1 INSTRUCTION. SET BY THE "S" COMMAND
C       IPROC      COUNT FOR PROCEEDING FROM BREAKPOINTS, OR FOR STEPING
C                       WILL COME TO THE BREAKPOINT "IPROC" TIMES BEFORE
C                       RETURNING TO THE USER; OR WILL STEP "IPROC"
C                       TIMES BEFORE RETURNING TO THE USER.
C                       SET BY THE "Q" COMMAND
C       BRKTYP     TYPE OF BREAKPOINT OPEN:  0 - NONE,  1 - PS,
C                       2 - MD,  3 - TM.  SET BY THE "B" COMMAND,
C                       CLEARED BY THE "D" COMMAND, PRINTED OUT BY THE
C                       "L" COMMAND.
C
C
        NCMD=26
        NMEM=8
        NREG=41
        CLOCK=4.0
C       SET THE CONSOLE INPUT/OUTPUT CHANNEL NUMBERS
        IF(IP1 .EQ. 1) GOTO 1111
        CALL SETTY(ITTI,ITTO)
        WRITE(ITTO,60)
C
C
C       DEFAULT RADIX FOR USER I/O, SET AS DESIRED TO 8, 10, OR 16
C       FOR OCTAL, DECIMAL, OR HEX
C       CHANGEABLE BY THE USER WITH AN "N" COMMAND
C
C       SET FOR OCTAL USER I/O
        H=8
C
        CYCLES=0.0
        FP=1
        FIE=0
        OFF=0
        OPN=0
        IORST=0
        IHLT=0
        IPROC=1
        BRKTYP=0
        NIOBPT=0
        GO TO 3000
C  (START OUT WITH AN IMPLICT 'ZERO' COMMAND)
C
C
C       TYPE A "*" AND GET THE NEXT COMMAND
C
1000    WRITE (ITTO,50)
         CALL AREAD(IA,1,ITTI,ITTO)
C
C       LOOK UP THE COMMAND
        DO 1010 I=1,NCMD
        IF (IA(1).EQ.C(I)) GO TO 1020
1010    CONTINUE
C
C       COMMAND NOT FOUND, TYPE A "?"
1012    WRITE (ITTO,51)
        GO TO 1000
C
C       GO DO THE COMMAND
1020    GO TO (1100,1200,1300,1400,1500,1600,1700,1750,1800,1900,
     1    2000,2100,2200,2300,1105,3000,4000,5000,5000,4100,4200,
     2    4300,4400,3100,3200,5400),I
C
C       RUN "R" <LOC>
1100     CALL IREAD(DEC,H,ITTI,ITTO)
C        ADD OFFSET TO RUN ADDRESS
         DEC=DEC+OFF
        CALL UNPKRG(DEC,WRK)
        APREG(7)=WRK(1)
        APREG(8)=WRK(2)
         CYCLES=0.0
C
C       PROCEED: "P"
1105     IPRCT=0
C
C        THIS WAS ADDED FOR OVERLAYED VERSIONS (NOVA RT11) 5/2/79/ TWL
C
         RETURN
1111     CONTINUE
C
C       WHEN WE COME BACK TYPE OUT THE PSA
C       AND ALSO THE ELAPSED TIME AND THE CONTENTS
C       OF THE CURRENTLY OPEN LOCATION
        WRK(1)=APREG(7)
        WRK(2)=APREG(8)
        FPN = CYCLES / CLOCK
        CALL PAKRG(WRK,WXY)
C        SUBTRACT OFFSET FROM PSA FOR TYPEOUT
         WXY=WXY-OFF
        CALL NUMOUT(WXY,DIGITS,H)
        WRITE (ITTO,52) (DIGITS(I),I=1,6 ),FPN
        IF (OPN.LT.1.OR.OPN.GT.NREG) GO TO 1000
        GO TO 1910
C
C       SET BREAK-POINT COUNTER: "Q" <NUMBER>
1200     CALL IREAD(IPROC,10,ITTI,ITTO)
        IF (IPROC.LE.0) IPROC=1
        GO TO 1000
C
C       BREAKPOINTS: "B" <TYPE> <LOC>
1300     CALL AREAD(IA,2,ITTI,ITTO)
C       SEE WHICH MEMORY TO BREAKPOINT
        DO 1310 I=1,3
         IF  (IA(1).EQ.N(1,I).AND.IA(2).EQ.N(2,I)) GO TO 1315
1310    CONTINUE
C       NOT FOUND
        GO TO 1012
1315     BRKTYP=I
         CALL IREAD(BRKLOC,H,ITTI,ITTO)
C        ADD OFFSET IF BREAKPOINT IN FOR PS
         IF (BRKTYP.EQ.1) BRKLOC=BRKLOC+OFF
        IPROC=1
        GO TO 1000
C
C       DELETE BREAKPOINTS: "D"
1400    BRKTYP=0
        IPROC=1
        NIOBPT=0
        GO TO 1000
C
C       STEP FLAG: "S" <#>
1500     CALL IREAD(IHLT,10,ITTI,ITTO)
        IPROC=1
        GO TO 1000
C
C       F.P. INPUT/OUTPUT FLAG: "F" <#>
1600     CALL IREAD(FP,10,ITTI,ITTO)
        GO TO 1000
C
C       P.S. FIELD VALUE I/O FLAG: "V" <#>
1700     CALL IREAD(FIE,10,ITTI,ITTO)
        GO TO 1000
C
C       LIST BREAKPOINTS: "L"
1750     IF (BRKTYP.EQ.0) GO TO 1760
         WXY=BRKLOC
C        IF BREAKPOINT IS IN PS SUBTRACT OFFSET FOR TYPEOUT
         IF (BRKTYP.EQ.1) WXY=WXY-OFF
        CALL NUMOUT(WXY,DIGITS,H)
         I=BRKTYP
        WRITE (ITTO,53) N(1,I),N(2,I),(DIGITS(J),J=1,6)
1760    IF (NIOBPT.EQ.0) GO TO 1000
C       LIST IO BREAKPOINTS (INTERRUPTS): "IO" DEV.INDEX PSA
        DO 1770 I=1,NIOBPT
                CALL NUMOUT(IOBKPT(I,1),DIGITS,H)
                WXY = IOBKPT(I,2)-OFF
                CALL NUMOUT(WXY,DIG2,H)
                WRITE (ITTO,58) (DIGITS(J),J=5,6),(DIG2(J),J=1,6)
1770    CONTINUE
        GO TO 1000
C
C       EXAMINE: "E" <TYPE> <LOC>
1800     CALL AREAD(IA,2,ITTI,ITTO)
        DO 1810 OPN=1,NREG
         IF (IA(1).EQ.N(1,OPN).AND.IA(2).EQ.N(2,OPN)) GO TO 1815
1810    CONTINUE
C       REG OR MEM NOT FOUNQD
        OPN=0
        GO TO 1012
1815    TYP=T(OPN)
        IF (OPN.GT.NMEM) GO TO 1830
         CALL IREAD (LOCV,H,ITTI,ITTO)
C        IF EXAMINING PS ADD OFFSET
         IF (OPN.EQ.1) LOCV=LOCV+OFF
1820    GO TO (1821,1822,1823,1824,1825,1826,1827,1828), OPN
1821    CALL PSMEM(1,LOCV,REG)
        GO TO 1850
1822    CALL MDMEM(1,LOCV,REG)
         GO TO 1850
1823    CALL TMMEM(1,LOCV,REG)
        GO TO 1850
1824    CALL MREAD(DPX,LOCV,REG,DPSIZE,3,6)
        GO TO 1850
1825    CALL MREAD(DPY,LOCV,REG,DPSIZE,3,6)
        GO TO 1850
1826    CALL MREAD(IODEV,LOCV,REG,IOSIZE,3,6)
        GO TO 1850
1827    CALL MREAD(SP,LOCV,REG,SPSIZE,1,2)
        GO TO 1850
1828    CALL MREAD(SRS,LOCV,REG,16,1,2)
        GO TO 1850
C
1830    CALL MOVPRT (APREG,L(OPN-NMEM),REG,1,112,8,(TYP-1)*4+2)
C
1850    GO TO (1851,1852,1853), TYP
C       OCTAL INTEGER OUTPUT
1851    CALL MOVPRT(REG,1,WRK,1,8,2,2)
        CALL PAKRG(WRK,WXY)
C        IF EXAMINING PSA, SUBTRACT OFFSET FOR TYPEOUT
         IF (OPN.EQ.NMEM+4) WXY=WXY-OFF
        CALL NUMOUT(WXY,DIGITS,H)
        WRITE(ITTO,56) (DIGITS(I),I=1,6)
        GO TO 1000
C
C       FLOATING POINT NUMBER OUTPUT
1852    IF (FP.NE.0) GO TO 1892
C       OUTPUT AS 3 6-DIGIT OCTAL NUMBERS
        DO 1882 I=1,3
        J=I*2-1
        CALL MOVPRT(REG,J,WRK,1,8,2,2)
        CALL PAKRG(WRK,WXY)
        CALL NUMOUT(WXY,DIGITS,H)
        DO 1882 J=1,6
1882    DIG4(I,J)=DIGITS(J)
        WRITE (ITTO,56) ((DIG4(I,J),J=1,6 ),I=1,3)
        GO TO 1000
C
1892    CALL FPOUT(REG,DECFP,MAXEX,IOV)
        IF (IOV.EQ.1) GO TO 1891
        WRITE (ITTO,55) DECFP
        GO TO 1000
1891    WRITE (ITTO,54)
        GO TO 1000
C
C       PROGRAM SOURCE OUTPUT
1853    IF (FIE.NE.0) GO TO 1893
C       OUTPUT AS 4 6-DIGIT OCTAL NUMBERS
        DO 1854 I=1,4
        J=I*2-1
        CALL MOVPRT(REG,J,WRK,1,8,2,2)
        CALL PAKRG(WRK,WXY)
        CALL NUMOUT(WXY,DIGITS,H)
        DO 1854 J=1,6
1854    DIG4(I,J)=DIGITS(J)
        WRITE (ITTO,56) ((DIG4(I,J),J=1,6 ),I=1,4)
        GO TO 1000
C
1893    CALL SPLIT (REG,FV)
        WRK(1)=0
        DO 1895 I=1,24
        WRK(2)=FV(I)
        CALL PAKRG(WRK,WXY)
        CALL NUMOUT(WXY,DIGITS,H)
        FD(I,1)=DIGITS(5)
1895    FD(I,2)=DIGITS(6)
        WRITE (ITTO,57) (F(1,I),F(2,I),FD(I,1),FD(I,2), I=1,24)
        GO TO 1000
C
C       RE-EXAMINE CURRENT LOCATION: "."
1900    IF (OPN.LT.1.OR.OPN.GT.NREG) GO TO 1012
1910    IF (OPN.GT.NMEM) GO TO 1950
1920     WXY=LOCV
C        IF EXAMINING PS SUBTRACT OFFSET FROM LOCATION FOR TYPEOUT
         IF (OPN.EQ.1) WXY=WXY-OFF
        CALL NUMOUT(WXY,DIGITS,H)
        WRITE (ITTO,53) N(1,OPN),N(2,OPN),(DIGITS(I),I=1,6)
        GO TO 1820
1950    WRITE (ITTO,53) N(1,OPN),N(2,OPN)
        GO TO 1830
C
C       INCREMENT LOCATION: "+"
2000    IF (OPN.LT.1.OR.OPN.GT.NMEM) GO TO 1012
         LOCV=LOCV+1
        GO TO 1920
C
C       DECREMENT LOCATION: "-"
2100    IF (OPN.LT.1.OR.OPN.GT.NMEM) GO TO 1012
         LOCV=LOCV-1
         GO TO 1920
C
C       IORST FLAG: "I" <#>
2200     IORST=1
        GO TO 1000
C
C       CHANGE  CURRENT LOCATION : "C" <VALUE>
2300    IF (OPN.LT.1.OR.OPN.GT.NREG) GO TO 1012
        GO TO (2301,2302,2303), TYP
C
C        OCTAL INPUT
2301     CALL IREAD(DEC,H,ITTI,ITTO)
C        IF CHANGING PSA ADD OFFSET
         IF (OPN.EQ.NMEM+4) DEC=DEC+OFF
        CALL UNPKRG(DEC,WRK)
        CALL MOVPRT(WRK,1,REG,1,2,8,2)
        GO TO 2400
C
C       FLOATING POINT INPUT
2302    IF (FP.NE.0) GO TO 2352
C       INPUT AS 3 OCTAL INTEGERS: EXP, HMAN, LMAN
        DO 2332 I=1,3
         CALL IREAD(DEC,H,ITTI,ITTO)
        CALL UNPKRG(DEC,WRK)
        J=I*2-1
2332    CALL MOVPRT(WRK,1,REG,J,2,8,2)
        GO TO 2400
C       INPUT AS A FLOATING POINT NUMBER
2352     CALL FREAD(DECFP,ITTI,ITTO)
        CALL FPINPT(DECFP,REG)
        GO TO 2400
C
C       PROGRAM SOURCE INPUT
2303    IF (FIE.NE.0) GO TO 2453
C       INPUT AS 4 OCTAL INTEGERS
        DO 2304 I=1,4
         CALL IREAD(DEC,H,ITTI,ITTO)
        CALL UNPKRG(DEC,WRK)
        J=I*2-1
2304    CALL MOVPRT(WRK,1,REG,J,2,8,2)
C
2400    IF (OPN.GT.NMEM) GO TO 2420
        GO TO (2401,2402,2403,2404,2405,2406,2407,2408), OPN
2401    CALL PSMEM(2,LOCV,REG)
        GO TO 1000
2402    CALL MDMEM(2,LOCV,REG)
        GO TO 1000
2403    CALL TMMEM(2,LOCV,REG)
        GO TO 1000
2404    CALL MWRIT(REG,DPX,LOCV,DPSIZE,6,3)
        GO TO 1000
2405    CALL MWRIT(REG,DPY,LOCV,DPSIZE,6,3)
        GO TO 1000
2406    CALL MWRIT(REG,IODEV,LOCV,IOSIZE,6,3)
        GO TO 1000
2407    CALL MWRIT(REG,SP,LOCV,SPSIZE,2,1)
        GO TO 1000
2408    CALL MWRIT(REG,SRS,LOCV,16,2,1)
        GO TO 1000
C
2420    CALL MOVPRT (REG,1,APREG,L(OPN-NMEM),8,112,(TYP-1)*4+2)
        GO TO 1000
C
C
2453    CALL PSMEM(1,LOCV,REG)
         CALL AREAD(IA,2,ITTI,ITTO)
        DO 2500 I=1,41
         IF (IA(1).EQ.F(1,I).AND.IA(2).EQ.F(2,I))  GO TO 2520
2500    CONTINUE
        GO TO 1012
2520     CALL IREAD(DEC,H,ITTI,ITTO)
        CALL UNPKRG(DEC,WRK)
        J=WRK(2)
        CALL INCODE(J,I,REG)
        GO TO 2400
C
C       ZERO OUT USER MEMORIES: "Z"
C
3000    CALL PSMEM(0,0,0)
        CALL MDMEM(0,0,0)
        CALL TMMEM(0,0,0)
        DO 3013 I=1,DPSIZE
        DO 3013 J=1,3
        DPX(I,J)=0
3013    DPY(I,J)=0
        DO 3014 I=1,SPSIZE
3014    SP(I,1)=0
        DO 3015 I=1,IOSIZE
        DO 3015 J=1,3
3015    IODEV(I,J)=0
        DO 3016 I=1,16
3016    SRS(I,1)=0
        DO 3020 I=1,118
3020    APREG(I)=0
        DO 3021 I=1,70
3021    EXTRA(I)=0
        DO 3023 I=1,16
3023    IOINT(I)=0
        INTTYP(1)=0
        INTTYP(2)=0
        GO TO 1000
C  *****NEW FPS100
C
C       SET MODE OF FPSSIM: "U"
C       FORMAT: U  <CR>                 WHERE
C               I1 <CR>         = 1/0   SETS SUPERVISOR/USER MODE
C               I2 <CR>         = 1/0   SETS UNIVERSAL INT. ENABLE/INHIBIT
C               I3 <CR>         = 1/0   SETS SUPERVISOR MEM ADR REG/USER MAR
3100    CALL IREAD (I1,10,ITTI,ITTO)
        IF (I1.NE.0 .AND. I1.NE.1) GO TO 1012
        CALL IREAD (I2,10,ITTI,ITTO)
        IF (I2.NE.0 .AND. I2.NE.1) GO TO 1012
        CALL IREAD (I3,10,ITTI,ITTO)
        IF (I3.NE.0 .AND. I3.NE.1) GO TO 1012
C       SET BITS IN APSTAT2
        CALL LAND (3,APREG(107),APREG(107),1)
        APREG(107) = APREG(107) + (I1*4 + I2*2 + I3)*4
        GO TO 1000
C
C       IO INTERRUPT COMMAND: "A"
C       FORMAT: A   <CR>
C               I1  <CR>        = DEVICE INDEX (0-17)
C               I2  <CR>        = PSA AT WHICH INT. IS TO OCCUR
C       IF ATTEMPT TO ASSIGN MORE THAN MAX NO. OF INTERRUPTS, ERROR.
3200    CALL IREAD (I1,H,ITTI,ITTO)
        IF (I1.LT.0 .OR. I1.GT.15) GO TO 1012
        CALL IREAD (I2,H,ITTI,ITTO)
        I2 = I2+OFF
C       IOBKPT TABLE HAS FORM: IOBKPT(I,1) = DEVICE INDEX
C                              IOBKPT(I,2) = PSA
        IF (NIOBPT.EQ.6) GO TO 1012
        NIOBPT = NIOBPT+1
        IOBKPT(NIOBPT,1) = I1
        IOBKPT(NIOBPT,2) = I2
        GO TO 1000
C  *****NEW END FPS100
C
C       RADIX(IN DECIMAL):   "H" <RADIX>
4000     CALL IREAD(I,10,ITTI,ITTO)
         IF (I.NE.8.AND.I.NE.10.AND.I.NE.16) GO TO 1012
        H=I
         GO TO 1000
C
C
C
C        LOAD OFFSET REGISTER: "O" #
C        THE OFFSET IS APPLIED TO PSA AND PS ADDRESSES
4100     CALL IREAD(OFF,H,ITTI,ITTO)
         GO TO 1000
C
C
C        SET MEMORY SPEED, 1 OR 2 CYCLE MEMORY: "M" <1 OR 2>
4200     CALL IREAD(I,10,ITTI,ITTO)
         IF (I.NE.1.AND.I.NE.2) GO TO 1012
         MEMSPD=I
         GO TO 1000
C
C       "X" EXIT HERE
4300    STOP
C
C       TYPE OUT TIME: "T"
4400    FPN=CYCLES/CLOCK
        WRITE(ITTO,76) FPN
        GO TO 1000
C
C
C       YANK DATA FROM A FILE: "Y" <TYPE> <LOC>
C       WRITE DATA TO A FILE: "W" <TYPE> <START LOC> <END LOC>
C
5000     CALL AREAD(IA,2,ITTI,ITTO)
C       SEE WHICH MEMORY TO READ OR WRITE
        DO 5010 J=1,3
         IF (IA(1).EQ.N(1,J).AND.IA(2).EQ.N(2,J)) GO TO 5015
5010    CONTINUE
        GO TO 1012
C       GET STARTING LOC
5015     CALL IREAD(IV,H,ITTI,ITTO)
C        ADD OFFSET IF PS
         IF (J.EQ.1) IV=IV+OFF
        IF (I.EQ.18) GO TO 5020
C       GET END LOC FOR WRITE
         CALL IREAD(DEC,H,ITTI,ITTO)
        ICNT=DEC-IV+1
         IF (J.EQ.1) ICNT=ICNT+OFF
        IF (ICNT.LE.0) GO TO 1012
C
C
C       GET A FILE
C
C       "GTFIL" ACCEPTS THE USER'S FILE NAME FROM THE CONSOLE, GETS
C         A CHANNEL NUMBER FROM THE SYSTEM AND PUTS IT INTO "ISL", AND
C         FINALLY ATTACHES THE DESIRED FILE NAME TO "ISL"
5020    ISL=9
        CALL GTFIL(ISL,ITTI,ITTO)
C
        IF (I.EQ.19) GO TO 6100
C
C       YANK
C       GET COUNT
        READ(ISL,5310,END=5900) FPN
991     ICNT=INT(FPN)
C       SET LOWER AND UPPER LIMITS
        II=IV+1
        JJ=II+ICNT-1
C
        IF (J.GE.2) GO TO 5300
C
C       INPUT PS
C       WE READ NUMBERS IN AS IF THEY WERE FLOATING POINT, TO AVOID
C         PROBLEMS WITH -32768
        DO 5160 I=II,JJ
        READ(ISL,5115) (FPN4(K),K=1,4)
        DO 5150 K=1,4
        FF=FPN4(K)
        IF  (FF-32768.0) 5140,5120,5130
5120    KK=-32767-1
        GO TO 5145
5130    FF=FF-65536.0
5140    KK=INT(FF)
C
5145    CALL UNPKRG(KK,WRK)
        J=K*2-1
5150    CALL MOVPRT(WRK,1,REG,J,2,8,2)
C
5160    CALL PSMEM(2,I-1,REG)
         GO TO 5900
C
C       INPUT MD OR TM
5300    DO 5350 I=II,JJ
           IF (FP .NE. 0) GO TO 5305
           READ(ISL,17) (RREG(JO1),JO1=1,3)
17         FORMAT(1X,3(F6.0,2X))
        DO 15150 K=1,3
        FF=RREG(K)
        IF  (FF-32768.0) 15140,15120,15130
15120    KK=-32767-1
        GO TO 15145
15130    FF=FF-65536.0
15140    KK=INT(FF)
C
15145    CALL UNPKRG(KK,WRK)
        J=K*2-1
15150    CALL MOVPRT(WRK,1,REG,J,2,8,2)
         IF(J.NE.3)CALL MDMEM(2,I-1,REG)
         IF(J.EQ.3)CALL TMMEM(2,I-1,REG)
         GO TO 5350
C
5305       CONTINUE
C
         READ(ISL,5310) DECFP
5310     FORMAT(G17.0)
        CALL FPINPT(DECFP,REG)
        IF (J.EQ.3) GO TO 5320
        CALL MDMEM(2,I-1,REG)
        GO TO 5350
5320    CALL TMMEM(2,I-1,REG)
5350    CONTINUE
         READ(ISL,5310,END=5900) FPN
         IV=IV+ICNT
         GO TO 991
C
C       "G" COMMAND - GET APLOAD OUTPUT INTO FPSSIM MEMORY
C
5400    CALL LODINP(ITTI,ITTO)
        GO TO 1000
C
C
C-----------------------------
C       HERE WE RELEASE THE FILE WE HAVE BEEN USING
5900    CALL CLFIL(ISL,ITTO)
        GO TO 1000
C
C       WRITE OUT DATA
6100    IF (J.GE.2) GO TO 6300
C       WRITE OUT PS
        WRITE(ISL,74) ICNT
        DO 6150 I=1,ICNT
C        SUBTRACT OFFSET FROM LOCATION FOR TYPEOUT
         WXY=IV-OFF
        CALL NUMOUT(WXY,DIGITS,H)
        DO 6110 J=1,6
6110    DIG4(5,J)=DIGITS(J)
        CALL PSMEM(1,IV,REG)
        DO 6120 K=1,4
        J=K*2-1
        CALL MOVPRT(REG,J,WRK,1,8,2,2)
        CALL PAKRG(WRK,WXY)
        CALL NUMOUT(WXY,DIGITS,H)
        DO 6120 J=1,6
6120    DIG4(K,J)=DIGITS(J)
        WRITE(ISL,71) ((DIG4(K,J),J=1,6 ),K=1,5)
        IV=IV+1
6150    CONTINUE
        GO TO 5900
C
C       WRITE OUT MD OR TM
6300    WRITE(ISL,74) ICNT
        DO 6330 IIJ=1,ICNT
        CALL NUMOUT(IV ,DIGITS,H)
        IF (J.EQ.3) GO TO 6305
        CALL MDMEM(1,IV,REG)
        GO TO 6306
6305    CALL TMMEM(1,IV,REG)
6306    IF (FP.NE.0) GO TO 6310
C       OUTPUT AS 3 6-DIGIT OCTAL NUMBERS
        DO 6307 J=1,6
6307    DIG4(4,J)=DIGITS(J)
        DO 6308 I=1,3
        J=I*2-1
        CALL MOVPRT(REG,J,WRK,1,8,2,2)
        CALL PAKRG(WRK,WXY)
        CALL NUMOUT(WXY,DIGITS,H)
        DO 6308 J=1,6
6308    DIG4(I,J)=DIGITS(J)
        WRITE (ISL,59) ((DIG4(I,J),J=1,6 ),I=1,4)
        GO TO 6330
C
6310    CALL FPOUT(REG,DECFP,MAXEX,IOV)
        IF (IOV.EQ.1) GO TO 6320
        WRITE(ISL,72) DECFP,(DIGITS(K),K=1,6)
        GO TO 6330
6320    WRITE(ISL,73) (DIGITS(K),K=1,6 )
        WRITE(ITTO,73) (DIGITS(K),K=1,6)
6330    IV=IV+1
        GO TO 5900
C
C
50      FORMAT (2H *)
51      FORMAT (2H ?)
52      FORMAT (5H PSA=, 6A1, F11.2,4H US.)
53      FORMAT (1X,2A2,2X, 6A1)
54       FORMAT(13H OUT OF RANGE)
55      FORMAT (1X,G17.10)
56      FORMAT (1X,4(6A1,2X))
57      FORMAT (6(4X,2A2,1X,2A1))
58      FORMAT(1X,2HIO,2X,2A1,2X,6A1)
59      FORMAT(1X,3(6A1,2X),1H",6A1)
60      FORMAT(' SIM100   REL.  1.00 , 09/01/79')
71      FORMAT(1X,4(6A1,2X),1H",6A1)
72      FORMAT(G17.10,4X,1H",6A1)
73      FORMAT (1X, '  OUT OF RANGE "',6A1)
 74     FORMAT(1X,I6,1H.)
76      FORMAT(F11.2,4H US.)
5115    FORMAT(1X,4(F6.0,2X))
        END
C+++ DBGSYM
C****** DBGSYM = SIM100 BLOCK DATA = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 19:56:22
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE DBGSYM
C
        INTEGER C(26),N(2,41),F(2,41),T(41),L(33)
        COMMON /Q/C,N,F,T,L
        COMMON /IDTB/ IBLNK,INSIGN,IPSIGN,IPOINT,IEXP,IDB(16)
C
C---------------------------------------------------------------------------
C
C       SET SIZE OF PS, MD, AND IODEV
C       FIND SIZE OF TM IN 'TMROM' BLOCK DATA
C
        INTEGER PS(512,4),PSSIZE
        COMMON /PSRM/ PS,PSSIZE
C
C       PSSIZE IS THE SIZE OF P.S.  IT MUST AGREE WITH THE 1ST DIMENSION OF
C       ARRAY 'PS'
C
C
        INTEGER MD(512,3),PAGNUM,PAGSIZ
        COMMON /MDRM/ MD,PAGNUM,PAGSIZ
C
C       'MD' IS DIVIDED INTO 'PAGNUM' PAGES, EACH 'PAGSIZ' LOCATIONS LONG
C       THE PRODUCT OF 'PAGNUM' TIMES 'PAGSIZ' MUST EQUAL THE 1ST DIMENSION
C       OF ARRAY 'MD'
C
C
        INTEGER IODEV(64,3),IOSIZE,INTTYP(2),IOINT(16),
     1          IOBKPT(6,2),NIOBPT,TMSPEC(6)
        COMMON /IORM/ IODEV,IOSIZE,INTTYP,IOINT,IOBKPT,NIOBPT,TMSPEC
C
C
        DATA PSSIZE /  512 /
C
        DATA PAGNUM / 1 /
        DATA PAGSIZ /  512 /
C
        DATA IOSIZE / 64 /
C
C---------------------------------------------------------------------
C
C       COMMANDS
        DATA C(1),C(2),C(3),C(4),C(5),C(6),C(7),C(8),C(9),C(10),C(11),
     1C(12),C(13),C(14),C(15),C(16),C(17),C(18),C(19),C(20),C(21),C(22),
     2C(23),C(24),C(25)/
     32HR ,2HQ ,2HB ,2HD ,2HS ,2HF ,2HV ,2HL ,2HE ,2H. ,
     42H+ ,2H- ,2HI ,2HC ,2HP ,2HZ ,2HN ,2HY ,2HW ,2HO ,2HM ,2HX ,
     52HT ,2HU ,2HA /
        DATA C(26)/2HG /
C       MEMORY AND REGISTER NAMES
        DATA N(1,1),N(2,1),N(1,2),N(2,2),N(1,3),N(2,3),N(1,4),N(2,4),
     1N(1,5),N(2,5),N(1,6),N(2,6),N(1,7),N(2,7),N(1,8),N(2,8),
     2N(1,9),N(2,9),N(1,10),N(2,10),N(1,11),N(2,11),N(1,12),
     3N(2,12),N(1,13),N(2,13),N(1,14),N(2,14),N(1,15),N(2,15),
     4N(1,16),N(2,16),N(1,17),N(2,17),N(1,18),N(2,18),N(1,19),
     5N(2,19),N(1,20),N(2,20)/
     62HPS,2H  ,2HMD,2H  ,2HTM,2H  ,2HDP,2HX ,2HDP,2HY ,
     72HIO,2H  ,2HSP,2H  ,2HSR,2HS ,2HMA,2H  ,2HTM,2HA ,
     82HDP,2HA ,2HPS,2HA ,2HSP,2HD ,2HST,2HAT,2HDA,2H  ,
     92HSW,2HCH,2HLG,2HTS,2HMD,2HR ,2HTM,2HR ,2HMI,2H  /
        DATA N(1,21),N(2,21),N(1,22),N(2,22),N(1,23),N(2,23),N(1,24),
     1N(2,24),N(1,25),N(2,25),N(1,26),N(2,26),N(1,27),N(2,27),
     2N(1,28),N(2,28),N(1,29),N(2,29),N(1,30),N(2,30),N(1,31),N(2,31),
     3N(1,32),N(2,32)/
     42HDP,2HBS,2HIN,2HBS,2HPN,2HBS,2HSP,2HFN,2HFL,2HAG,
     52HSR,2HA ,2HFA,2H  ,2HFM,2H  ,2HM1,2H  ,2HM2,2H  ,
     62HA1,2H  ,2HA2,2H  /
C       FPS100 REGISTERS
        DATA N(1,33),N(2,33),N(1,34),N(2,34),N(1,35),N(2,35),
     1       N(1,36),N(2,36),N(1,37),N(2,37),N(1,38),N(2,38),
     2       N(1,39),N(2,39),N(1,40),N(2,40),N(1,41),N(2,41)/
     3       2HDP,2HIX, 2HDP,2HIY, 2HSM,2HA , 2HST,2H2 , 2HST,2H3 ,
     4       2HIM,2HSK, 2HCC,2HTR, 2HCC,2HST, 2HCC,2HTL/
C       DATA TYPES, 1=16-BIT, 2=38-BIT, 3=64-BIT
        DATA T(1),T(2),T(3),T(4),T(5),T(6),T(7),T(8),T(9),T(10),
     1T(11),T(12),T(13),T(14),T(15),T(16),T(17),T(18),T(19),T(20),
     2T(21),T(22),T(23),T(24),T(25),T(26),T(27),T(28),T(29),T(30),
     3T(31),T(32),T(33),T(34),T(35),T(36),T(37),T(38),T(39),T(40),
     4T(41)/
     53,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,1,1,1,
     62,2,2,2,2,2,2,2,1,1,1,1,1,1,1/
C       PROGRAM SOURCE FIELD NAMES
        DATA F(1,1),F(2,1),F(1,2),F(2,2),F(1,3),F(2,3),F(1,4),F(2,4),
     1F(1,5),F(2,5),F(1,6),F(2,6),F(1,7),F(2,7),F(1,8),F(2,8),F(1,9),
     2F(2,9),F(1,10),F(2,10),F(1,11),F(2,11),F(1,12),F(2,12),F(1,13),
     3F(2,13),F(1,14),F(2,14),F(1,15),F(2,15),F(1,16),F(2,16),F(1,17),
     4F(2,17),F(1,18),F(2,18),F(1,19),F(2,19),F(1,20),F(2,20)/
     52HD ,2H  ,2HSO,2HP ,2HSH,2H  ,2HSP,2HS ,2HSP,2HD ,
     62HFA,2HDD,2HA1,2H  ,2HA2,2H  ,2HCO,2HND,2HDI,2HSP,
     72HDP,2HX ,2HDP,2HY ,2HDP,2HBS,2HXR,2H  ,2HYR,2H  ,
     82HXW,2H  ,2HYW,2H  ,2HFM,2H  ,2HM1,2H  ,2HM2,2H  /
        DATA F(1,21),F(2,21),F(1,22),F(2,22),F(1,23),F(2,23),F(1,24),
     1F(2,24),F(1,25),F(2,25),F(1,26),F(2,26),F(1,27),F(2,27),
     2F(1,28),F(2,28),F(1,29),F(2,29),F(1,30),F(2,30),F(1,31),
     3F(2,31),F(1,32),F(2,32),F(1,33),F(2,33),F(1,34),F(2,34),F(1,35),
     4F(2,35),F(1,36),F(2,36),F(1,37),F(2,37),F(1,38),F(2,38),F(1,39),
     5F(2,39),F(1,40),F(2,40),F(1,41),F(2,41)/
     62HMI,2H  ,2HMA,2H  ,2HDP,2HA ,2HTM,2HA ,2HSO,2HP1,
     72HSP,2HEC,2HST,2HST,2HHP,2HNL,2HSP,2HSA,2HPS,2HEV,
     82HPS,2HOD,2HPS,2H  ,2HSE,2HXT,2HFA,2HD1,2HIO,2H  ,
     92HLR,2HEG,2HRR,2HEG,2HIO,2HUT,2HSN,2HSE,2HFL,2HAG,
     82HCO,2HNT/
C       POINTERS TO AP REGISTERS IN COMMON ARRAY APREG
        DATA L(1),L(2),L(3),L(4),L(5),L(6),L(7),L(8),L(9),L(10),
     1L(11),L(12),L(13),L(14),L(15),L(16),L(17),L(18),L(19),L(20),
     2L(21),L(22),L(23),L(24),L(25),L(26),L(27),L(28),L(29),L(30),
     3L(31),L(32),L(33)/
     41,3,5,7,9,11,13,15,17,19,25,31,37,43,49,
     551,53,55,57,63,69,75,81,87,93,99,105,107,109,111,113,115,117/
C
C       ARRAY OF DIGITS FOR IREAD,FREAD,AND NUMOUT
        DATA IBLNK,INSIGN,IPSIGN,IPOINT,IEXP,IDB(1),IDB(2),IDB(3),
     1  IDB(4),IDB(5),IDB(6),IDB(7),IDB(8),IDB(9),IDB(10),IDB(11),
     2  IDB(12),IDB(13),IDB(14),IDB(15),IDB(16)/
     3  2H  ,2H- ,2H+ ,2H. ,2HE ,2H0 ,2H1 ,2H2 ,2H3 ,2H4 ,2H5 ,2H6 ,
     4  2H7 ,2H8 ,2H9 ,2HA ,2HB ,2HC ,2HD ,2HE ,2HF /
        END
C
C+++ APSIM
C****** APSIM = FPS100 SIMULATOR = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 19:57:13
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
         SUBROUTINE APSIM
C
C------------------------------------------
C
C       THIS IS A SUBROUTINE WHICH PROVIDES (HOPEFULLY) A NEARLY
C       EXACT SIMULATION OF THE INTERNAL DATA TRANSFERS OF
C       THE AP-120B
C
C       IT IS CALLED BY THE AP-DEBUG PROGRAM WHENEVER THE
C       USER REQUESTS PROGRAM EXECUTION
C
C       ALL COMMUNICATION WITH APDBUG IS THROUGH VARIOUS COMMON ARRAYS
C
C       THE DEBUG DEPOSITS AND EXAMINES DIRECTLY INTO THE INTERNAL
C               REGISTERS AND MEMORIES THROUGH COMMON
C
C       ALL INTERNAL REGISTERS ARE SIMULATED BY STRINGS OF
C               EIGHT BIT BYTES
C       THIS IS DONE TO AVOID PROBLEMS WITH THE LEFT MOST BIT
C               OF 16-BIT AND LONGER REGISTERS WHEN USING
C               MINI-COMPUTER FORTRANS WITH 16-BIT INTEGERS
C
C       ALL ARITHMETIC IS SUMULATED TO AGREE TO THE LSB (INCLUDING
C               ROUNDING) WITH THE HARDWARE
C
C       SIMILARLY, THE MEMORY TIMING AND OPERATION
C               OF THE ARITHMETIC PIPELINES IS DUPLICATED EXACTLY
C
C       THIS IS POSSIBLE SIMCE THE AP-120B HARDWARE IS TOTALLY
C               SINCHRONOUS, WITH EVERYTHING BEING DRIVEN BY ONE
C               167 NS.  CLOCK
C
C-----------------------------------------------------------------------
C
C
C
C
C
C       INDEX
C
C       00000   INITIALIZE
C       10000   DECODE CB
C       11000   BRANCH CONDITIONS
C       12000   FETCH DPX,DPY,TM,MD,FA,FM
C       13000   COMPUTE SPFN
C
C       20000   BUS SELECTS
C       21000   REGISTERS TO PANEL BUS
C       22000   IODEVICES TO INBS
C       23000   DPBS SELECT
C         100           PS TO DPBS
C         200           SWITCHES TO PNLBS TO DPBS
C         300           DB FIELD
C       24000   MORE PANEL BUS ENABLE
C         100           DB TO PNLBS TO LIGHTS
C         200           PS TO PNLBS TO LIGHTS
C                               AND SWITCHES TO PNLBS TO PS
C       25000   DPBS TO PS
C       26000   SET EXIT
C
C       30000   UPDATE STATUS, MA,TMA,DPA, AND GENERAL FLAGS
C       31000   STORE INTO SPDR
C       32000   I/O GROUP FIELDS
C         100           STORE INTO REGISTERS
C         200           OUTPUT TO IODEVICES
C         300           SENSE
C         400           FLAGS
C         500           CONTROL
C       33000   WRITE DPX,DPY
C       34000   FMUL
C       35000   FADD
C
C       40000   TM FETCH
C       41000   MD CYCLE
C
C       50000   JMP AND JSR
C       60000   CHECK FOR BREAKPOINTS
C
C
C
C
C       REGISTER AND; MEMORY BIT LAYOUTS
C
C       16-BITS(S-PAD,ETC.)'
C               MEMORIES'       1 16-B=IT WORD
C               REGISTERS'      2 8-BIT BYTES
C
C       38-BITS(DP,MD,TM, ETC.)'G
C               MEMORIES'       1 10-BIT WORD (EXPONENT)
C                               1 12-BIT WORD (HIGH MANTISSA)
C                               1 16-BIT WORD (LOW MANTISSA)
C               REGISTERS'      2 8-BIT BYTES (EXPONENT)
C                               4 8-BIT BYTES (MANTISSA)
C
C       64 BITS(PS)'
C               MEMORY'         4 16-BIT WORDS
C               REGISTERS'      8 8-BIT BYTES
C
        INTEGER DPX(32,3),DPY(32,3),SP(16,1),SRS(16,1)
C
        INTEGER HALT
        INTEGER II
C
C       HALT WHEN HALT=1
C
C       MEMORY SIZES
        INTEGER DPSIZE,SPSIZE,MEMSPD
C       MEMORY BUFFERS
        INTEGER CB(8),MDR(6),MI(6),TMR(6),DPXR(6),DPYR(6),DPXW(6),
     1DPYW(6),SPSR(2),SPDR(2),SPFN(2),DPIB(6)
C       BUSES
        INTEGER INBS(6),DPBS(6),PNLBS(2)
C       REGISTERS
        INTEGER PSA(2),SPD(2),MA(2),TMA(2),DPA(2),STATUS(2),DA(2),
     1          FLAG(2),SWITCH(2),LIGHTS(2),SRA(2),SMA(2),STAT2(2),
     2          STAT3(2),IMASK(2),CCTR(2),CCST(2),CCTL(2),NWSTAT(2),
     3          NWFLAG(2),PSFLD
C       REGISTER VALUES
        INTEGER PSAV,XRA,YRA,XWA,YWA,SPDV,SRAV,TMAV,MAV
C       MULTIPLIER PIPELINE
        INTEGER M1(6),M2(6),FMB1(7),FMB2(7),FMB3(7),FM(6)
C       ADDER PIPELINE
        INTEGER A1(6),A2(6),FAB1(7),FAB2(7),FA(6)
C       MEMORY PIPELINES
        INTEGER TMB1(6),TMB2(6),MDB1(7),MDB2(7),MDB3(7)
C       PROGRAM FLAGS
        INTEGER WRTN,WRTL,BRANCH,LDSPD,PSPTR,THISBK,LASTBK,
     1          FPERR,FACOND,SPCOND,IVAL,TMAW,TWOCYC,SMODE,MAMODE,
     2          RDPI,FPAFLG,ST3FLG,CLKSET,CLKFIX,CLKINT
C       CONSTANTS
        INTEGER ONE2(2),MONE2(2),ZERO2(2),ZERO6(6),M21(2),
     1P512(2),M512(2)
C       TEMPORARY STORAGE
        INTEGER TA2(2),TB2(2),TA(6),PST(8),PSCOMP(2),TA4(4),
     1          AMA(2),IMA(2),DPXW1(6),DPYW1(6)
        REAL CYCLES,CLCK,CLKCYC
C       BREAKPOINTS
         INTEGER BRKTYP,BRKLOC
C       PS FIELDS
        INTEGER FV(24)
        INTEGER DF,SOPF,SHF,SPSF,SPDF,FADDF,A1F,A2F,
     1CONDF,DISPF,DPXF,DPYF,DPBSF,XRF,YRF,XWF,YWF,
     2FMF,M1F,M2F,MIF,MAF,TMAF,DPAF,VALUE(2)
         INTEGER EXTRA(14)
        INTEGER IODEV(64,3),IOSIZE,INTTYP(2),IOINT(16),
     1          IOBKPT(6,2),NIOBPT,TMSPEC(6)
        COMMON /IORM/ IODEV,IOSIZE,INTTYP,IOINT,IOBKPT,NIOBPT,TMSPEC
        COMMON DPX,DPY,SP,SRS,MA,TMA,DPA,PSA,
     1SPD,STATUS,DA,SWITCH,LIGHTS,
     2MDR,TMR,MI,DPBS,INBS,PNLBS,SPFN,FLAG,SRA,
     3FA,FM,M1,M2,A1,A2,DPXW,DPYW,SMA,STAT2,STAT3,IMASK,CCTR,CCST,CCTL,
     4BRKTYP,BRKLOC,CYCLES,CLCK,MEMSPD,
     5DPSIZE,SPSIZE,
     6IORST,IHLT,
     7THISBK,LDSPD,MDB1,MDB2,MDB3,FMB1,FMB2,FMB3,
     8FAB1,FAB2,TMB1,TMB2,EXTRA
        INTEGER TM(512,3),RAMSIZ,TRIGSZ,HFFTSZ,SFFTSZ,RAMBAS
        INTEGER IHOLD(11)
        COMMON /SPCOM/ IHOLD
        COMMON /TMRM/ TM,RAMSIZ,TRIGSZ,HFFTSZ,SFFTSZ,RAMBAS
        COMMON /FVV/ FV
        EQUIVALENCE (FV(1),DF),(FV(2),SOPF),(FV(3),SHF),(FV(4),SPSF)
     1,(FV(5),SPDF),(FV(6),FADDF),(FV(7),A1F),(FV(8),A2F)
     2,(FV(9),CONDF),(FV(10),DISPF),(FV(11),DPXF),(FV(12),DPYF)
     3,(FV(13),DPBSF),(FV(14),XRF),(FV(15),YRF),(FV(16),XWF)
     4,(FV(17),YWF),(FV(18),FMF),(FV(19),M1F),(FV(20),M2F)
     5,(FV(21),MIF),(FV(22),MAF),(FV(23),DPAF),(FV(24),TMAF)
C
C
C
C       INITIALIZE
C
        DO 50 I=1,6
50      ZERO6(I)=0
        CALL RMOV(FLAG,NWFLAG,2)
        IF (IORST.EQ.0) GO TO 90
        LDSPD=0
        RDPI=0
        FMB1(7)=0
        FMB2(7)=0
        FMB3(7)=0
        FAB1(7)=0
        FAB2(7)=0
        MDB1(7)=0
        MDB2(7)=0
        MDB3(7)=0
        DO 55 I=1,2
                STATUS(I)=0
                STAT2(I)=0
                STAT3(I)=0
                SRA(I)=0
                CCTR(I)=0
                CCST(I)=0
                CCTL(I)=0
                INTTYP(I)=0
55      CONTINUE
        DO 60 I=1,16
60      IOINT(I)=0
        CLKINT=0
        CLKFIX=0
        CLKSET=0
        CLKCYC=0.0
C
C       CLEAR PAGE SELECT
        DO 70 I=24,26
        II = I
70      CALL MWRIT(ZERO6,IODEV,II,IOSIZE,6,3)
90      HALT=IHLT
        DO 110 I=1,2
        ZERO2(I)=0
110     MONE2(I)=255
        ONE2(1)=0
        ONE2(2)=1
        M21(1)=255
        M21(2)=239
        P512(1)=2
        P512(2)=0
        M512(1)=254
        M512(2)=0
C
C
C
C       FETCH A WORD OF PROGRAM SOURCE
C
10000   PSAV=MOD(PSA(1),16)*256+PSA(2)
C  *****NEW FPS100
C
C       SET FLAGS FOR SUPERVISOR MODE (SMODE) AND MEMORY
C       ADDRESS MODE (MAMODE), DEPENDING ON STATUS2 REGISTER
        SMODE = MOD (STAT2(1)/16,2)
        MAMODE = MOD (STAT2(1)/4,2)
C
C       SET ACTIVE MEMORY ADDRESS REGISTER (AMA) TO MA OR SMA, DEPENDING
C       ON MODE.  SET INACTIVE MEMORY ADDRESS REGISTER (IMA) TO THE
C       OTHER MEMORY REGISTER.
C       (NOTE CORRESPONDING RESTORE CODE AT LOCATION 60010)
        IF (MAMODE.EQ.1) GO TO 10010
                CALL RMOV (MA,AMA,2)
                CALL RMOV (SMA,IMA,2)
                GO TO 10020
10010   CALL RMOV (SMA,AMA,2)
        CALL RMOV (MA,IMA,2)
C
C       IF CLOCK INTERRUPT CONDITION FROM PREVIOUS CYCLE, CAUSE
C       INTERRUPT.  INCREMENT CLOCK.
10020   IF (CLKINT.EQ.1) CALL INTRPT(1,8)
        IF (CLKSET.EQ.1)CLKCYC=0.0
        CALL CLOCK (CLKFIX,CLKSET,(CLKCYC+1.0)/CLCK,CCTR,CCST,CCTL,
     1              CLKINT)
C  *****NEW END FPS100
C
C
C        EXIT AFTER COMPLETING INSTRUCTION IF SENSE SWITCH IS ON
        CALL TERM(I)
        IF (I.NE.0) HALT=1
C       READ THE SENSE SWITCHES (OR WHATEVER THE COMPUTER HAS)
C         THE SUBROUTINE RETURNS A "1" IF THE USER WANTS TO STOP
C         EXECUTION, OTHERWISE A ZERO
C       WE DO THIS, SINCE FORTRAN HAS NO OTHER WAY FOR THE USER TO
C         SIGNAL US THAT HE WANTS OUT OF THE SIMULATOR ONCE HE HAS
C         GOTTEN IN.
C
C
        CALL PSMEM(1,PSAV,CB)
        WRTN=6
        WRTL=1
        TMAW=0
        IF(TWOCYC.GT.0)TWOCYC=TWOCYC-1
        ST3FLG=0
        INTTYP(1)=0
        CLKSET=0
        CLKFIX=0
C
C       DECODE COMMAND BUFFER
        CALL SPLIT (CB,FV)
        IVAL=0
C       SEE IF ANYBODY IS USING THE VALUE FIELD, IF SO SET A FLAG
C               TO DISABLE THE YX,FM,M1,M2,MA,TMA, AND DPA FIELDS
        IF ((SOPF.EQ.1.AND.SPSF.GE.8.AND.SPSF.LE.12.AND.
     1MOD(SPDF,8).LE.3).OR.
     2(DPBSF.EQ.2)) IVAL=1
C
        VALUE(1)=CB(7)
        VALUE(2)=CB(8)
C        IF WE ARE USING THE VALUE FIELD, SET YW TO XF
         IF (IVAL.EQ.1) YWF=XWF
C
C       TEST BRANCH CONDITIONS
C
C       BRANCH FIELD
C
        BRANCH=0
        I=CONDF+1
        INTRQ=1
        IODRDY=1
        FPERR=MOD(STATUS(1)/32,8)
        FACOND=MOD(STATUS(1)/8,4)
        SPCOND=MOD(STATUS(1),8)
        IF(SOPF.EQ.1.AND.SPSF.EQ.8)GO TO 12000
        GO TO (11500,11500,11102,11103,11104,11105,11106,
     111500,11110,11111,11112,11113,11114,11115,11116,11117),I
11102   BRANCH=1
         GO TO 11500
11103   IF(INTRQ.EQ.1) BRANCH=1
         GO TO 11500
11104   IF(IODRDY.EQ.1) BRANCH=1
         GO TO 11500
11105   IF(IODRDY.EQ.0) BRANCH=1
         GO TO 11500
11106   IF(FPERR.NE.0) BRANCH=1
         GO TO 11500
11110   IF(FACOND.EQ.2) BRANCH=1
         GO TO 11500
11111   IF(FACOND.NE.2) BRANCH=1
         GO TO 11500
11112   IF(MOD(FACOND,2).EQ.0) BRANCH=1
         GO TO 11500
11113   IF(FACOND.EQ.0) BRANCH=1
         GO TO 11500
11114   IF(SPCOND/2.EQ.2) BRANCH=1
         GO TO 11500
11115   IF(SPCOND/2.NE.2) BRANCH=1
         GO TO 11500
11116   IF(MOD(SPCOND/2,2).EQ.0) BRANCH=1
         GO TO 11500
11117   IF(SPCOND/2.EQ.0) BRANCH=1
         GO TO 11500
C
C       STEST FIELD (SOP=0, SPEC=0)
C
11500   IF(.NOT.(SOPF.EQ.1.AND.SPSF.EQ.0)) GO TO 12000
        I=SPDF+1
        GO TO (11600,11601,11602,11603,11604,11605,
     111606,11607,12000,12000,12000,12000,11614,11614,11614,11614),I
11600   IF(MOD(FACOND,2).EQ.1) BRANCH=1
        GO TO 12000
11601   IF(MOD(SPCOND/2,2).EQ.1) BRANCH=1
        GO TO 12000
11602   IF(MOD(SPCOND,2).EQ.1) BRANCH=1
        GO TO 12000
11603   IF (MOD(SPCOND,2).EQ.0) BRANCH=1
        GO TO 12000
11604   IF ( PSFLD .EQ. 1 ) GO TO 12000
        IF(MOD(DPBS(3)/8,2).EQ.1) BRANCH=1
        GO TO 12000
11605   IF(MOD(DPBS(3)/4,4).EQ.0) BRANCH=1
        IF ( PSFLD .EQ. 1 ) BRANCH=1
        GO TO 12000
11606   IF(MOD(STATUS(2)/16,2).EQ.1) BRANCH=1
        GO TO 12000
11607   IF(MOD(STATUS(2)/16,2).EQ.0) BRANCH=1
        GO TO 12000
11614   TA2(1)=0
        TA2(2)=2**MOD(SPDF,4)
        CALL LAND(TA2,FLAG,TA2,2)
        IF (TA2(2).NE.0) BRANCH=1
C       FETCH FROM DPX, DPY
12000   CONTINUE
        PSFLD=0
        XRA=MOD(DPA(2)+XRF+28,32)
        YRA=MOD(DPA(2)+YRF+28,32)
        XWA=MOD(DPA(2)+XWF+28,32)
        YWA=MOD(DPA(2)+YWF+28,32)
C  *****NEW FPS100
C       IF RDPI IN PREVIOUS CYCLE, USE DPAD WRITE BUFFER,
C       RATHER THAN DPAD MEMORY
        IF (RDPI.EQ.0) GO TO 12010
                RDPI = 0
                CALL RMOV (DPXW1,DPXR,6)
                CALL RMOV (DPYW1,DPYR,6)
                GO TO 12100
C  *****NEW END FPS100
12010   CALL MREAD(DPX,XRA,DPXR,DPSIZE,3,6)
        CALL MREAD(DPY,YRA,DPYR,DPSIZE,3,6)
C
C       FETCH TM FROM TMA OF 2 CYCLES EARLER
C
12100   CALL RMOV(TMB2,TMR,6)
C
C       FETCH MD FROM MA SET THREE CYCLES AGO IF A
C       READ WAS DONE THEN
C
C       SPIN ON MAIN DATA MEMORY BUSY
        IF (.NOT.((SOPF.EQ.1.AND.SPSF.EQ.2).OR.
     1          (FADDF.EQ.7.AND.A1F.EQ.2))) GO TO 12600
C       PUSH THE MEMORY PIPELINE UNTIL ALL ACTIVITY IS DONE
C  *****NEW FPS100
C       IF S-MODE, SKIP SPIN
        IF (SMODE.EQ.1) GO TO 12600
C  *****NEW END FPS100
12550   IF (MDB1(7).EQ.0.AND.MDB2(7).EQ.0) GO TO 12600
        CALL RMOV(MDB2,MDB3,7)
        CALL RMOV(MDB1,MDB2,7)
        MDB1(7)=0
        CYCLES=CYCLES+1.0
        CLKCYC=CLKCYC+1.0
        GO TO 12550
12600   IF(MDB3(7).EQ.1) CALL MOVPRT(MDB3,1,MDR,1,7,6,6)
C
C       GET FA, FM, AND UPDATE ERROR AND CONDITION BITS
C
        CALL MOVPRT(FAB2,1,FA,1,7,6,6)
        CALL MOVPRT(FMB3,1,FM,1,7,6,6)
C  *****NEW FPS100
C       IF SUPERVISOR MODE AND NEITHER FADD NOR FMUL, DON'T UPDATE
C       CONDITION BITS.
        IF (SMODE.EQ.1 .AND.
     1      (FADDF.EQ.7 .OR. (FADDF.EQ.0.AND.A1F.EQ.0)) .AND.
     2      (FMF.EQ.0 .OR. IVAL.EQ.1)) GO TO 13000
C  *****NEW END FPS100
        FACOND=MOD(FAB2(7),4)
        IF (FPERR.LT.4.AND.(FAB2(7).GE.16.OR.FMB3(7).GE.16))
     1FPERR=FPERR+4
        IF (MOD(FPERR/2,2).EQ.0.AND.(MOD(FAB2(7)/8,2).EQ.1.OR.
     1MOD(FMB3(7)/8,2).EQ.1)) FPERR=FPERR+2
C
C
C       S-PAD FUNCTIONS
C
C
C       FIRST GET THE SOURCE AND DESTINATION REG@S
C               (SPS AND SPD FIELDS)
13000   CONTINUE
        IXNOP=0
        IHOLD(6)=SPCOND
        IF(SOPF.EQ.1.OR.SOPF.EQ.0.AND.SPSF.LT.8) IXNOP=1
        IF (LDSPD.EQ.1) GO TO 13001
        SPD(1)=0
        SPD(2)=SPDF
13001   LDSPD=0
        IF(IXNOP.EQ.1)GO TO 20000
        SPDV=SPD(2)
        CALL MREAD(SP,SPSF,SPSR,SPSIZE,1,2)
        IF (DF.EQ.0) GO TO 13090
C       BIT INVERSE OF SP(SPS)
C       THE LAST THREE BITS OF THE STATUS REGISTER ARE THE RIGHT
C               SHIFT TO BE APPLIED TO THE RESULT OF THE
C               15-BIT WIDE NIT REVERSAL
        J=15-MOD(STATUS(2),8)
        CALL RMOV(SPSR,TA2,2)
        CALL RMOV(ZERO2,SPSR,2)
        CALL LSHFT(TA2,-1,2,0,K,K)
        DO 13050 I=1,J
        CALL LSHFT(SPSR,1,2,0,K,K)
        CALL LSHFT(TA2,-1,2,0,K,KC)
        IF (K.EQ.0) GO TO 13050
        CALL TCADD(ONE2,SPSR,SPSR,2,K)
13050   CONTINUE
        CALL LSHFT(SPSR,1,2,0,K,K)
C       GET SP(SPD)
13090   CALL MREAD(SP,SPDV,SPDR,SPSIZE,1,2)
        SPCOND=0
        I=SOPF+1
        GO TO (13100,20000,13102,13103,13104,13105,13106,13107),I
C
C       SINGLE OPERAND (SOP=0,SOP1=10-13)
C
13100   I=SPSF-7
        GO TO (13110,13111,13112,13113,13114,13114,13114,13114),I
13110   CALL RMOV(ZERO2,SPFN,2)
        GO TO 13800
13111   CALL TCADD(ONE2,SPDR,SPFN,2,SPCOND)
        GO TO 13800
13112   CALL TCADD(MONE2,SPDR,SPFN,2,SPCOND)
        GO TO 13800
13113   CALL LCOM(SPDR,SPFN,2)
        GO TO 13800
13114   CALL RMOV(SPDR,SPFN,2)
        GO TO 13800
C
C       DOUBLE OPERAND (SOP FIELD)
C
13103   CALL NEGATE(SPSR,2,K)
13102   CALL TCADD(SPDR,SPSR,SPFN,2,SPCOND)
        GO TO 13800
13104   CALL RMOV(SPSR,SPFN,2)
        GO TO 13800
13105   CALL LAND(SPDR,SPSR,SPFN,2)
        GO TO 13800
13106   CALL LCOM(SPDR,TA2,2)
        CALL LCOM(SPSR,TB2,2)
        CALL LAND(TA2,TB2,SPFN,2)
        CALL LCOM(SPFN,SPFN,2)
        GO TO 13800
13107   CALL LCOM(SPDR,TA2,2)
        CALL LAND(SPSR,TA2,TA2,2)
        CALL LCOM(SPSR,TB2,2)
        CALL LAND(SPDR,TB2,TB2,2)
        CALL TCADD(TA2,TB2,SPFN,2,K)
        CALL LCOM(SPFN,SPFN,2)
C
C       SHIFT IF CALLED FOR (SH FIELD)
C
13800   IF (SHF.EQ.0) GO TO 13850
        I=1
        IF (SHF.EQ.2) I=-2
        IF (SHF.EQ.3) I=-1
        CALL LSHFT(SPFN,I,2,0,SPCOND,K)
C
C       SET S-PAD CONDITION BITS AND STORE INTO DESTINATION REG
C               (UNLESS COND=1)
C
13850   CONTINUE
        DO 13860 KKK=1,4
          IHOLD(KKK)=FV(KKK)
13860   CONTINUE
        IHOLD(5)=SPD(2)
        IF (IXNOP .NE. 1) GO TO 13880
          SPCOND=IHOLD(6)
          DO 13870 KKK=1,5
            FV(KKK)=IHOLD(KKK+6)
13870     CONTINUE
          GO TO 20000
13880     CONTINUE
        IF(SPFN(1).GE.128) SPCOND=SPCOND+2
        IF(SPFN(1).EQ.0.AND.SPFN(2).EQ.0) SPCOND=SPCOND+4
        IF(CONDF.NE.1) CALL MWRIT(SPFN,SP,SPDV,SPSIZE,2,1)
C
C
C
C
C       BUSS SELECTS
C               FIRST TRY ENOUGH OF THE PANEL BUS ENABLES
C               SO THAT WE CAN SELECT ONTO THE DATA PAD BUS
C
C
20000   CALL RMOV(ZERO2,PNLBS,2)
        IF(FADDF.NE.7) GO TO 23000
C
C       REGISTERS TO PANEL BUS (FADD=7,I/O=1,(RDREG FIELD))
C
        IF(A1F.NE.1) GO TO 21500
        I=A2F+1
        GO TO (21100,21101,21102,21103,21104,21105,21106,21107),I
21100   CALL RMOV(PSA,PNLBS,2)
        GO TO 23000
21101   CALL RMOV(SPD,PNLBS,2)
        GO TO 23000
C  *****NEW FPS100
C       RMA
21102   CALL RMOV(AMA,PNLBS,2)
C  *****NEW END FPS100
        GO TO 23000
21103   CALL RMOV(TMA,PNLBS,2)
        GO TO 23000
21104   CALL RMOV(DPA,PNLBS,2)
        GO TO 23000
C  *****NEW FPS100
C       RSPFN
21105   CALL MREAD (SP,SPDV,SPDR,SPSIZE,1,2)
        CALL RMOV (SPDR,PNLBS,2)
C  *****NEW END FPS100
        GO TO 23000
21106   CALL RMOV(STATUS,PNLBS,2)
        GO TO 23000
21107   CALL RMOV(DA,PNLBS,2)
        GO TO 23000
C  *****NEW FPS100
C
C       IOMEM FIELD (FADD=7, I/O=3, IOMEM=0-3)
C       (REXIT AND ROMA HANDLED HERE.  STATMA AT 41010, LDOMA AT 32150)
21500   IF (A1F.NE.3) GO TO 22000
        IF (A2F.NE.0) GO TO 21510
C               REXIT
                CALL MREAD (SRS,SRA(2),TA2,16,1,2)
                CALL RMOV (TA2,PNLBS,2)
                GO TO 23000
21510   IF (A2F.NE.3) GO TO 23000
C               ROMA
                CALL RMOV (IMA,PNLBS,2)
                GO TO 23000
C  *****NEW END FPS100
C
C
C       INPUT BUS SELECT (FADD=7, I/O=4, INOUT=4-7)
C       (IN, SPININ, INDA, SPINDA)
22000   IF (.NOT.(A1F.EQ.4.AND.(A2F.GE.4.AND.A2F.LE.7))) GO TO 22500
        I=DA(1)*256+DA(2)
C  *****NEW FPS100
C       SEE IF SPECIAL DEVICE ADDRESS FOR REGISTERS (370-377)
        IF (I.LT.248 .OR. I.GT.255) GO TO 22080
                I = I-247
                CALL RMOV (ZERO6, INBS, 6)
C               DA =    370,  371,  372,  373,  374,  375
                GO TO (22010,22020,22030,22040,22080,22080,
     1                 22050,22060),I
C                        376   377
C
C               CLOCK REGISTER CCTR
22010           CALL MOVPRT (CCTR,1,INBS,5,2,6,2)
                GO TO 22090
C               CCST
22020           CALL MOVPRT (CCST,1,INBS,5,2,6,2)
                GO TO 22090
C               CCTL
22030           CALL MOVPRT (CCTL,1,INBS,5,2,6,2)
                GO TO 22090
C               IMASK
22040           CALL MOVPRT (IMASK,1,INBS,5,2,6,2)
                GO TO 22090
C               STAT3
22050           CALL MOVPRT (STAT3,1,INBS,5,2,6,2)
                GO TO 22090
C               STAT2
22060           CALL MOVPRT (STAT2,1,INBS,5,2,6,2)
                GO TO 22090
22080   CALL MREAD (IODEV,I,INBS,IOSIZE,3,6)
22090   I = A2F-3
C  *****NEW END FPS100
        GO TO (23000,23000,22100,22100),I
22100   CALL RMOV(SPFN,DA,2)
        GO TO 23000
C
C       CONTROL FIELD: INTA
C
22500   IF (.NOT.(A1F.EQ.7 .AND. A2F.EQ.3)) GO TO 23000
C       CLEAR INTERRUPT AND GET DEVICE INDEX
C       INBS = DEVICE INDEX
        CALL INTRPT (3,K)
        CALL RMOV (ZERO6,INBS,6)
        INBS(6) = K
C       CLEAR DNE BIT IN CLOCK IF K=8 (CLOCK DEVICE INDEX)
        IF (K.EQ.8 .AND. MOD(CCTL(1)/2,2).EQ.1)
     1          CCTL(1) = CCTL(1)-2
C
C
C       SET UP POINTERS TO PS IF WE NEED THEM
C
23000   IF (SOPF.NE.1) GO TO 23300
        I=MOD(SPDF,8)/2+1
        GO TO (23010,23011,23012,23013),I
23010   CALL RMOV(VALUE,PSCOMP,2)
        GO TO 23050
23011   CALL TCADD(PSA,VALUE,PSCOMP,2,K)
        GO TO 23050
23012   CALL RMOV(TMA,PSCOMP,2)
        GO TO 23050
23013   IF ( SPSF .NE. 8 ) GO TO 23014
          CALL RMOV(SWITCH,PNLBS,2)
          CALL RMOV(PNLBS,PSCOMP,2)
          GO TO 23050
C
C       WE COME TO 23014 IF SPSF=12, I.E. SETEXIT INSTRUCTION
C       WHICH DIFFERS FROM THE JMP & JSR ONLY IN CASES WHEN
C       SPDF =6 OR 7. SETEXIT AND JMP & JSR ARE MUTUALLY EXCLUSIVE
C       SINCE THEY BOTH ENCODE INTO THE SPSF FIELD.
C
23014     CONTINUE
        CALL TCADD(ONE2,PSA,PSCOMP,2,I)
23050   PSCOMP(1)=MOD(PSCOMP(1),16)
        PSPTR=PSCOMP(1)*256+PSCOMP(2)
C
C
        IF (.NOT.(SPSF.EQ.11.AND.SPDF.LE.7)) GO TO 23200
C
C       PS TO DPBS (SOP=1,SPEC=13,PS=0-7)
C
        TWOCYC=2
        PSFLD=1
        CALL PSMEM(1,PSPTR,PST)
        I=MOD(SPDF,2)*4+1
        CALL MOVPRT(PST,I,DPBS,3,8,6,4)
        DPBS(1)=0
        DPBS(2)=DPBS(3)/16
        DPBS(3)=MOD(DPBS(3),16)
        IF (I.EQ.1) GO TO 30000
        DPBS(1)=MOD(PST(4)/16,4)
        DPBS(2)=DPBS(2)+MOD(PST(4),16)*16
        GO TO 30000
C
C       SWITCHES TO DPBS (SOP=1,SPEC=1,HOSTPNL=10-13)
C               SET WHAT PART MEMORY WE ARE STORING INTO
C
23200   IF(.NOT.(SPSF.EQ.1.AND.(SPDF.GE.8.AND.SPDF.LE.11))) GO TO 23220
        CALL RMOV(ZERO6,DPBS,6)
        I=SPDF-7
        GO TO (23210,23211,23212,23213),I
C  *****NEW FPS100
23210   CALL MOVPRT(SWITCH,1,DPBS,1,2,6,2)
        DPBS(1)=MOD(DPBS(1),4)
        CALL MOVPRT(SWITCH,1,DPBS,3,2,6,2)
        DPBS(3)=MOD(DPBS(3),16)
        CALL MOVPRT(SWITCH,1,DPBS,5,2,6,2)
        GO TO 30000
23211   CALL MOVPRT(SWITCH,1,DPBS,1,2,6,2)
        DPBS(1)=MOD(DPBS(1),4)
        WRTN=2
        WRTL=1
        GO TO 30000
23212   CALL MOVPRT(SWITCH,1,DPBS,3,2,6,2)
        DPBS(3)=MOD(DPBS(3),16)
        WRTN=2
        WRTL=3
        GO TO 30000
23213   CALL MOVPRT(SWITCH,1,DPBS,5,2,6,2)
C  *****NEW END FPS100
        WRTN=2
        WRTL=5
        GO TO 30000
C  *****NEW FPS100
C       SPECINT FIELD, PN2DBL (SOP=1, SPEC=4, SPECINT=14)
23220   IF (.NOT.(SPSF.EQ.4 .AND. SPDF.EQ.12)) GO TO 23300
                CALL RMOV (ZERO6, DPBS, 6)
                CALL MOVPRT (PNLBS,1,DPBS,5,2,6,2)
                GO TO 30000
C  *****NEW END FPS100
C
C       ENABLE ONTO DATA PAD BUS (DB FIELD)
C
23300   CALL RMOV(ZERO6,DPBS,6)
        I=DPBSF+1
        GO TO (24000,23301,23302,23303,23304,23305,23306,23307),I
23301   CALL RMOV(INBS,DPBS,6)
        GO TO 24000
23302   CALL MOVPRT(VALUE,1,DPBS,1,2,6,2)
        DPBS(1)=MOD(DPBS(1),4)
        CALL MOVPRT(VALUE,1,DPBS,5,2,6,2)
        GO TO 23316
23303   CALL RMOV(DPXR,DPBS,6)
        GO TO 24000
23304   CALL RMOV(DPYR,DPBS,6)
        GO TO 24000
23305   CALL RMOV(MDR,DPBS,6)
        GO TO 24000
23306   CALL TCADD(SPFN,P512,TA2,2,K)
         TA2(1)=MOD(TA2(1),4)
        CALL MOVPRT(TA2,1,DPBS,1,2,6,2)
        CALL MOVPRT(SPFN,1,DPBS,5,2,6,2)
23316   IF(DPBS(5).LT.128) GO TO 24000
         DPBS(3)=15
         DPBS(4)=255
        GO TO 24000
23307   CALL RMOV(TMR,DPBS,6)
C
C       NOW DO THE REST OF THE PANEL BUS POSSIBILITIES
C       DPBS TO PANEL BUS TO LIGHTS (SOP=1,SPEC=1,HOSTPNL=0-3)
C
24000   IF(SOPF.NE.1) GO TO 30000
        IF(.NOT.(SPSF.EQ.1.AND.SPDF.LE.3)) GO TO 24200
        I=SPDF+1
        GO TO (24110,24101,24102,24103),I
C  *****NEW FPS100
24101   CALL MOVPRT(DPBS,1,LIGHTS,1,6,2,2)
        LIGHTS(1)=MOD(DPBS(1),256)
        GO TO 30000
24102   CALL MOVPRT(DPBS,3,LIGHTS,1,6,2,2)
        GO TO 30000
24103   CALL MOVPRT(DPBS,5,LIGHTS,1,6,2,2)
        GO TO 30000
C  *****NEW END FPS100
24110   CALL RMOV(PNLBS,LIGHTS,2)
        GO TO 30000
C
C       PS TO/FROM HOST (SOP=1, SPEC=11,12)
C               (PSEVEN AND PSODD FIELDS)
C
24200   IF(.NOT.(SPSF.EQ.9.OR.SPSF.EQ.10)) GO TO 25000
        IF(MOD(SPDF,8).GE.6) GO TO 30000
        I=(MOD(SPDF,2)*2+SPSF-9)*2+1
        TWOCYC=2
        CALL RMOV (ZERO6,DPBS,6)
        IF(SPDF.GE.8) GO TO 24250
C
C       PS TO PNLBS TO LIGHTS
C
        CALL PSMEM(1,PSPTR,PST)
C  *****NEW FPS100
        CALL MOVPRT (PST,I,DPBS,5,8,6,2)
        CALL MOVPRT (DPBS,5,LIGHTS,1,6,2,2)
C  *****NEW END FPS100
        GO TO 30000
C
C       SWITCHES TO PANEL BUS TO PS
C
C  *****NEW FPS100
24250   CALL MOVPRT (SWITCH,1,DPBS,5,2,6,2)
        CALL PSMEM(1,PSPTR,PST)
        CALL MOVPRT (DPBS,5,PST,I,6,8,2)
C  *****NEW END FPS100
        CALL PSMEM(2,PSPTR,PST)
        GO TO 30000
C
C       DPBS TO PS
C
25000   IF (.NOT.(SPSF.EQ.11.AND.SPDF.GE.8)) GO TO 26000
        TWOCYC=2
        PSFLD=1
        CALL PSMEM(1,PSPTR,PST)
        CALL RMOV(DPBS,TA,6)
        TA(3)=TA(3)+MOD(TA(2),16)*16
        I=MOD(SPDF,2)*4+1
        CALL MOVPRT(TA,3,PST,I,6,8,4)
        CALL PSMEM(2,PSPTR,PST)
        GO TO 30000
C
C       SET EXIT (SOP=1,SPEC=14)  (SETEXIT FIELD)
C
26000   IF(SPSF.NE.12.OR.CONDF.EQ.7) GO TO 30000
        CALL MWRIT(PSCOMP,SRS,SRA(2),16,2,1)
        GO TO 30000
C
C
C
C
C       UPDATE STATUS AND GENERAL FLAGS
C
30000   STATUS(1)=FPERR*32+FACOND*8+SPCOND
        IF ( LDAPS .EQ. 1 ) CALL RMOV(NWSTAT,STATUS,2)
        LDAPS=0
      CALL RMOV(NWFLAG,FLAG,2)
C  *****NEW FPS100
C       IF USER MODE, UPDATE DPBS BITS IN APSTAT2; AND FADD, FADD1 FIELDS
C       IN APSTAT3 (IF NOT FADDR NOP)
        IF (SMODE.EQ.1) GO TO 30001
                CALL LAND (252,STAT2(1),STAT2(1),1)
                STAT2(1) = STAT2(1) + MOD(DPBS(3)/4,4)
                IF (FADDF.EQ.7 .OR.
     1              FADDF.EQ.0 .AND. A1F.EQ.0) GO TO 30001
                CALL LAND (192,STAT3(2),STAT3(2),1)
                STAT3(2) = STAT3(2) + FADDF*8 + A1F
C  *****NEW END FPS100
C
C       INHIBIT TMA,DPA, AND MA FIELDS IF A VALUE WAS USED
C
30001   IF (IVAL.EQ.1) GO TO 31000
C
C       UPDATE DPA (DPA FIELD)
C
        CALL RMOV(SPFN,TA2,2)
        IF(FADDF.EQ.7.AND.A1F.EQ.0) CALL MOVPRT(DPBS,5,TA2,1,6,2,2)
        I=DPAF+1
        GO TO (30100,30011,30012,30013),I
30011   CALL TCADD(ONE2,DPA,DPA,2,K)
        GO TO 30050
30012   CALL TCADD(MONE2,DPA,DPA,2,K)
        GO TO 30050
30013   CALL RMOV(TA2,DPA,2)
30050   DPA(1)=0
        DPA(2)=MOD(DPA(2),64)
C
C       UPDATE TMA (TMA FIELD)
C
30100   I=TMAF+1
        GO TO (30200,30101,30102,30103),I
30101   CALL TCADD(ONE2,TMA,TMA,2,K)
        GO TO 30200
30102   CALL TCADD(MONE2,TMA,TMA,2,K)
        GO TO 30200
30103   CALL RMOV(TA2,TMA,2)
C
C       UPDATE ACTIVE MA (MA FIELD)
C
30200   I=MAF+1
        GO TO (31000,30201,30202,30203),I
C  *****NEW FPS100
30201   CALL TCADD(ONE2,AMA,AMA,2,K)
        GO TO 31000
30202   CALL TCADD(MONE2,AMA,AMA,2,K)
        GO TO 31000
30203   CALL RMOV(TA2,AMA,2)
C  *****NEW END FPS100
        GO TO 31000
C
C       REST OF SOP1 FIELD
C
31000   IF (.NOT.(SOPF.EQ.0.AND.(SPSF.LE.3.OR.SPSF.GE.12))) GO TO 32000
C
C       STORE DIRECT INTO S-PAD DESTINATION
C               (SOP=F0,SOP1=14-17)
C
        IF(SPSF.LE.3) GO TO 31150
        I=SPSF-11
        GO TO (31114,31115,31116,31117),I
31114   CALL MWRIT(PNLBS,SP,SPDV,SPSIZE,2,1)
        GO TO 32000
31115   CALL MOVPRT(DPBS,1,TA2,1,6,2,2)
        CALL TCADD(TA2,M512,TA2,2,K)
        GO TO 31120
31116   CALL MOVPRT(DPBS,5,TA2,1,6,2,2)
        GO TO 31120
31117   TA2(1)=0
        TA2(2)=MOD(DPBS(3),4)*32+MOD(DPBS(4)/8,32)
31120   CALL MWRIT(TA2,SP,SPDV,SPSIZE,2,1)
        GO TO 32000
C
C       RESTRICT WIDTH OF MEMORY WRITE (SOP=0,SOP1=1-3)
C
31150   I=SPSF+1
        GO TO (32000,31151,31152,31153),I
31151   WRTN=2
        WRTL=1
        GO TO 32000
31152   WRTN=2
        WRTL=3
        GO TO 32000
31153   WRTN=2
        WRTL=5
C
C
C       I/O FIELDS (FADD=7)
C
32000   IF(FADDF.NE.7) GO TO 33000
        I=A1F+1
        K=A2F+1
        GO TO (32100,33000,33000,32150,32200,32300,32400,32500),I
C
C       STORE INTO REG@S (I/O=0) (LDREG FIELD)
C
32100   GO TO (33000,32101,32102,32103,32104,32105,32106,32107),K
32101   SPD(1)=0
        SPD(2)=MOD(DPBS(6),16)
        LDSPD=1
        GO TO 33000
C       LDMA
32102   CALL MOVPRT(DPBS,5,AMA,1,6,2,2)
C       GO CHANGE MAE (UNLESS SOP1 = WRTLMN OR WRTEXP)
        IF (WRTN.EQ.2.AND.WRTL.NE.3) GO TO 33000
        I=24
        TA(6)=DPBS(4)
        GO TO 32250
32103   CALL MOVPRT(DPBS,5,TMA,1,6,2,2)
        GO TO 33000
32104   DPA(1)=0
        DPA(2)=MOD(DPBS(6),64)
        GO TO 33000
C  *****NEW FPS100
C       LDSP
C       IF SPAD OPERATION, THEN NOP HERE.
32105   IF (SOPF.EQ.0.AND.SPSF.GE.8 .OR.
     $      SOPF.GT.1) GO TO 33000
C  *****NEW END FPS100
        CALL MOVPRT(DPBS,5,TA2,1,6,2,2)
        CALL MWRIT(TA2,SP,SPDV,SPSIZE,2,1)
        GO TO 33000
32106   CALL MOVPRT(DPBS,5,NWSTAT,1,6,2,2)
        LDAPS=1
        GO TO 33000
32107   DA(1)=0
        DA(2)=DPBS(6)
        GO TO 33000
C  *****NEW FPS100
32150   IF (A2F.NE.2) GO TO 33000
C               LDOMA
                CALL MOVPRT (DPBS,5,IMA,1,6,2,2)
                GO TO 33000
C  *****NEW END FPS100
C
C       OUTPUT (I/O=4, INOUT=0-3)
C
32200   IF(A2F.GE.4) GO TO 33000
        I=DA(1)*256+DA(2)
C       SET TM WRITE FLAG IF DA=5
        IF (I.EQ.5) TMAW=1
        GO TO (32230,32230,32210,32210),K
32210   DA(1)=0
        DA(2)=SPFN(2)
C
C       NOW SEE IF PAGE SELECT
32230   IF (I.GE.24.AND.I.LE.26) GO TO 32245
C  *****NEW FPS100
C       SEE IF SPECIAL DEVICE ADDRESS FOR REGISTERS (370-377)
        IF (I.LT.248 .OR. I.GT.255) GO TO 32242
                I = I-247
C                DA =   370,  371,  372,  373,  374,  375
                GO TO (33000,32232,32234,32236,32242,32242,
     1                 32238,32240),I
C                        376,  377
C               CLOCK REGISTERS
C               CCTR IS READ ONLY
C               CCST
32232           CALL MOVPRT (DPBS,5,CCST,1,6,2,2)
                GO TO 33000
C               CCTL
C                       IF CRN (RUN) BIT CHANGES FROM 0 TO 1,
C                       SET FLAG TO SET CLOCK.  IF ATTEMPT IS
C                       MADE TO SET FX (FIX) BIT TO 1, SET FLAG.
32234           K = MOD (CCTL(2),2)
                CALL MOVPRT (DPBS,5,CCTL,1,6,2,2)
                IF (K.EQ.0 .AND. MOD(CCTL(2),2).EQ.1) CLKSET = 1
                IF (MOD(CCTL(2)/128,2).EQ.0) GO TO 33000
                CLKFIX = 1
                CCTL(2) = CCTL(2) - 128
                GO TO 33000
C               IMASK
32236           CALL MOVPRT (DPBS,5,IMASK,1,6,2,2)
                GO TO 33000
C               STAT3
C               UPDATE STAT3.  SET FLAG TO BE READ AT 60000.
32238           CALL MOVPRT (DPBS,5,STAT3,1,6,2,2)
                ST3FLG = 1
                GO TO 33000
C               STAT2
32240           CALL MOVPRT (DPBS,5,STAT2,1,6,2,2)
                GO TO 33000
32242   CALL MWRIT (DPBS,IODEV,I,IOSIZE,6,3)
C  *****NEW END FPS100
        GO TO 33000
C
C       PAGE SELECT OPTION
C
32245   TA(6)=DPBS(6)
C       GET MODE AND MASK(DA=26)
32250   CALL MREAD(IODEV,26,PST,IOSIZE,3,6)
C       IF MODE=1, THEN DON'T CHANGE DA=25 OR 26
        MODE=MOD(PST(6),64)/32
        IF (MODE.EQ.1.AND.(I.EQ.25.OR.I.EQ.26)) GO TO 33000
C       GET MASK (ITS ONES COMPLEMENT)
        CALL LCOM(PST(6),MASK,1)
        MASK=MOD(MASK,16)
C       NOW MASK TO PROPER BIT WIDTH
        IF (I.EQ.24.OR.I.EQ.25) CALL LAND(MASK,TA(6),TA(6),1)
        IF (I.EQ.26) TA(6)=MOD(TA(6),64)
C
C       NOW PUT IT AWAY
        CALL MOVPRT(ZERO6,1,TA,1,6,6,5)
        CALL MWRIT(TA,IODEV,I,IOSIZE,6,3)
        GO TO 33000
C
C       SENSE (I/O=5)
C
32300   GO TO (33000,33000,32310,32310,33000,33000,32310,32310),K
32310   CALL RMOV(SPFN,DA,2)
        GO TO 33000
C
C       FLAGS (I/O=6) (FLAG FIELD)
C
C       SET AND RESET THE FLAGS
C       FLAG 0 = BIT 15
C       FLAG 1 = BIT 14
C       FLAG 2 = BIT 13
C       FLAG 3 = BIT 12
C       FIRST MAKE UP A MASK
32400   I=2**MOD(A2F,4)
C       THEN SET THE NEW FLAG VALUE
        J=MOD((A2F+4)/4,2)*I
        TA2(1)=0
        TA2(2)=I
        CALL LCOM(TA2,TA2,2)
        CALL LAND(TA2,NWFLAG,NWFLAG,2)
        NWFLAG(2)=NWFLAG(2)+J
        GO TO 33000
C
C       CONTROL (I/O=7) (CONTROL FIELD)
C
32500   GO TO (32510,32520,33000,33000,33000,32540,32550,33000),K
32510   HALT=1
        GO TO 33000
C       IORST:  CLEAR ALL IO INTERRUPTS
32520   INTTYP(2) = 0
        DO 32530 I=1,16
32530   IOINT(I) = 0
        GO TO 33000
32540   WRTN=2
        WRTL=1
        GO TO 33000
32550   WRTN=4
        WRTL=3
        GO TO 33000
C
C
C
C       WRITE INTO DPX AND DPY
C
C  *****NEW FPS100
C       IF RDPI, SET FLAG TO BE TESTED IN NEXT INSTRUCTION
C       AND SAVE PREVIOUS WRITE BUFFERS
33000   IF (.NOT.(SOPF.EQ.1.AND.SPSF.EQ.4.AND.SPDF.EQ.9)) GO TO 33010
                RDPI = 1
                CALL RMOV (DPXW,DPXW1,6)
                CALL RMOV (DPYW,DPYW1,6)
C  *****NEW END FPS100
C
C       WRITE INTO DPX (DPX FIELD)
C
33010   I=DPXF+1
        GO TO (33200,33101,33102,33103),I
33101   CALL MOVPRT(DPBS,WRTL,DPXW,WRTL,6,6,WRTN)
        GO TO 33120
33102   CALL MOVPRT(FA,WRTL,DPXW,WRTL,6,6,WRTN)
        GO TO 33120
33103   CALL MOVPRT(FM,WRTL,DPXW,WRTL,6,6,WRTN)
C  *****NEW FPS100
C       IF WDPI, DON'T WRITE INTO DP MEMORY
33120   IF (.NOT.(SOPF.EQ.1.AND.SPSF.EQ.4.AND.SPDF.EQ.10))
     1          CALL MWRIT(DPXW,DPX,XWA,DPSIZE,6,3)
C  *****NEW END FPS100
C
C       WRITE INTO DPY (DPY FIELD)
C
33200   I=DPYF+1
        GO TO (34000,33201,33202,33203),I
33201   CALL MOVPRT(DPBS,WRTL,DPYW,WRTL,6,6,WRTN)
        GO TO 33220
33202   CALL MOVPRT(FA,WRTL,DPYW,WRTL,6,6,WRTN)
        GO TO 33220
33203   CALL MOVPRT(FM,WRTL,DPYW,WRTL,6,6,WRTN)
C  *****NEW FPS100
C       IF WDPI, DON'T WRITE INTO DP MEMORY
33220   IF (.NOT.(SOPF.EQ.1.AND.SPSF.EQ.4.AND.SPDF.EQ.10))
     1           CALL MWRIT(DPYW,DPY,YWA,DPSIZE,6,3)
C  *****NEW END FPS100
C
C
C       FLOATING MULTIPLIER (FM FIELD)
C
34000   IF(FMF.NE.1.OR.IVAL.EQ.1) GO TO 35000
C
C       GET M1 (M1 FIELD)
C
        I=M1F+1
        GO TO (34100,34101,34102,34103),I
34100   CALL RMOV(FM,M1,6)
        GO TO 34110
34101   CALL RMOV(DPXR,M1,6)
        GO TO 34110
34102   CALL RMOV(DPYR,M1,6)
        GO TO 34110
34103   CALL RMOV(TMR,M1,6)
C
C       GET M2 (M2 FIELD)
C
34110   I=M2F+1
        GO TO (34200,34201,34202,34203),I
34200   CALL RMOV(FA,M2,6)
        GO TO 34300
34201   CALL RMOV(DPXR,M2,6)
        GO TO 34300
34202   CALL RMOV(DPYR,M2,6)
        GO TO 34300
34203   CALL RMOV(MDR,M2,6)
C
C       PUSH THE MULTIPLIER PIPELINE AND DO THE MULTIPLY
34300   CALL RMOV (FMB2,FMB3,7)
        CALL RMOV (FMB1,FMB2,7)
        CALL FPMUL(M1,M2,FMB1)
C
C
C       FLOATING ADDER (FADD FIELD)
C
35000   IF(FADDF.EQ.7.OR.(FADDF.EQ.0.AND.A1F.EQ.0))
     1        GO TO 40000
C  *****NEW FPS100
        FPAFLG = 1
C       IF FPA1 OR FPA2, SKIP TO 35300
        IF (FADDF.NE.0 .AND. (A1F.EQ.6 .OR. A1F.EQ.7) ) GO TO 35300
        FPAFLG = 0
C  *****NEW END FPS100
C
C       GET A1 (A1 FIELD)
C
        IF ( FADDF .EQ. 0 ) GO TO 35200
        I=A1F+1
        GO TO (35200,35101,35102,35103,35104,35105,35105,35105),I
35101   CALL RMOV(FM,A1,6)
        GO TO 35200
35102   CALL RMOV(DPXR,A1,6)
        GO TO 35200
35103   CALL RMOV(DPYR,A1,6)
        GO TO 35200
35104   CALL RMOV(TMR,A1,6)
        GO TO 35200
35105   CALL RMOV(ZERO6,A1,6)
C
C       GET A2 (A2 FIELD)
C
35200   I=A2F+1
        GO TO (35300,35201,35202,35203,35204,35205,35206,35207),I
35201   CALL RMOV(FA,A2,6)
        GO TO 35300
35202   CALL RMOV(DPXR,A2,6)
        GO TO 35300
35203   CALL RMOV(DPYR,A2,6)
        GO TO 35300
35204   CALL RMOV(MDR,A2,6)
        GO TO 35300
35205   CALL RMOV(ZERO6,A2,6)
        GO TO 35300
35206   CALL MOVPRT(DPXR,3,A2,3,6,6,4)
        CALL TCADD(SPFN,P512,TA2,2,K)
         TA2(1)=MOD(TA2(1),4)
        CALL MOVPRT(TA2,1,A2,1,2,6,2)
        GO TO 35300
35207   CALL RMOV(ZERO6,A2,6)
        CALL MOVPRT(DPXR,1,A2,1,6,6,2)
        A2(3)=MOD(SPFN(2),4)*4
C
C       PUSH THE ADDER PIPELINE AND DO THE ADD
C  *****NEW FPS100
35300   CALL RMOV (FAB1,FAB2,7)
        IF (FPAFLG.EQ.0) GO TO 35310
C               FPA1, FPA2
                CALL MOVPRT (A1,1,FAB1,1,6,7,6)
                IF (A1F.EQ.7) CALL MOVPRT (A2,1,FAB1,1,6,7,6)
C               SET SIGN BIT IN CONDITION BITS
                FAB1(7) = 0
                IF (MOD(FAB1(3)/8,2) .EQ. 1) FAB1(7) = 1
                GO TO 40000
35310   CALL FPADD (A1,A2,FAB1,FADDF,A1F,SPFN)
C  *****NEW END FPS100
C
C
C
C
C       TMA FETCH
C       PUSH THE TM PIPELINE IF USER MODE OR TMA FETCH (TMA FIELD OR LDTMA)
C  *****NEW FPS100
40000   IF ((SMODE.EQ.0) .OR. (IVAL.EQ.0.AND.TMAF.GT.0) .OR.
     1      (FADDF.EQ.7.AND.A1F.EQ.0.AND.A2F.EQ.3))
     2                  CALL RMOV (TMB1,TMB2,6)
C  *****NEW END FPS100
        TMAV=TMA(1)*256+TMA(2)
C       SEE IF A TM WRITE ???
        IF (TMAW.EQ.1) GO TO 40300
C       SEE IF WE ARE IN FFT MODE
        IF (MOD(STATUS(2)/8,2).EQ.1) GO TO 40100
C       NOT IN FFT MODE, FETCH THE REQUESTED ADDRESS
        CALL TMMEM(1,TMAV,TMB1)
        GO TO 41000
C
C       IF FFT MODE' INTERPRET TMA AS FOLLOWS
C       BIT 15' 0 - COSINE VALUE DESIRED
C               1 - SINE VALUE DESIRED
C       THE REST OF THE BITS ARE AS FOLLOWS:
C       BITS 1 AND 2 ARE UNUSED AND ARE IGNORED.
C       BITS 2 AND 3 ARE THE QUADRENT OF THE ANGLE.
C       BITS 4 TO 14 ARE AN ANGLE BETWEEN 0 AND
C               ALMOST PI/2.
C       SFFTSZ SPECIFIES THE LENGTH OF THE TABLE OF COSINES
C               IN TABLE MEMORY
40100   IF(TMAV.GE.0)GO TO 40110
C            REMOVE THE UNUSED SIGN BIT
          TMAV=TMAV+32767+1
40110   IQUAD=MOD(TMAV/(SFFTSZ*2),4)
        ICS=MOD(TMAV,2)
        TMAV=MOD(TMAV/2,SFFTSZ)
C       IF THE COSINE IS IN QUADRENTS 1 OR 3,
C               OR THE SINE IS IN QUADRENTS 0 OR 2
C               WE WANT COS(PI/2-THETA)
        I=IQUAD+ICS
        IF (I.EQ.1.OR.I.EQ.3) TMAV=SFFTSZ-TMAV
C       PI/2 IS NOT IN THE TABLE, SO FORCE ZERO
C               AS A SPECIAL CASE
        IF (TMAV.NE.SFFTSZ) GO TO 40200
        CALL RMOV(ZERO6,TMB1,6)
        GO TO 41000
40200    CALL TMMEM(1,TMAV,TMB1)
C       IF THE COSINE IS IN QUADRENTS 1 OR 2,
C               IF THE SINE IS IN QUADRENTS 2 OR 3
C       OR, THE IFFT FLAG(STATUS BIT 11) IS NOT ON
C               AND THE SINE IS IN QUADRENTS 0 OR 1
C       NEGATE THE VALUE FETCHED
        I=IQUAD-ICS
        IF (ICS.EQ.1.AND.MOD(STATUS(2)/16,2).EQ.0) I=I+2
        IF (I.NE.1.AND.I.NE.2) GO TO 41000
        CALL MOVPRT(TMB1,3,TA4,1,6,4,4)
        CALL NEGATE(TA4,4,K)
        CALL MOVPRT(TA4,1,TMB1,3,4,6,4)
        GO TO 41000
C
C       WRITE TO TABLE MEMORY FROM DPBS (DONE IF DA=5)
40300   CALL TMMEM(2,TMAV,DPBS)
        CALL RMOV(ZERO6,TMB1,6)
        GO TO 41000
C
C
C       MEMORY FETCH
C       IF MA WAS CHANGED INITIATE A MEMORY CYCLE
C
C       DO A WRITE IF THE MI FIELD WAS NON-ZERO
C
C  *****NEW FPS100
C       PUSH THE MEMORY PIPELINE IF USER MODE ("TIME-PUSHING")
41000   IF (SMODE.EQ.1) GO TO 41010
                CALL RMOV (MDB2,MDB3,7)
                CALL RMOV (MDB1,MDB2,7)
                MDB1(7) = 0
C
C       DO A MEMORY CYCLE IF REQUIRED
C       TEST FOR INCMA, DECMA, SETMA, LDMA, STATMA
41010   IF (.NOT.((MAF.GE.1.AND.IVAL.EQ.0) .OR.
     1            (FADDF.EQ.7.AND.A1F.EQ.0.AND.A2F.EQ.2) .OR.
     2            (FADDF.EQ.7.AND.A1F.EQ.3.AND.A2F.EQ.1))) GO TO 45000
C       PUSH MEMORY PIPELINE IF SUPERVISOR MODE ("STATE-PUSHING")
        IF (SMODE.EQ.0) GO TO 41020
                CALL RMOV (MDB2,MDB3,7)
                CALL RMOV (MDB1,MDB2,7)
41020   MAV = AMA(1)*256 + AMA(2)
C  *****NEW END FPS100
        IF(MIF.NE.0.AND.IVAL.EQ.0) GO TO 41100
C
C       READ FROM MEMORY
        MDB1(7)=1
        CALL MDMEM(1,MAV,TA)
        CALL MOVPRT(TA,1,MDB1,1,6,7,6)
        GO TO 41500
C
C       WRITE TO MEMORY (MI FIELD)
41100   MDB1(7)=-1
        CALL MDMEM(1,MAV,MI)
        GO TO (41101,41102,41103),MIF
41101   CALL MOVPRT(FA,WRTL,MI,WRTL,6,6,WRTN)
        GO TO 41200
41102   CALL MOVPRT(FM,WRTL,MI,WRTL,6,6,WRTN)
        GO TO 41200
41103   CALL MOVPRT(DPBS,WRTL,MI,WRTL,6,6,WRTN)
41200   CALL MDMEM(2,MAV,MI)
C
C       CHECK FOR MEMORY LOCK-OUT IF THE LAST MEMORY CYCLE
C       IS NOT DONE
C
41500   LASTBK=THISBK
C       GET PAGE NUMBER
        CALL MREAD(IODEV,24,TA,IOSIZE,3,6)
        THISBK=(MOD(TA(6),16)*32) + (MAV/4096) + MOD(MAV,2)
C       GO TO (41550,41560),MEMSPD
C       1 CYCLE MEMORY
        IF (MDB2(7).EQ.0.OR.THISBK.EQ.LASTBK) GO TO 45000
          CYCLES=CYCLES+1.0
          CLKCYC=CLKCYC+1.0
C       FOLLOWING CODE FOR AP-120B ONLY
C        GO TO 50000
C       2 CYCLE MEMORY
C41560   IF(MDB2(7).EQ.0) GO TO 41600
C        CALL RMOV(MDB2,MDB3,7)
C        MDB2(7)=0
C        CYCLES=CYCLES+1.0
C41600   IF(MDB3(7).NE.0.AND.THISBK.EQ.LASTBK) CYCLES=CYCLES+1.0
C  *****NEW FPS100
C
C       SPECINT FIELD (SOP=1, SPEC=4)
C
45000   IF (.NOT.(SOPF.EQ.1 .AND. SPSF.EQ.4)) GO TO 50000
           IF ( SPDF .GE. 7 ) GO TO 45005
                CALL LAND(28,STAT2(1),ITMP,1)
                CALL LSHFT(ITMP,3,1,0,I,I)
                CALL LAND(31,STAT2(1),STAT2(1),1)
                STAT2(1)=STAT2(1)+ITMP
45005           CONTINUE
                I = SPDF+1
                GO TO (45010,45050,45020,45060,45070,45030,45090,
     1                 45100,45110,50000,50000,45120,50000,50000,
     2                 50000,46000),I
C               SET APPROPRIATE BIT IN APSTAT2
C               ION
45010           K = 8
                GO TO 45040
C               SETMOD
45020           K = 16
                GO TO 45040
C               SELSMA
45030           K = 4
45040           IF (MOD(STAT2(1)/K,2).EQ.0) STAT2(1) = STAT2(1)+K
                GO TO 50000
C               CLEAR APPROPRIATE BIT IN APSTAT2
C               IOFF
45050           K = 8
                GO TO 45080
C               CLRMOD
45060           K = 16
                GO TO 45080
C               SELMA
45070           K = 4
45080           IF (MOD(STAT2(1)/K,2).EQ.1) STAT2(1) = STAT2(1)-K
                GO TO 50000
C
C               ENTINT -- SET TO SUPER. MODE, UNIV. INT. INHIB., SELECT SMA
45090           CALL LAND (227,STAT2(1),STAT2(1),1)
                STAT2(1) = STAT2(1)+20
                GO TO 50000
C  CMP2    MOVE MO TO PMO
45100           CONTINUE
                CALL LAND(16,STAT2(1),ITMP,1)
                CALL LSHFT(ITMP,3,1,0,I,I)
                CALL LAND(127,STAT2(1),STAT2(1),1)
                STAT2(1)=STAT2(1)+ITMP
                GO TO 50000
C
C               TRAP
C               SET TRAP INTERRUPT FLAG
45110           INTTYP(1)=1
                GO TO 50000
C               (RDPI IS HANDLED AT 33000)
C               (WDPI IS HANDLED AT 33120 AND 33220)
C               DBLSW
45120           CALL MOVPRT (DPBS,5,SWITCH,1,6,2,2)
                GO TO 50000
C               (PN2DBL HANDLED AT 23220)
C  EXINT -- RESTORE PREVIOUS STATE FROM BITS 0, 1 , AND 2
C                                         (PMO,PINTU,   PMAS)
C          TO MO, INTU, AND MAS (BITS 3, 4, AND 5 OF STAT2)
46000           CONTINUE
                CALL LAND(224,STAT2(1),ITMP,1)
                CALL LSHFT(ITMP,-3,1,0,I,I)
                CALL LAND(227,STAT2(1),STAT2(1),1)
                STAT2(1)=STAT2(1)+ITMP
                GO TO 50000
C  *****NEW END FPS100
C
C
C
C
C       BRANCHING AND JUMPING
C
C       SET FOR PSA BREAKPOINT
50000    IF (BRKTYP.EQ.1.AND.BRKLOC.EQ.PSA(1)*256+PSA(2)) HALT=1
C  *****NEW FPS100
C       CHECK FOR IO INTERRUPT
        IF (NIOBPT.EQ.0) GO TO 50020
                DO 50010 I=1,NIOBPT
                IF (IOBKPT(I,2).EQ.PSAV) CALL INTRPT(1,IOBKPT(I,1))
50010           CONTINUE
C  *****NEW END FPS100
C       INCREMENT PSA
50020   CALL TCADD(ONE2,PSA,PSA,2,K)
        IF(BRANCH.EQ.0) GO TO 51000
C
C       THE BRANCH CONDITION WAS SATISFIED, DO THE
C               SHORT RANGE RELATIVE BRANCH
        TA2(1)=0
        TA2(2)=DISPF
        CALL TCADD(TA2,PSA,PSA,2,K)
        CALL TCADD(M21,PSA,PSA,2,K)
C
C
C       SEE IF WE HAVE A LONG RANGE JMP OR JSR
C               (SOP=1, SPEC=10)
C       A JUMP OR JSR HAS PRIORITY OVER A BRANCH OR RETURN
C
51000   IF(.NOT.(SOPF.EQ.1.AND.SPSF.EQ.8)) GO TO 51200
C
C       JUMP
C
        IF(MOD(SPDF,2).EQ.1) GO TO 51100
        CALL RMOV(PSCOMP,PSA,2)
        GO TO 60000
C
C       JSR
C
51100   CALL TCADD(SRA,ONE2,SRA,2,K)
C       CHECK FOR STACK OVERFOW
        IF (SRA(2)/15.EQ.0) GO TO 51150
        SRA(1)=0
        SRA(2)=MOD(SRA(2),16)
C       SET SRAO (SRA OVERFLOW BIT) IN THE STATUS REGISTER
        STATUS(2)=(STATUS(2)/64)*64+MOD(STATUS(2),32)+32
51150   SRAV=SRA(2)
         CALL MWRIT(PSA,SRS,SRAV,16,2,1)
        CALL RMOV(PSCOMP,PSA,2)
        GO TO 60000
C
C
C       RETURN (COND=7)
C
51200   IF(CONDF.NE.7) GO TO 60000
        SRAV=SRA(2)
        CALL MREAD(SRS,SRAV,PSA,16,1,2)
        CALL TCADD(SRA,MONE2,SRA,2,K)
C       SEE IF WE HAVE SUBROUTINE STACK UNDERFLOW
        IF (SRA(2)/15.EQ.0) GO TO 60000
        SRA(1)=0
        SRA(2)=MOD(SRA(2),16)
C       SET SRAO (SRA OVERFLOW BIT) IN THE STATUS REGISTER
        STATUS(2)=(STATUS(2)/64)*64+MOD(STATUS(2),32)+32
C
60000   PSA(1)=MOD(PSA(1),16)
        CYCLES=CYCLES+1.0
        CLKCYC=CLKCYC+1.0
C  *****NEW FPS100
C
C       INTERRUPT ACTION
C
C       IF INTERRUPT OF ANY KIND HAS OCCURRED, CAUSE INTERRUPT ACTION:
C               SET APSTAT2 AS FOR ENTINT
C               JSRA 0
        CALL INTRPT (2,K)
        IF (K.EQ.0) GO TO 60005
                CALL LAND(28,STAT2(1),ITMP,1)
                CALL LSHFT(ITMP,3,1,0,I,I)
                CALL LAND(31,STAT2(1),STAT2(1),1)
                STAT2(1)=STAT2(1)+ITMP
                CALL LAND (227,STAT2(1),STAT2(1),1)
                STAT2(1) = STAT2(1)+20
                CALL TCADD (SRA,ONE2,SRA,2,K)
C               CHECK FOR STACK OVERFLOW
                IF (SRA(2)/16.EQ.0) GO TO 60002
                        SRA(1) = 0
                        SRA(2) = MOD(SRA(2),16)
                        STATUS(2) = (STATUS(2)/64)*64 +
     1                                      MOD(STATUS(2),32) + 32
60002           SRAV = SRA(2)
                CALL MWRIT (PSA,SRS,SRAV,16,2,1)
                CALL RMOV (ZERO2,PSA,2)
C
C       SAVE SRA IN APSTAT3
C            IN HARDWARE, SRA AND APSTAT3 BITS 4-7 ARE THE SAME
C       REGISTER.  HERE THEY ARE SEPARATE; HENCE, IF APSTAT3 HAS
C       BEEN WRITTEN (WITH AN  "OUT" INSTR), CHANGE SRA, ELSE COPY
C       SRA INTO APSTAT3.
60005   IF (ST3FLG.EQ.0) GO TO 60010
                SRA(1) = 0
                SRA(2) = MOD(STAT3(1),4)*4 + MOD(STAT3(2)/64,4)
                GO TO 60020
60010   STAT3(1) = MOD(SRA(2)/4,4)
        CALL LAND (63,STAT3(2),STAT3(2),1)
        STAT3(2) = STAT3(2) + MOD(SRA(2),4)*64
C  *****NEW END FPS100
C
C       PUSH MD IF A TWO CYCLE INSTRUCTION AND IN USER MODE
C
60020   IF (TWOCYC.NE.2) GO TO 60030
C
        CYCLES=CYCLES+1.0
C  CLKCYC NOT INCREMENTED HERE SO THAT A POSSIBLE INTERRUPT WILL
C  BE SERVICED AFTER THE TWO CYCLE INSTRUCTION.
C  *****NEW FPS100
        IF (SMODE.EQ.1) GO TO 60030
C  *****NEW END FPS100
        IF (MDB3(7).EQ.1) CALL MOVPRT(MDB3,1,MDR,1,7,6,6)
        CALL RMOV(MDB2,MDB3,7)
        CALL RMOV(MDB1,MDB2,7)
        MDB1(7)=0
C
C  *****NEW FPS100
C       RESTORE MEMORY ADDRESS REGISTERS
60030   IF (MAMODE.EQ.1) GO TO 60040
                CALL RMOV (AMA,MA,2)
                CALL RMOV (IMA,SMA,2)
                GO TO 60050
60040   CALL RMOV (AMA,SMA,2)
        CALL RMOV (IMA,MA,2)
60050   IF (HALT.NE.0) RETURN
C  *****NEW END FPS100
C
C
C       CHECK ACTIVE MA BREAK-POINT
         IF (BRKTYP.EQ.2.AND.BRKLOC.EQ.AMA(1)*256+AMA(2)) HALT=1
C       CHECK FOR TMA BREAK-POINT
         IF (BRKTYP.EQ.3.AND.BRKLOC.EQ.TMA(1)*256+TMA(2)) HALT=1
        GO TO 10000
        END
C+++ PSMEM
C****** PSMEM = P.S. MEMORY ACCESS = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 19:59:13
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE PSMEM(OP,ADDR,REG)
        INTEGER OP,ADDR,REG(8)
C
C       ACCESS P.S. MEMORY
C
C       OP = 0 ZERO, 1 READ, 2 WRITE
C       ADDR - ADDRESS; REG - CONTAINS DATA, 8-BITS TO A WORD, 8 WORD TOTAL
C
C       PS IS STORED: QUARTER 0,1,2,3 IN FOUR WORDS
C
        INTEGER PS(512,4),PSSIZE
        COMMON /PSRM/ PS,PSSIZE
C
C-------LOCAL STORAGE
C
        INTEGER I,J
C
        I=OP+1
        GO TO (100,200,300),I
C
C-------ZERO
C
100     DO 150 I=1,PSSIZE
        DO 150 J=1,4
150     PS(I,J)=0
        RETURN
C
C-------READ
C
200     CALL MREAD(PS,ADDR,REG,PSSIZE,4,8)
        RETURN
C
C-------WRITE
C
300     CALL MWRIT(REG,PS,ADDR,PSSIZE,8,4)
        RETURN
        END
C
C+++ MDMEM
C****** MDMEM = MAIN DATA MEMORY ACCESS = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 19:59:58
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE MDMEM(OP,ADDR,REG)
        INTEGER OP,ADDR,REG(6)
C
C       MAIN DATA MEMORY ACCESS
C
C       OP = 0 FOR ZERO, 1 FOR READ, 2 FOR WRITE
C       ADDR IS MEMORY ADDRESS, REG IS DATA (8 BITS PER WORD, 6 WORDS TOTAL)
C
C       'MD' IS STORED: EXPONENT, HIGH MANTISSA, LOW MANTISSA
C       IN THREE WORDS
C
        INTEGER MD(512,3),PAGNUM,PAGSIZ
        COMMON /MDRM/ MD,PAGNUM,PAGSIZ
C
C       'MD' IS DIVIDED INTO 'PAGNUM' PAGES, EACH 'PAGSIZ' LOCATIONS LONG
C
        INTEGER IODEV(64,3),IOSIZE
        COMMON /IORM/ IODEV,IOSIZE
C
C-------LOCAL STORAGE
C
        INTEGER I,J,MDSIZE,TEMP(6)
C
        MDSIZE = PAGNUM * PAGSIZ
        IF (OP.GT.0) GO TO 195
C
C-------ZERO
C
        DO 150 I=1,MDSIZE
        DO 150 J=1,3
150     MD(I,J)=0
        RETURN
C
C-------READ / WRITE
C
C       GET 'MAE'
C
195     CALL MREAD(IODEV,24,TEMP,IOSIZE,3,6)
        I = MOD(TEMP(6),16)
C
C       SEE IF ADDRESS IS OUT OF RANGE, EITHER
C          1. THE PAGE SELECT IS TOO BIG
C       OR 2. THE ADDRESS WITHIN A PAGE IS TOO BIG
C
        IF (I.GE.PAGNUM.OR.ADDR.GE.PAGSIZ) GO TO 400
C
        J = I * PAGSIZ + ADDR
        GO TO (200,300),OP
C
C-------READ
C
200     CALL MREAD(MD,J,REG,MDSIZE,3,6)
        RETURN
C
C-------WRITE
C
300     CALL MWRIT(REG,MD,J,MDSIZE,6,3)
        RETURN
C
C-------ADDRESS OUT OF RANGE, IF READING, RETURN ZERO
C
400     IF (OP.NE.1) RETURN
        DO 410 I=1,6
410     REG(I)=0
        RETURN
        END
C
C+++ TMMEM
C****** TMMEM = TABLE MEMORY ACCESS = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:00:44
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE TMMEM(OP,ADDR,REG)
        INTEGER OP,ADDR,REG(6)
C
C       TABLE MEMORY ACCESS
C       OP = 0 FOR ZEROING, 1 FOR READ, 2 FOR WRITE
C       ADDR = MEMORY ADDRESS; REG = DATA (8 BITS TO A WORD, 6 WORD TOTAL)
C
C       TABLE MEMORY IS STORED: EXPONENT, HIGH MANTISSA, LOW MANTISSA
C       IN THREE WORDS
C
        INTEGER TM(512,3),RAMSIZ,TRIGSZ,HFFTSZ,SFFTSZ,RAMBAS
        COMMON /TMRM/ TM,RAMSIZ,TRIGSZ,HFFTSZ,SFFTSZ,RAMBAS
C
C-------TM LAYOUT
C
C       HARDWARE: FFT-TABLE                  0 - 2047
C                 FUNCTION COEFFICIENTS   2048 - 2348
C                 HOLE                    2349 - 4095
C                 TMRAM                   4096 +
C
C       ARRAY TM  FFT-TABLE                  1       - FFTSIZ
C                 FUNCTION COEFFICIENTS   FFTSIZ+1   - FFTSIZ+301
C                 TMRAM (1024 WORDS)      FFTSIZ+302 - FFTSIZ+301+RAMSIZ
C
C       ROMSIZ - TOTAL ROM SIZE (FFT + FUNCTION COEFF)  (USUALLY 2349)
C       RAMSIZ - TMRAM SIZE  (SET TO 1024 HERE)
C       RAMBAS - BASE ADDRESS OF TMRAM (USUALLY 4096)
C
C  *****NEW FPS100
C       STORAGE FOR SPECIAL FPS100 TM REGISTER
C
        INTEGER EXTRA(224),TMSPEC(6)
        COMMON /IORM/ EXTRA,TMSPEC
C  *****NEW END FPS100
C
C-------LOCAL STORAGE
C
        INTEGER TMSIZE,I,J,K1,K2,TEMP(2)
C
        TMSIZE=SFFTSZ+TRIGSZ+RAMSIZ
C
        IF (OP.GT.0) GO TO 180
C
C-------ZERO TMRAM
C
        K1=SFFTSZ+TRIGSZ+1
        K2=TMSIZE
        DO 150 I=K1,K2
        DO 150 J=1,3
150     TM(I,J)=0
        DO 160 I=1,6
160     TMSPEC(I)=0
        RETURN
C
C-------READ, WRITE
C
C       SEE WICH PART OF TABLE MEMORY
C
C       SEE IF IN THE RAM
180     IF (ADDR.GE.RAMBAS.AND.ADDR.LT.RAMBAS+RAMSIZ) GOTO 196
C       SEE IF IN THE FFT PART
        IF (ADDR.GE.0.AND.ADDR.LT.SFFTSZ) GOTO 197
C       SEE IF IN THE TRIG TABLE
        IF (ADDR.GE.HFFTSZ.AND.ADDR.LT.HFFTSZ+TRIGSZ) GOTO 198
C
C       IN NONE OF THEM
C  *****NEW FPS100
C
C       TEST FOR SPECIAL TMRAM DEDICATED ADDRESS (177777)
        CALL UNPKRG (ADDR, TEMP)
        IF (.NOT.(TEMP(1).EQ.255 .AND. TEMP(2).EQ.255)) GO TO 400
                GO TO (190,192), OP
C               READ SPECIAL REGISTER
190             CALL RMOV (TMSPEC,REG,6)
                RETURN
C               WRITE SPECIAL REGISTER
192             CALL RMOV (REG,TMSPEC,6)
                RETURN
C  *****NEW END FPS100
C
C       IN THE RAM
196     I=ADDR-RAMBAS+SFFTSZ+TRIGSZ
        GOTO 199
C
C       IN THE FFT TABLE
197     I=ADDR
        GOTO 199
C
C       IN THE TRIG TABLE
198     I=ADDR-HFFTSZ+SFFTSZ
C
199     GOTO (200,300),OP
C
C-------READ
C
200     CALL MREAD(TM,I,REG,TMSIZE,3,6)
        RETURN
C
C-------WRITE
C
C       KEEP FROM MODIFYING THE ROM PART
300     IF (ADDR.LT.RAMBAS) RETURN
        CALL MWRIT(REG,TM,I,TMSIZE,6,3)
        RETURN
C
C-------ADDRESS IN THE HOLE, RETURN ZERO ON READING
C
400     IF (OP.NE.1) RETURN
        DO 410 I=1,6
410     REG(I)=0
        RETURN
        END
C
C+++ FPADD
C****** FPADD = ADDER SIMULATION = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:01:33
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE FPADD(A1,A2,A3,FADDF,FADD1F,VALUE)
C
C
C
C       FLOATING POINT ADD.....................
C       ADD A1 AND A2 AND PUT THE RESULT INTO AM3
C       FADDF AND FADD1F ARE THE ADDER OPERATION CODES
C
        INTEGER A1(6),A2(6),A3(7),FADDF,FADD1F,VALUE(2)
        INTEGER MA(4),MB(4),MC(4),EA,EB,EC,DELTA,TRUNC,MT(4)
C
C       GET ARGUMENTS AND ALIGN AGAINST LEFT BYTE BOUNDARY
C       SINCE THE FIRST WORD HAS ONLY 4 RIGHT JUSTIFIED
C       BITS OF INFORMATION, AND THIS CREATES OUR GUARD
C       BITS DOWN IN WORD 4
        CALL MOVPRT(A1,3,MA,1,6,4,4)
        CALL MOVPRT(A2,3,MB,1,6,4,4)
        CALL LSHFT(MA,4,4,0,K,K)
        CALL LSHFT(MB,4,4,0,K,K)
        EA=A1(1)*256+A1(2)
        EB=A2(1)*256+A2(2)
C       SET TRUNC TO ROUND
        TRUNC=0
         NOCNT=40
         ISM=0
C
C       SHIFT BOTH MANTISSAS RIGHT ONE PLACE
C       TO ALLOW FOR OVERFLOW ON ADDING
C
        CALL LSHFT(MA,-1,4,1,K,K)
        CALL LSHFT(MB,-1,4,1,K,K)
        EA=EA+1
        EB=EB+1
C
C       SEE IF A SINGLE OP INSTRUCTION
C
        IF (FADDF.EQ.0) GO TO 10000
C
C       SEE IF WE@RE DOING A SUBTRACTION
C
        IF (FADDF.EQ.1) CALL NEGATE(MA,4,K)
        IF (FADDF.EQ.2) CALL NEGATE(MB,4,K)
C
C       SWAP TO PUT ARGUMENT WITH SMALLER EXPONENT IN MB
C
        DELTA=EA-EB
        EC=EA
        IF (DELTA.GE.0) GO TO 200
        CALL RMOV(MA,MC,4)
        CALL RMOV(MB,MA,4)
        CALL RMOV(MC,MB,4)
        EC=EB
C
C       SEE IF THE  EXPONENT DIFFERENCE IS TOO GREAT
C       IF SO MA IS THE ANSWER
C       NOT NECESSARILLY ... RATHER FORCE ZERO MANTISSA IN MB
C
200     DELTA=-IABS(DELTA)
        IF (DELTA.GE.-32) GO TO 250
C        CALL RMOV (MA,MC,4)
C        GO TO 1000
        MB(1)=0
        MB(2)=0
        MB(3)=0
        MB(4)=0
        GO TO 260
C
C       ALIGN MANTISSAS
250     CALL LSHFT(MB,DELTA,4,1,K,KC)
C
C       KC HAS CAUGHT THE OR OF ANY BITS THAT HAVE BEEN SHOVED OFF
C               THE RIGHT END DURING ALLIGNMENT
C       OR IT WITH THE LSB OF THE SHIFTED MANTISSA
C
        IF (MOD(MB(4),2).EQ.0.AND.KC.EQ.1) MB(4)=MB(4)+KC
C
C       DO THE SPECIFIED ALU OPERATION
C
260     CONTINUE
        GO TO (300,300,300,400,500,600), FADDF
C
C       AN ADD
300     CALL TCADD(MA,MB,MC,4,K)
        GO TO 1000
C
C       AN EQUIVALENCE
C       A EQV B = NOT(NOT A AND B) OR (A AND NOT B))
400     CALL LCOM(MA,MC,4)
        CALL LAND(MB,MC,MC,4)
        CALL LCOM(MB,MT,4)
        CALL LAND(MA,MT,MT,4)
        CALL TCADD(MT,MC,MC,4,K)
        CALL LCOM(MC,MC,4)
        GO TO 1000
C
C       AND
500     CALL LAND(MA,MB,MC,4)
        GO TO 1000
C
C       OR
C       A OR B = NOT(NOT A AND NOT B)
600     CALL LCOM(MA,MT,4)
        CALL LCOM(MB,MC,4)
        CALL LAND(MT,MC,MC,4)
        CALL LCOM(MC,MC,4)
        GO TO 1000
C
C       STORE THE ALU RESULT AND GO FINISH
C
1000         CONTINUE
        CALL NORMAL(EC,MC,A3,TRUNC,NOCNT)
C        TURN ON SIGN BIT IF NEGATIVE SIGNED MAGNITUDE RESULT
         IF (ISM.NE.1) GO TO 1100
        A3(3)=A3(3)+8
        A3(7)=A3(7)+1
1100    RETURN
C
C       SINGLE OP INSTRUCTIONS
C
10000   CALL RMOV(MB,MC,4)
        EC=EB
        GO TO (10100,10200,10300,10400,10500,10600,10700),FADD1F
C
C       SCALE (TRUNCATED)
10300    TRUNC=1
C        SCALE (ROUNDED)
10600   ISCALE=MOD(VALUE(1),4)*256+VALUE(2)
        I=512
        IF (ISCALE.GE.512) I=-I
        ISCALE=ISCALE+I-1
         GO TO 10150
C       FIX (TRUNCATED)
10200   TRUNC=1
C       FIX (ROUNDED)
10100    ISCALE=512+27
C        COMMON FOR FIX AND SCALE (INHIBIT NORMALIZATION)
10150   NOCNT=0
C
C       FORCE VALUE INTO A1 FOR LATER INSTRUCTIONS TO GET AT WITH NC
C
        A1(1)=(ISCALE+1)/256
        A1(2)=MOD(ISCALE+1,256)
        DO 10110 KKK=3,6
          A1(KKK)=0
10110     CONTINUE
        DELTA=EC-ISCALE
C        DON'T SHIFT LEFT
         IF (DELTA.LE.1) GO TO 10120
           EC=EC-2
           CALL LSHFT(MC,2,4,0,K,KC)
           MC(1)=KC*128+MOD(MC(1),128)
           GO TO 1000
10120   CONTINUE
        IF (DELTA.GE.-32) GO TO 10350
C       TOO GREAT A SHIFT, MAKE A CLEAN ZERO
        DO 10330 J=1,4
10330   MC(J)=0
        EC=0
        GO TO 1000
C       SHIFT A ND OR IN BIT BUCKET
10350   CALL LSHFT(MC,DELTA,4,1,K,KC)
        IF (MOD(MC(4),2).EQ.0.AND.KC.EQ.1) MC(4)=MC(4)+KC
        EC=ISCALE
        GO TO 1000
C
C       SIGNED MAGNITUDE TO 2@S COMPLEMENT
C        IF SIGN BIT ON, TURN OFF LEFT TWO BITS AND NEGATE & NORMALIZE
10400   IF (MOD(MC(1)/128,2).EQ.0) GO TO 1000
        MC(1)=MOD(MC(1),64)
        CALL NEGATE(MC,4,K)
        GO TO 1000
C
C       2'S COMPLEMENT TO SIGNED MAGNITUDE
C        IF NEGATIVE, MAKE POSITIVE AND REMEMBER TO TURN ON SIGN BIT
C              AFTER NORMALIZATION
10500   IF (MOD(MC(1)/128,2).EQ.0) GO TO 1000
        CALL NEGATE(MC,4,K)
         ISM=1
        GO TO 1000
C
C       ABSOLUTE VALUE
10700   IF (MOD(MC(1)/128,2).EQ.0) GO TO 1000
        CALL NEGATE(MC,4,K)
        GO TO 1000
        END
C
C+++ FPINPT
C****** FPINPT = FORTRAN TO AP-120B F.P. = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:02:28
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE FPINPT(DECIN,REG)
C
C
C
C
C
C-----------------------------------------------
C
C       THE TWO FOLLOWING SUBROUTINES PROVIDE THE DEBUGGER WITH
C               FLOATING POINT NUMBER CONVERSION BETWEEN THE
C               HOST@S FORTRAN FLOATING POINT FORMAT AND THE
C               AP-120B@S INTERNAL FORMAT
C
C
C       INPUT
C       STORE A DOUBLE PRECISION FLOATING POINT NUMBER, DECIN,
C               INTO REG
C
        DOUBLE PRECISION DEC,DECIN
        INTEGER REG(6),MANT(8),WRK(7),MC(4)
        DEC=DECIN
        IF (DEC.NE.0.0D0) GO TO 100
C       MAKE A CLEAN ZERO AND RETURN
        DO 10 J=1,6
10      REG(J)=0
        RETURN
C       MAKE POSITIVE AND REMEMBER SIGN
100     ISG=0
        IF (DEC.LT.0.0D0) ISG=1
        DEC=DABS(DEC)
C       WE@RE GOING TO MULTIPLY BY POWERS OF TWO UNTIL OUT INPUT
C               VALUE IS BETWEEN 0.5 AND 0.9999999999
C
        IEXP=512
200     IF (DEC.GE.1.0D0) GO TO 400
300     IF (DEC.GE.0.5D0) GO TO 500
C       WE MUST MAKE THINGS LARGER
        DEC=DEC*2.0D0
        IEXP=IEXP-1
        GO TO 300
C
C       WE MUST MAKE THINGS SMALLER
400     DEC=DEC/2.0D0
        IEXP=IEXP+1
        GO TO 200
C
500     DO 600 I=1,8
        DEC=DEC*256.0D0
        IDEC=IDINT(DEC)
        MANT(I)=IDEC
600     DEC=DEC-DBLE(FLOAT(IDEC))
C
C       CONVERT FROM SIGNED MAGNITUDE TO 2@S COMPLEMENT
C
        CALL LSHFT(MANT,-1,8,0,K,K)
        IF (ISG.EQ.1) CALL NEGATE(MANT,8,K)
C       OR THE EXTRA BITS INTO THE LSB
        IBUKET=0
        DO 650 J=5,8
        IF (MANT(J).NE.0) IBUKET=1
650     CONTINUE
        IF (MOD(MANT(4),2).EQ.0.AND.IBUKET.EQ.1)
     1MANT(4)=MANT(4)+IBUKET
        CALL MOVPRT(MANT,1,MC,1,8,4,4)
        CALL NORMAL(IEXP,MC,WRK,0,40)
        CALL MOVPRT(WRK,1,REG,1,7,6,6)
        RETURN
        END
C
C+++ FPMUL
C****** FPMUL = FLOATING MULTIPLY SIM = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:03:16
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE FPMUL(M1,M2,M3)
C
C
C
C
C
C----------------------------------------------------
C
C       THE FOLLOWING THREE PROVIDE THE EXACT SIMULATION OF THE
C               AP-120B@S FLOATING POINT ARITHMETIC
C       BOTH ADD AND MULTIPLY CALL "NORMAL" TO NORMALIZE
C               THE ANSWER ROUND, CHECK FOR ERRORS, AAND SET
C               TH CONDITION BITS
C
C
C
C       FLOATING POINT MULTIPLY...........
C
C       MULTIPLY M1 TIMES M2 AND PUT ANSWER IN M3
C       THESE ARE 6 BYTES WIDE
C       PUT ERROR BITS IN SEVENTH WORD OF M3
C
        INTEGER M1(6),M2(6),M3(7)
        INTEGER MA(4),MB(4),MC(8),MHP(8),MLP(8),EC
C
C       SEPARATE OUT MANTISSAS AND ALIGN TO LEFT BOUNDARY
C       BY SHIFTING LEFT 4 PLACES
C
        CALL MOVPRT(M1,3,MA,1,6,4,4)
        CALL MOVPRT(M2,3,MB,1,6,4,4)
        CALL LSHFT(MA,4,4,0,K,K)
        CALL LSHFT(MB,4,4,0,K,K)
C
C       ADD EXPONENTS, AND SUBTRACT OUT BIAS OF 512
C
        EC=M1(1)*256+M1(2)+M2(1)*256+M2(2)-512+1
C
C       TAKE ABSOLUTE VALUE OF MANTISSAS AND
C       COMPUTE THE SIGN OF THE PRODUCT
C
        ISA=1
        IF (MA(1).LT.128) GO TO 100
        CALL NEGATE(MA,4,K)
        ISA=-1
100     ISB=1
        IF (MB(1).LT.128) GO TO 110
        CALL NEGATE(MB,4,K)
        ISB=-1
110     ISC=ISA*ISB
C
C       DO THE 16 CROSS PRODUCTS
C
C       ZERO OUT THE PRODUCT ARRAY
        DO 200 K=1,8
200     MC(K)=0
C       DO A 16-BIT PRODUCT FOR EACH BYTE OF M1
        DO 250 I=1,4
C       ZERO THE HIGH AND LOW PARTS REGISTERS
        DO 210 K=1,8
        MHP(K)=0
210     MLP(K)=0
C       AND DO A PRODUCT FOR EACH BYTE OF M2
        DO 220 J=1,4
        K=I+J
C       SEPARATE OUT THE HIGH ORDER TWO BITS OF EACH BYTE SO THE
C               BYTE PRODUCT DOESN@T OVERFLOW INTO THE SIGN
C                       BIT OF 16-BIT MINI@S
        MAL=MOD(MA(I),64)
        MAH=MOD(MA(I)/64,4)
        MBL=MOD(MB(J),64)
        MBH=MOD(MB(J)/64,4)
C       DO THE BYTE PRODUCT
        IPL=MAL*MBL+(MAL*MBH+MAH*MBL)*64
        IPH=MAH*MBH*16
C       STORE THE HIGH AND LOW BYTES OF THE PRODUCT
        MHP(K-1)=IPL/256+IPH
220     MLP(K)=MOD(IPL,256)
C       ADD THE HIGH AND LOW PRODUCT PARTS INTO THE PARTIAL PRODUCT
        CALL TCADD(MHP,MC,MC,8,K)
250     CALL TCADD(MLP,MC,MC,8,K)
C
C       NEGATE IF NECESSARY TO GIVE THE PROPER SIGN
C
        IF (ISC.EQ.-1) CALL NEGATE(MC,8,K)
C
C       COLLECT ALL THE EXTRA BITS INTO THE LSB OF THE MANTISSA
C
        IBUKET=0
        DO 300 J=5,8
        IF (MC(J).NE.0) IBUKET=1
300     CONTINUE
C
C       OR THE BIT BUCKET WITH THE LSB
C
        IF (MOD(MC(4),2).EQ.0.AND.IBUKET.EQ.1) MC(4)=MC(4)+IBUKET
C
C       STORE THE UNNORMALIZED ANSWER AND GO FINISH
C
        CALL MOVPRT(MC,1,MA,1,8,4,4)
C        SET INHIB TO ONLY NORMALIZE 2 PLACES
        CALL NORMAL(EC,MA,M3,0,2)
        RETURN
        END
C
C+++ FPOUT
C****** FPOUT = AP-120B TO FORTRAN F.P. = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:04:10
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE FPOUT(REG,DEC,MAXEX,IOV)
C
C
C
C
C       FLOATING POINT OUTPUT
C       CONVERT REG INTO A DOUBLE PRECISION FORTRAN
C               FLOATING POINT NUMBER, DEC
C
        INTEGER REG(6),MANT(4)
        DOUBLE PRECISION DEC
C       SPLIT INTO EXPONENT AND MANTISSA
        CALL MOVPRT(REG,3,MANT,1,6,4,4)
C
C       SHIFT LEFT TO LEFT JUSTIFY AND THEN
C               RIGHT SHIFT ONE TO AVOID
C               -(-1.0) PROBLEMS
        IOV=0
        CALL LSHFT(MANT,4,4,0,K,K)
        CALL LSHFT(MANT,-1,4,1,K,K)
C       LOOK FOR ZERO
        DO 50 J=1,4
        IF (MANT(J).NE.0) GO TO 100
50      CONTINUE
        DEC=0.0D0
        GO TO 200
100     IEX=REG(1)*256+REG(2)-512+1
        IF (IABS(IEX).GE.MAXEX) GO TO 300
C       NEGATE IF NEGATIVE
        ISG=MOD(MANT(1)/128,2)
        IF (ISG.NE.0) CALL NEGATE(MANT,4,K)
        DEC=DBLE(FLOAT(MANT(4)))/2147483648.0D0+DBLE(FLOAT(MANT(3)))/
     1          8388608.0D0+DBLE(FLOAT(MANT(2)))/32768.0D0+
     2          DBLE(FLOAT(MANT(1)))/128.0D0
        DEC=DEC*2.0D0**IEX
        IF (ISG.EQ.1) DEC=-DEC
200     RETURN
C
300     IOV=1
        RETURN
        END
C
C+++ INCODE
C****** INCODE = MODIFY P.S. WORDS = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:05:04
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE INCODE(OCT,IDX,REG)
C
C
C       ENCODE AN OCTAL VALUE INTO THE SPECIFIED FIELD
C               OF A PROGRAM SOURCE WORD STORED AS 8 BYTES
C
C
        INTEGER REG(8),OCT,IDX
C       GO CHANGE THE PROPER FIELD
        GO TO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
     119,20,21,22,23,24,4,4,5,5,5,5,5,5,5,
     27,7,8,8,8,8,8,8), IDX
C
C       D FIELD
1       REG(1)=MOD(OCT,2)*128+MOD(REG(1),128)
        GO TO 100
C       SOP FIELD
2       REG(1)=MOD(OCT,8)*16+(REG(1)/128)*128+MOD(REG(1),16)
        GO TO 100
C       SH FIELD
3       REG(1)=MOD(OCT,4)*4+(REG(1)/16)*16+MOD(REG(1),4)
        GO TO 100
C       SPS FIELD
4       REG(1)=MOD(OCT/4,4)+(REG(1)/4)*4
        REG(2)=MOD(OCT,4)*64+MOD(REG(2),64)
        GO TO 100
C       SPD FIELD
5       REG(2)=MOD(OCT,16)*4+(REG(2)/64)*64+MOD(REG(2),4)
        GO TO 100
C       FADD FIELD
6       REG(2)=MOD(OCT/2,4)+(REG(2)/4)*4
        REG(3)=MOD(OCT,2)*128+MOD(REG(3),128)
        GO TO 100
C       A1 FIELD
7       REG(3)=MOD(OCT,8)*16+(REG(3)/128)*128+MOD(REG(3),16)
        GO TO 100
C       A2 FIELD
8       REG(3)=MOD(OCT,8)*2+(REG(3)/16)*16+MOD(REG(3),2)
        GO TO 100
C       COND FIELD
9       REG(3)=MOD(OCT/8,2)+(REG(3)/2)*2
        REG(4)=MOD(OCT,8)*32+MOD(REG(4),32)
        GO TO 100
C       DISP FIELD
10      REG(4)=MOD(OCT,32)+(REG(4)/32)*32
        GO TO 100
C       DPX FIELD
11      REG(5)=MOD(OCT,4)*64+MOD(REG(5),64)
        GO TO 100
C       DPY FIELD
12      REG(5)=MOD(OCT,4)*16+(REG(5)/64)*64+MOD(REG(5),16)
        GO TO 100
C       DPBS FIELD
13      REG(5)=MOD(OCT,8)*2+(REG(5)/16)*16+MOD(REG(5),2)
        GO TO 100
C       XR FIELD
14      REG(5)=MOD(OCT/4,2)+(REG(5)/2)*2
        REG(6)=MOD(OCT,4)*64+MOD(REG(6),64)
        GO TO 100
C       YR FIELD
15      REG(6)=MOD(OCT,8)*8+(REG(6)/64)*64+MOD(REG(6),8)
        GO TO 100
C       XW FIELD
16      REG(6)=MOD(OCT,8)+(REG(6)/8)*8
        GO TO 100
C       YW FIELD)
17      REG(7)=MOD(OCT,8)*32+MOD(REG(7),32)
        GO TO 100
C       FM FIELD
18      REG(7)=MOD(OCT,2)*16+(REG(7)/32)*32+MOD(REG(7),16)
        GO TO 100
C       M1 FIELD
19      REG(7)=MOD(OCT,4)*4+(REG(7)/16)*16+MOD(REG(7),4)
        GO TO 100
C       M2 FIELD
20      REG(7)=MOD(OCT,4)+(REG(7)/4)*4
        GO TO 100
C       MI FIELD
21      REG(8)=MOD(OCT,4)*64+MOD(REG(8),64)
        GO TO 100
C       MA FIELD
22      REG(8)=MOD(OCT,4)*16+(REG(8)/64)*64+MOD(REG(8),16)
        GO TO 100
C       DPA FIELD
23      REG(8)=MOD(OCT,4)*4+(REG(8)/16)*16+MOD(REG(8),4)
        GO TO 100
C       TMA FIELD
24      REG(8)=MOD(OCT,4)+(REG(8)/4)*4
100     RETURN
        END
C
C+++ LAND
C****** LAND = LOGICAL AND = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:05:54
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE LAND (REGA,REGB,REGC,W)
C
C       LOGICAL AND
C
C       PRODUCE THE LOGICAL AND OF (REGA AND REGB,
C               PUT THE RESULT INTO REGC
C       ALL THREE REGISTERSX ARE W BYTES WIDE
C
        INTEGER W,REGA(W),REGB(W),REGC(W)
        DO 100 I=1,W
        KA=REGA(I)
        KB=REGB(I)
        KC=0
        DO 50 J=1,8
        KC=KC/2
        IF (MOD(KA,2)+MOD(KB,2).EQ.2) KC=KC+128
        KA=KA/2
50      KB=KB/2
100     REGC(I)=KC
        RETURN
        END
C
C+++ LCOM
C****** LCOM = LOGICAL COMPLEMENT = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:06:40
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE LCOM (REGA,REGB,W)
C
C
C
C       INTEGER ARITHMETIC AND LOGICAL OPERATIONS.............
C
C       LOGICAL COMPLEMENT
C
C       PRODUCE THE LOGICAL COMPLEMENT OF REGA AND STORE
C               IT INTO REGB
C       BOTH ARE W BYTES WIDE
C
        INTEGER W,REGA(W),REGB(W)
        DO 100 I=1,W
        KA=REGA(I)
        KB=0
        DO 50 J=1,8
        KB=KB/2
        IF (MOD(KA,2).EQ.0) KB=KB+128
50      KA=KA/2
100     REGB(I)=KB
        RETURN
        END
C
C+++ LSHFT
C****** LSHFT = LOGICAL SHIFT = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:07:26
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE LSHFT (REGA,COUNT,W,SIGNED,CARRY,BUCKET)
C
C
C
C
C       ARITHMETIC SHIFTING
C
C       SHIFT REGA COUNT POSITIONS TO THE RIGHT OR LEFT
C               ANDT PUT THE RESULT INTO REGB
C       IF COUNT IS 0 DO NOTHING
C       IF COUNT -IS NEGATIVE SHIFT RIGHT
C       IF COUNT IS POSITIVE SHIFT LEFT
C       REGA AND REGB ARE W BYTES WIDE
C       ANY RESULTING CARRY IS RETURNED
C       IF SIGNED IS 1 AN ARITHMETIC IS PERFORMED, IF 0
C               A LOGICAL SHIFT
C       BUCKET RETURNS THE INCLUSIVE OR OF ANY BITS SHIFTED
C               INTO CARRY
C
        INTEGER W,COUNT,REGA(W),CARRY,SIGNED,BUCKET
C
C       RETURN IF NO SHIFTING REQUIRED
C
        BUCKET=0
        CARRY=0
        ICNT=IABS(COUNT)
        IF (COUNT.EQ.0) RETURN
        IF (COUNT.LT.0) GO TO 100
C
C       LEFT SHIFT (I.E. MULTIPLY BY POWERS OF TWO)
C
        DO 50 K=1,ICNT
        CARRY=MOD(REGA(1)/128,2)
        IF (BUCKET.EQ.1.OR.CARRY.EQ.1) BUCKET=1
        M=W-1
        DO 10 I=1,M
10      REGA(I)=MOD(REGA(I)*2+MOD(REGA(I+1)/128,2),256)
50      REGA(W)=MOD(REGA(W)*2,256)
        RETURN
C
C       RIGHT SHIFT (I.E.MULTIPLY BY A NEGATIVE POWER OF TWO)
C
100     DO 150 K=1,ICNT
        CARRY=MOD(REGA(W),2)
        IF (BUCKET.EQ.1.OR.CARRY.EQ.1) BUCKET=1
        M=W-1
        IF(M.EQ.0)GO TO 120
        DO 110 I=1,M
        J=W+1-I
110     REGA(J)=REGA(J)/2+MOD(REGA(J-1),2)*128
120     CONTINUE
        IS=0
        IF (SIGNED.EQ.1) IS=MOD(REGA(1)/128,2)*128
C       THIS EXTRA ASSIGNMENT IS HERE BECAUSE OF A BUG IN
C       PDP-11 RT-11 FORTRAN (THE /2 IS LEFT OUT OTHERWISE)
        IS=REGA(1)/2+IS
150     REGA(1)=IS
        RETURN
        END
C
C+++ MOVPRT
C****** MOVPRT = MOVE PART OF REGISTER = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:08:15
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE MOVPRT (SRC,S1,DST,D1,SW,DW,N)
C
C       INTER-REGISTER PARTIAL WIDTH TRANSFERS
C
C       MOVE REGISTER SRC TO REGIBSTER DST
C       START AT BYTE S1 OF SRC AND D1 OF DST AND MOVE N BYTE0S
C       SRC IS SW BYTES WIDE, DST IS DW BYTES WIDE
C
        INTEGER S1,D1,SW,DW,SRC(SW),DST(DW),N
        DO 100 I=1,N
        J=S1+I-1
        K=D1+I-1
100     DST(K)=SRC(J)
        RETURN
        END
C
C+++ MREAD
C****** MREAD = MEMORY READ = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:09:04
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE MREAD(MEM,MA,REG,MSIZE,MW,RW)
C
C       MEMORY FETCHES AND STORES..........................
C
C       MEMORIES ARE ARRANGED AS STRINGS OF 16-BIT WORDS
C               TO CONSERVE SPACE
C
C       MEMORY FETCHES
C
C       FETCH LOCATION MA OF MEMORY MEM AND PUT IT INTO
C               REGISTER REG
C       MEM IS MW WORDS WIDE AND MSIZE LOCATIONS LONG
C       REG IS RW BYTES WIDE
        INTEGER MSIZE,MW,RW,MA,MEM(MSIZE,MW),REG(RW)
        MAR=MA+1
C       SEE IF FETCH IS OUT OF RANGE, IF SO RETURN ZERO
        IF (MAR.LE.0.OR.MAR.GT.MSIZE) GO TO 200
        DO 100 I=1,MW
        J=I*2-1
        INF=0
        ITMP=MEM(MAR,I)
C       IF THIS IS A 16-BIT MACHINE THE SIGN BIT MIGHT BE ON,
C       IF SO SET A FLAG AND TURN IT OFF
        IF (ITMP.GE.0) GO TO 50
        INF=1
        ITMP=ITMP+32767+1
50      REG(J)=ITMP/256+INF*128
100     REG(J+1)=MOD(ITMP,256)
        RETURN
200     DO 210 I=1,RW
210     REG(I)=0
        RETURN
        END
C
C+++ MWRIT
C****** MWRIT = MEMORY WRITE  = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:09:51
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE MWRIT(REG,MEM,MA,MSIZE,RW,MW)
C
C       MEMORY STORES
C       STORE REGISTER REG INTO MEMORY MEM LOCATION MA
C       MEM IS MSIZE LOCATIONS LONG AND MW WORDS WIDE
C       REG ID RW BYTES WIDE
        INTEGER MSIZE,MA,RW,MW,REG(RW),MEM(MSIZE,MW)
        MAR=MA+1
C       IF MA IS OUT OF RANGE DON@T STORE ANYTHING
        IF (MAR.LE.0.OR.MAR.GT.MSIZE) RETURN
        DO 100 I=1,MW
        J=I*2-1
C       IN A 16-BIT MACHINE THE SIGN BIT OF THE LEFT BYTE
C       MIGHT BE ON, SO WORRY ABOUT IT
        INF=MOD(REG(J)/128,2)
        ITMP=MOD(REG(J),128)*256+REG(J+1)
        IF (INF.EQ.1) ITMP=ITMP-32767-1
100     MEM(MAR,I)=ITMP
        RETURN
        END
C
C+++ NEGATE
C****** NEGATE = 2'S COMPLEMENT NEGATE = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:10:42
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE NEGATE(REGA,W,OVER)
C
C-------------------------------------------------
C
C       THE REST OF THE SUBROUTINES DO BASIC INTEGER TYPE
C               OPERATIONS ON OUR REGISTERS (WHICH, AS WE
C               REMEMBER, ARE MADE UP OF EIGHT BIT BYTES, TO
C               AVOID SIGN BIT PROBLEMS WITH FORTRAN
C
C
C       TWOS COMPLEMENT NEGATE
C
C       COMPLEMENT AND ADD ONE
C
        INTEGER W,REGA(W),OVER,ONE(8)
        M=W-1
        DO 10 I=1,M
10      ONE(I)=0
        ONE(W)=1
        OVER=0
        IS=MOD(REGA(1)/128,2)
        CALL LCOM(REGA,REGA,W)
        CALL TCADD(REGA,ONE,REGA,W,IC)
        IF (MOD(REGA(1)/128,2).EQ.IS) OVER=IS
        RETURN
        END
C
C+++ NORMAL
C****** NORMAL = NORMALIZE = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:11:35
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE NORMAL(EC,MC,ANSWER,TRUNC,NOCNT)
C
C
C
C
C
C       NORMALIZE, ROUND, AND SET ERROR AND CONDITION BITS
C       ROUND CONVERGENTLY
C       POSITIVE NUMBERS'
C               0.0 TO 0.5 GOES TOWARD 0 .0
C               0.5+ TO +1.0 GOES TOWARD 1.0-
C       NEGATIVE NUMBERS'
C               0.0 TO -0.5 GOES TOWARD 0.0
C               -0.5+ TO +-1.0 GOES TOWARD -1.0
C
C       DO THIS BY ADDING ONE BIT TO THE RIGHT OF THE FINAL LSB'
C               POSITI4VE       01111.......
C               NEGATIVE        10000.....
C       TO TRUNCATE, ADD'
C               POSITIVE        00000.....
C               NEGATIVE        11111.....
C
C       ANSWER(1-2) IS THE EXPONENT
C       ANSWER(3-6) IS THE MANTISSA AS FOUR EIGHT BIT BYTES
C       ANSWER(7) HOLDS THE ERROR AND CONDITION BITS'
C               00001=NEGATIVE
C               00010=ZERO
C               01000=EXPONENT UNDERFLOW
C               10000=EXPONENT OVERFLOW
C
C       IF TRUNC=1 TRUNCATE INSTEAD OF ROUNDING
C        NOCNT IS THE MAXIMUM NUMBER OF NORMALIZE SHIFTS TO BE ALLOWED
C        0 WHEN NORMALIZATION IS TO BE INHIBITED
C        2 FOR MULTIPLY
C        40 OTHERWISE  (MORE THAN ENOUGH)
C
        INTEGER ANSWER(7),TRUNC,MC(4),EC,ROUND(4),RNDCON(4),TMP(4)
C
C        INITIALIZE
         NCNT=NOCNT
        ANSWER(7)=0
        RNDCON(1)=7
        RNDCON(2)=8
        RNDCON(3)=0
        RNDCON(4)=15
        ISC=0
C       FIRST SEE IF WE HAVE A MANTISSA OF ALL ZEEROS
C               OR ALL ONES, IF SO FORCE A CLEAN
C               FLOATING POINT ZERO
C
        CALL RMOV(MC(1),TMP(1),4)
        ISHIFT=-3
        IF (TRUNC .EQ. 1 ) ISHIFT=-4
        CALL LSHFT(TMP,ISHIFT,4,1,KKK,J)
        IALL=0
        IF (TMP(1).NE.0) IALL=255
        DO 250 J=1,4
        IF (TMP(J).NE.IALL) GO TO 300
250     CONTINUE
        GO TO 550
C
C       NORMALIZE LOOP, LOOK FOR 01 OR 10 AS THE TWO HIGH BITS
C
300     INRM=MOD(MC(1)/64,4)
        IF (INRM.EQ.1.OR.INRM.EQ.2.OR.NCNT.LE.0)  GO TO 400
        CALL LSHFT(MC,1,4,1,K,K)
        EC=EC-1
         NCNT=NCNT-1
        GO TO 300
C
C       ROUND
C
C       GET THE ROUNDING CONSTANT'
C               POSITIVE' 0,0,0,7
C               NEGATIVE' 0,0,0,*10
C       OR TRUNCATE'
C               POSITIVE' 0,0,0,0
C               NEGATIVE' 0,0,0,15
C
400     DO 410 J=1,3
410     ROUND(J)=0
        ISC=MOD(MC(1)/128,2)
        IRND=TRUNC*2+ISC+1
        ROUND(4)=RNDCON(IRND)
C       ADD IN THE PROPER CONSTANT
        CALL TCADD(MC,ROUND,MC,4,K)
C
C       SEE IF WE HAD ALL ONES WHICH OVERFLOWED WHEN
C               WE ADDED THE ROUNDING CONSTANT
C
        IF (ISC.EQ.1.OR.MC(1).LT.128) GO TO 500
C       DENORMALIZE ONE POSITION RIGHT
        CALL LSHFT(MC,-1,4,0,K,K)
        EC=EC+1
C
C       CHECK FOR UNDERFLOW
C
500     IF (EC.GE.0) GO TO 600
C       FORCE A CLEAN ZERO AND SET ERROR BIT
        ANSWER(7)=8
550     EC=0
        DO 560 J=1,4
560     MC(J)=0
        ANSWER(7)=ANSWER(7)+2
        GO TO 1000
C
C       CHECK FOR OVERFLOW
C
600     IF (EC.LT.1024) GO TO 1000
C       SET ERROR BIT AND FORCE SIGNED MAXIMUM VALUE
        ANSWER(7)=16
        EC=1023
        IF (ISC.EQ.1) GO TO 670
C       MAX POSITIVE VALUE
        MC(1)=127
        DO 660 J=2,4
660     MC(J)=255
        GO TO 1000
C       MAX NEGATIVE VALUE
670     MC(1)=128
        DO 680 J=2,4
680     MC(J)=0
C
C       SET CONDITION BITS
C
1000    IF (ISC.EQ.1) ANSWER(7)=ANSWER(7)+1
C
C       ALIGN MANTISSA WITH RIGHT BOUNDARY AND STORE RESULT
C
        CALL LSHFT(MC,-4,4,0,K,K)
        DO 1010 KKK=1,4
          IF(MC(KKK).NE.0)GO TO 1020
1010      CONTINUE
        EC=0
        ANSWER(7)=( (ANSWER(7)/4)*4 ) +2
        MC(1)=0
        MC(2)=0
        MC(3)=0
        MC(4)=0
1020    CONTINUE
        ANSWER(1)=EC/256
        ANSWER(2)=MOD(EC,256)
        CALL MOVPRT(MC,1,ANSWER,3,4,7,4)
        RETURN
        END
C
C+++ PAKRG
C****** PAKRG = PACK REGISTER = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:12:26
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE PAKRG(REG,DEC)
        INTEGER DEC,REG(2),WRK(1,1)
C       PACKS A 2 BYTE REGISTER INTO A 16-BIT INTEGER
        CALL MWRIT(REG,WRK,0,1,2,1)
        DEC=WRK(1,1)
        RETURN
        END
C
C+++ RMOV
C****** RMOV = REGISTER MOVE = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:13:11
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE RMOV (SRC,DST,W)
C
C       MOVE REGISTER SRC TO REGISTER DST
C       SRC AND DST ARE W BYTES WIDE
C
        INTEGER W,SRC(W),DST(W)
        DO 100 I=1,W
100     DST(I)=SRC(I)
        RETURN
        END
C
C+++ SPLIT
C****** SPLIT = SPLIT UP OPCODE WORD = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:13:53
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE SPLIT (REG,FV)
C       DECODE A WORD OF PROGRAM SOURCE STORED AS 8 BYTES
C               INTO THE 24 FIELD VALUES
C
        INTEGER REG(8),FV(24)
C
        FV(1)=MOD(REG(1)/128,2)
        FV(2)=MOD(REG(1)/16,8)
        FV(3)=MOD(REG(1)/4,4)
        FV(4)=MOD(REG(1),4)*4+MOD(REG(2)/64,4)
        FV(5)=MOD(REG(2)/4,16)
        FV(6)=MOD(REG(2),4)*2+MOD(REG(3)/128,2)
        FV(7)=MOD(REG(3)/16,8)
        FV(8)=MOD(REG(3)/2,8)
        FV(9)=MOD(REG(3),2)*8+MOD(REG(4)/32,8)
        FV(10)=MOD(REG(4),32)
        FV(11)=MOD(REG(5)/64,4)
        FV(12)=MOD(REG(5)/16,4)
        FV(13)=MOD(REG(5)/2,8)
        FV(14)=MOD(REG(5),2)*4+MOD(REG(6)/64,4)
        FV(15)=MOD(REG(6)/8,8)
        FV(16)=MOD(REG(6),8)
        FV(17)=MOD(REG(7)/32,8)
        FV(18)=MOD(REG(7)/16,2)
        FV(19)=MOD(REG(7)/4,4)
        FV(20)=MOD(REG(7),4)
        FV(21)=MOD(REG(8)/64,4)
        FV(22)=MOD(REG(8)/16,4)
        FV(23)=MOD(REG(8)/4,4)
        FV(24)=MOD(REG(8),4)
        RETURN
        END
C
C+++ TCADD
C****** TCADD = TWO'S COMPLEMENT ADD = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:14:38
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE TCADD (REGA,REGB,REGC,W,CARRY)
C
C       2@S COMPLEMENT ADDITION
C
C       ADD REGA TO REGB AND PUT THE RESULT INTO REGC
C       ALL THREE REGISTERS ARE W BYTES WIDE
C       ANY RESULTING CARRY IS RETURNED
C
        INTEGER W,CARRY,REGA(W),REGB(W),REGC(W)
        CARRY=0
        DO 100 I=1,W
        J=W-I+1
        REGC(J)=REGA(J)+REGB(J)+CARRY
        CARRY=0
        IF (REGC(J).LT.256) GO TO 100
        CARRY=1
        REGC(J)=REGC(J)-256
100     CONTINUE
        RETURN
        END
C
C+++ UNPKRG
C****** UNPKRG = UNPACK REGISTER = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:15:22
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE UNPKRG(DEC,REG)
         INTEGER DEC,REG(2),WRK(1,1)
C        UNPACKS A 16-BIT INTEGER INTO A 2 BYTE REGISTER
C
         WRK(1,1)=DEC
        CALL MREAD(WRK,0,REG,1,1,2)
        RETURN
        END
C+++ LODINP
C****** LODINP = LOAD AN APLOAD LOAD MODULE =REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:16:07
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
        SUBROUTINE LODINP (ITTI,ITTO)
C
        INTEGER ITTI,ITTO
C
C       THIS ROUTINE READS THE APLOAD LOAD MODULE OUTPUT INTO APSIM'S
C       SIMULATED MEMORIES.
C
C       VARIABLES:
C
C       BUFFER = AN ARRAY FOR READING IN THE CODE VALUE BLOCKS - THIS MUST BE
C                AT LEAST AS LARGE AS THE BUFFER() IN APLOAD.
C       BUFSIZ = THE NUMBER OF ELEMENTS IN BUFFER().
C       PAKFAC = 1 IF HOST WORD SIZE < 32, ELSE 2.
C       PG     = THE MD PAGE DESTINATION OF A BLOCKS VALUES (IF APPLICABLE)
C       IADDR  = THE AP MEMORY ADDRESS OF A BLOCKS VALUE(S) (IF APPLICABLE)
C       ICNT   = THE NUMBER OF RECORDS BELONGING TO A BLOCK OR THE NUMBER
C                OF VALUES IN THE NEXT BLOCK.
C       IDEST  = IN CODE BLOCKS: 0=PS DESTINATION, 1=MD
C       PG0    = THE MD PAGE SELECTED (MAE CONTENTS) WHEN THIS ROUTINE
C                WAS CALLED
C       PGCRNT = THE CURRENTLY SELECT MD PAGE
C
        INTEGER I,J,II,K,KK,BUF(8),REG(8),ICNT,IADDR,IDEST,ISL,WRK(2)
        INTEGER JJ,PG,BUFFER(200),PGCRNT,PG0,SKP,BUFSIZ,HOLD,PAKFAC
        INTEGER REG1(8),CP
        REAL SPFPN(2)
        COMMON /DUMB/ BUF
        EQUIVALENCE (BUF(5),SPFPN(1))
C
        INTEGER MD(512,3),PAGNUM,PAGSIZ
        COMMON /MDRM/ MD,PAGNUM,PAGSIZ
C
        INTEGER IODEV(64,3),IOSIZE
        COMMON /IORM/ IODEV,IOSIZE
C
        DATA BUFSIZ,PAKFAC / 200 , 1 /
C
C
C STATEMENT FUNCTIONS FOR 32BIT AND GREATER MACHINES
C
C                                                                       STATEFUN
          IRSHFT(I,J)=0                                                 STATEFUN
          ILSHFT(I,J)=0                                                 STATEFUN
C                                                                       STATEFUN
C
C       INITIALIZE ...
C
        SKP=4/PAKFAC
C
C       GET INPUT FILE NAME, GET CURRENT VALUE OF MAE
C
        ISL=9
        CALL GTFIL (ISL,ITTI,ITTO)
        CALL MREAD (IODEV,24,REG,IOSIZE,3,6)
        PG0=MOD (REG(6),16)
        PGCRNT=PG0
C
C       GET A HEADER:  TYPE, COUNT, ADDRESS, DESTINATION.  SEE IF TYPE
C       IS IN RANGE (1-4)
C
5450    READ  (ISL,END=90000) (BUF(K),K=1,8)
        K=BUF(1)+1
        ICNT=BUF(2)
        IADDR=BUF(3)
        PG=BUF(4)
        IDEST=BUF(5)
        IF (K .LE. 0 .OR. K .GT. 4) GOTO 90000
C
C       PROCESS:  CODE (OR OVERLAY MAP) BLOCK, INITIALIZED VALUES BLOCK, N.U.,
C                 END BLOCK.
C
        GOTO (5470,5700,5450,5460),K
C
C------- END BLOCK, CLOSE FILE, RESTORE MAE
C        THIS IS NOT A REAL END OF LOAD MODULE IF SECOND NUMBER IS ZERO.
C
5460    CONTINUE
        IF (BUF(2).EQ.0) GOTO 5450
5462    CONTINUE
        CALL CLFIL (ISL,ITTO)
        DO 5465 I=1,5
5465    REG(I)=0
        REG(6)=PG0
        CALL MWRIT (REG,IODEV,24,IOSIZE,6,3)
        RETURN
C
C------- CODE VALUES (OR OVERLAY MAP)
C       (IDEST=0=PS, 1=MD)
C
C       GET A BUFFER FULL
C
5470    CONTINUE
        IF (ICNT.EQ.0) GO TO 5450
        JJ=MIN0 (ICNT,BUFSIZ)
        DO 5472 I=1,JJ,8
           K=MIN0(JJ,I+7)
           READ  (ISL,END=90000) (BUFFER(J),J=I,K)
5472    CONTINUE
        IF (IDEST .NE. 0) GOTO 5540
C
C       WRITE CODE VALUES INTO PS
C
        II= 1
        DO 5500 I=1,JJ,SKP
        DO 5480 K=1,4
        IF (PAKFAC .EQ. 1) GOTO 5478
        IF (K .EQ. 2 .OR. K .EQ. 4  ) GOTO 5477
C#      PICK UP THE LEFT 16 BITS OF BUFFER(II)
        HOLD=IRSHFT(BUFFER(II),16)
        GOTO 5479
C#      PICK UP THE RIGHT 16 BITS OF BUFFER(II)
5477    HOLD=ILSHFT(BUFFER(II),16)
        HOLD=IRSHFT(HOLD,16)
        II=II+1
        GOTO 5479
5478    II=I+K-1
        HOLD=BUFFER(II)
5479    CALL UNPKRG (HOLD,WRK)
        J=K*2-1
5480    CALL MOVPRT (WRK,1,REG,J,2,8,2)
        CALL PSMEM (2,IADDR,REG)
5500    IADDR=IADDR+1
        IF (JJ .EQ. ICNT) GOTO 5450
        ICNT=ICNT-JJ
        GOTO 5470
C
C       WRITE CODE VALUES INTO MD
C       SEE IF CORRECT MD PAGE IS SELECTED.
C
5540    IF (PG .EQ. PGCRNT) GOTO 5570
        REG(5)=0
        REG(6)=PG
        CALL MWRIT (REG,IODEV,24,IOSIZE,6,3)
        PGCRNT=PG
C
C       PLACE VALUES IN MEMORY
C
5570    DO 5600 I=1,JJ,2
        CALL UNPKRG (BUFFER(I),REG(3))
        CALL UNPKRG (BUFFER(I+1),REG(5))
        REG(1)=0
        REG(2)=0
        CALL MDMEM (2,IADDR,REG)
5600    IADDR=IADDR+1
        IF (JJ .EQ. ICNT) GOTO 5450
        ICNT=ICNT-JJ
        GOTO 5470
C
C------- DB INITIALIZED VALUES
C
C       MAKE SURE WE HAVE THE CORRECT MD PAGE
C
5700    IF (PGCRNT .EQ. PG) GOTO 5710
        REG(5)=0
        REG(6)=PG
        CALL MWRIT (REG,IODEV,24,IOSIZE,6,3)
C
C       GET A DATUM
C
5710    DO 5800 JJ=1,ICNT
        READ  (ISL,END=90000) (BUF(K),K=1,8)
        KK=BUF(1)
        CP=1
C ASSUME INTEGER OR REAL NUMBER
        IF (KK.EQ.3) CP=2
C IT IS COMPLEX
C
C       GET ITEM ADDRESS AND REPETITION COUNT
C       PLACE VALUE IN MD BY TYPE:  INTEGER, REAL, COMPLEX
C
        K=BUF(3)
        J=BUF(2)*CP+K-1
        GOTO (5720,5760,5765,5750),KK
C
C       VALUE IS INTEGER
C
5720    CALL UNPKRG (BUF(5),REG(5))
        REG(1)=0
        REG(2)=0
        REG(3)=0
        REG(4)=0
        GOTO 5770
C
C       VALUE IS TRIPLE
C
C
5750    CONTINUE
        REG(2)=IRSH16(BUF(6),12)
        BUF(6)=IAND16(BUF(6),4095)
        CALL UNPKRG(BUF(6),REG(3))
        CALL UNPKRG(BUF(7),REG(5))
        REG(1)=0
        GO TO 5770
C
C
C       VALUE IS FP (SINGLE PRECISION)
C
5760    CALL FPINPT (DBLE (SPFPN(1)),REG)
        GO TO 5770
C
C       VALUE IS COMPLEX
C
5765    CONTINUE
        CALL FPINPT(DBLE(SPFPN(1)),REG)
        CALL FPINPT(DBLE(SPFPN(2)),REG1)
C
C       PLACE VALUE(S) IN MD
C
5770    DO 5780 II=K,J,CP
        CALL MDMEM (2,II,REG)
        IF (CP.EQ.1) GO TO 5780
        CALL MDMEM(2,II+1,REG1)
5780    CONTINUE
5800    CONTINUE
        GOTO 5450
C
C       ERROR - BAD LM
C
90000   WRITE (ITTO,90010)
90010   FORMAT (17H  BAD LOAD MODULE)
        GOTO 5462
        END
C+++ TMROM
C****** TMROM =PARTIAL 4.5K DATA TABLE=REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:17:02
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
           SUBROUTINE TMROM
C
C
C     PARTIAL TABLE MEMORY TABLE FOR APSIM
C     CONTAINS 64 FFT COEFFECIENTS AND 301 TRIG COEFFECIENTS
C
C----------------------------------------------------------------
C
C       HERE SET THE SIZE OF TM
C
        INTEGER TM(512,3),RAMSIZ,TRIGSZ,HFFTSZ,SFFTSZ,RAMBAS
        COMMON /TMRM/  TM,RAMSIZ,TRIGSZ,HFFTSZ,SFFTSZ,RAMBAS
C
        DATA RAMSIZ / 147 /
        DATA TRIGSZ / 301 /
        DATA HFFTSZ / 4096 /
        DATA SFFTSZ / 64 /
        DATA RAMBAS / 8192 /
C
C       SFFTSZ+TRIGSZ+RAMSIZE MUST EQUAL THE 1ST DIMENSION OF THE 'TM'
C       ARRAY.
C
C-------TM LAYOUT
C
C       HARDWARE: FFT-TABLE                  0 - 4095
C                 FUNCTION COEFFICIENTS   4096 - 4396
C                 HOLE                    4397 - 8191
C                 TMRAM                   8192 +
C
C       ARRAY TM  FFT-TABLE                  1 - 64
C                 FUNCTION COEFFICIENTS   65 - 365
C                 TMRAM (147 WORDS)      366 - 512
C
C       ROMSIZ - TOTAL ROM SIZE (FFT + FUNCTION COEFF)  (365)
C       RAMSIZ - TMRAM SIZE  (SET TO 147 HERE)
C       RAMBAS - BASE ADDRESS OF TMRAM (8192)
C
C---------------------------------------------------------------------
C
C    64 POINT FFT TABLE   AND    301    TRIG ENTRIES.
C---------------------------------------------------------------------
C
C
        DATA TM(  1,1),TM(  1,2),TM(  1,3)/   513,  1024,     0/
        DATA TM(  2,1),TM(  2,2),TM(  2,3)/   512,  2047, 25112/
        DATA TM(  3,1),TM(  3,2),TM(  3,3)/   512,  2045,-30599/
        DATA TM(  4,1),TM(  4,2),TM(  4,3)/   512,  2042, 29547/
        DATA TM(  5,1),TM(  5,2),TM(  5,3)/   512,  2038,  9065/
        DATA TM(  6,1),TM(  6,2),TM(  6,3)/   512,  2032,-26340/
        DATA TM(  7,1),TM(  7,2),TM(  7,3)/   512,  2025,-10912/
        DATA TM(  8,1),TM(  8,2),TM(  8,3)/   512,  2017, -9921/
        DATA TM(  9,1),TM(  9,2),TM(  9,3)/   512,  2008,-23052/
        DATA TM( 10,1),TM( 10,2),TM( 10,3)/   512,  1998, 15595/
        DATA TM( 11,1),TM( 11,2),TM( 11,3)/   512,  1986,-24641/
        DATA TM( 12,1),TM( 12,2),TM( 12,3)/   512,  1973,-12230/
        DATA TM( 13,1),TM( 13,2),TM( 13,3)/   512,  1959,-12202/
        DATA TM( 14,1),TM( 14,2),TM( 14,3)/   512,  1944,-24005/
        DATA TM( 15,1),TM( 15,2),TM( 15,3)/   512,  1928, 18497/
        DATA TM( 16,1),TM( 16,2),TM( 16,3)/   512,  1910,-15122/
        DATA TM( 17,1),TM( 17,2),TM( 17,3)/   512,  1892,  6900/
        DATA TM( 18,1),TM( 18,2),TM( 18,3)/   512,  1872, 19764/
        DATA TM( 19,1),TM( 19,2),TM( 19,3)/   512,  1851, 24253/
        DATA TM( 20,1),TM( 20,2),TM( 20,3)/   512,  1829, 21192/
        DATA TM( 21,1),TM( 21,2),TM( 21,3)/   512,  1806, 11452/
        DATA TM( 22,1),TM( 22,2),TM( 22,3)/   512,  1781, -4053/
        DATA TM( 23,1),TM( 23,2),TM( 23,3)/   512,  1756,-24367/
        DATA TM( 24,1),TM( 24,2),TM( 24,3)/   512,  1730, 17046/
        DATA TM( 25,1),TM( 25,2),TM( 25,3)/   512,  1702, -9846/
        DATA TM( 26,1),TM( 26,2),TM( 26,3)/   512,  1674, 27112/
        DATA TM( 27,1),TM( 27,2),TM( 27,3)/   512,  1644, -2030/
        DATA TM( 28,1),TM( 28,2),TM( 28,3)/   512,  1614,-30574/
        DATA TM( 29,1),TM( 29,2),TM( 29,3)/   512,  1583,  8219/
        DATA TM( 30,1),TM( 30,2),TM( 30,3)/   512,  1550,-15485/
        DATA TM( 31,1),TM( 31,2),TM( 31,3)/   512,  1517, 30665/
        DATA TM( 32,1),TM( 32,2),TM( 32,3)/   512,  1483, 16910/
        DATA TM( 33,1),TM( 33,2),TM( 33,3)/   512,  1448, 10138/
        DATA TM( 34,1),TM( 34,2),TM( 34,3)/   512,  1412, 11733/
        DATA TM( 35,1),TM( 35,2),TM( 35,3)/   512,  1375, 23117/
        DATA TM( 36,1),TM( 36,2),TM( 36,3)/   512,  1337,-19793/
        DATA TM( 37,1),TM( 37,2),TM( 37,3)/   512,  1299, 15561/
        DATA TM( 38,1),TM( 38,2),TM( 38,3)/   512,  1259,  -374/
        DATA TM( 39,1),TM( 39,2),TM( 39,3)/   512,  1219,  -513/
        DATA TM( 40,1),TM( 40,2),TM( 40,3)/   512,  1179, 16723/
        DATA TM( 41,1),TM( 41,2),TM( 41,3)/   512,  1137,-12594/
        DATA TM( 42,1),TM( 42,2),TM( 42,3)/   512,  1095,-21291/
        DATA TM( 43,1),TM( 43,2),TM( 43,3)/   512,  1052, -7706/
        DATA TM( 44,1),TM( 44,2),TM( 44,3)/   511,  2018, -5833/
        DATA TM( 45,1),TM( 45,2),TM( 45,3)/   511,  1930,-10418/
        DATA TM( 46,1),TM( 46,2),TM( 46,3)/   511,  1841,-25690/
        DATA TM( 47,1),TM( 47,2),TM( 47,3)/   511,  1751, 17410/
        DATA TM( 48,1),TM( 48,2),TM( 48,3)/   511,  1659, -8623/
        DATA TM( 49,1),TM( 49,2),TM( 49,3)/   511,  1567, 30890/
        DATA TM( 50,1),TM( 50,2),TM( 50,3)/   511,  1474,  8524/
        DATA TM( 51,1),TM( 51,2),TM( 51,3)/   511,  1379, -6499/
        DATA TM( 52,1),TM( 52,2),TM( 52,3)/   511,  1284,-10459/
        DATA TM( 53,1),TM( 53,2),TM( 53,3)/   511,  1189,   396/
        DATA TM( 54,1),TM( 54,2),TM( 54,3)/   511,  1092, 29849/
        DATA TM( 55,1),TM( 55,2),TM( 55,3)/   510,  1990, 32351/
        DATA TM( 56,1),TM( 56,2),TM( 56,3)/   510,  1794, -8037/
        DATA TM( 57,1),TM( 57,2),TM( 57,3)/   510,  1598, 11791/
        DATA TM( 58,1),TM( 58,2),TM( 58,3)/   510,  1400,-31471/
        DATA TM( 59,1),TM( 59,2),TM( 59,3)/   510,  1202,  1052/
        DATA TM( 60,1),TM( 60,2),TM( 60,3)/   509,  2005,-27754/
        DATA TM( 61,1),TM( 61,2),TM( 61,3)/   509,  1605, -5713/
        DATA TM( 62,1),TM( 62,2),TM( 62,3)/   509,  1205, 18469/
        DATA TM( 63,1),TM( 63,2),TM( 63,3)/   508,  1607, -9860/
        DATA TM( 64,1),TM( 64,2),TM( 64,3)/   507,  1608, 21886/
        DATA TM( 65,1),TM( 65,2),TM( 65,3)/   512,     7,    -1/
        DATA TM( 66,1),TM( 66,2),TM( 66,3)/   513,  1024,     0/
        DATA TM( 67,1),TM( 67,2),TM( 67,3)/   514,  1024,     0/
        DATA TM( 68,1),TM( 68,2),TM( 68,3)/   513,  2032,  8128/
        DATA TM( 69,1),TM( 69,2),TM( 69,3)/   513,  2016, 32264/
        DATA TM( 70,1),TM( 70,2),TM( 70,3)/   513,  2001,  6504/
        DATA TM( 71,1),TM( 71,2),TM( 71,3)/   513,  1985, -3972/
        DATA TM( 72,1),TM( 72,2),TM( 72,3)/   513,  1971,   493/
        DATA TM( 73,1),TM( 73,2),TM( 73,3)/   513,  1956, 19563/
        DATA TM( 74,1),TM( 74,2),TM( 74,3)/   513,  1941,-12622/
        DATA TM( 75,1),TM( 75,2),TM( 75,3)/   513,  1927,-30840/
        DATA TM( 76,1),TM( 76,2),TM( 76,3)/   513,  1913, 30137/
        DATA TM( 77,1),TM( 77,2),TM( 77,3)/   513,  1899,-26594/
        DATA TM( 78,1),TM( 78,2),TM( 78,3)/   513,  1885, -4715/
        DATA TM( 79,1),TM( 79,2),TM( 79,3)/   513,  1872, 29959/
        DATA TM( 80,1),TM( 80,2),TM( 80,3)/   513,  1859, 11620/
        DATA TM( 81,1),TM( 81,2),TM( 81,3)/   513,  1846,  5538/
        DATA TM( 82,1),TM( 82,2),TM( 82,3)/   513,  1833, 11457/
        DATA TM( 83,1),TM( 83,2),TM( 83,3)/   513,  1820, 29127/
        DATA TM( 84,1),TM( 84,2),TM( 84,3)/   513,  1807, -7232/
        DATA TM( 85,1),TM( 85,2),TM( 85,3)/   513,  1795,-32319/
        DATA TM( 86,1),TM( 86,2),TM( 86,3)/   513,  1783, 19170/
        DATA TM( 87,1),TM( 87,2),TM( 87,3)/   513,  1771, 15941/
        DATA TM( 88,1),TM( 88,2),TM( 88,3)/   513,  1759, 23311/
        DATA TM( 89,1),TM( 89,2),TM( 89,3)/   513,  1747,-24467/
        DATA TM( 90,1),TM( 90,2),TM( 90,3)/   513,  1736,  3472/
        DATA TM( 91,1),TM( 91,2),TM( 91,3)/   513,  1724,-24145/
        DATA TM( 92,1),TM( 92,2),TM( 92,3)/   513,  1713, 23559/
        DATA TM( 93,1),TM( 93,2),TM( 93,3)/   513,  1702, 15320/
        DATA TM( 94,1),TM( 94,2),TM( 94,3)/   513,  1691, 16490/
        DATA TM( 95,1),TM( 95,2),TM( 95,3)/   513,  1680, 26887/
        DATA TM( 96,1),TM( 96,2),TM( 96,3)/   513,  1669,-19202/
        DATA TM( 97,1),TM( 97,2),TM( 97,3)/   513,  1659,  9125/
        DATA TM( 98,1),TM( 98,2),TM( 98,3)/   513,  1648,-19372/
        DATA TM( 99,1),TM( 99,2),TM( 99,3)/   513,  1638, 26214/
        DATA TM(100,1),TM(100,2),TM(100,3)/   513,  1628, 14654/
        DATA TM(101,1),TM(101,2),TM(101,3)/   513,  1618, 11327/
        DATA TM(102,1),TM(102,2),TM(102,3)/   513,  1608, 16082/
        DATA TM(103,1),TM(103,2),TM(103,3)/   513,  1598, 28772/
        DATA TM(104,1),TM(104,2),TM(104,3)/   513,  1588,-16285/
        DATA TM(105,1),TM(105,2),TM(105,3)/   513,  1579, 11844/
        DATA TM(106,1),TM(106,2),TM(106,3)/   513,  1569,-18052/
        DATA TM(107,1),TM(107,2),TM(107,3)/   513,  1560, 24966/
        DATA TM(108,1),TM(108,2),TM(108,3)/   513,  1551,  9695/
        DATA TM(109,1),TM(109,2),TM(109,3)/   513,  1542,  1542/
        DATA TM(110,1),TM(110,2),TM(110,3)/   513,  1533,   383/
        DATA TM(111,1),TM(111,2),TM(111,3)/   513,  1524,  6096/
        DATA TM(112,1),TM(112,2),TM(112,3)/   513,  1515, 18562/
        DATA TM(113,1),TM(113,2),TM(113,3)/   513,  1506,-27872/
        DATA TM(114,1),TM(114,2),TM(114,3)/   513,  1497, -2247/
        DATA TM(115,1),TM(115,2),TM(115,3)/   513,  1489, 29789/
        DATA TM(116,1),TM(116,2),TM(116,3)/   513,  1481,  2592/
        DATA TM(117,1),TM(117,2),TM(117,3)/   513,  1472,-18409/
        DATA TM(118,1),TM(118,2),TM(118,3)/   513,  1464, 32219/
        DATA TM(119,1),TM(119,2),TM(119,3)/   513,  1456, 23302/
        DATA TM(120,1),TM(120,2),TM(120,3)/   513,  1448, 20276/
        DATA TM(121,1),TM(121,2),TM(121,3)/   513,  1440, 23046/
        DATA TM(122,1),TM(122,2),TM(122,3)/   513,  1432, 31515/
        DATA TM(123,1),TM(123,2),TM(123,3)/   513,  1424,-19946/
        DATA TM(124,1),TM(124,2),TM(124,3)/   513,  1416,  -354/
        DATA TM(125,1),TM(125,2),TM(125,3)/   513,  1409, 24664/
        DATA TM(126,1),TM(126,2),TM(126,3)/   513,  1401,-10514/
        DATA TM(127,1),TM(127,2),TM(127,3)/   513,  1394, 25099/
        DATA TM(128,1),TM(128,2),TM(128,3)/   513,  1387,   347/
        DATA TM(129,1),TM(129,2),TM(129,3)/   513,  1379,-19316/
        DATA TM(130,1),TM(130,2),TM(130,3)/   513,  1372, 31567/
        DATA TM(131,1),TM(131,2),TM(131,3)/   513,  1365, 21845/
        DATA TM(132,1),TM(132,2),TM(132,3)/   513,  1358, 16978/
        DATA TM(133,1),TM(133,2),TM(133,3)/   513,  1351, 16891/
        DATA TM(134,1),TM(134,2),TM(134,3)/   513,  1344, 21509/
        DATA TM(135,1),TM(135,2),TM(135,3)/   513,  1337, 30762/
        DATA TM(136,1),TM(136,2),TM(136,3)/   513,  1330,-20958/
        DATA TM(137,1),TM(137,2),TM(137,3)/   513,  1323, -2648/
        DATA TM(138,1),TM(138,2),TM(138,3)/   513,  1317, 20089/
        DATA TM(139,1),TM(139,2),TM(139,3)/   513,  1310,-18350/
        DATA TM(140,1),TM(140,2),TM(140,3)/   513,  1304, 13042/
        DATA TM(141,1),TM(141,2),TM(141,3)/   513,  1297,-16871/
        DATA TM(142,1),TM(142,2),TM(142,3)/   513,  1291, 22921/
        DATA TM(143,1),TM(143,2),TM(143,3)/   513,  1285,  1285/
        DATA TM(144,1),TM(144,2),TM(144,3)/   513,  1278,-16304/
        DATA TM(145,1),TM(145,2),TM(145,3)/   513,  1272,-29905/
        DATA TM(146,1),TM(146,2),TM(146,3)/   513,  1266, 25961/
        DATA TM(147,1),TM(147,2),TM(147,3)/   513,  1260, 20165/
        DATA TM(148,1),TM(148,2),TM(148,3)/   513,  1254, 18187/
        DATA TM(149,1),TM(149,2),TM(149,3)/   513,  1248, 19973/
        DATA TM(150,1),TM(150,2),TM(150,3)/   513,  1242, 25469/
        DATA TM(151,1),TM(151,2),TM(151,3)/   513,  1236,-30913/
        DATA TM(152,1),TM(152,2),TM(152,3)/   513,  1230,-18153/
        DATA TM(153,1),TM(153,2),TM(153,3)/   513,  1224, -1837/
        DATA TM(154,1),TM(154,2),TM(154,3)/   513,  1219, 17984/
        DATA TM(155,1),TM(155,2),TM(155,3)/   513,  1213,-24273/
        DATA TM(156,1),TM(156,2),TM(156,3)/   513,  1208,  2416/
        DATA TM(157,1),TM(157,2),TM(157,3)/   513,  1202, 32467/
        DATA TM(158,1),TM(158,2),TM(158,3)/   513,  1197,   299/
        DATA TM(159,1),TM(159,2),TM(159,3)/   513,  1191,-28598/
        DATA TM(160,1),TM(160,2),TM(160,3)/   513,  1186, 11269/
        DATA TM(161,1),TM(161,2),TM(161,3)/   513,  1180,-11218/
        DATA TM(162,1),TM(162,2),TM(162,3)/   513,  1175,-30564/
        DATA TM(163,1),TM(163,2),TM(163,3)/   513,  1170, 18725/
        DATA TM(164,1),TM(164,2),TM(164,3)/   513,  1165,  5534/
        DATA TM(165,1),TM(165,2),TM(165,3)/   513,  1159, -4640/
        DATA TM(166,1),TM(166,2),TM(166,3)/   513,  1154,-11837/
        DATA TM(167,1),TM(167,2),TM(167,3)/   513,  1149,-16097/
        DATA TM(168,1),TM(168,2),TM(168,3)/   513,  1144,-17457/
        DATA TM(169,1),TM(169,2),TM(169,3)/   513,  1139,-15957/
        DATA TM(170,1),TM(170,2),TM(170,3)/   513,  1134,-11632/
        DATA TM(171,1),TM(171,2),TM(171,3)/   513,  1129, -4520/
        DATA TM(172,1),TM(172,2),TM(172,3)/   513,  1125,  5344/
        DATA TM(173,1),TM(173,2),TM(173,3)/   513,  1120, 17924/
        DATA TM(174,1),TM(174,2),TM(174,3)/   513,  1115,-32350/
        DATA TM(175,1),TM(175,2),TM(175,3)/   513,  1110,-14440/
        DATA TM(176,1),TM(176,2),TM(176,3)/   513,  1106,  6084/
        DATA TM(177,1),TM(177,2),TM(177,3)/   513,  1101, 29188/
        DATA TM(178,1),TM(178,2),TM(178,3)/   513,  1096,-10694/
        DATA TM(179,1),TM(179,2),TM(179,3)/   513,  1092, 17476/
        DATA TM(180,1),TM(180,2),TM(180,3)/   513,  1087,-17404/
        DATA TM(181,1),TM(181,2),TM(181,3)/   513,  1083, 15707/
        DATA TM(182,1),TM(182,2),TM(182,3)/   513,  1078,-14294/
        DATA TM(183,1),TM(183,2),TM(183,3)/   513,  1074, 23636/
        DATA TM(184,1),TM(184,2),TM(184,3)/   513,  1069, -1605/
        DATA TM(185,1),TM(185,2),TM(185,3)/   513,  1065,-24509/
        DATA TM(186,1),TM(186,2),TM(186,3)/   513,  1061, 20430/
        DATA TM(187,1),TM(187,2),TM(187,3)/   513,  1057,  2114/
        DATA TM(188,1),TM(188,2),TM(188,3)/   513,  1052,-13949/
        DATA TM(189,1),TM(189,2),TM(189,3)/   513,  1048,-27787/
        DATA TM(190,1),TM(190,2),TM(190,3)/   513,  1044, 26110/
        DATA TM(191,1),TM(191,2),TM(191,3)/   513,  1040, 16644/
        DATA TM(192,1),TM(192,2),TM(192,3)/   513,  1036,  9325/
        DATA TM(193,1),TM(193,2),TM(193,3)/   513,  1032,  4128/
        DATA TM(194,1),TM(194,2),TM(194,3)/   513,  1028,  1028/
        DATA TM(195,1),TM(195,2),TM(195,3)/   511,    15,    -1/
        DATA TM(196,1),TM(196,2),TM(196,3)/   513,  1448, 10138/
        DATA TM(197,1),TM(197,2),TM(197,3)/   513,  1024,     0/
        DATA TM(198,1),TM(198,2),TM(198,3)/   514,  1024,     0/
        DATA TM(199,1),TM(199,2),TM(199,3)/   512,  1448, 10137/
        DATA TM(200,1),TM(200,2),TM(200,3)/   512,  1459, 27823/
        DATA TM(201,1),TM(201,2),TM(201,3)/   512,  1470,-25688/
        DATA TM(202,1),TM(202,2),TM(202,3)/   512,  1481,-19194/
        DATA TM(203,1),TM(203,2),TM(203,3)/   512,  1492,-18109/
        DATA TM(204,1),TM(204,2),TM(204,3)/   512,  1503,-22313/
        DATA TM(205,1),TM(205,2),TM(205,3)/   512,  1514,-31692/
        DATA TM(206,1),TM(206,2),TM(206,3)/   512,  1525, 19401/
        DATA TM(207,1),TM(207,2),TM(207,3)/   512,  1536,     0/
        DATA TM(208,1),TM(208,2),TM(208,3)/   512,  1546,-24256/
        DATA TM(209,1),TM(209,2),TM(209,3)/   512,  1557, 12269/
        DATA TM(210,1),TM(210,2),TM(210,3)/   512,  1567,-21402/
        DATA TM(211,1),TM(211,2),TM(211,3)/   512,  1578,  5897/
        DATA TM(212,1),TM(212,2),TM(212,3)/   512,  1588, 28720/
        DATA TM(213,1),TM(213,2),TM(213,3)/   512,  1598,-18384/
        DATA TM(214,1),TM(214,2),TM(214,3)/   512,  1608, -4256/
        DATA TM(215,1),TM(215,2),TM(215,3)/   512,  1619,  5647/
        DATA TM(216,1),TM(216,2),TM(216,3)/   512,  1629, 11405/
        DATA TM(217,1),TM(217,2),TM(217,3)/   512,  1639, 13094/
        DATA TM(218,1),TM(218,2),TM(218,3)/   512,  1649, 10790/
        DATA TM(219,1),TM(219,2),TM(219,3)/   512,  1659,  4563/
        DATA TM(220,1),TM(220,2),TM(220,3)/   512,  1668, -5517/
        DATA TM(221,1),TM(221,2),TM(221,3)/   512,  1678,-19381/
        DATA TM(222,1),TM(222,2),TM(222,3)/   512,  1688, 28544/
        DATA TM(223,1),TM(223,2),TM(223,3)/   512,  1698,  7333/
        DATA TM(224,1),TM(224,2),TM(224,3)/   512,  1707,-17498/
        DATA TM(225,1),TM(225,2),TM(225,3)/   512,  1717, 19674/
        DATA TM(226,1),TM(226,2),TM(226,3)/   512,  1726,-12163/
        DATA TM(227,1),TM(227,2),TM(227,3)/   512,  1736, 18119/
        DATA TM(228,1),TM(228,2),TM(228,3)/   512,  1745,-20496/
        DATA TM(229,1),TM(229,2),TM(229,3)/   512,  1755,  3118/
        DATA TM(230,1),TM(230,2),TM(230,3)/   512,  1764, 23478/
        DATA TM(231,1),TM(231,2),TM(231,3)/   512,  1773,-24902/
        DATA TM(232,1),TM(232,2),TM(232,3)/   512,  1782,-10899/
        DATA TM(233,1),TM(233,2),TM(233,3)/   512,  1792,     0/
        DATA TM(234,1),TM(234,2),TM(234,3)/   512,  1801,  7841/
        DATA TM(235,1),TM(235,2),TM(235,3)/   512,  1810, 12672/
        DATA TM(236,1),TM(236,2),TM(236,3)/   512,  1819, 14537/
        DATA TM(237,1),TM(237,2),TM(237,3)/   512,  1828, 13479/
        DATA TM(238,1),TM(238,2),TM(238,3)/   512,  1837,  9543/
        DATA TM(239,1),TM(239,2),TM(239,3)/   512,  1846,  2769/
        DATA TM(240,1),TM(240,2),TM(240,3)/   512,  1854, -6801/
        DATA TM(241,1),TM(241,2),TM(241,3)/   512,  1863,-19128/
        DATA TM(242,1),TM(242,2),TM(242,3)/   512,  1872, 31364/
        DATA TM(243,1),TM(243,2),TM(243,3)/   512,  1881, 13640/
        DATA TM(244,1),TM(244,2),TM(244,3)/   512,  1889, -6727/
        DATA TM(245,1),TM(245,2),TM(245,3)/   512,  1898,-29700/
        DATA TM(246,1),TM(246,2),TM(246,3)/   512,  1907, 10292/
        DATA TM(247,1),TM(247,2),TM(247,3)/   512,  1915,-17788/
        DATA TM(248,1),TM(248,2),TM(248,3)/   512,  1924, 17166/
        DATA TM(249,1),TM(249,2),TM(249,3)/   512,  1932,-15885/
        DATA TM(250,1),TM(250,2),TM(250,3)/   512,  1941, 14163/
        DATA TM(251,1),TM(251,2),TM(251,3)/   512,  1949,-23730/
        DATA TM(252,1),TM(252,2),TM(252,3)/   512,  1958,  1540/
        DATA TM(253,1),TM(253,2),TM(253,3)/   512,  1966, 24465/
        DATA TM(254,1),TM(254,2),TM(254,3)/   512,  1974,-20459/
        DATA TM(255,1),TM(255,2),TM(255,3)/   512,  1982, -2132/
        DATA TM(256,1),TM(256,2),TM(256,3)/   512,  1991, 13939/
        DATA TM(257,1),TM(257,2),TM(257,3)/   512,  1999, 27782/
        DATA TM(258,1),TM(258,2),TM(258,3)/   512,  2007,-26113/
        DATA TM(259,1),TM(259,2),TM(259,3)/   512,  2015,-16645/
        DATA TM(260,1),TM(260,2),TM(260,3)/   512,  2023, -9326/
        DATA TM(261,1),TM(261,2),TM(261,3)/   512,  2031, -4128/
        DATA TM(262,1),TM(262,2),TM(262,3)/   512,  2039, -1028/
        DATA TM(263,1),TM(263,2),TM(263,3)/   512,  1303,-13285/
        DATA TM(264,1),TM(264,2),TM(264,3)/   509,  1305,-23875/
        DATA TM(265,1),TM(265,2),TM(265,3)/   512,  2047,    -1/
        DATA TM(266,1),TM(266,2),TM(266,3)/   513,  1024,     0/
        DATA TM(267,1),TM(267,2),TM(267,3)/   513,  1608, 32469/
        DATA TM(268,1),TM(268,2),TM(268,3)/   500,  1270,-16426/
        DATA TM(269,1),TM(269,2),TM(269,3)/   512,  2773,  4346/
        DATA TM(270,1),TM(270,2),TM(270,3)/   505,  2870,-13099/
        DATA TM(271,1),TM(271,2),TM(271,3)/   514,  1024,     0/
        DATA TM(272,1),TM(272,2),TM(272,3)/   513,  1477, 20953/
        DATA TM(273,1),TM(273,2),TM(273,3)/   521,  1416,-15729/
        DATA TM(274,1),TM(274,2),TM(274,3)/   512,  2047,    -1/
        DATA TM(275,1),TM(275,2),TM(275,3)/   512,  2048,     0/
        DATA TM(276,1),TM(276,2),TM(276,3)/   521,  2673,-20972/
        DATA TM(277,1),TM(277,2),TM(277,3)/   503,  1304, 25940/
        DATA TM(278,1),TM(278,2),TM(278,3)/   508,  1818,  5122/
        DATA TM(279,1),TM(279,2),TM(279,3)/   506,  1268,-24573/
        DATA TM(280,1),TM(280,2),TM(280,3)/   500,  1820,-31645/
        DATA TM(281,1),TM(281,2),TM(281,3)/   510,  1967, -2437/
        DATA TM(282,1),TM(282,2),TM(282,3)/   512,  1419,-28507/
        DATA TM(283,1),TM(283,2),TM(283,3)/   513,  1024,     0/
        DATA TM(284,1),TM(284,2),TM(284,3)/   513,  1024,     0/
        DATA TM(285,1),TM(285,2),TM(285,3)/   512,  1625, 32681/
        DATA TM(286,1),TM(286,2),TM(286,3)/   512,  1290, 10430/
        DATA TM(287,1),TM(287,2),TM(287,3)/   512,  1419,-28480/
        DATA TM(288,1),TM(288,2),TM(288,3)/   511,  1778, -8507/
        DATA TM(289,1),TM(289,2),TM(289,3)/   510,  2881,-32672/
        DATA TM(290,1),TM(290,2),TM(290,3)/   512,  2048,    36/
        DATA TM(291,1),TM(291,2),TM(291,3)/   511,  2733,  3784/
        DATA TM(292,1),TM(292,2),TM(292,3)/   482,  2822,-23381/
        DATA TM(293,1),TM(293,2),TM(293,3)/   511,  2757,-18845/
        DATA TM(294,1),TM(294,2),TM(294,3)/   511,  3040, 11400/
        DATA TM(295,1),TM(295,2),TM(295,3)/   512,  3071, -2767/
        DATA TM(296,1),TM(296,2),TM(296,3)/   513,  1174,-29227/
        DATA TM(297,1),TM(297,2),TM(297,3)/   512,  2056, 23615/
        DATA TM(298,1),TM(298,2),TM(298,3)/   509,  2452, 20227/
        DATA TM(299,1),TM(299,2),TM(299,3)/   500,  2692, -3034/
        DATA TM(300,1),TM(300,2),TM(300,3)/   513,  2757,-18845/
        DATA TM(301,1),TM(301,2),TM(301,3)/   512,  2051, 22813/
        DATA TM(302,1),TM(302,2),TM(302,3)/   512,  2986, 11785/
        DATA TM(303,1),TM(303,2),TM(303,3)/   516,  1294, 25305/
        DATA TM(304,1),TM(304,2),TM(304,3)/   512,  2473,  8470/
        DATA TM(305,1),TM(305,2),TM(305,3)/   515,  1111,-10216/
        DATA TM(306,1),TM(306,2),TM(306,3)/   506,  2323, 11000/
        DATA TM(307,1),TM(307,2),TM(307,3)/   515,  2757,-18845/
        DATA TM(308,1),TM(308,2),TM(308,3)/   516,  2866,   505/
        DATA TM(309,1),TM(309,2),TM(309,3)/   513,  2211,-24707/
        DATA TM(310,1),TM(310,2),TM(310,3)/   513,  1024,     0/
        DATA TM(311,1),TM(311,2),TM(311,3)/   511,  1696,-24986/
        DATA TM(312,1),TM(312,2),TM(312,3)/   514,  1236,  5069/
        DATA TM(313,1),TM(313,2),TM(313,3)/   514,  1024,     0/
        DATA TM(314,1),TM(314,2),TM(314,3)/     0,     0,     0/
        DATA TM(315,1),TM(315,2),TM(315,3)/   513,  2487,-32469/
        DATA TM(316,1),TM(316,2),TM(316,3)/   512,  1608, 32469/
        DATA TM(317,1),TM(317,2),TM(317,3)/   509,  1732, 23098/
        DATA TM(318,1),TM(318,2),TM(318,3)/   510,  2929, 29677/
        DATA TM(319,1),TM(319,2),TM(319,3)/   510,  1638, 16640/
        DATA TM(320,1),TM(320,2),TM(320,3)/   508,  2118,-29272/
        DATA TM(321,1),TM(321,2),TM(321,3)/   511,  2730,-21776/
        DATA TM(322,1),TM(322,2),TM(322,3)/   513,  1024,     0/
        DATA TM(323,1),TM(323,2),TM(323,3)/   514,  1608, 32469/
        DATA TM(324,1),TM(324,2),TM(324,3)/   514,  1391,-15709/
        DATA TM(325,1),TM(325,2),TM(325,3)/   511,  1506,-10866/
        DATA TM(326,1),TM(326,2),TM(326,3)/   515,  1891,-26322/
        DATA TM(327,1),TM(327,2),TM(327,3)/   513,  1172, 13330/
        DATA TM(328,1),TM(328,2),TM(328,3)/   513,  1124, -1377/
        DATA TM(329,1),TM(329,2),TM(329,3)/   514,  1178, -5009/
        DATA TM(330,1),TM(330,2),TM(330,3)/   511,  1233,  1236/
        DATA TM(331,1),TM(331,2),TM(331,3)/   511,  1303,-13285/
        DATA TM(332,1),TM(332,2),TM(332,3)/   507,  1143,-11863/
        DATA TM(333,1),TM(333,2),TM(333,3)/   516,  1263, 20274/
        DATA TM(334,1),TM(334,2),TM(334,3)/   515,  1608, 32469/
        DATA TM(335,1),TM(335,2),TM(335,3)/   513,  1814,  -476/
        DATA TM(336,1),TM(336,2),TM(336,3)/   513,  1290, 10430/
        DATA TM(337,1),TM(337,2),TM(337,3)/   513,  1476, -8942/
        DATA TM(338,1),TM(338,2),TM(338,3)/   513,  1217,-16509/
        DATA TM(339,1),TM(339,2),TM(339,3)/   513,  1773,-24902/
        DATA TM(340,1),TM(340,2),TM(340,3)/   514,  1144, -8729/
        DATA TM(341,1),TM(341,2),TM(341,3)/   514,  1619,  5647/
        DATA TM(342,1),TM(342,2),TM(342,3)/   512,  1182,  9023/
        DATA TM(343,1),TM(343,2),TM(343,3)/   513,  1656, -8729/
        DATA TM(344,1),TM(344,2),TM(344,3)/   512,  1024,     0/
        DATA TM(345,1),TM(345,2),TM(345,3)/   511,  1365, 21845/
        DATA TM(346,1),TM(346,2),TM(346,3)/   511,  1024,     0/
        DATA TM(347,1),TM(347,2),TM(347,3)/   510,  1638, 26214/
        DATA TM(348,1),TM(348,2),TM(348,3)/   510,  1365, 21845/
        DATA TM(349,1),TM(349,2),TM(349,3)/   510,  1170, 18725/
        DATA TM(350,1),TM(350,2),TM(350,3)/   510,  1024,     0/
        DATA TM(351,1),TM(351,2),TM(351,3)/   509,  1820, 29127/
        DATA TM(352,1),TM(352,2),TM(352,3)/   509,  1638, 26214/
        DATA TM(353,1),TM(353,2),TM(353,3)/   509,  1024,     0/
        DATA TM(354,1),TM(354,2),TM(354,3)/   514,  1536,     0/
        DATA TM(355,1),TM(355,2),TM(355,3)/   515,  1024,     0/
        DATA TM(356,1),TM(356,2),TM(356,3)/   515,  1280,     0/
        DATA TM(357,1),TM(357,2),TM(357,3)/   515,  1536,     0/
        DATA TM(358,1),TM(358,2),TM(358,3)/   515,  1792,     0/
        DATA TM(359,1),TM(359,2),TM(359,3)/   516,  1024,     0/
        DATA TM(360,1),TM(360,2),TM(360,3)/   516,  1152,     0/
        DATA TM(361,1),TM(361,2),TM(361,3)/   516,  1280,     0/
        DATA TM(362,1),TM(362,2),TM(362,3)/   517,  1024,     0/
        DATA TM(363,1),TM(363,2),TM(363,3)/   512,  1182, 27089/
        DATA TM(364,1),TM(364,2),TM(364,3)/   511,  1831,-13966/
        DATA TM(365,1),TM(365,2),TM(365,3)/   511,  1295, 17625/
       END
C+++ INTRPT
C****** INTRPT = DETERMINE INTERRUPT = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:18:21
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
        SUBROUTINE INTRPT (MODE, DEVICE)
C
C       INTERRUPT SUBROUTINE FOR FPSSIM
C
C       THIS ROUTINE HAS 3 FUNCTIONS, DEPENDING ON 'MODE':
C       INTERRUPT SET (IO ONLY), INTERRUPT QUERY AND INTERRUPT CLEAR.
C       EACH FUNCTION HAS DIFFERENT PARAMETERS.
C       COMMON STORAGE FOR ALL FUNCTIONS CONSISTS OF
C
C               INTTYP(I), WHERE I=1-TRAP INTERRUPT, 2-IO
C                                  (EXCEPTION AND FATAL INTERRUPTS
C                                  ARE DETERMINED FROM APSTAT)
C               INTTYP(I) IS NONZERO IF AN INTERRUPT OF TYPE I HAS
C               OCCURRED.  ALSO, FOR IO INTERRUPTS,
C               INTTYP(2) = DEVICE INDEX+1 OF THE HIGHEST
C               PRIORITY OUTSTANDING IO INTERRUPT.
C               THE DEVICE INDEX IS THE BIT POSITION IN IMASK
C               (0 TO 15) REPRESENTING THE IO DEVICE.
C
C               IOINT(I) IS NONZERO IF AN INTERRUPT ON IO DEVICE
C               INDEX I-1 HAS OCCURRED.
C
C       PARAMETERS
        INTEGER MODE, DEVICE
C
C       COMMON STORAGE
        INTEGER EXTRA(234),STATUS(2),EXTRA1(94),STAT2(2),STAT3(2),
     $          IMASK(2),EXTRA2(8),EXTRA4(89)
        REAL EXTRA3(2)
        INTEGER IODEV(64,3),IOSIZE,INTTYP(2),IOINT(16),
     1          IOBKPT(6,2),NIOBPT,TMSPEC(6)
        COMMON /IORM/ IODEV,IOSIZE,INTTYP,IOINT,IOBKPT,NIOBPT,TMSPEC
        COMMON EXTRA,STATUS,EXTRA1,STAT2,STAT3,IMASK,EXTRA2,
     $         EXTRA3,EXTRA4
C
        IO = 2
C       DETERMINE FUNCTION
        GO TO (100, 200, 300), MODE
C
C
C  *********IO INTERRUPT SET**********
C       MODE = 1
C       CALL INTRPT (1, DEVICE)
C
C       PARAMETERS:
C       (INPUT) DEVICE -- DEVICE INDEX (BIT POSN IN IMASK, 0-15)
C
C       ACTION:
C       (INTTYP FOR TRAP INTERRUPT IS SET AND CLEARED IN APSIM.
C       EXCEPTION AND FATAL INTERRUPTS ARE SET IN APSIM IN
C       APSTAT BITS.)
C       SET IOINT.  SET INTTYP TO HIGHEST PRIORITY IO INTERRUPT.
C
C       SET IOINT; INTTYP TO HIGHEST PRIORITY IO INTERRUPT.
100     I = DEVICE+1
        IOINT(I) = 1
        IF (INTTYP(IO).EQ.0 .OR. INTTYP(IO).GT.I) INTTYP(IO) = I
        RETURN
C
C
C  **********INTERRUPT QUERY**********
C       MODE = 2
C       DETERMINE IF AN INTERRUPT HAS OCCURRED
C       CALL INTRPT (2, TYPE)
C       PARAMETERS:
C       (OUTPUT)  TYPE  --  NONZERO IF INTERRUPT HAS OCCURRED,
C                           0 OTHERWISE
C                           (PARAMETER NAME "DEVICE" USED HERE)
C       ACTION:
C       IF UNIVERSAL INTERRUPT INHIBIT, RETURN.
C       IF ANY OF THE FOLLOWING INTERRUPT CONDITIONS OCCURS AND
C       THE CORRESPONDING ENABLE BIT IN APSTAT2 IS SET, THEN SET
C       APSTAT2 TO THE APPROPRIATE INTERRUPT CONDITION AND
C       RETURN, ELSE RETURN.
C               (1) FATAL INTERRUPT (SRAO IN APSTAT) SET
C               (2) TRAP INTERRUPT (INTTYP(1))
C               (3) EXCEPTION INTERRUPT (OVF,UNF,DIVZ IN APSTAT)
C               (4) AN INTERRUPT IS SET IN IOINT(I) FOR WHICH
C                   THE APPROPRIATE IMASK BIT IS ALSO SET
C       (FOR IO INTERRUPTS, INTTYP(2) IS CLEARED BY AN INTA--
C       SEE MODE=3)
C
200     DEVICE = 0
C       IF UNIVERSAL INTERRUPT INHIBIT, RETURN.
        IF (MOD(STAT2(1)/8,2) .EQ. 0) RETURN
C       FATAL INTERRUPT? (SRAO SET AND FATAL ENABLED)
        IF (MOD(STATUS(2)/32,2).EQ.0 .OR.
     $      MOD(STAT2(2)/32,2).EQ.0) GO TO 210
                IBIT = 2
                GO TO 270
C       TRAP INTERRUPT? (FLAG SET AND TRAP ENABLED)
210     IF (INTTYP(1).EQ.0 .OR.
     $      MOD(STAT2(2)/16,2).EQ.0) GO TO 220
                IBIT = 1
                GO TO 270
C       EXCEPTION INTERRUPT? (OVF,UNF,DIVZ SET AND EXC. ENABLED)
220     IF (MOD(STATUS(1)/32,8).EQ.0 .OR.
     $      MOD(STAT2(2)/64,2).EQ.0) GO TO 230
                IBIT = 4
                GO TO 270
C       IO INTERRUPT?
C       SEE IF IO INTERRUPT AND IO ENABLED IN APSTAT2
230     IF (INTTYP(2).EQ.0 .OR. MOD(STAT2(2)/128,2).EQ.0) RETURN
                IBIT = 8
C       GET HIGHEST PRIORITY INTERRUPT FOR WHICH IMASK BIT SET.
        K = INTTYP(IO)
        IF (K.GT.8) GO TO 250
        DO 240 I = K,8
                IF (IOINT(I).EQ.1 .AND.
     $              MOD(IMASK(1)/2**(8-I),2).EQ.1) GO TO 270
240     CONTINUE
        K = 9
250     DO 260 I = K,16
                IF (IOINT(I).EQ.1 .AND.
     $              MOD(IMASK(2)/2**(16-I),2).EQ.1) GO TO 270
260     CONTINUE
C       RETURN IF NOTHING ENABLED IN IMASK
        RETURN
C
C       SET APPROPRIATE BIT IN APSTAT2.  SET TYPE (DEVICE) NONZERO.
270     DEVICE = 1
        IF (MOD(STAT2(2)/IBIT,2) .EQ. 0) STAT2(2) = STAT2(2)+IBIT
        RETURN
C
C  **********INTERRUPT CLEAR AFTER INTA**********
C       MODE = 3
C       CALL INTRPT (3, DEVICE)
C       PARAMETERS:
C       (OUTPUT) DEVICE--DEVICE INDEX OF HIGHEST PRIORITY
C                        OUTSTANDING IO INTERRUPT
C       ACTION:
C       SET DEVICE=0.
C       IF INTTYP(2)=0, RETURN.
C       SET DEVICE = DEVICE INDEX OF HIGHEST PRIORITY
C       OUTSTANDING IO INTERRUPT THAT IS ENABLED IN IMASK.
C       SET INTTYP(2) TO INDEX+1 OF HIGHEST PRIORITY REMAINING
C       IO INTERRUPT (OR 0).
C
300     DEVICE = 0
        K = INTTYP(IO)
        IF (K.EQ.0) RETURN
C       GET HIGHEST PRIORITY INTERRUPT FOR WHICH IMASK BIT SET.
        IF (K.GT.8) GO TO 320
        DO 310 I = K,8
                IF (IOINT(I).EQ.1 .AND.
     $              MOD(IMASK(1)/2**(8-I),2).EQ.1) GO TO 340
310     CONTINUE
        K = 9
320     DO 330 I = K,16
                IF (IOINT(I).EQ.1 .AND.
     $              MOD(IMASK(2)/2**(16-I),2).EQ.1) GO TO 340
330     CONTINUE
C       RETURN IF NOTHING ENABLED IN IMASK
        RETURN
340     DEVICE = I-1
        IOINT(I) = 0
C       SET INTTYP TO HIGHEST PRIORITY OUTSTANDING IO INTERRUPT.
        INTTYP(IO) = 0
        DO 350 I = K,16
                IF (IOINT(I).NE.0) GO TO 360
350     CONTINUE
        RETURN
360     INTTYP(IO) = I
        RETURN
        END
C+++ CLOCK
C****** CLOCK = CLOCK FOR SIM100 = REL.  1.00 , 09/01/79
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF APSIM WAS PRODUCED BY CROCK
C    *    ON TUE, DEC 04 1979 FOR THE PDP11 COMPUTER AT 20:19:12
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
        SUBROUTINE CLOCK (FIX, SET, ELAPSE, CCTR, CCST, CCTL, INTRPT)
C
C       SIMULATES THE FPS-100 REAL TIME CLOCK
C
C       PARAMETERS:
C       (INPUT) FIX  --  1 IF CLOCK IS IN "FIX" MODE, ELSE 0
C                        (CAUSED IN APSIM BY ATTEMPTING TO SET THE
C                        FX BIT IN CCTL)
C               SET  --  1 IF CRN (RUN) BIT HAS BEEN CHANGED FROM 0
C                        TO 1 (IN APSIM)
C               ELAPSE - ELAPSED TIME IN MICROSECONDS
C       (INPUT & OUTPUT)
C               CCTR --  CLOCK COUNTER REGISTER
C               CCST --  CLOCK SET REGISTER
C               CCTL --  CLOCK CONTROL REGISTER
C       (OUTPUT)INTPRT - SET TO 1 IF CLOCK INTERRUPT, ELSE 0
C                        (APSIM GENERATES INTERRUPT IN FOLLOWING CYCLE)
C
        INTEGER FIX, SET, CCTR(2), CCST(2), CCTL(2), INTRPT
        REAL ELAPSE
C
        INTEGER UD, DNE, INCR(2), UNUSED
C
C       INITIALIZE
        INTRPT = 0
C
C       IF SET=1, SET CCTR AND RETURN
        IF (SET.EQ.1) GO TO 210
C
C       SINGLE CLOCKING MODE? (FIX SET?)
        IF (FIX.EQ.1) GO TO 100
C
C       IF RUN BIT (CRN) OFF, RETURN
        IF (MOD(CCTL(2),2) .EQ. 0) RETURN
C
C       SEE IF CLOCK PERIOD HAS OCCURRED
        IRATE = MOD(CCTL(2)/2,16)
C       (IRATE=15 IS EXTERNAL, WHICH NOT IMPLEMENTED)
        IF (IRATE.EQ.15) IRATE = 0
        IF (ABS (AMOD(ELAPSE,FLOAT(2**IRATE))) .GT. .00001) RETURN
C
C       INCREMENT OR DECREMENT COUNTER, DEPENDING ON UP/DOWN BIT
100     UD = MOD (CCTL(2)/64,2)
        IF (UD.EQ.1) GO TO 110
                INCR(1) = 255
                INCR(2) = 255
                GO TO 120
110     INCR(1) = 0
        INCR(2) = 1
120     CALL TCADD (CCTR,INCR,CCTR,2,UNUSED)
C
C       IF NO OVERFLOW/UNDERFLOW (WITH COUNTUP/COUNTDOWN), RETURN
        IF (.NOT.((CCTR(1).EQ.0.AND.CCTR(2).EQ.0.AND.UD.EQ.0) .OR.
     $      (CCTR(1).EQ.255.AND.CCTR(2).EQ.255.AND.UD.EQ.1)) ) RETURN
C
C       UNDERFLOW/OVERFLOW
C       IF DNE ALREADY SET, SET CERR.  SET DNE.
        DNE = MOD(CCTL(1)/2,2)
        IF (DNE.EQ.1) CCTL(1) = MOD(CCTL(1),128)+128
        IF (DNE.EQ.0) CCTL(1) = CCTL(1)+2
C
C       IF INTC=1, CAUSE INTERRUPT.
        IF (MOD(CCTL(1),2) .EQ. 1) INTRPT = 1
C
C       TEST MODE BIT (CMO)
        IF (MOD(CCTL(2)/32,2) .EQ. 1) GO TO 210
C
C       SINGLE INTEGER MODE: SET RUN BIT TO 0
        IF (MOD(CCTL(2),2).EQ.1) CCTL(2) = CCTL(2)-1
        RETURN
C
C       REPEAT INTEGER MODE: SET CCTR = CCST
210     CALL RMOV (CCST, CCTR, 2)
        RETURN
        END
