C+++ IUTIL
C****** IUTIL = INDEPENDENT UTILITIES = REL.  1.00 , 09/01/79
C
C                                                                       STARTPRE
C                                                                       ENDPRE
C    ******* CROCK INITIALIZER FILE REV.  1.07 , 09/27/79 ********
C    *
C    *    THIS VERSION OF IUTIL WAS PRODUCED BY CROCK
C    *    ON MON, DEC 03 1979 FOR THE PDP11 COMPUTER AT 09:09:10
C    *
C    *            CROCK VALUES FOR THE PDP11 COMPUTER
C    *
C    *  CHARACTERS PER WORD      =  1
C    *  CHARACTER SET            =  ASCII
C    *  CHARACTER STORAGE MODE   =  STRING
C    *  FORMAT                   =  1 BLANK(S)
C    *  ENDTBL SYMBOL            =  $END$
C    *
C    *************************************************************
C
C========= INDEPENDENT CHARACTER UTILITIES ==================================
C
C       THESE ROUTINES ASSUME: A CHARACTER IS ONE WORD,
C                               AS STORED IN A1 FORTRAN FORMAT.
C                       A STRING IS PRECEDED BY ITS CHARACTER COUNT,
C                       AND A LIST IS PRECEDED BY ITS STRING COUNT.
C
C       EXAMPLES:
C   LA=8257 . . . . . . . LETTER 'LA' HAS THE VALUE 8257
C   STRA=1,8257 . . . . . STRING 'STRA' IS ONE CHARACTER LONG
C   STRAB=2,8257,8258 . . . STRING 'STRAB' IS TWO CHARS LONG
C   LISTA=1,1,8257 . . . . LIST 'LISTA' IS ONE STRING LONG (STRA)
C   LISTAB=1,2,8257,8258 . . LISTAB IS ONE STR LONG (STRAB)
C   LIST=2,1,8257,2,8257,8258 'LIST' IS TWO STR LONG (STRA,STRAB)
C
C
C       THESE ROUTINES ASSUME AN INTERNAL CHARACTER SET WHICH IS
C       THE HOSTS INTERNAL A1 REPRESENTATION OF CHARACTERS.
C
C       NON-PRINTING CHARACTERS:
C
C       PURPOSE    SIXBIT VALUE        INPUT       OUTPUT
C                  OCTAL  DECIMAL      CHARACTER   ACTION
C
C       TAB        73     59           TAB         TAB
C       UNUSED     74     60           [           SPACE
C       EOF        75     61           ]
C       FORM FEED  76     62           ^           EJECT PAGE
C       EOL        77     63           _   "   "   NEW LINE
C
C
C============ SPECIALIZED ROUTINES FOR TRANSLATORS ========================
C
C+++ RMVTFF
C****** RMVTFF = REMOVE A TOKEN FROM A FILE = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION RMVTFF(TOKEN,TOKSIZ,STR,RADIX,LUN,RECSIZ)
        INTEGER TOKEN(9999),TOKSIZ,STR(9999),RADIX,LUN,RECSIZ
        INTEGER RDLIN,RMVTOK
C
C       TOKENS FALL INTO THREE CATAGORIES:     (CODES)
C               I/O ERROR               -3
C               NUMERIC                 -2
C               ALPHAMERIC              -1
C               SPECIAL                 ACTUAL CHARACTER
C       THE VALUE OF RMVTFF IS THE TYPE OF TOKEN RETURNED.
C       NUMERICS START WITH AN INTEGER AND END WITH THE FIRST NON-
C       INTEGER.  ALPHAMERICS BEGIN WITH A LETTER AND END ON THE
C       FIRST NON-ALPHANUMERIC.  THE TOKEN IS TAKEN FROM THE FIRST
C       NON-BLANK CHARACTER IN STRING 'STR'.  STR IS RETURNED WITH THE
C       TOKEN REMOVED.  IF STR CONTAINS NO TOKENS, LOGICAL UNIT 'LUN'
C       IS READ IN 'RECSIZ' RECORDS INTO STR.  IF RMVTFF FAILS A ZERO
C       VALUE AND NULL TOKEN ARE RETURNED.  THE TOKEN IS RETURNED IN
C       TOKEN.
C
C       ROUTINES USED:
C               RMVTOK
C               RDLIN
C
        INTEGER IVAL
C
100     RMVTFF=RMVTOK (TOKEN,TOKSIZ,STR,RADIX)
        IF (RMVTFF .NE. 0) RETURN
        IVAL=RDLIN (STR,LUN,RECSIZ)
        IF (IVAL. NE. -1 ) GO TO 100
        TOKEN(1)=0
        RMVTFF=-3
        RETURN
        END
C+++ RMVTOK
C****** RMVTOK = REMOVE A TOKEN FROM A STRING = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION RMVTOK(TOKEN,TOKSIZ,STR,RADIX)
        INTEGER TOKEN(9999),TOKSIZ,STR(9999),RADIX
C
C       TOKENS FALL INTO THREE CATAGORIES:     (CODES)
C               NUMERIC                 -2
C               ALPHAMERIC              -1
C               SPECIAL                 ACTUAL CHARACTER
C       THE VALUE OF RMVTOK IS THE TYPE OF TOKEN RETURNED.
C       NUMERICS START WITH AN INTEGER AND END WITH THE FIRST NON-
C       INTEGER.  ALPHAMERICS BEGIN WITH A LETTER AND END ON THE
C       FIRST NON-ALPHANUMERIC.  THE TOKEN IS TAKEN FROM THE FIRST
C       NON-BLANK CHARACTER IN STRING 'STR'.  STR IS RETURNED WITH THE
C       TOKEN REMOVED.  IF STR CONTAINS NO TOKENS  A ZERO
C       VALUE AND NULL TOKEN ARE RETURNED.  THE TOKEN IS RETURNED IN
C       TOKEN.
C
C       ROUTINES USED:
C               RMVCS
C               EXTTOK
C
        INTEGER EXTTOK,TOKPTR
C
        RMVTOK=EXTTOK (TOKEN,TOKSIZ,STR,1,TOKPTR,RADIX)
        CALL RMVCS (STR,1,TOKPTR-1)
        RETURN
        END
C+++ EXTTOK
C****** EXTTOK = GET A TOKEN FROM A STRING = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION EXTTOK(TOKEN,TOKSIZ,STR,POS,TOKPTR,RADIX)
        INTEGER TOKEN(9999),TOKSIZ,STR(9999),POS,TOKPTR,RADIX
C
C       TOKENS FALL INTO THREE CATAGORIES:     (CODES)
C               NUMERIC                 -2
C               ALPHAMERIC              -1
C               SPECIAL                 ACTUAL CHARACTER
C       THE VALUE OF EXTTOK IS THE TYPE OF TOKEN RETURNED.
C       NUMERICS START WITH AN INTEGER AND END WITH THE FIRST NON-
C       INTEGER.  ALPHAMERICS BEGIN WITH A LETTER AND END ON THE
C       FIRST NON-ALPHANUMERIC.  THE TOKEN IS TAKEN FROM THE FIRST
C       NON-BLANK CHARACTER IN STRING 'STR'.
C       IF STR CONTAINS NO TOKENS  A ZERO
C       VALUE AND NULL TOKEN ARE RETURNED.  THE TOKEN IS RETURNED IN
C       TOKEN.  TOKPTR RETURNS THE POSITION OF THE LAST CHARACTER
C       OF TOKEN IN STR PLUS ONE.
C
        INTEGER EXTSS,TYPC,CHR,TC,LBLANK,L,I,J,P
C
C       ROUTINES USED:
C               RMVCS
C               EXTSS
C               TYPC
C       DEFINED CONSTANTS USED:
C
        P=POS
        L=STR(1)
        IF (P .LE. 0) P=1
        IF (L.LE.0.OR.P.GT.L) GO TO 1000
C    REMOVE BLANKS OR TABS
        DO 10 I=P,L
        IF (TYPC(STR(I+1),10).NE.8224) GO TO 100
10      CONTINUE
C    BLANK LINE
        TOKPTR=L+1
        GO TO 500
C
C    SEE IF A NON-ALPHANUMERIC OR AT END OF STRING
100     CHR=TYPC(STR(I+1),RADIX)
      IF((CHR.NE.-1 .AND.CHR.NE.-2).OR.I.EQ.L)GOTO 200
        L=L-1
C
C    LOOK FOR THE END OF THE ALPHANUMERIC TOKEN
        DO 120 J=I,L
        TC=TYPC(STR(J+2),RADIX)
        IF ( TC .NE. -1 .AND. TC .NE. -2 ) GO TO 300
        IF (TC.EQ.-1 .AND.CHR.EQ.-2) GO TO 300
120     CONTINUE
        J=L+1
300     J=J+1-I
C
C    EXTRACT TOKEN FROM STRING
310     L=EXTSS(STR,I,TOKEN,MIN0(J,TOKSIZ))
        TOKPTR=I+J
        EXTTOK=CHR
        RETURN
C
200     J=1
        GO TO 310
C
C    RETURN NULL STRING
500     CONTINUE
1000    EXTTOK=0
        TOKEN(1)=0
        RETURN
        END
C+++ EXTFLD
C****** EXTFLD = EXTRACT A FIELD FROM A STRING = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION EXTFLD (STR,POS,FIELD,FLDPTR,STCHR,ENDCHR,OPT)
        INTEGER STR(9999),POS,FIELD(9999),FLDPTR,STCHR,ENDCHR,OPT
C
C   'STCHR' AND 'ENDCHR' ARE CHARACTERS TO USE AS DELIMITERS
C   IN EXTRACTING 'FIELD'.
C
C   EXTRACTS FIELDS FROM 'STCHR' TO 'ENDCHR'. IF 'STCHR'
C   AND 'ENDCHR' ARE THE SAME, EXTRACTS FROM 'POS'
C   TO NEXT ENDCHR. IF THEY ARE DIFFERENT, EXTRACTS FROM
C   'POS' TO 'ENDCHR' AT SAME LEVEL, I.E. IF 'N'
C   'STCHR'S ARE FOUND, EXTRACTS UNTIL 'N+1'TH 'ENDCHR'.
C
C   RETURNS EXTRACTED STRING IN 'FIELD' AND SETS 'FLDPTR'
C   AND FUNCTION VALUE TO POS OF LAST CHARACTER EXTRACTED + 1.
C
C   IF END OF FIELD NOT FOUND, EXTRACTS FROM 'POS' TO END OF 'STR'
C   INTO 'FIELD', AND RETURNS 0 AS FUNCTION VALUE, AND LENGTH OF
C   'STR' + 1 IN 'FLDPTR'.
C
C   IF 'OPT' IS NOT EQUAL TO 0, DOES NOT RETURN STARTING AND ENDING
C   DELIMITERS IN 'FIELD', BUT DOES RETURN FIRST CHARACTER IF NOT
C   A 'STCHR'.
C
C-------LOCAL DECLARATIONS
C    VARIABLES
        INTEGER P,ILEVEL,ITEMP,I,L,M,N
C    FUNCTIONS USED
        INTEGER EXTCS,EXTSS
C
        P = POS + 1
        IF (P .LT. 1) P = 1
        M = 0
        N = 0
        IF (EXTCS (STR,POS,ITEMP) .EQ. STCHR) GOTO 10
        M = 1
        N = 1
10      IF (OPT .NE. 0) GOTO 20
        M = 1
        N = 2
20      EXTFLD = 0
        L = LENS (STR)
        IF (L .LT. P) GOTO 201
        ILEVEL = 1
        DO 200 I = P,L
        IF (EXTCS (STR,I,ITEMP) .EQ. ENDCHR) ILEVEL = ILEVEL - 1
        IF (ILEVEL .NE. 0) GOTO 100
        FLDPTR = I + 1
        EXTFLD = FLDPTR
        ITEMP = EXTSS (STR,P-M,FIELD,I-P+N)
        RETURN
100     IF (EXTCS (STR,I,ITEMP) .EQ. STCHR) ILEVEL = ILEVEL + 1
200     CONTINUE
201     ITEMP = EXTSS (STR,P-M,FIELD,-1)
        FLDPTR = L + 1
        RETURN
        END
C+++ WRTERR
C****** WRTERR = HANDLE ERROR MARKING = REL.  1.00 , 09/01/79
C
        SUBROUTINE WRTERR(LNO,LINE,MSG1,MSG2,CODE,LUN,RECSIZ,ERRCNT)
        INTEGER LNO,LINE(999),MSG1(999),MSG2(999),CODE,LUN,RECSIZ,ERRCNT
C
C       THIS ROUTINE PRINTS THE LINE 'LINE' AND THEN THE LINE NUMBER
C       FOLLOWED BY THE MESSAGES 'MSG1' AND 'MSG2' ON UNIT VWTTY IF
C       IABS(CODE) = 1  AND SAME ON LUN IF LUN > 0.
C       ERRCNT IS INCREMENTED.
C       THE ROUTINE RETURNS IF CODE IS NEGATIVE.
C
        INTEGER VWTTY,MSG(81),VEND,VBEG,LSPC,VALL
C
C       ROUTINES USED:
C               WRTLIN
C               RMVCS
C               INSSS
C               INSCS
C               LENS
C               ITOS
C
C                                                                       STARTPRE
      INTEGER SSTARS(11)
C STRNG SSTARS ""*** LINE "
      DATA SSTARS(2)/'" '/,SSTARS(3)/'* '/,SSTARS(4)/'* '/
      DATA SSTARS(5)/'* '/,SSTARS(6)/'  '/,SSTARS(7)/'L '/
      DATA SSTARS(8)/'I '/,SSTARS(9)/'N '/,SSTARS(10)/'E '/
      DATA SSTARS(11)/'  '/
      DATA SSTARS(1)/10/
C                                                                       ENDPRE
C
C-------DEFINED CONSTANTS USED:
        DATA VWTTY,VEND,VBEG,VALL
     1  /       -1,  -1,   0,  -1/
C
        ERRCNT=ERRCNT+1
        CALL RMVCS(MSG,VBEG,VALL)
        CALL INSSS(MSG,VEND,LINE,80)
        IF (CODE.EQ.1.OR.CODE.EQ.-1) CALL WRTLIN(MSG,VWTTY,80)
        CALL ITOS(LNO,MSG,4,10)
        CALL INSCS(MSG,VEND,8224)
        CALL INSSS(MSG,VEND,MSG1,79-LENS(MSG))
        CALL INSCS(MSG,VEND,8224)
        CALL INSSS(MSG,VEND,MSG2,80-LENS(MSG))
        CALL INSSS(MSG,VBEG,SSTARS,80-LENS(MSG))
        IF (CODE.EQ.1.OR.CODE.EQ.-1) CALL WRTLIN(MSG,VWTTY,80)
        IF (LUN.GT.0) CALL WRTLIN(MSG,LUN,RECSIZ)
        IF (CODE.LT.0) RETURN
        CALL EXIT
        END
C+++ DTTOS
C****** DTTOS = CONVERT CURRENT TIME TO STRING = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION DTTOS (STR,NPAR)
        INTEGER STR(9999),NPAR
C
C   FUNCTION RETURNS 0 IF TIME CONVERTED, 1 IF DATTIM NOT AVAILABLE
C   RETURNS DATE & TIME IN 'STR' - FORMAT MM/DD/YY   HH:MM:SS.SSSS
C   RETURNS NUMBER OF PARAMETERS SPECIFIED BY NPAR
C   I.E. -  IF NPAR = 3   RETURN MM/DD/YY
C              NPAR = 5   RETURN MM/DD/YY   HH:MM
C
C   MAXIMUM LENGTH OF ARRAY (STR) RETURNED = 25 WORDS
C
C------ ROUTINES USED: DATTIM ITOS RMVCS INSCS INSSS,SRJUST
C
C
        INTEGER TIME(7),BUF(5),I,LSPACE,LZERO,LSLASH,LCOLON,LDOT
C
        DTTOS = 1
        CALL DATTIM (TIME)
        CALL RMVCS (STR,0,-1)
        IF (TIME (1) .EQ. 0) RETURN
        DTTOS = 0
        DO 10 I = 1,NPAR
        CALL ITOS (TIME (I),BUF,4,10)
        IF (I .EQ. 3) CALL RMVCS (BUF,1,2)
        IF (I.GT.3.AND.I.LT.7) CALL SRJUST(BUF,2,8240)
        IF (I.EQ.7) CALL SRJUST(BUF,3,8240)
        CALL INSSS (STR,-1,BUF,-1)
        IF (I.LE.2.AND.I.NE.NPAR) CALL INSCS (STR,-1,8239)
        IF(I.EQ.3.AND.I.NE.NPAR) CALL INSCS (STR,LENS (STR) + 3,8224)
        IF (I.GT.3.AND.I.LT.6.AND.I.NE.NPAR) CALL INSCS (STR,-1,8250)
        IF (I.EQ.6.AND.I.NE.NPAR) CALL INSCS (STR,-1,8238)
10      CONTINUE
        RETURN
        END
C+++ TABS
C****** TABS = INSERT TABS (SPACES) = REL.  1.00 , 09/01/79
C
        SUBROUTINE TABS(STR,LEN)
        INTEGER STR(9999),LEN
C
C       APPEND BLANKS TO INCREASE STRING 'STR' LENGTH TO NEXT MULTIPLE
C       OF LEN.
C
        INTEGER I,M,N
C
        M=STR(1)+2
        N=STR(1)+LEN+1-MOD(STR(1),LEN)
        DO 100 I=M,N
100     STR(I)=8224
        STR(1)=N-1
        RETURN
        END
C+++ STOSF
C****** STOSF = STRING TO SINGLE FLOATING POINT = REL.  1.00 , 09/01/79
C
        REAL FUNCTION STOSF(STR,IERR)
        INTEGER STR(9999),IERR
C
C       CONVERT THE FLOATING POINT NUMBER IN 'STR' TO A SINGLE
C       FLOATING POINT NUMBER.
C
C       PARAMETERS:
C               STR     INPUT STRING
C
C               IERR    ERROR FLAG, SET TO 0 IF 'STR' CONTAINS A LEGAL NUMBER
C                               OR TO 1 IF NOT.
C
C               STOSF   RETURNS A SINGLE FLOATING POINT NUMBER, OR
C                               0.0 IF AN ERROR
C
C       A LEGAL FLOATING POINT NUMBER IS OF THE FORM:
C
C       SIGN  INTEGER PART  .  FRACTION PART  E  SIGN  EXPONENT
C
C-------LOCAL DECLARATIONS
C
C    ROUTINES USED
        DOUBLE PRECISION STODF
C
        STOSF=SNGL(STODF(STR,IERR))
        RETURN
        END
C+++ SFTOS
C****** SFTOS = SINGLE FLOATING POINT TO STRING = REL.  1.00 , 09/01/79
C
        SUBROUTINE SFTOS(VAL,STR,FMT,WIDTH,DIGITS)
        REAL VAL
        INTEGER STR(9999),FMT,WIDTH,DIGITS
C
C       CONVERTS A SINGLE PRECISION FLOATING POINT NUMBER INTO A CHARACTER
C       STRING.
C
C-------PARAMETERS
C
C       VAL     SINGLE PRECISION VALUE TO BE CONVERTED
C       STR     OUTPUT STRING
C       FMT     OUTPUT FORMAT:  1  'E'  SCIENTIFIC NOTATION
C                               2  'F'  FIXED POINT
C                               3  'G'  GENERAL (EITHER 'E' OR 'F')
C                       NOTE THAT THESE HAVE THE SAME MEANING AS THEY DO FOR
C                       FORTRAN FORMATTED OUTPUT OF REAL NUMBERS.
C       WIDTH   WIDTH OF OUTPUT
C       DIGITS  NUMBER OF DIGITS IN THE FRACTION PART
C
C       IF THE NUMBER CANNOT BE CONVERTED IN THE WIDTH ALLOWED, THAN THE STRING
C       IS FILLED WITH ASKERISKS (*).
C
C       THE THREE FORMATS MODEL AFTER THE 'E', 'F', AND 'G' FORMATS OF FORTRAN
C       FORMATTED FLOATING-POINT OUTPUT.  THUS:
C
C               FMT     WIDTH   DIGITS  CORRESPONDING FORTRAN FORMAT
C               1       6       3       F6.3
C               2       12      5       E12.5
C               3       9       2       G9.2
C
C       FOR 'E' FORMAT, 'DIGITS' MUST BE AT LEAST 7 LESS THAT 'WIDTH'
C       FOR 'F' FORMAT, 'DIGITS' MUST BE AT LEAST 3 LESS THAN 'WIDTH'
C
        CALL DFTOS(DBLE(VAL),STR,FMT,WIDTH,DIGITS)
        RETURN
        END
C+++ STODF
C****** STODF = STRING TO DOUBLE FLOATING POINT = REL.  1.00 , 09/01/79
C
        DOUBLE PRECISION FUNCTION STODF(STR,IERR)
        INTEGER STR(9999),IERR
C
C       CONVERT THE FOATING POINT NUMBER IN 'STR' TO A DOUBLE PRECISION
C       FLOATING POINT NUMBER.
C
C       PARAMETERS:
C               STR     INPUT STRING
C
C               IERR    ERROR FLAG, SET TO 0 IF 'STR' CONTAINS A LEGAL NUMBER
C                               OR TO 1 IF NOT.
C
C               STODF   RETURNS A DOUBLE PRECISION FLOATING POINT NUMBER, OR
C                               0.0 IF AN ERROR
C
C       A LEGAL FLOATING POINT NUMBER IS OF THE FORM:
C
C       SIGN  INTEGER PART  .  FRACTION PART  E  SIGN  EXPONENT
C
C       AS IN  -2.3E-3
C
C       STATES:
C               1       MANTISSA SIGN
C               2       INTEGER VALUE
C               3       FRACTION VALUE
C               4       EXPONENT SIGN
C               5       EXPONENT VALUE
C
C       'PNOK' DECIMAL POINT NOT OK IS '1' IF A DECIMAL POINT IS NOT OK,
C               AND '0' IF OK.  IT IS NOT OK IF THERE WAS NEITHER AN INTEGER
C               IN FRONT OF THE POINT, OR A FRACTION AFTER
C
C-------DECLARATIONS
C
C    LOCAL VARIABLES
        INTEGER I,L,MANSGN,EXPSGN,EXPVAL,STATE,CHR,TYP,PNOK
        DOUBLE PRECISION VAL,FRAC,DIG
C    DEFINED CONSTANTS
        DOUBLE PRECISION MAXVAL,MINVAL
        REAL RMAXEX
        INTEGER MAXEX
C
C    FUNCTIONS USED
        INTEGER TYPC
C-----------------------------------------------------------------------
C
C       THESE CONSTANTS DEFINE THE MAXIMUM AND MINIMUM LEGAL FLOATING POINT
C               NUMBERS THAT 'STODF' CAN CONVERT.  THEY ARE SET TO VALUES
C               APPROPRIATE TO FLOATING POINT FORMATS WITH THE SMALLEST
C               DYNAMIC RANGE, I.E. AN EIGHT BIT BINARY EXPONENT, WHICH
C               HAS A RANGE OF APPROXIMATELY 3.4 X 10**38.  THEY MAY BE
C               INCREASED FOR SYSTEMS WITH A LARGER DYNAMIC RANGE.
C
C    A FACTOR OF 10.0 LESS THAN THE MAXIMUM FLOATING POINT NUMBER
        DATA MAXVAL /3.4D37/
C    A FACTOR OF 10.0 MORE THAN THE MINIMUM FLOATING POINT NUMBER
        DATA MINVAL /3.4D-37/
C    MAXIMUM POWER OF 10 (I.E., LOG10(MAXIMUM NUMBER))
        DATA RMAXEX /38.23/
C    MAXIMUM POWER OF 10 (I.E., LOG10(MAXIMUM NUMBER)), TRUNCATED TO AN INTEGER
        DATA MAXEX /38/
C
C----------------------------------------------------------------------------
C
C  STATEMENT FUNCTIONS
      MAKR1(IA1) = IAND16(IA1,"377)
C
C
        IERR=0
        STATE=1
        PNOK=0
        VAL=0.0D0
        FRAC=1.0D0
        EXPVAL=0
        MANSGN=0
        EXPSGN=0
C
        L=STR(1)
        IF (L.LE.0) GO TO 20000
        L=L+1
C
C-------LOOP
C
        DO 9999 I=2,L
        CHR=STR(I)
        TYP=TYPC(CHR,10)
C
C    SEE IF A DIGIT
        IF (TYP.NE.-2) GO TO 2000
C
C    PUT INTO EITHER INTEGER PART, FRACTION PART, OR EXPONENT
        DIG = MAKR1(CHR-8240)
        GO TO (1100,1100,1200,1300,1300),STATE
C
C    INTEGER PART
1100    IF (VAL.GE.MAXVAL) GO TO 20000
        VAL=VAL*10.0D0 + DIG
        STATE=2
        GO TO 9999
C
C    FRACTION PART
1200    IF (FRAC.LE.MINVAL) GO TO 20000
        FRAC=FRAC/10.0D0
        DIG=DIG*FRAC
        VAL=VAL+DIG
        PNOK=0
        GO TO 9999
C
C    EXPONENT
1300    EXPVAL=EXPVAL*10 + DIG
        IF (EXPVAL.GT.MAXEX) GO TO 20000
        STATE=5
        GO TO 9999
C
C    SEE IF A '+' OR '-'
2000    IF (CHR.NE.8235 .AND. CHR.NE.8237) GO TO 3000
C    SET THE PROPER SIGN
        GO TO (2100,20000,20000,2200,20000),STATE
C
C    SET MANTISSA SIGN
2100    IF (MANSGN.NE.0) GO TO 20000
        MANSGN=CHR
        GO TO 9999
C
C    SET EXPONENT SIGN
2200    IF (EXPSGN.NE.0) GO TO 20000
        EXPSGN=CHR
        GO TO 9999
C
C    SEE IF A '.'
3000    IF (CHR.NE.8238) GO TO 4000
C    ADVANCE TO FRACTION PART
        IF (STATE.GE.3) GO TO 20000
        IF (STATE.EQ.1) PNOK=1
        STATE=3
        GO TO 9999
C
C    SEE IF A 'E'
4000    IF (CHR.NE.8261) GO TO 5000
C    ADVANCE TO EXPONENT PART
        IF (STATE.EQ.1.OR.STATE.GE.4) GO TO 20000
        STATE=4
        GO TO 9999
C
5000    IF (CHR .NE. 8224) GO TO 20000
C
9999    CONTINUE
C
C-------DONE, PUT TOGTHER PIECES
C
        IF (STATE.EQ.1.OR.STATE.EQ.4.OR.PNOK.EQ.1) GO TO 20000
C
C    NEGATE MANTISSA
        IF (MANSGN.EQ.8237) VAL=-VAL
        IF (STATE.LE.3) GO TO 11000
C
C    INCORPORATE EXPONENT
C    NEGATE EXPONENT
        IF (EXPSGN.EQ.8237) EXPVAL=-EXPVAL
C    SEE IF COMBINATION IS OUT OF RANGE
        IF (VAL .EQ. 0.0D0) GOTO 11000
        IF (ABS(ALOG10(ABS(SNGL(VAL)))+FLOAT(EXPVAL)).GE.RMAXEX)
     1     GO TO 20000
        IF (EXPVAL .GT. 12 .OR. EXPVAL .LT. -12) GOTO 10100
        IF (EXPVAL .EQ. 0) GOTO 11000
        IF (EXPVAL .LT. 0) GOTO 10050
        DO 10020 L=1,EXPVAL
10020   VAL=VAL*10.0D0
        GOTO 11000
10050   EXPVAL=-EXPVAL
        DO 10070 L=1,EXPVAL
10070   VAL=VAL/10.0D0
        GOTO 11000
10100   VAL=VAL * 10.0D0**EXPVAL
C
11000   STODF=VAL
        IERR=0
        RETURN
C
C-------ERROR RETURN
C
20000   STODF=0.0D0
        IERR=1
        RETURN
        END
C+++ DFTOS
C****** DFTOS = DOUBLE FLOATING POINT TO STRING = REL.  1.00 , 09/01/79
C
        SUBROUTINE DFTOS(DVAL,STR,FMT,WIDTH,DIGITS)
        DOUBLE PRECISION DVAL
        INTEGER STR(9999),FMT,WIDTH,DIGITS
C
C       CONVERTS A DOUBLE PRECISION FLOATING POINT NUMBER INTO A CHARACTER
C       STRING.
C
C-------PARAMETERS
C
C       DVAL    DOUBLE PRECISION VALUE TO BE CONVERTED
C       STR     OUTPUT STRING
C       FMT     OUTPUT FORMAT:  1  'E'  SCIENTIFIC NOTATION
C                               2  'F'  FIXED POINT
C                               3  'G'  GENERAL (EITHER 'E' OR 'F')
C                       NOTE THAT THESE HAVE THE SAME MEANING AS THEY DO FOR
C                       FORTRAN FORMATTED OUTPUT OF REAL NUMBERS.
C       WIDTH   WIDTH OF OUTPUT
C       DIGITS  NUMBER OF DIGITS IN THE FRACTION PART
C
C       IF THE NUMBER CANNOT BE CONVERTED IN THE WIDTH ALLOWED, THAN THE STRING
C       IS FILLED WITH ASKERISKS (*).
C
C       THE THREE FORMATS MODEL AFTER THE 'E', 'F', AND 'G' FORMATS OF FORTRAN
C       FORMATTED FLOATING-POINT OUTPUT.  THUS:
C
C               FMT     WIDTH   DIGITS  CORRESPONDING FORTRAN FORMAT
C               1       6       3       F6.3
C               2       12      5       E12.5
C               3       9       2       G9.2
C
C       FOR 'E' FORMAT, 'DIGITS' MUST BE AT LEAST 7 LESS THAT 'WIDTH'
C       FOR 'F' FORMAT, 'DIGITS' MUST BE AT LEAST 3 LESS THAN 'WIDTH'
C
C-------METHOD
C
C       1. THE NUMBER IS DIVIDED OR MULTIPLIED BY 10.0 UNTIL IT IS
C          0.1 <= VAL < 1.0,   WHICH IS THE MANTISSA. IEXP IS COUNTED UP OR
C               DOWN TO GIVE THE EXPONENT.  NOTE THAT THIS COULD HAVE BEEN
C               WITH LOGARITHMS, I.E.   IEXP = LOG(VAL) + 1
C                                       VAL  = VAL * 10**-IEXP
C               BUT I DIDN'T TRUST THE ACCURACY OF 'LOG' FUNCTIONS, ESPECIALLY
C               NEAR EACH POWER OF 10.
C
C       2. IF 'G' FORMAT WAS PICKED, THEN USE EITHER
C          'F' OR 'E', DEPENDING UPON THE SIZE OF VAL:
C               IF IEXP<0 OR IEXP>DIGITS  USE  E (WIDTH).(DIGITS)
C               OTHERWISE USE  F(WIDTH-4).(DIGITS-IEXP) , 4X
C
C       3. ROUND AT THE LAST FRACTION DIGIT TO BE PRINTED:
C               IF 'E' FORMAT, ADD  0.5 X 10**(-DIGITS)
C               IF 'F' FORMAT, ADD  0.5 X 10**(-DIGITS-IEXP)
C                       UNLESS THE MANTISSA IS TOO SMALL, IN WHICH
C                       CASE FORCE 0.0
C
C       4. CHECK FOR MANTISSA OVERFLOW
C               IF SO, SET VAL TO 0.1, AND COUNT UP IEXP.
C               ALSO, IF 'F' FORMAT CONVERTED FROM 'G', INCREMENT
C               DIGITS, UNLESS THIS CAUSES 'F' FORMAT OVERFLOW,
C               INWHICH CASE, SWITCH TO 'E' FORMAT
C
C       5. CHECK FOR FORMAT OVERFLOW:
C               IF 'E' FORMAT: IF  WIDTH < DIGITS + 7   OR
C                              IF  IEXP > 99
C                       THEN OVERFLOW
C               IF 'F' FORMAT: IF  WIDTH < DIGITS + 3   OR
C                              IF  IEXP > WIDTH - DIGITS - 2
C                       THEN OVERFLOW
C
C       6. PUT OUT '-' IF VAL WAS NEGATIVE
C
C       7. IF 'E' FORMAT, OR 'F' FORMAT AND IEXP <= 0 PUT OUT '0.'
C
C       8. SET DIGIT LOOP COUNT:
C               IF 'E' FORMAT: COUNT DOWN FROM 0
C               IF 'F' FORMAT: COUNT DOWN FROM IEXP
C                       IF IEXP < 0, THEN PUT OUT IEXP LEADING ZEROS
C
C       9. MAKE DIGITS.  MULTIPLY VAL BY 10.0.  THE INTEGER PART IS THE
C               DIGIT, THE FRACTION PART IS THE UPDATED VAL.  COUNT DOWN
C               THE COUNTER.  IF 'F' FORMAT AND THE COUNT IS ZERO, THEN
C               PUT OUT A '.'.  DONE WHEN THE COUNT REACHES  -DIGITS.
C
C       10. IF 'E' FORMAT, PUT OUT 'E', A '-' IF THE EXPONENT WAS NEGATIVE,
C               ELSE A SPACE, AND THEN THE TWO EXPONENT DIGITS.
C           IF 'F' FORMAT AND THE USER SPECIFIED 'G', THEN PUT OUT 4 SPACES.
C
C       11. RIGHT JUSTIFY THE STRING IN THE SPECIFIED WIDTH.
C
C-------LOCAL DECLARATIONS
C
C    LOCAL VARIABLES
        INTEGER ISGN,TFMT,TWIDTH,TDIGIT,IEXP,PTR,I,I1,ICNT,IDIG
        DOUBLE PRECISION VAL
C    DEFINED CONSTANTS
        INTEGER LSPACE,LMINUS,LZERO,LPOINT,LSTAR,LE,LPLUS
        DATA LSPACE,LMINUS,LZERO,LPOINT,LSTAR,LE/8224,8237,
     *       8240,8238,8234,8261/
        DATA LPLUS /8235/
C
C       STATEMENT FUNCTIONS
      MAKA1(IR1) = IR1
C
C
        TFMT=FMT
        TWIDTH=WIDTH
        TDIGIT=DIGITS
C    REMEMBER SIGN
        ISGN=0
        IF (DVAL.LT.0.0D0) ISGN=1
        VAL=DABS(DVAL)
        IEXP=0
        IF (VAL.EQ.0.0D0) GO TO 2000
C
C    ADJUST UNTIL:  0.1 <=  VAL  < 1.0
C
1200    IF (VAL.GE.1.0D0) GO TO 1400
1300    IF (VAL.GE.0.1D0) GO TO 2000
C
C    MAKE VAL LARGER
        VAL=VAL * 10.0D0
        IEXP=IEXP-1
        GO TO 1300
C
C    MAKE VAL SMALLER
1400    VAL=VAL / 10.0D0
        IEXP=IEXP+1
        GO TO 1200
C
C    IF 'G' FORMAT, PICK EITHER 'E' OR 'F'
C
2000    IF (FMT.NE.3) GO TO 3000
        IF (IEXP.LT.0.OR.IEXP.GT.DIGITS) GO TO 2500
C    USE 'F' FORMAT
        TFMT=2
        TDIGIT=DIGITS-IEXP
        TWIDTH=WIDTH-4
        GO TO 3000
C    USE 'E' FORMAT
2500    TFMT=1
C
C    ROUND
C
3000    IF (VAL.EQ.0.0D0) GO TO 4000
C    DIFFERENT FOR 'E' AND 'F'
        GO TO (3100,3200),TFMT
C
C    'E' FORMAT ROUND
3100    VAL=VAL + 0.5D0 * 10.0D0**(-TDIGIT)
        GO TO 3300
C
C    'F' FORMAT ROUND
C    SEE IF TOO SMALL TO SHOW UP IN FRACTION
3200    IF ((TDIGIT.GT.-IEXP) .OR.
     1      (TDIGIT.EQ.-IEXP.AND.VAL.GE.0.5D0)) GO TO 3210
C
        VAL=0.0D0
        IEXP=0
        GO TO 4000
C
3210    VAL=VAL + 0.5D0 * 10.0D0**(-TDIGIT-IEXP)
C
C    CHECK FOR MANTISSA OVERFLOW ON ROUNDING
3300    IF (VAL.LT.1.0D0) GO TO 4000
        VAL=VAL / 10.0D0
        IEXP=IEXP+1
C    IF 'F' CONVERTED FROM 'G', INCREMENT TDIGIT UNLESS THIS CAUSES FORMAT
C    OVERFLOW, INWHICH CASE SWITCH TO 'E' FORMAT
        IF (.NOT.(TFMT.EQ.2.AND.FMT.EQ.3)) GO TO 4000
C    IF NOW TOO BIG FOR 'F', SWITCH TO 'E'
        IF (IEXP.GT.DIGITS) GO TO 3310
C
C    NOT TOO BIG, MERELY ALTER TDIGIT
        TDIGIT=TDIGIT-1
        GO TO 4000
C
C    TOO BIG, SWITCH TO 'E'
3310    TFMT=1
        TWIDTH=WIDTH
        TDIGIT=DIGITS
C
C    CHECK FOR FORMAT OVERFLOW
C
4000    GO TO (4100,4200),TFMT
C
C    'E' FORMAT, OVERFLOW IF:
C          1. WIDTH < DIGITS + 7
C          2. IABS(IEXP) > 99
4100    IF (TWIDTH.LT.TDIGIT+7 .OR. IABS(IEXP).GT.99) GO TO 10000
        GO TO 5000
C    'F' FORMAT, OVERFLOW IF:
C          1. WIDTH < DIGITS + 3
C          2. IEXP > WIDTH - DIGITS - 2
4200    IF (TWIDTH.LT.TDIGIT+3 .OR.
     1      IEXP.GT.TWIDTH-TDIGIT-2 ) GO TO 10000
        GO TO 5000
C
C    NOW, FINALLY, MAKE THE DIGITS
C
5000    PTR=2
C    PUT OUT A '-' IF NEGATIVE
        IF (ISGN.EQ.0) GO TO 5100
C
        STR(PTR)=LMINUS
        PTR=PTR+1
C
C    IF 'E' FORMAT, OR 'F' FORMAT AND NUMBER IS <1.0, PUT OUT '0.'
5100    IF (.NOT.(TFMT.EQ.1 .OR.
     1            (TFMT.EQ.2.AND.IEXP.LE.0) )) GO TO 5200
C
        STR(PTR)=LZERO
        STR(PTR+1)=LPOINT
        PTR=PTR+2
C
C    SET LOOP COUNT
5200    GO TO (5210,5220),TFMT
C
C    'E' FORMAT, COUNT FROM ZERO DOWN TO THE NUMBER OF DIGITS
5210    ICNT=0
        GO TO 5300
C
C    'F' FORMAT, COUNT FROM 'IEXP' DOWN TO THE NUMBER OF DIGITS
5220    ICNT=IEXP
C    IF 'ICNT' < 0, PUT OUT ICNT LEADING ZEROS
        IF (ICNT.GE.0) GO TO 5300
C
        I1=-IEXP
        DO 5230 I=1,I1
        STR(PTR)=LZERO
5230    PTR=PTR+1
C
C    LOOP TO FORM THE DIGITS
C
5300    VAL=VAL * 10.0D0
        IDIG=IDINT(VAL)
        STR(PTR) = MAKA1(IDIG) + LZERO
        PTR=PTR+1
        VAL=VAL - DBLE(FLOAT(IDIG))
        ICNT=ICNT-1
C    IF 'F' FORMAT AND ICNT DOWN TO ZERO, PUT OUT A '.'
        IF (.NOT.(TFMT.EQ.2.AND.ICNT.EQ.0)) GO TO 5400
C
        STR(PTR)=LPOINT
        PTR=PTR+1
C
5400    IF (ICNT.GT.-TDIGIT) GO TO 5300
C
C    DONE PUTTING OUT DIGITS, IF 'E' PUT OUT EXPONENT
C                             IF 'F' PUT OUT 4 SPACES IF WAS 'G'
        GO TO (5410,5420),TFMT
C
C    'E' FMT
5410    STR(PTR)=LE
        PTR=PTR+1
        STR(PTR)=LPLUS
        IF (IEXP.LT.0) STR(PTR)=LMINUS
        IEXP=IABS(IEXP)
        STR(PTR+1)=MAKA1(IEXP/10) + LZERO
        STR(PTR+2)=MAKA1(MOD(IEXP,10)) + LZERO
        PTR=PTR+3
        GO TO 6000
C
C    'F' FORMAT, ADD FOUR SPACES IF WAS 'G' FORMAT
5420    IF (FMT.NE.3) GO TO 6000
        I1=PTR+3
        DO 5430 I=PTR,I1
5430    STR(I)=LSPACE
        PTR=PTR+4
C
C    NOW RIGHT JUSTIFY IN THE WIDTH
6000    STR(1)=PTR-2
        CALL SRJUST(STR,WIDTH,LSPACE)
        RETURN
C
C    FORMAT OVERFLOW, FILL THE FIELD WITH '*'
C
10000   I1=WIDTH+1
        DO 10010 I=2,I1
10010   STR(I)=LSTAR
        STR(1)=WIDTH
        RETURN
        END
C+++ RPLIS
C****** RPLIS = REPLACE INTEGER INTO STRING = REL.  1.00 , 09/01/79
C
        SUBROUTINE RPLIS(STR,POS,VALUE,MAXLEN,RADIX,PADCHR)
        INTEGER STR(9999),POS,VALUE,MAXLEN,RADIX,PADCHR
C
C       CONVERTS A 'VALUE' (AN INTEGER) TO A 'MAXLEN' LONG RIGHT JUSTIFIED
C       STRING IN RADIX 'RADIX' AND REPLACES IT INTO 'STR' AT POSITION 'POS'
C
C       PARAMETERS
C
C       STR     STRING INTO WHICH THE CONVERTED VALUE IS TO BE PLACED
C       POS     POSITION IN THE DESTINATION STRING, IF POS IF OFF THE END OF
C               'STR', THEN 'STR' IS EXTENDED WITH BLANKS.
C       VALUE   INTEGER VALUE TO BE CONVERTED
C       MAXLEN  MAXIMUM WIDTH TO BE REPLACED (80 MAX)
C       RADIX   CONVERSION RADIX
C       PADCHR  THE PAD CHAR USED DURRING RIGHT JUSTIFICATION.
C
C
C       LOCAL STORAGE
C
        INTEGER TEMP(81)
C
C----------ROUTINES USED:  ITOS, SRJUST, RPLSS
C
C    CLEAR TEMPORARY STRING
        TEMP(1)=0
C    CONVERT INTEGER
        CALL ITOS(VALUE,TEMP,MAXLEN,RADIX)
C    RIGHT JUSTIFY WITH PADCHR
        CALL SRJUST(TEMP,MAXLEN,PADCHR)
C    REPLACE INTO DESTINATION
        CALL RPLSS (STR,POS,MAXLEN,TEMP,MAXLEN)
        RETURN
        END
C+++ SRJUST
C****** SRJUST = STRING RIGHT JUSTIFY = REL.  1.00 , 09/01/79
C
        SUBROUTINE SRJUST(STR,LEN,PADCHR)
        INTEGER LEN,STR(9999),PADCHR
C
C
C       RIGHT JUSTIFIES THE STRING AT STR INTO A 'LEN' LONG STRING.
C       EXTRA LEFT HAND PLACES ARE FILLED WITH PADCHR'S.
C       STR IS TRUNCATED IF NECESSARY.
C
        INTEGER I,J,K,L,M
C
        L=STR(1)
        IF (L-LEN) 10,1000,500
10      K=LEN-L
        DO 100 I=1,L
        J=L+2-I
        M=LEN+2-I
100     STR(M)=STR(J)
        DO 200 I=1,K
200     STR(I+1)=PADCHR
500     STR(1)=LEN
1000    RETURN
        END
C+++ STOI
C****** STOI = CHARACTER STRING TO INTEGER = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION STOI(STR,RADIX)
        INTEGER STR(9999),RADIX
C
C       RETURNS AN INTEGER WHICH IS THE VALUE OF THE UNSIGNED STRING IN 'STR'
C       USING 'RADIX' AS THE INTEGER CONVERSION RADIX.  THE VALUE IS RETURNED
C       MODULO 65536.
C
        STOI = IPFIX( STOFI(STR,RADIX) )
        RETURN
        END
C+++ STOFI
C****** STOFI = STRING TO FLOATING INTEGER = REL.  1.00 , 09/01/79
C
        REAL FUNCTION STOFI(STR,RADIX)
        INTEGER STR(9999),RADIX
C
C       RETURNS A REAL NUMBER WHICH IS THE VALUE OF THE UNSIGNED INTEGER STRING
C       IN 'STR' USING 'RADIX' AS THE INTEGER RADIX.  IF 'STR' CONTAINS
C       NON-DIGITS, A -1.0 IS RETURNED.
C
        REAL RRADIX
        INTEGER TYPS,I,L,N
C
C       STATEMENT FUNCTIONS
      MAKR1(IA1) = IAND16(IA1,"377)
C
C
C    SEE IF A PROPER STRING
        IF (TYPS(STR,RADIX).NE.-2) GO TO 200
C
        RRADIX=RADIX
        STOFI=0.0
        L=STR(1)
C
        DO 50 I=1,L
        N=MAKR1(STR(I+1)-8240)
        IF (N.GT.9) N=N-MAKR1(((8257-8249)-1))
50      STOFI=STOFI*RRADIX + N
        RETURN
C
200     STOFI=-1.0
        RETURN
        END
C+++ ITOS
C****** ITOS = INTEGER TO CHARACTER CONVERSION = REL.  1.00 , 09/01/79
C
        SUBROUTINE ITOS(VALUE,STR,MAXLEN,RADIX)
        INTEGER VALUE,STR(9999),MAXLEN,RADIX
C
C       CONVERTS THE INTEGER 'VALUE' INTO A RADIX 'RADIX' CHARACTER
C       STRING OF UPTO 'MAXLEN' CHARACTERS. IF 'MAXLEN' IS EXCEEDED, RETURN
C       A STRING OF '**** ... ***'.
C
        REAL J,N,A
        INTEGER I,K,M
C
C  STATEMENT FUNCTIONS
      MAKR1(IA1) = IAND16(IA1,"377)
      MAKA1(IR1) = IR1
C
        J=RADIX
        A=J
        N=PFLOAT(VALUE)
        DO 100 I=1,MAXLEN
        IF (J.GT.N) GO TO 200
100     J=J*A
        I=MAXLEN
        IF (N.GT.J) GO TO 1000
200     STR(1)=I
        J=J/A
        DO 300 K=1,I
        M=N/J
C
C CONVERT INTEGER N TO INTERNAL CHARACTER REPRESENTATION
C
        N=N-FLOAT(M)*J
        IF (M.GT.9) M=M+MAKR1((8257-8249)-1)
        STR(K+1)=MAKA1(M) + 8240
300     J=J/A
        RETURN
1000    STR(1)=I
        DO 1100 K=1,I
1100    STR(K+1)=8234
        RETURN
        END
C+++ TYPS
C****** TYPS = TYPE STRING = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION TYPS(STR,RADIX)
        INTEGER STR(9999),RADIX
C
C       RETURNS        -2 IF ALL CHARACTERS DIGITS IN THE SPECIFIED 'RADIX'
C                      -1 IF ALL CHARACTERS ALPHA OR DIGITS
C                       0 IF NON-ALPHANUMERICS
C
C       NOTE: IF THE STRING COULD BE EITHER NUMERIC IN THE SPECIFIED RADIX, OR
C       ALPHA, THEN -2 (NUMERIC) IS RETURNED
C
        INTEGER I,J,L,TYPC
C
        TYPS=-2
        L=STR(1)
        IF (L.LE.0) GO TO 200
C
        DO 100 I=1,L
        J=TYPC(STR(I+1),RADIX)
        IF (TYPS.EQ.-2.AND.J.EQ.-1) TYPS=-1
        IF (TYPS.LT.0.AND.J.GE.0) TYPS=0
100     CONTINUE
        RETURN
C
200     TYPS=0
        RETURN
        END
C+++ TYPC
C****** TYPC = TYPE OF CHARACTER = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION TYPC(CHR,RADIX)
        INTEGER CHR,RADIX
C
C       RETURNS:
C         -2  IF THE CHARACTER IS A DIGIT IN 'RADIX'
C         -1  IF THE CHARACTER IS ALPHA (A-Z) OR DIGIT (0-9)
C        ELSE  THE CHARACTER VALUE IF NON-ALPHANUMERIC
C
C       NOTE: BLANK IS RETURNED FOR A TAB
C
C       IF A CHARACTER IS BOTH A LETTER AND A DIGIT, NUMERIC (-2) WILL BE
C               RETURNED
C
        INTEGER L0,L9,LA,LTAB,LBLANK,LZ
C
C       DEFINED CONSTANTS USED:
        DATA   L0, L9,  LA, LZ,  LBLANK, LTAB/
     1     8240,8249,8257, 8282, 8224, 8283/
C
C       NOTE:  L0<L9  AND  LA<LZ
C
C  THIS ASSUMES CHARACTERS 0 THROUGH 9 AND A THROUGH Z ARE CONTIGUOUS
C  BLOCKS OF ASCENDING VALUES. AND THAT L9<LA.
C  HOWEVER, LA DOES NOT HAVE TO BE L9+1
C
C  STATEMENT FUNCTIONS
      MAKA1(IR1) = IR1
C
C-------SEE IF A DIGIT
C
C    RADIX <=10, LOOK ONLY FOR  0 THROUGH RADIX-1
C    RADIX  >10, LOOK FOR  0 THROUGH 9  OR  A THROUGH  A-11+RADIX
        IF ( (RADIX.LT.10.AND.(CHR.GE.L0.AND.CHR.LE. L0+
     *                                 MAKA1(RADIX-1) )) .OR.
     1       (RADIX.GE.10.AND.(CHR.GE.L0.AND.CHR.LE. L9) .OR.
     2       (CHR.GE.LA.AND.CHR.LE. LA+MAKA1(RADIX-11))))
     3    GO TO 100
C
C-------SEE IF A LETTER OR A DIGIT
C
        IF (CHR.GE.LA.AND.CHR.LE.LZ .OR. CHR.GE.L0.AND.CHR.LE.L9)
     1        GO TO 200
C
C-------A SPECIAL CHARACTER
        TYPC=CHR
        IF (CHR.EQ.LTAB) TYPC=LBLANK
        RETURN
C
C    WAS A DIGIT
100     TYPC=-2
        RETURN
C
C    WAS A LETTER
200     TYPC=-1
        RETURN
        END
C+++ SRCST
C****** SRCST = SEARCH FOR A STRING IN A TABLE = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION SRCST (TAB,RNGS,RNGE,STR,MAXLEN)
        INTEGER TAB(9999),STR(9999),RNGS,RNGE,MAXLEN
C
C       TABLE 'TAB' IS SEARCHED FOR THE FIRST OCCURANCE OF UP TO
C       'MAXLEN' CHARACTERS OF STRING 'STR'.  THE TABLE IS SEARCHED
C       BEGINNING AT ENTRY 'RNGS' THROUGH ENTRY 'RNGE'.  IF 'MAXLEN'
C       IS NEGATIVE ALL CHARACTERS MUST MATCH, OTHERWISE ONLY
C       'MAXLEN' CHARACTERS OF 'STR' WILL BE USED.  IF THE EFFECTIVE
C       STRING LENGTH IS LESS THAN THE TABLE WIDTH THE STRING IS
C       PADDED WITH BLANKS.  THE VALUE OF THE FUNCTION IS THE ENTRY
C       NUMBER OF THE MATCHING ENTRY OR 0 IF NO MATCH IS FOUND.
C
        INTEGER R1,R2,TL,TW,TV,I1,I2,IOCR,I,J,IJ
        INTEGER SW,TVTW
        SRCST=0
        TL=TAB(1)
        IF (TL .LE. 0) RETURN
        IF (MAXLEN .EQ. 0) RETURN
        SW=MAXLEN
        IF (SW .LT. 0) SW=STR(1)
        SW=MIN0(SW,STR(1))
        IF (SW .LE. 0) RETURN
        R1=RNGS
        IF (R1 .GT. TL) RETURN
        IF (R1 .LE. 0) R1=1
        R2=RNGE
        IF (R2 .LT. 0 .OR. R2 .GT. TL) R2=TL
        IF (R2 .LT. R1) RETURN
        TW=TAB(2)
        TV=TAB(3)
        TVTW=TV+TW
        I1=(R1-1)*TVTW+3
        I2=(R2-1)*TVTW+3
C
C       DO THE SEARCH
C
        DO 500 I=I1,I2,TVTW
        DO 300 J=1,TW
        IJ=I+J
        IF (J .GT. SW) GOTO 200
        IF (TAB(IJ) .NE. STR(J+1)) GOTO 500
        GOTO 300
200     IF (TAB(IJ) .NE. 8224) GOTO 500
300     CONTINUE
        SRCST=(I-3)/TVTW+1
        RETURN
500     CONTINUE
        RETURN
        END
C+++ SRCSBT
C****** SRCSBT = SEARCH A BINARY TABLE = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION SRCSBT (TAB,STR,INDEX)
        INTEGER TAB(9999),STR(9999),INDEX
C
C       THE BINARY SEARCH IS CARRIED OUT ON THE TABLE 'TAB'.  IF 'STR'
C       IS FOUND IN 'TAB', THE FUNCTION RETURNS 1, ELSE 0 IF NOT FOUND.
C       'INDEX' IS RETURNED AS THE POSITION WHERE 'STR' WAS FOUND
C       OR THE INDEX WHERE 'STR' SHOULD BE INSERTED TO KEEP 'TAB'
C       SORTED.  IF 'STR' IS A NULL STRING THE FUNCTION VALUE IS 0.
C
        INTEGER TW,SW,TVTW,IPTR,INDX,IPTR1,IPTR2,I
C
        INDX=0
        SRCSBT=0
        INDEX=1
        IPTR2=TAB(1)+1
        IF (IPTR2 .LE. 1) RETURN
        SW=STR(1)
        IF (SW .LE. 0) RETURN
        TW=TAB(2)
        TVTW=TW+TAB(3)
        IPTR1=0
100     INDX=(IPTR1+IPTR2)/2
        IF (INDX .EQ. IPTR1) GOTO 250
        IPTR=(INDX-1)*TVTW+4
        DO 200 I=1,TW
        IF (I .GT. SW) GOTO 150
        IF (TAB(IPTR) .NE. STR(I+1)) GOTO 300
        GOTO 200
150     IF (TAB(IPTR) .NE. 8224) GOTO 300
200     IPTR=IPTR+1
        SRCSBT=1
        INDX=INDX-1
250     INDEX=INDX+1
        RETURN
300     IF (I .GT. SW .OR. TAB(IPTR) .GT. STR(I+1)) GOTO 400
        IPTR1=INDX
        GOTO 100
400     IPTR2=INDX
        GOTO 100
        END
C+++ INSST
C****** INSST = INSERT STRING ENTRY INTO A TABLE = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION INSST (TAB,POS,STR,MAXLEN)
        INTEGER TAB(9999),POS,STR(9999),MAXLEN
C
C       TABLE 'TAB' IS RETURNED WITH 'MAXLEN' CHARS OF
C       'STR' INSERTED AT POSITION 'POS'.
C       IF 'POS' IS NEGATIVE THEN THE ENTRY SPACE IS APPENDED
C       AT THE END OF THE TABLE.  IF 'POS' IS PAST THE END OF THE
C       TABLE THEN THE TABLE IS PADDED WITH 0 ENTRIES.  THE VALUE
C       OF THE FUNCTION IS THE ENTRY POSITION.  IF 'MAXLEN' IS 0
C       NO INSERTION IS MADE AND THE FUNCTION RETURNS 0.
C
        INTEGER TL,TW,TV,P,TVTW,I1,I2,IX,JX,I,SW
C
        TL=TAB(1)
        INSST=0
        SW=MAXLEN
        IF (SW .LT. 0) SW=STR(1)
        SW=MIN0(SW,STR(1),TAB(2))
        IF (SW .EQ. 0) RETURN
        P=POS
        IF (P .LT. 0) P=TL+1
        IF (P .EQ. 0) P=1
        TW=TAB(2)
        TV=TAB(3)
        TVTW=TV+TW
        I1=(P-1)*TVTW+4
        IF (P .LE. TL) GOTO 250
C
C       PADD END OF TAB WITH ZEROES (NULL STRINGS)
C
        I1=TL*TVTW+4
        I2=I1+(P-TL)*TVTW-1
        DO 225 I=I1,I2
225     TAB(I)=0
        TAB(1)=P-1
        GOTO 350
C
C       MAKE ROOM FOR NEW TABLE ENTRY
C
250     I2=TL*TVTW+3
        DO 300 I=I1,I2
        IX=I2-I+I1
        JX=IX+TVTW
        TAB(JX)=TAB(IX)
        TAB(IX)=0
300     CONTINUE
C
C       INSERT THE STRING ENTRY
C
350     I1=(P-1)*TVTW+4
        I2=I1+TW-1
        IX=1
        DO 500 I=I1,I2
        IF (IX .GT. SW) GOTO 400
        TAB(I)=STR(IX+1)
        IX=IX+1
        GOTO 500
400     TAB(I)=8224
500     CONTINUE
        TAB(1)=TAB(1)+1
        INSST=P
        RETURN
        END
C+++ RPLST
C****** RPLST = REPLACE STRING IN A TABLE = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION RPLST (TAB,POS,STR)
        INTEGER TAB(9999),POS,STR(9999)
C
C       THE STRING AT POSTION 'POS' OF TABLE 'TAB' IS
C       REPLACED BY STRING 'STR'.  IF THE STRING IS TOO SHORT
C       IT IS PADDED WITH BLANKS.  IF 'POS' IS NEGATIVE THEN
C       THE ENTRY IS PLACED AFTER THE CURRENT END OF THE TABLE.
C       IF 'POS' IS PAST THE END OF THE TABLE THEN THE TABLE
C       IS PADDED WITH BLANK ENTRIES.  ZERO IS USED FOR ALL
C       VALUES OF ANY NEW ENTRIES.  THE FUNCTION RETURNS THE
C       POSITION OF ENTRY.
C
        INTEGER TL,TW,TV,P,TVTW,SW,I1,I2,I,J
C
        TL=TAB(1)
        SW=STR(1)
        P=POS
        IF (P .LT. 0) P=TL+1
        IF (P .EQ. 0) P=1
        TW=TAB(2)
        TV=TAB(3)
        TVTW=TV+TW
        IF (P .LE. TL) GOTO 250
C
C       PADD END OF TAB W/ ZEROES FOR NEW ENTRY
C
        I1=TL*TVTW+4
        I2=I1+(P-TL)*TVTW-1
        DO 225 I=I1,I2
225     TAB(I)=0
        TAB(1)=P
C
C REPLACE THE STRING IN THE ENTRY
C
250     I1=(P-1)*TVTW+4
        I2=I1+TW-1
        J=1
        DO 300 I=I1,I2
        IF (J .GT. SW) GOTO 275
        TAB(I)=STR(J+1)
        J=J+1
        GOTO 300
275     TAB(I)=8224
300     CONTINUE
        RPLST=P
        RETURN
        END
C+++ RPLVT
C****** RPLVT = REPLACE VALUE(S) IN A TABLE = REL.  1.00 , 09/01/79
C
        SUBROUTINE RPLVT (TAB,POS,SVAL,VALS,MAXVAL)
        INTEGER TAB(9999),POS,SVAL,VALS(9999),MAXVAL
C
C       'MAXVAL' VALUES (STARTING AT 'SVAL') OF THE ENTRY AT
C       POSITION 'POS' OF TABLE 'TAB' ARE REPLACED BY VALUES IN
C       'VALS'.  IF 'MAXVAL' IS LESS THAN 0 ALL VALUES PAST SVAL
C       WILL BE REPLACED.  IF 'POS' IS NEGATIVE THE VALUES OF THE
C       LAST TABLE ENTRY ARE REPLACED.  IF 'POS' IS PAST THE END OF
C       THE TABLE THEN THE TABLE IS PADDED WITH BLANK ENTRIES UP
C       TO 'POS'.
C
        INTEGER TL,TW,TV,P,M,I1,I2,I,J,TVTW
        TL=TAB(1)
        IF (TL .LT. 0) RETURN
        IF (TL .EQ. 0 .AND. POS .LT. 0) RETURN
        IF (POS .EQ. 0) RETURN
        P=POS
        IF (P .LT. 0) P=TL
        IF (SVAL .LE. 0) RETURN
        TV=TAB(3)
        IF (TV .EQ. 0) RETURN
        M=MAXVAL
        IF (M .EQ. 0) RETURN
        IF (M .LT. 0) M=9999
        TW=TAB(2)
        TVTW=TV+TW
        IF (P .LE. TL) GOTO 400
        I1=TL*TVTW+4
        I2=I1+(P-TL-1)*TVTW-1+TW
        DO 300 I=I1,I2
300     TAB(I)=0
        TAB(1)=P
400     I1=(P-1)*(TV+TW)+4+TW+SVAL-1
        I2=I1+MIN0 (TV-SVAL+1,M)-1
        J=1
        DO 500 I=I1,I2
        TAB(I)=VALS(J)
500     J=J+1
        RETURN
        END
C+++ EXTVT
C****** EXTVT = EXTRACT VALUE(S) FROM A TABLE = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION EXTVT (TAB,POS,SVAL,VALS,MAXVAL)
        INTEGER TAB(9999),POS,SVAL,VALS(9999),MAXVAL
C
C       ARRAY 'VALS' IS RETURNED CONTAINING THE VALUES FOR THE
C       ENTRY OF TABLE 'TAB' IN POSITION 'POS'.  UP TO 'MAXVAL'
C       VALUES STARTING AT VALUE 'SVAL' ARE RETURNED IN ARRAY
C       'VALS'.  IF 'MAXVAL' IS NEGATIVE ALL VALUES ARE RETURNED.
C       IF THERE IS NO VALUE OR POS IS PAST THE END OF THE TABLE
C       A -1 IS RETURNED, AND THE REQUESTED VALS ELEMENTS
C       ARE SET TO ZERO.
C
        INTEGER TL,TW,TV,S,M,J,I,I1,I2
C
        TV=TAB(3)
        IF (TV .EQ. 0) RETURN
        IF (MAXVAL .EQ. 0) RETURN
        S=SVAL
        IF (S .EQ. 0) S=1
        M=MAXVAL
        IF (M .LT. 0) M=9999
        IF (S .LE. TV .AND. S .GT. 0) GOTO 200
50      J=MIN0 (TV-SVAL+1,M)
        DO 100 I=1,J
100     VALS(I)=0
        EXTVT=0
        RETURN
200     TL=TAB(1)
        IF (TL .LE. 0) GOTO 50
        IF (POS .GT. TL .OR. POS .LE. 0) GOTO 50
        TW=TAB(2)
        I1=(POS-1)*(TV+TW)+4+TW+S-1
        I2=I1+MIN0 (TV-S+1,M)-1
        J=1
        DO 500 I=I1,I2
        VALS(J)=TAB(I)
500     J=J+1
        EXTVT=VALS(1)
        RETURN
        END
C+++ INTT
C****** INTT = INITIALIZE TABLE = REL.  1.00 , 09/01/79
C
        SUBROUTINE INTT (TABLE,STRLEN,VALCNT)
        INTEGER TABLE(9999),STRLEN,VALCNT
C
C       TABLE 'TABLE' IS INITIALIZED TO CONTAIN NO ENTRIES.
C       SUBSEQUENT ENTRIES INTO THE TABLE ARE CONSIDEREDS TO
C       HAVE A STRING LENGTH OF 'STRLEN' AND TO HAVE 'VALCNT'
C       VALUES.
C
C
        TABLE(1)=0
        TABLE(2)=STRLEN
        TABLE(3)=VALCNT
        RETURN
        END
C+++ LENT
C****** LENT = RETURNS THE LENGTH OF A TABLE = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION LENT (TAB)
        INTEGER TAB(9999)
        LENT=TAB(1)
        RETURN
        END
C+++ EXTST
C****** EXTST = EXTRACT A STRING FROM A TABLE = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION EXTST (TAB,POS,STR,MAXLEN)
        INTEGER TAB(9999),POS,STR(9999),MAXLEN
C
C       STRING 'STR' IS RETURNED CONTAINING THE ENTRY OF
C       TABLE 'TAB' IN POSITION 'POS'.  UP TO 'MAXLEN' CHAR-
C       ACTERS ARE RETURNED IN STRING 'STR'.  IF 'MAXLEN'
C       IS NEGATIVE THEN THE ENTIRE STRING IS RETURNED,
C       OTHERWISE ONLY 'MAXLEN' CHARACTERS ARE MOVED.  THE
C       VALUE OF THE FUNCTION IS THE FIRST CHARACTER OF 'STR'.
C       IF 'POS' IS PAST THE END OF 'TAB' THEN A NULL STRING
C       IS RETURNED AND THE VALUE OF THE FUNCTION IS -1.
C
        INTEGER TL,TW,TV,TVTW,M,I1,I2,J,K,P
C
        TL=TAB(1)
        P=POS
        IF (P .LE. 0) P=1
        IF (MAXLEN .NE. 0 .AND. P .LE. TL) GOTO 100
        STR(1)=0
        EXTST=0
        RETURN
100     TW=TAB(2)
        TV=TAB(3)
        TVTW=TV+TW
        M=MAXLEN
        IF (M .LT. 0) M=TW
        I1=(P-1)*TVTW+4
        I2=I1+MIN0 (TW,M)-1
        K=2
        DO 200 J=I1,I2
        STR(K)=TAB(J)
200     K=K+1
        STR(1)=K-2
        EXTST=STR(2)
        RETURN
        END
C+++ RMVET
C****** RMVET = REMOVE ENTRIES FROM A TABLE = REL.  1.00 , 09/01/79
C
        SUBROUTINE RMVET (TAB,POS,CNT)
        INTEGER TAB(9999),POS,CNT
C
C       'CNT' ENTRIES ARE REMOVED FROM TABLE 'TAB' STARTING
C       AT POSITION 'POS'.  IF 'CNT' IS NEGATIVE THE TABLE IS
C       TRUNCTATED AT POSITION 'POS'.
C
        INTEGER TVTW,P,TL,C,I1,J1,J2,K
C
        IF (CNT .EQ. 0) RETURN
        P=POS
        TL=TAB(1)
        IF (P .LE. 0) P=1
        IF (P .GT. TL) RETURN
        C=CNT
        IF (C .LT. 0) C=9999
        IF (TL-(C+P-1) .GT. 0) GOTO 100
        TAB(1)=P-1
        RETURN
100     TVTW=TAB(2)+TAB(3)
        I1=(P-1)*TVTW+4
        J1=(P+C-1)*TVTW+4
        J2=TL*TVTW+3
        DO 200 K=J1,J2
        TAB(I1)=TAB(K)
200     I1=I1+1
        TAB(1)=TL-C
        RETURN
        END
C+++ RPLSL
C****** RPLSL = REPLACE A STRING IN A LIST = REL.  1.00 , 09/01/79
C
C======== LIST MANIPULATION ROUTINES ===================================
C
C
        SUBROUTINE RPLSL (LIST,POS,STR)
        INTEGER LIST(9999),POS,STR(9999)
C
C       THE STRING AT POSITION 'POS' IN 'LIST' IS REPLACED BY 'STR'.  IF
C       'POS' IS PAST THE END OF 'LIST' THEN NULL STRINGS ARE USED TO PAD
C       UP TO POSITION 'POS' BEFORE REPLACEMENT IS DONE.
C
C       ROUTINES USED:
C
C               RMVSL, INSSL
C
        CALL RMVSL (LIST,POS,1)
        CALL INSSL (LIST,POS,STR,-1)
        RETURN
        END
C+++ SRCSL
C****** SRCSL = SEARCH A LIST FOR A STRING = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION SRCSL(LIST,POS,STR,MAXLEN)
        INTEGER LIST(9999),POS,STR(9999),MAXLEN
C
C        HAS THE VALUE OF THE INDEX OF THE FIRST OCCURANCE OF STRING
C       'STR' IN LIST 'LIST' OR 0 IF 'STR' DOES NOT OCCUR.
C       THE SEARCH BEGINS WITH THE POS(TH) STRING IN LIST.
C       'MAXLEN' SPECIFIES THE NUMBER OF CHARACTERS THAT MUST
C       MATCH, -1 MEANS ALL.
C
        INTEGER PC,CMPSS,L,LEN,I,J,P
C
C       ROUTINES USED:  CMPSS
C
        L=LIST(1)
        LEN=MAXLEN
        IF (LEN.EQ.0.OR.L.LE.0) GO TO 300
        P=POS
        IF (P.LE.0) P=1
        IF (P .GT. L) GOTO 300
        PC=2
        DO 200 J=1,L
        IF (J .LT. P) GOTO 200
        IF (CMPSS(LIST(PC),STR,LEN).EQ.0) GO TO 100
200     PC=PC+LIST(PC)+1
300     SRCSL=0
        RETURN
100     SRCSL=J
        RETURN
        END
C+++ EXTCL
C****** EXTCL = EXTRACT A CHARACTER FROM A LIST = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION EXTCL(LIST,POS,CHR,COL)
        INTEGER LIST(9999),POS,CHR,COL
C
C       HAS THE VALUE OF THE COLUMN 'COL' CHARACTER OF THE STRING AT
C       POSITION 'POS' OF LIST 'LIST'.
C       IF THE POSITION IS PAST THE END OF LIST, OR COLUMN IS PAST THE
C       END OF STRING, A ZERO IS RETURNED FOR CHARACTER 'CHR' AND VALUE.
C
        INTEGER P,C,LC,I
        EXTCL=0
        CHR=0
        C=COL
        IF (C .LE. 0) C=1
        P=POS
        IF (P .LE. 0) P=1
        IF (P .GT. LIST(1)) RETURN
C
C       FIND THE POSITION
C
        LC=2
        IF (P .EQ. 1) GOTO 400
        DO 200 I=2,P
200     LC=LIST(LC)+LC+1
400     IF (C .GT. LIST(LC)) RETURN
        LC=LC+C
        CHR=LIST(LC)
        EXTCL=CHR
        RETURN
        END
C+++ INSCL
C****** INSCL = INSERT A CHARACTER INTO A LIST = REL.  1.00 , 09/01/79
C
        SUBROUTINE INSCL(LIST,POS,CHR)
        INTEGER LIST(9999),POS,CHR
C
C       INSERT CHARACTER 'CHR' INTO LIST LIST AT STRING POSITION POS.
C       IF POSITION IS PAST THE END OF THE LIST, PAD WITH 0'S
C       (NULL STRINGS - ZERO LENGTH) BEFORE INSERTING STRING FOR CHR.
C       IF POSITION IS NEGATIVE, APPEND STR AT THE END OF LIST.
C
        INTEGER DUMMY(2)
C
C       ROUTINES USED:    INSSL
C
        DUMMY(1)=1
        DUMMY(2)=CHR
        CALL INSSL(LIST,POS,DUMMY,1)
        RETURN
        END
C+++ RMVSL
C****** RMVSL = REMOVE STRINGS FROM A LIST = REL.  1.00 , 09/01/79
C
        SUBROUTINE RMVSL(LIST,POSITN,COUNT)
        INTEGER LIST(9999),POSITN,COUNT
C
C       SHORTENS THE LIST BY REMOVING STRINGS AT POSITION 'POSITN'.
C       'COUNT' STRINGS ARE REMOVED.
C       A NEGATIVE VALUE FOR  COUNT INDICATES TRUNCATING THE LIST
C       IMMEDIATELY BEFORE POSITION.
C
C       LOCAL VARIABLES:
        INTEGER LC,CC,RC,RLC,P,L,LL,I,J
C
        P=POSITN
        L=LIST(1)
        IF (P.LE.0) P=1
        IF (L.LT.0) LIST(1)=0
        IF (L.LT.P.OR.COUNT.EQ.0) RETURN
        IF (P+COUNT.GT.L.OR.COUNT.LT.0) GO TO 200
        LC=2
C       FIND POSITION - DETERMINE LEFT (FIRST) CHARACTER TO REMOVE (LC)
        IF (P.EQ.1) GO TO 1000
        DO 2000 I=2,P
2000    LC=LIST(LC)+LC+1
1000    CC=LC
C       SKIP COUNT STRINGS - DETERMINE LAST CANCELED CHARACTER (CC)
        DO 3000 I=1,COUNT
3000    CC=LIST(CC)+CC+1
        RC=CC
        LL=COUNT+P
C       FIND END OF LIST - DETERMINE RIGHT CHARACTER (RC)
        DO 4000 I=LL,L
4000    RC=RC+LIST(RC)+1
C       DETERMINE NEW LIST LENGTH
        L=L-COUNT
C       DETERMINE NUMBER OF CHARS PAST END OF REMOVED STRINGS
        RC=RC-CC
C       DETERMINE NUMBER OF CHARS TO REMOVE
        CC=CC-LC
C       DETERMINE NEW END OF LIST POSITION
        RLC=LC+RC-1
C       CLOSE HOLE
        DO 100 I=LC,RLC
        J=I+CC
100     LIST(I)=LIST(J)
        LIST(1)=L
        RETURN
200     LIST(1)=P-1
        RETURN
        END
C+++ EXTSL
C****** EXTSL = EXTRACT A STRING FROM A LIST = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION EXTSL(LIST,POS,STR,MAXLEN)
        INTEGER LIST(9999),POS,STR(9999),MAXLEN
C
C       HAS THE VALUE OF THE FIRST CHARACTER OF THE STRING AT POSITION
C       'POS' OF LIST 'LIST'.  IF MAXLEN IS 0, NO STRING IS RETURNED.
C       IF MAXLEN IS NEGATIVE THE ENTIRE STRING IS RETURNED.
C       THE STRING 'STR' IS OF MAXIMUM LENGTH 'MAXLEN' AND IS NULL
C       (OF LENGTH 0) IF POSITION IS PAST THE END OF LIST.
C       IF THE POSITION IS PAST THE END OF LIST, A 0 IS RETURNED.
C
C       LOCAL VARIABLES:
        INTEGER PC,CHR,P,L,LEN,I,J
        L=LIST(1)
        P=POS-1
        IF (POS.GT.L)GO TO 90
        LEN=MAXLEN
        PC=2
C       FIND POSITION
        IF (P.LE.0) GO TO 10
        DO 1000 I=1,P
1000    PC=PC+LIST(PC)+1
C       FIND LENGTH OF STRING TO RETURN
        IF(LIST(PC).EQ.0)GO TO 90
10      CHR=LIST(PC+1)
        IF(LEN.LT.0.OR.LEN.GT.LIST(PC)) LEN=LIST(PC)
        IF(LEN.EQ.0)GO TO 95
C       COPY STRING FROM LIST TO STR
        DO 50 I=1,LEN
        J=PC+I
50      STR(I+1)=LIST(J)
        STR(1)=LEN
        GO TO 100
90      CHR=0
95      IF (MAXLEN.NE.0) STR(1)=0
100     EXTSL=CHR
        RETURN
        END
C+++ INSSL
C****** INSSL = INSERT A STRING INTO A LIST = REL.  1.00 , 09/01/79
C
        SUBROUTINE INSSL(LIST,POS,STR,MAXLEN)
        INTEGER LIST(9999),POS,STR(9999),MAXLEN
C
C       INSERT STRING 'STR' INTO LIST LIST AT POSITION POS.
C       IF POSITION IS PAST THE END OF THE LIST, PAD WITH 0'S
C       (NULL STRINGS - ZERO LENGTH) BEFORE
C       INSERTING STRING.  IF MAXLEN IS NEGATIVE, INSERT ALL OF STR,
C       OTHERWISE INSERT UP TO MAXLEN CHARACTERS.
C       IF POSITION IS NEGATIVE, APPEND STR AT THE END OF LIST.
C
C       LOCAL VARIABLES:
        INTEGER P,PC,CC,L,LEN,I,J,K,LSTR,M
C
        L=LIST(1)
        LEN=MAXLEN
        IF (LEN.LT.0.OR.LEN.GT.STR(1)) LEN=STR(1)
        P=POS
C       FIND POSITION NUMBER FOR STRING
        IF (P) 10,20,30
10      P=L
20      P=P+1
C       FIND CHARACTER POSITION TO INSERT STRING AT
30      PC=2
        IF (P.EQ.1.OR.L.EQ.0) GO TO 1000
        LSTR=MIN0(L,P-1)
        DO 2000 I=1,LSTR
2000    PC=LIST(PC)+PC+1
1000    CC=PC
        IF (P-L-1) 100,200,300
C
C INSERT IN MID-LIST
C
C       FIND END CHARACTER OF LIST
100     DO 3000 I=P,L
3000    CC=LIST(CC)+CC+1
        CC=CC-PC
C       PROVIDE SPACE FOR INSERTING STRING
        DO 120 I=1,CC
        J=PC+CC-I
        K=J+LEN+1
120     LIST(K)=LIST(J)
C
C INSERT STRING AT END OF LIST OR IN PROVIDED SPACE
C
200     LIST(1)=L+1
400     LIST(PC)=LEN
        IF (LEN.EQ.0) RETURN
C       COPY STRING INTO LIST
        DO 220 K=1,LEN
        M=PC+K
220     LIST(M)=STR(K+1)
        RETURN
C
C INSERT AFTER END OF LIST
C
300     K=P-L-1
        DO 320 I=1,K
        M=CC+I-1
320     LIST(M)=0
        LIST(1)=P
        PC=M+1
        GO TO 400
        END
C+++ LENL
C****** LENL = RETURN THE LENGTH OF LIST = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION LENL(LIST)
        INTEGER LIST(9999)
C
C       HAS THE VALUE OF THE NUMBER OF STRINGS IN LIST 'LIST'
C
        LENL=LIST(1)
        RETURN
        END
C+++ RPLSS
C****** RPLSS = REPLACE A STRING WITHIN A STRING = REL.  1.00 , 09/01/79
C
C========== STRING MANIPULATION ==============================
C
C
        SUBROUTINE RPLSS (STR,POS,STRLEN,SUB,SUBLEN)
        INTEGER STR(9999),POS,STRLEN,SUB(9999),SUBLEN
C
C       'STRLEN' CHARS ARE REMOVED FROM 'STR' STARTING AT POSITION
C       'POS';  IF 'STRLEN' IS NEGATIVE 'STR' IS TRUNCATED;  IF 'STRLEN'
C       IS 0 OR 'POS' IS NOT WITHIN 'STR' NO REMOVAL IS DONE.  THEN,
C       'SUBLEN' CHARS FROM 'SUB' ARE INSERTED INTO 'STR' AT POSITION
C       'POS';  IF 'SUBLEN' IS NEGATIVE ALL OF 'SUB' IS USED.  IF 'POS'
C       IS NOT WITHIN 'STR' THEN 'STR' IS PADDED W/ BLANKS UP TO 'POS'
C       BEFORE THE INSERTION IS DONE.
C
C       ROUTINES USED:
C
C               RMVCS, INSSS
C
        IF (POS .LT. 0) GOTO 100
        CALL RMVCS (STR,POS,STRLEN)
100     CALL INSSS (STR,POS,SUB,SUBLEN)
        RETURN
        END
C+++ RMVCS
C****** RMVCS = REMOVE CHARACTERS FROM A STRING = REL.  1.00 , 09/01/79
C
        SUBROUTINE RMVCS(STRING,POSITN,COUNT)
        INTEGER STRING(9999),POSITN,COUNT
C
C       SHORTENS THE STRING BY REMOVING CHARACTERS AT POSITION 'POSITN'.
C       A NEGATIVE VALUE FOR  COUNT INDICATES TRUNCATING THE STRING
C       IMMEDIATELY BEFORE POSITION.
C
        INTEGER P,C,L,I,J
C
        L=STRING(1)
        P=POSITN
        C=COUNT
        IF (L.LT.0) STRING(1)=0
        IF (P.LE.0) P=1
        IF (L.LT.P.OR.C.EQ.0) RETURN
        IF (P+C.GT.L.OR.C.LT.0) GO TO 200
        L=L-C
        DO 100 I=P,L
        J=I+1+C
100     STRING(I+1)=STRING(J)
        STRING(1)=L
        RETURN
200     STRING(1)=P-1
        RETURN
        END
C+++ EXTCS
C****** EXTCS = EXTRACT CHARACTER FROM STRING = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION EXTCS(STR,POS,CHR)
        INTEGER STR(9999),POS,CHR
C
C       HAS THE VALUE OF THE CHARACTER AT POSITION POS OF STRING STR.
C       THE CHARACTER IS ALSO RETURNED IN CHR.
C       IF THE POSITION IS PAST THE END OF STRING A 0 IS RETURNED.
C
        INTEGER P
        IF (POS.GT.STR(1)) GO TO 90
        P=POS
        IF (P .LE. 0) P=1
        CHR=STR(P+1)
        GO TO 100
90      CHR=0
100     EXTCS=CHR
        RETURN
        END
C+++ INSCS
C****** INSCS = INSERT A CHARACTER INTO A STRING = REL.  1.00 , 09/01/79
C
        SUBROUTINE INSCS(STR,POS,CHR)
        INTEGER STR(9999),POS,CHR
C
C       INSERT CHARACTER CHR INTO STRING STR AT POSITION POS.
C       IF POSITION IS PAST THE END OF THE STRING, PAD WITH BLANKS BEFORE
C       INSERTING CHARACTER.  IF POSITION IS NEGATIVE, APPEND THE
C       CHARACTER TO THE END OF THE STRING.
C
        INTEGER P,I,J,L
C
        L=STR(1)
        P=POS
        IF (P) 10,20,30
10      P=L
20      P=P+1
30      IF (P-L-1) 100,200,300
C
C INSERT AT MID-STRING
C
100     DO 120 I=P,L
        J=1+L+P-I
120     STR(J+1)=STR(J)
200     STR(P+1)=CHR
C
C INSERT AT END OF STRING
C
        STR(1)=L+1
        RETURN
C
C INSERT AFTER END OF STRING
C
300     J=P-2
        DO 320 I=L,J
320     STR(I+2)=8224
        STR(P+1)=CHR
        STR(1)=P
        RETURN
        END
C+++ SRCCS
C****** SRCCS = SEARCH A STRING FOR A CHARACTER = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION SRCCS(STR,POS,CHR)
        INTEGER STR(9999),POS,CHR
C
C       HAS THE VALUE OF THE INDEX OF THE FIRST OCCURANCE OF CHARACTER
C       'CHR' IN STRING 'STR'.  THE FUNCTION VALUE IS 0 IF THE
C       CHARACTER DOES NOT APPEAR AND THE SEARCH BEGINS AT POSITION POS.
C
        INTEGER I,J,K,L,P
C
        L=STR(1)
        IF (L.LE.0.OR.POS.GT.L) GO TO 300
        P=POS
        IF (P .LE. 0) P=1
        DO 200 J=P,L
        IF (STR(J+1).EQ.CHR) GO TO 100
200     CONTINUE
300     SRCCS=0
        RETURN
100     SRCCS=J
        RETURN
        END
C+++ EXTSS
C****** EXTSS = EXTRACT A STRING FROM A STRING = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION EXTSS(STR,POS,SUB,MAXLEN)
        INTEGER STR(9999),POS,SUB(9999),MAXLEN
C
C       HAS THE VALUE OF THE CHARACTER AT POSITION POS OF STRING STR.
C       THE SUBSTRING 'SUB' IS OF MAXIMUM LENGTH 'MAXLEN' AND IS NULL
C       (OF LENGTH 0) IF POSITION IS PAST THE END OF STRING.
C       IF THE POSITION IS PAST THE END OF STRING, A 0 IS RETURNED.
C
        INTEGER CHR,P,L,LEN,I,J
C
        L=STR(1)
        P=POS
        IF (P.LE.0) P=1
        IF (P.GT.L.OR.MAXLEN.EQ.0)GO TO 90
        LEN=MAXLEN
        CHR=STR(P+1)
        IF (LEN.LT.0.OR.P+LEN.GT.L) LEN=L-P+1
        DO 50 I=1,LEN
        J=P+I
50      SUB(I+1)=STR(J)
        SUB(1)=LEN
        GO TO 100
90      CHR=0
        SUB(1)=0
100     EXTSS=CHR
        RETURN
        END
C+++ INSSS
C****** INSSS = INSERT A STRING INTO A STRING = REL.  1.00 , 09/01/79
C
        SUBROUTINE INSSS(STR,POS,SUB,MAXLEN)
        INTEGER STR(9999),POS,SUB(9999),MAXLEN
C
C       INSERT STRING 'SUB' INTO STRING STR AT POSITION POS.
C       IF POSITION IS PAST THE END OF THE STRING, PAD WITH BLANKS BEFORE
C       INSERTING STRING SUB.  IF MAXLEN IS NEGATIVE, INSERT ALL OF SUB,
C       OTHERWISE INSERT UP TO MAXLEN CHARACTERS.
C       IF POSITION IS NEGATIVE, APPEND SUB AT THE END OF STRING.
C
        INTEGER P,L,LEN,I,J,K,M
C
        L=STR(1)
        LEN=MAXLEN
        IF (LEN.LT.0.OR.LEN.GT.SUB(1)) LEN=SUB(1)
        IF (LEN.EQ.0) RETURN
        P=POS
        IF (P) 10,20,30
10      P=L
20      P=P+1
30      IF (P-(L+1)) 100,200,310
C
C INSERT IN MID-STRING
C
100     M=1+L+P
        DO 120 I=P,L
        J=M-I
        K=J+LEN
120     STR(K)=STR(J)
200     STR(1)=L+LEN
300     DO 210 K=1,LEN
C
C INSERT AT END OF STRING
C
        M=P+K
210     STR(M)=SUB(K+1)
        RETURN
C
C INSERT AFTER END OF STRING
C
310     DO 320 I=L,P
320     STR(I+2)=8224
        STR(1)=P+LEN-1
        GO TO 300
        END
C+++ SRCSS
C****** SRCSS = SEARCH A STRING FOR A STRING = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION SRCSS(STR,POS,SUB,MAXLEN)
        INTEGER STR(9999),POS,SUB(9999),MAXLEN
C
C       HAS THE VALUE OF THE INDEX OF THE FIRST OCCURANCE OF STRING
C       'SUB' IN STRING 'STR' OR 0 IF 'SUB' DOES NOT OCCUR.
C       'MAXLEN' IS THE NUMBER OF CHARACTER OF 'SUB' THAT MUST MATCH.
C       IF 'MAXLEN' IS NEGATIVE ALL CHARACTERS MUST MATCH.
C       'POS' SPECIFIES WHERE THE SEARCH WILL BEGIN.
C
        INTEGER LEN,I,J,K,L,M,N,P
C
        L=STR(1)
        LEN=MAXLEN
        IF (LEN.LT.0.OR.LEN.GT.SUB(1)) LEN=SUB(1)
        IF (LEN.EQ.0.OR.L.LE.0) GO TO 400
        P=POS
        IF (P .LE. 0) P=1
        IF (P .GT. L) GOTO 400
        DO 200 J=P,L
        DO 150 M=1,LEN
        N=J+M
        IF (STR(N).NE.SUB(M+1)) GO TO 200
150     CONTINUE
        SRCSS=J
        RETURN
200     CONTINUE
400     SRCSS=0
        RETURN
        END
C+++ LENS
C****** LENS = RETURN THE LENGTH OF A STRING = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION LENS(STR)
        INTEGER STR(9999)
C
C       HAS THE VALUE OF THE LENGTH (CHARACTER COUNT) OF STRING 'STR'
C
        LENS=STR(1)
        RETURN
        END
C+++ CMPSS
C****** CMPSS = COMPARE TWO STRINGS = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION CMPSS(S1,S2,MAXLEN)
        INTEGER S1(9999),S2(9999),MAXLEN
C
C       COMPARE STRING 'S1' TO 'S2'.  IF THE STRINGS ARE
C       NOT OF EQUAL LENGTH, PAD THE SHORTER ONE WITH BLANKS FOR
C       COMPARISON PURPOSES.  COMPARE ONLY THE FIRST 'MAXLEN' CHARACTERS.
C       COMPARE THE ENTIRETY IF MAXLEN IS NEGATIVE.
C       RETURN:
C          -1 IF S1 .LT. S2
C           0 IF S1 .EQ. S2
C          +1 IF S1 .GT. S2
C
        INTEGER L1,L2,LEN,MN,I,MX
C
        L1=S1(1)
        L2=S2(1)
        LEN=MAXLEN
        IF (MAXLEN.LT.0) LEN=9999
        MN=MIN0(L1,L2,LEN)
        IF (MN.EQ.0) GO TO 100
        DO 50 I=1,MN
        IF (S1(I+1)-S2(I+1)) 1000,50,3000
50      CONTINUE
100     MX=MIN0(MAX0(L1,L2),LEN)
        IF (MN.EQ.MX) GO TO 2000
        MN=MN+1
        IF (L1.GT.L2) GO TO 200
        DO 150 I=MN,MX
        IF (S2(I+1).NE.8224) GO TO 1000
150     CONTINUE
        GO TO 2000
200     DO 250 I=MN,MX
        IF (S1(I+1).NE.8224) GO TO 3000
250     CONTINUE
2000    CMPSS=0
        RETURN
1000    CMPSS=-1
        RETURN
3000    CMPSS=1
        RETURN
        END
C+++ RPLCS
C****** RPLCS = REPLACE A CHARACTER IN A STRING = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION RPLCS (STR,POS,CHR)
        INTEGER STR(9999),POS,CHR
C
C       THE CHARACTER AT POSITION 'POS' INS STRING 'STR'
C       IS REPLACED BY THE CHARACTER 'CHR'.  THE FUNCTION
C       RETURNS THE OLD CHARACTER OR -1 IF 'POS' DID NOT
C       EXIST WITHIN 'STR'.  IF 'POS' IS PAST THE END OF 'STR',
C       'STR' IS PADDED WITH BLANKS UP TO 'POS' AND THEN 'CHR'
C       IS INSERTED.
C
        INTEGER SW,P,I,J
C
        P=POS
        IF (P .EQ. 0) P=1
        SW=STR(1)
        IF (P .LT. 0) P=SW+1
        IF (P .LE. SW) GOTO 100
        J=SW+1
        DO 50 I=J,P
50      STR(I+1)=8224
        STR(P+1)=CHR
        STR(1)=P
        RPLCS=-1
        RETURN
100     RPLCS=STR(P+1)
        STR(P+1)=CHR
        RETURN
        END
C+++ FTOA
C****** FTOA = FORTRAN TO AP-120B FLOATING POINT = REL.  1.00 , 09/01/79
C
C============== AP-120B FORMAT CONVERSION ==================================
C
C
        SUBROUTINE FTOA(A,IREG)
        DOUBLE PRECISION A
        INTEGER IREG(3)
C
C       CONVERTS FROM A FORTRAN DOUBLE PRECISION FLOATING POINT VALUE
C       TO AN AP-120B 38-BIT FLOATING POINT WORD.
C
C       PARAMETERS:
C       A       - INPUT DOUBLE PRECISION FLOATING POINT VALUE
C       IREG    - OUTPUT AP-120B 38 BIT WORD, RIGHT JUSTIFIED IN 3 INTEGERS:
C                 IREG(1) - EXPONENT PART
C                 IREG(2) - HIGH MANTISSA PART (BITS 0-11)
C                 IREG(3) - LOW MANTISSA PART (BITS 12-27)
C
C       ROUTINES USED: IPFIX, PFLOAT, IADDC, IADD16, INOT16, IAND16
C
C-------LOCAL
C
        DOUBLE PRECISION AA
        INTEGER HMAN,LMAN,IEXP,J,ISG,IC
        AA=A
C
C       IF ZERO, MAKE A CLEAN ZERO AND RETURN
        IF (AA.NE.0.0D0) GO TO 100
        DO 10 J=1,3
10      IREG(J)=0
        RETURN
C
C       MAKE POSITIVE AND REMEMBER SIGN
100     ISG=0
        IF (AA.LT.0.0D0) ISG=1
        AA=DABS(AA)
C
C       WE'RE GOING TO MULTIPLY BY POWERS OF TWO UNTIL OUT INPUT
C               VALUE IS BETWEEN 0.5 AND 0.9999999999
C
        IEXP=512
200     IF (AA.GE.1.0D0) GO TO 400
300     IF (AA.GE.0.5D0) GO TO 500
C
C       WE MUST MAKE THINGS LARGER
        AA=AA*2.0D0
        IEXP=IEXP-1
        GO TO 300
C
C       WE MUST MAKE THINGS SMALLER
400     AA=AA/2.0D0
        IEXP=IEXP+1
        GO TO 200
C
C
C       NOW GET THE HIGH 12 BITS, THE LOW 16 BITS, AND 16 MORE BITS
C          FOR ROUNDING
C
C       DO THIS BY SUCESSIVELY MULTIPLYING TO GET THESE BITS
C           INTO THE INTEGER PORTION OF OUR FLOATING POINT NUMBER
500     AA=AA*2048.0D0
        HMAN=IDINT(AA)
        AA=(AA-DBLE(FLOAT(HMAN)))*65536.0D0
        LMAN=IPFIX(SNGL(AA))
        AA=(AA-DBLE(PFLOAT(LMAN)))*65536.0D0
C
C       ROUND UP IN MAGNITUDE IF REMAINDER IS .GT. 0.5
C           I.E., IF ROUND IS .GT. 32768.0
        IF (AA.LE.32768.0D0) GO TO 600
        LMAN=IADDC(LMAN,1,IC)
        HMAN=IADD16(HMAN,IC)
C
C       WORRY ABOUT OVERFLOW INTO SIGN BIT FROM ROUNDING CARRY
C         I.E. HMAN=2048 (AND LMAN=0)
        IF (HMAN.NE.2048) GO TO 600
        HMAN=1024
        IEXP=IEXP+1
C
C       NOW NEGATE MANTISSA IF SIGN OF FLOATING POINT
C        NUMBER WAS NEGATIVE
600     IF (ISG.NE.1) GO TO 700
C
C       TURN A FRACTION OF 0.5 INTO -1.0 AND DECREMENT EXPONENT
        IF (.NOT.(HMAN.EQ.1024.AND.LMAN.EQ.0)) GO TO 670
        HMAN=2048
        IEXP=IEXP-1
        GO TO 700
C
C       TWO'S COMPLEMENT MANTISSA
670     LMAN=IADDC(INOT16(LMAN),1,IC)
        HMAN=IAND16(IADD16(INOT16(HMAN),IC),4095)
C
C       PUT THE RESULT INTO IREG
700     IREG(1)=IAND16(IEXP,1023)
        IREG(2)=HMAN
        IREG(3)=LMAN
        RETURN
        END
C+++ ATOF
C****** ATOF = AP-120B TO FORTRAN FLOATING POINT = REL.  1.00 , 09/01/79
C
        DOUBLE PRECISION FUNCTION ATOF(IREG,IERR)
        INTEGER IREG(3),IERR
C
C       CONVERTS FROM A 38-BIT AP-120B FLOATING POINT WORD TO A FORTRAN
C       DOUBLE PRECISION FLOATING POINT VALUE.
C
C       PARAMETERS:
C       IREG    - INPUT AP-120B 38-BIT WORD, RIGHT JUSTIFIED IN 3 INTEGERS:
C                   IREG(1) - EXPONENT PART
C                   IREG(2) - HIGH MANTISSA (BITS 0-11)
C                   IREG(3) - LOW MANTISSA (BITS 12-27)
C       IERR     - ERROR FLAG, 0 IF INPUT WAS OK, 1 IF WAS TOO BIG TO
C                    EXPRESS IN THE HOST FLOATING POINT FORMAT.
C       ATOF     - RETURNS A DOUBLE PRECISION FLOATING POINT NUMBER, OR
C                    A SIGNED MAXIMUM OR MINIMUM ON OVERFLOW OR UNDERFLOW
C
C
C       ROUTINES USED: IADDC, INOT16, IAND16, PFLOAT, IADD16
C
C-------LOCAL STORAGE
C
        INTEGER HMAN,LMAN,IEXP,ISG,IC
C
C    DEFINED CONSTANTS
        INTEGER MAXEX
C
C----------------------------------------------------------------------------
C
C       'MAXEX' IS THE MAXIMUM POWER OF 2 LEGAL IN THE EXPONENT OF THE HOST
C       FLOATING POINT FORMAT.  IT IS SET HERE TO THE MINIMUM SAFE UNIVERSAL
C       VALUE.  THIS OS FOR FORMATS WITH AN 8 BIT EXPONENT, WHICH IS A
C       MAXIMUM EXPONENT VALUE OF 127.  IT MAY BE INCREASED FOR HOST FORMATS
C       WITH A LARGER RANGE.
C
        DATA MAXEX / 127 /
C
C---------------------------------------------------------------------------
C
C
        IEXP=IREG(1)-512
        ISG=0
        HMAN=IREG(2)
        LMAN=IREG(3)
        ATOF=0.0D0
C
C       SEE IF NEGATIVE, IF SO, 2'S COMPLEMENT MANTISSA
        IF (HMAN.LT.2048) GO TO 100
        ISG=1
C
C       FIRST WORRY ABOUT -(-1.0) WHICH WILL OVERFLOW
        IF (.NOT.(HMAN.EQ.2048.AND.LMAN.EQ.0)) GO TO 70
        HMAN=1024
        LMAN=0
        IEXP=IEXP+1
        GO TO 100
C
70      LMAN=IADDC(INOT16(LMAN),1,IC)
        HMAN=IAND16(IADD16(INOT16(HMAN),IC),4095)
C
C    COMPUTE THE FRACTION VALUE
100     ATOF=DBLE(PFLOAT(LMAN))/134217728.0D0+
     1       DBLE(FLOAT(HMAN))/2048.0D0
C    IF MANTISSA IS ZERO, DON'T CHECK EXPONENT
        IF (ATOF.EQ.0.0D0) GO TO 200
C    SEE IF EXPONENT IS TOO BIG
        IF (IABS(IEXP)-MAXEX) 170,150,300
C
C    ON BOARDERLINE, I.E. CAN'T DO 2**IEXP, SO DECREMENT IEXP AND
C       DOUBLE FRACTION
150     IEXP=IEXP-1
        ATOF=ATOF*2.0D0
C
C    FACTOR IN EXPONENT
170     ATOF=ATOF*2.0D0**IEXP
        IERR=0
C    NEGATE MANTISSA
200     IF (ISG.EQ.1) ATOF=-ATOF
        RETURN
C
C    EXPONENT OVERFLOW OR UNDERFLOW
300     ATOF=1.999D0 * 2.0D0**ISIGN(MAXEX-1,IEXP)
        IERR=1
        GO TO 200
        END
C+++ SPLIT
C****** SPLIT = SPLIT UP AN AP-120B PROGRAM WORD = REL.  1.00 , 09/01/79
C
        SUBROUTINE SPLIT(IREG,FV)
        INTEGER IREG(4),FV(26)
C
C       SPLITS A 64-BIT PROGRAM WORD INTO THE 24 OP-CODE FIELDS AS DEFINED
C       BY THE PROCESSOR HANDBOOK.
C
C       PARAMETERS:
C       IREG    - INPUT 64-BIT PROGRAM WORD, THE 4 16-BIT QUARTERS RIGHT
C                 JUSTIFIED IN THE 4 ELEMENTS OF IREG.
C       FV      - OUTPUT INTEGER OP-CODE FIELD VALUES:
C                   FV(1-24) - THE OP-CODE VALUES
C                   FV(25) - THE VALUE FIELD
C                   FV(26) - VALUE FIELD FLAG: 1 IF VALUE FIELD USED BY
C                            THE INSTRUCTION, ELSE 0
C
C       ROUTINES USED: IAND16, IRSH16, ILSH16, IOR16
C
        FV(1)=IAND16(IRSH16(IREG(1),15),1)
        FV(2)=IAND16(IRSH16(IREG(1),12),7)
        FV(3)=IAND16(IRSH16(IREG(1),10),3)
        FV(4)=IAND16(IRSH16(IREG(1),6),15)
        FV(5)=IAND16(IRSH16(IREG(1),2),15)
        FV(6)=IOR16(ILSH16(IAND16(IREG(1),3),1),
     1              IAND16(IRSH16(IREG(2),15),1))
        FV(7)=IAND16(IRSH16(IREG(2),12),7)
        FV(8)=IAND16(IRSH16(IREG(2),9),7)
        FV(9)=IAND16(IRSH16(IREG(2),5),15)
        FV(10)=IAND16(IREG(2),31)
        FV(11)=IAND16(IRSH16(IREG(3),14),3)
        FV(12)=IAND16(IRSH16(IREG(3),12),3)
        FV(13)=IAND16(IRSH16(IREG(3),9),7)
        FV(14)=IAND16(IRSH16(IREG(3),6),7)
        FV(15)=IAND16(IRSH16(IREG(3),3),7)
        FV(16)=IAND16(IREG(3),7)
        FV(17)=IAND16(IRSH16(IREG(4),13),7)
        FV(18)=IAND16(IRSH16(IREG(4),12),1)
        FV(19)=IAND16(IRSH16(IREG(4),10),3)
        FV(20)=IAND16(IRSH16(IREG(4),8),3)
        FV(21)=IAND16(IRSH16(IREG(4),6),3)
        FV(22)=IAND16(IRSH16(IREG(4),4),3)
        FV(23)=IAND16(IRSH16(IREG(4),2),3)
        FV(24)=IAND16(IREG(4),3)
C       THE VALUE FIELD
        FV(25)=IREG(4)
C       SET VALUE FIELD FLAG
        FV(26)=0
C       VALUE IS USED IF SOP=1 AND SPSF IS BETWEEN 8 AND 12 AND
C         THE LOW 2 BITS OF SPDF ARE BETWEEN 0 AND 3
C         OR   DPBSF=2:
        IF ((FV(2).EQ.1.AND.FV(4).GE.8.AND.FV(4).LE.12.AND.
     1    MOD(FV(5),8).LE.3).OR.FV(13).EQ.2) FV(26)=1
        RETURN
        END
C+++ INCODE
C****** INCODE = MODIFY AN AP-120B PROGRAM WORD = REL.  1.00 , 09/01/79
C
        SUBROUTINE INCODE(IA,IFNUM,IREG)
        INTEGER IA,IFNUM,IREG(4)
C
C       REPLACE AN OP-CODE FIELD OF A PROGRAM WORD
C
C       PARAMETERS:
C       IA      - NEW VALUE OF THE OP-CODE FIELD IN QUESTION
C       IFNUM   - NUMBER OF THE OP-CODE FIELD TO BE ALTERED, NUMBERED
C                 AS FOR 'SPLIT'
C       IREG    - PROGRAM WORD TO BE ALTERED, THE FOUR 16-BIT QUARTERS RIGHT
C                 JUSTIFIED IN THE FOUR ELEMENTS OF 'IREG'.
C
C       ROUTINES USED: IOR16, IAND16, ILSH16, IRSH16, NAND16
C
C       GO CHANGE THE PROPER FIELD
        GO TO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
     119,20,21,22,23,24,4,4,5,5,5,5,5,5,5,
     27,7,8,8,8,8,8,8), IFNUM
C
C       B FIELD
1       IREG(1)=IOR16(IAND16(IREG(1),32767),ILSH16(IAND16(IA,1),15))
        GO TO 100
C       SOP FIELD
2       IREG(1)=IOR16(NAND16(IREG(1),28672),ILSH16(IAND16(IA,7),12))
        GO TO 100
C       SH FIELD
3       IREG(1)=IOR16(NAND16(IREG(1),3072),ILSH16(IAND16(IA,3),10))
        GO TO 100
C       SPS FIELD
4       IREG(1)=IOR16(NAND16(IREG(1),960),ILSH16(IAND16(IA,15),6))
        GO TO 100
C       SPD FIELD
5       IREG(1)=IOR16(NAND16(IREG(1),60),ILSH16(IAND16(IA,15),2))
        GO TO 100
C       FADD FIELD
6       IREG(1)=IOR16(NAND16(IREG(1),3),IRSH16(IA,1))
        IREG(2)=IOR16(IAND16(IREG(2),32767),ILSH16(IAND16(IA,1),15))
        GO TO 100
C       A1 FIELD
7       IREG(2)=IOR16(NAND16(IREG(2),28672),ILSH16(IAND16(IA,7),12))
        GO TO 100
C       A2 FIELD
8       IREG(2)=IOR16(NAND16(IREG(2),3584),ILSH16(IAND16(IA,7),9))
        GO TO 100
C       COND FIELD
9       IREG(2)=IOR16(NAND16(IREG(2),480),ILSH16(IAND16(IA,15),5))
        GO TO 100
C       DISP FIELD
10      IREG(2)=IOR16(NAND16(IREG(2),31),IAND16(IA,31))
        GO TO 100
C       DPX FIELD
11      IREG(3)=IOR16(IAND16(IREG(3),16383),ILSH16(IAND16(IA,3),14))
        GO TO 100
C       DPY FIELD
12      IREG(3)=IOR16(NAND16(IREG(3),12288),ILSH16(IAND16(IA,3),12))
        GO TO 100
C       DPBS FIELD
13      IREG(3)=IOR16(NAND16(IREG(3),3584),ILSH16(IAND16(IA,7),9))
        GO TO 100
C       XR FIELD
14      IREG(3)=IOR16(NAND16(IREG(3),448),ILSH16(IAND16(IA,7),6))
        GO TO 100
C       YR FIELD
15      IREG(3)=IOR16(NAND16(IREG(3),56),ILSH16(IAND16(IA,7),3))
        GO TO 100
C       XW FIELD
16      IREG(3)=IOR16(NAND16(IREG(3),7),IAND16(IA,7))
        GO TO 100
C       YW FIELD
17      IREG(4)=IOR16(IAND16(IREG(4),8191),ILSH16(IAND16(IA,7),13))
        GO TO 100
C       FM FIELD
18      IREG(4)=IOR16(NAND16(IREG(4),4096),ILSH16(IAND16(IA,1),12))
        GO TO 100
C       M1 FIELD
19      IREG(4)=IOR16(NAND16(IREG(4),3072),ILSH16(IAND16(IA,3),10))
        GO TO 100
C       M2 FIELD
20      IREG(4)=IOR16(NAND16(IREG(4),768),ILSH16(IAND16(IA,3),8))
        GO TO 100
C       MI FIELD
21      IREG(4)=IOR16(NAND16(IREG(4),192),ILSH16(IAND16(IA,3),6))
        GO TO 100
C       MA FIELD
22      IREG(4)=IOR16(NAND16(IREG(4),48),ILSH16(IAND16(IA,3),4))
        GO TO 100
C       DPA FIELD
23      IREG(4)=IOR16(NAND16(IREG(4),12),ILSH16(IAND16(IA,3),2))
        GO TO 100
C       TMA FIELD
24      IREG(4)=IOR16(NAND16(IREG(4),3),IAND16(IA,3))
100     RETURN
        END
C+++ PFLOAT
C****** PFLOAT = POSITIVE 16-BIT FLOAT = REL.  1.00 , 09/01/79
C
C============== 16 - BIT INTEGER OPERATIONS =================================
C
C
        REAL FUNCTION PFLOAT(IA)
        INTEGER IA
C
C       RESULT IS THE LOW 16-BITS OF 'IA', TREATED AS AN UNSIGNED
C       FLOATING POINT NUMBER, FLOATED INTO A POSITIVE SINGLE
C       PRECISION FLOATING POINT VALUE.
C
C       ROUTINES USED: INT16
C
C-------NOTE: THIS CODE WILL NOT WORK FOR A 16-BIT 1'S COMPLEMENT CPU:
C
C       THE TWO OTHER CASES ARE:
C       1. 16-BIT 2'S COMPLEMENT:
C           ADD 65536 TO NEGATIVE INTEGERS AFTER FLOATING.
C       2. >16-BITS:
C           UPPER BITS ARE ALWAYS OFF, THEREFORE INTEGER IS ALWAYS
C           POSITIVE.
C
        INTEGER IAA
        IAA=INT16(IA)
        IF (IAA.EQ.-32767-1) GO TO 100
        PFLOAT=FLOAT(IAA)
        IF (IAA.LT.0) PFLOAT=PFLOAT+65536.0
        RETURN
100     PFLOAT=32768.0
        RETURN
        END
C+++ IPFIX
C****** IPFIX = 16-BIT FIX = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION IPFIX(A)
        REAL A
C
C       16-BIT FIX.  TRUNCATE THE ABSOLUTE VALUE OF 'A' TO THE RANGE
C       0.0 TO 65536.0.  IF 'A' IS NEGATIVE, ADD 65536.0 TO IT. THEN
C       FIX THE RESULT INTO AN INTEGER LEGAL FOR THE HOST COMPUTER.
C
        REAL AA
C
C       ROUTINES USED: IP16
C
C-------NOTE: THE CODE WILL NOT WORK FOR A 16-BIT 1'S COMPLEMENT CPU.
C
C       METHOD:
C
C       1. TAKE THE INTEGER PART OF THE NUMBER AND RESTRICT THE RANGE OF THE
C          ABSOLUTE VALUE TO 0.0 - 65536.0
C       2. IF THE NUMBER WAS NEGATIVE, ADD 65536.0 TO IT
C       3. IF A>=32768.0, FIX (65536.0-A).  THIS KEEPS THE INTEGER RESULT
C            IN THE PROPER RANGE FOR A 16-BIT 2'S COMPLEMENT CPU.
C       4. USE 'IP16' ON THE RESULT.  THIS WILL MAKE THE RESULT PROPERLY
C            POSITIVE ON >16 BIT CPU'S.
C
C       RESTRICT THE RANGE OF A TO 0.0 TO 65536.0
C
        AA=AINT(ABS(A))
        IF (AA.GT.65536.0) AA=AMOD(AA,65536.0)
        IF (A.LT.0.0) AA=65536.0-AA
C
C       NOW FIX THE RESULT INTO A 16-BIT SIGNED INTEGER FOR 16-BIT MACHINES,
C       OR A POSITIVE 16-BIT INTEGER FOR LARGER MACHINES
C
        IF (AA-32768.0) 100,200,300
C
C       LESS THAN OR EQUAL TO 32767.0
100     IPFIX=INT(AA)
        RETURN
C
C       EQUAL TO 32768.0
200     IPFIX=IP16(-32767-1)
        RETURN
C
C       GREATER THAN 32768.0
300     IPFIX=IP16(INT(AA-65536.0))
        RETURN
        END
C+++ IDRS
C****** IDRS = DOUBLE WORD RIGHT SHIFT = REL.  1.00 , 09/01/79
C
        SUBROUTINE IDRS(IA,IB,N)
        INTEGER IA,IB,N
C
C       TREATING THE LOW 16-BITS OF 'IA' AND 'IB' AS A CONCATENATED
C       32-BIT REGISTER, RIGHT SHIFT BY 'N' PLACES, ZERO FILLING.
C       ANY UPPER BITS OF 'IA' AND 'IB' ARE CLEARED.
C
C       PARAMETERS:
C       IA      - UPPER WORD
C       IB      - LOWER WORD
C       N       - SHIFT COUNT
C
C       ROUTINES USED: IRSH16, ILSH16, IOR16
C
        IF(N.LE.0) RETURN
        IF(N.GE.16) GO TO 10
C       1-15 PLACES RIGHT
        IB=IOR16(IRSH16(IB,N),ILSH16(IA,16-N))
        IA=IRSH16(IA,N)
        RETURN
C       16 OR MORE PLACES RIGHT
10      IB=IRSH16(IA,N-16)
        IA=0
        RETURN
        END
C+++ IDLS
C****** IDLS = DOUBLE WORD LEFT SHIFT = REL.  1.00 , 09/01/79
C
        SUBROUTINE IDLS(IA,IB,N)
        INTEGER IA,IB,N
C
C       TREATING THE LOW 16-BITS OF 'IA' AND 'IB' AS A CONCATENATED
C       32-BIT REGISTER, LEFT SHIFT BY 'N' PLACES, ZERO FILLING.
C       ANY UPPER BITS OF 'IA' AND 'IB' ARE CLEARED.
C
C       PARAMETERS:
C       IA      - UPPER WORD
C       IB      - LOWER WORD
C       N       - SHIFT COUNT
C
C       ROUTINES USED: IRSH16, ILSH16, IOR16
C
        IF(N.LE.0) RETURN
        IF(N.GE.16) GO TO 10
C       1-15 PLACES LEFT
        IA=IOR16(ILSH16(IA,N),IRSH16(IB,16-N))
        IB=ILSH16(IB,N)
        RETURN
C       16 OR MORE PLACES LEFT
10      IA=ILSH16(IB,N-16)
        IB=0
        RETURN
        END
C+++ ISWAP
C****** ISWAP = SWAP LOW BYTES = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION ISWAP(IA)
        INTEGER IA
C
C       RESULT IS THE TWO LOW 8-BIT BYTES OF 'IA' SWAPPED.  ANY UPPER
C       BITS OF THE RESULT ARE CLEARED.
C
C       ROUTINES USED: IRSH16, ILSH16, IOR16
C
        ISWAP=IOR16(IRSH16(IA,8),ILSH16(IA,8))
        RETURN
        END
C+++ NAND16
C****** NAND16 = 16-BIT NOT AND = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION NAND16(IA,IB)
        INTEGER IA,IB
C
C       RESULT IS THE LOWER 16-BITS OF 'IA' ANDED WITH THE LOGICAL
C       COMPLENENT OF THE LOWER 16-BITS OF 'IB'.  ANY UPPER BITS OF
C       THE RESULT ARE CLEARED.
C
C       ROUTINES USED: IAND16, INOT16
C
        NAND16=IAND16(IA,INOT16(IB))
        RETURN
        END
C+++ ICMP16
C****** ICMP16 = 16-BIT UNSIGNED COMPARE = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION ICMP16(IA,IB)
        INTEGER IA,IB
C
C       DOES AN UNSIGNED COMPARE OF 'IA' AND 'IB'
C       RETURNS:
C       1   IF  IA > IB
C       0   IF  IA = IB
C      -1   IF  IA < IB
C
C       ROUTINES USED: ISUB16, NEGCHK
C
C       LOCAL STORAGE:
        INTEGER IC,ICC
C
        IC=IADDC(IA,INEG16(IB),ICC)
        IF (IC.EQ.0) GO TO 200
        IF (ICC.EQ.0.AND.IB.NE.0) GO TO 300
C
C       IA > IB, RETURN 1
        ICMP16=1
        RETURN
C
C       IA = IB, RETURN 0
200     ICMP16=0
        RETURN
C
C       IA < IB, RETURN -1
300     ICMP16=-1
        RETURN
        END
C+++ ISUB16
C****** ISUB16 = 16-BIT SUBTRACT = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION ISUB16(IA,IB)
        INTEGER IA,IB
C
C       RESULT IS THE LOW 16-BITS OF  IA - IB, I.E. A 2'S COMPLEMENT SUBTRACT
C       OF THE LOW 16-BITS OF 'IB' FROM 'IA'
C
C       ROUTINES USED: IADD16, INEG16
C
        ISUB16=IADD16(IA,INEG16(IB))
        RETURN
        END
C+++ INEG16
C****** INEG16 = 16-BIT NEGATE = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION INEG16(IA)
        INTEGER IA
C
C       RESULT IS THE LOW 16-BITS OF THE 2'S COMPLEMENT NEGATION OF THE LOW
C       16-BITS OF 'IA'
C
C       ROUTINES USED: IADD16,INOT16
C
C       COMPLEMENT AND ADD 1
        INEG16=IADD16(INOT16(IA),1)
        RETURN
        END
C+++ IADDC
C****** IADDC = 16-BIT ADD WITH CARRY OUT = REL.  1.00 , 09/01/79
C
        FUNCTION IADDC(IA,IB,ICARRY)
        INTEGER IA,IB,ICARRY
C
C       RESULT IS THE LOW 16-BITS OF THE SUM OF THE LOW 16-BITS OF 'IA'
C       WITH THE LOW 16-BITS OF 'IB'.  'ICARRY' GETS ANY CARRY OUT OF
C       16-BITS.
C
C       ROUTINES USED: IADD16, NEGCHK
C
C       LOGIC TABLE FOR CARRY:
C
C       A & B HAVE SAME SIGNS:       CARRY IS SIGN OF ARGUEMENTS
C       A & B HAVE DIFFERENT SIGNS:  CARRY IS OPPOSITE SIGN OF ANSWER
C
        IADDC=IADD16(IA,IB)
        IF (NEGCHK(IA).NE.NEGCHK(IB)) GO TO 100
C
C       SIGNS THE SAME
        ICARRY=NEGCHK(IA)
        RETURN
C
C       SIGNS DIFFERENT
100     ICARRY=IAND16(INOT16(NEGCHK(IADDC)),1)
        RETURN
        END
C+++ NEGCHK
C****** NEGCHK = 16-BIT NEGATIVE CHECK = REL.  1.00 , 09/01/79
C
        INTEGER FUNCTION NEGCHK(IA)
        INTEGER IA
C
C       RESULT IS THE HIGH BIT OF THE LOW ORDER 16 BITS OF 'IA', WHICH
C       IS THE SIGN BIT OF 'IA', TREATING 'IA' AS A 16-BIT QUANTITY.
C
C       ROUTINES USED: IRSH16
C
        NEGCHK=IRSH16(IA,15)
        RETURN
        END
 