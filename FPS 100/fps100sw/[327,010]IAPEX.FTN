C****** IAPEX = HOST INDEPENDENT APEX (PDP-11 RT11) = REL B.1  , NOV 79 *******
C
C               THIS FILE IS:
C                  FPS100>PDP11>OPSYS>APX100.01>IAPEX.ALL
C
C               CHANGED           12-NOV-79     BY   J. RAMUS
C
C           LIST OF ROUTINES   (ARRANGED IN THIS ORDER)
C
C     MTSGO    STARTUP MTS SUPERVISOR
C     RTSGO    STARTUP RTS SUPERVISOR
C     APINIT   ASSIGN AP, INITIALIZE APEX, CLEAR MD
C     APCLR    SAME AS APXSET
C     APXSET   INITIALIZE APEX AND RESET THE AP
C     CLRMD    CLEAR MD (AND POSSIBLE PARITY BITS)
C     APXCLR   CLEAR APEX TABLES
C     LOADBT   LOAD THE BOOTSTRAP INTO 'PS'
C     APEX     P.S EXECUTIVE
C     APOVLD   HOST APOVLD CALL
C     LOADPS   LOAD PROGRAMS INTO 'PS'
C     APWAIT   WAIT FOR BOTH DMA AND RUNNING
C     APWD     WAIT FOR DMA AND ERROR CHECK
C     APWR     WAIT FOR RUNNING AND ERROR CHECK
C     SETBRK   SET APEX BREAKPOINT
C     CLRBRK   CLEAR APEX BREAKPOINT
C     APPUT    PUT DATA INTO 'MD'
C     APGET    GET DATA FROM 'MD'
C     APCHK    CHECK SOFTWARE ERROR STATUS
C     APSTAT   CHECK HARDWARE ERROR STATUS
C     APGSP    GET S-PAD VALUE
C     INMPGS   DETERMINE NUMBER OF PAGES OF MD
C     PAGESZ   SIZE A PAGE OF MD
C     SIZEMD   SIZE MAIN DATA MEMORY
C     SZSVPS   SIZE PS MEMORY & SAVE CONTENTS
C     SIZEPS   SIZE PROGRAM MEMORY
C     APEXAM   EXAMINE FPS-100 REGISTERS & MEMORIES
C     APDEP    DEPOSIT INTO FPS-100 REGISTERS & MEMORIES
C     PSFUNC   DO P.S. FUNCTIONS: SAVE, RESTORE, RUN
C     RREG     READ THROUGH THE AP-120B FRONT PANEL
C     WREG     WRITE THROUGH THE AP-120B FRONT PANEL
C     APPSEL   WRITE EXTENDED MEMORY SELECT REGISTERS  - DUMMY ROUTINE
C     APRSLT   READ EXTENDED MEMORY SELECT REGISTERS  - DUMMY ROUTINE
C     ISWR     INPUT FROM THE SWITCH REGISTER
C     OSWR     OUTPUT TO THE SWITCH REGISTER
C     IFN      INPUT FROM THE FUNCTION REGISTER
C     OFN      OUTPUT TO FUNCTION REGISTER
C     ILITES   INPUT FROM LITES REGISTER
C     OLITES   OUTPUT TO LITES REGISTER
C     IAPMA    INPUT FROM APMA
C     OAPMA    OUTPUT TO APMA
C     IHMA     INPUT FROM HMA
C     OHMA     OUTPUT TO HMA
C     IWC      INPUT WORD COUNT
C     OWC      OUTPUT TO WC
C     ICTRL    INPUT CONTROL REGISTER
C     OCTRL    OUTPUT TO CTRL
C     IFMTH    INPUT FROM FORMAT HIGH
C     OFMTH    OUTPUT TO FORMAT HIGH
C     IFMTL    INPUT FROM FORMAT LOW
C     OFMTL    OUTPUT TO FORMAT LOW
C     ORESET   DO AN INTERFACE RESET
C     IFSTAT   READ INTERFACE STATUS
C     IMASK    READ MASK,I/O,MODE REGISTER  - DUMMY ROUTINE
C     OMASK    WRITE MASK,I/O,MODE REGISTER  - DUMMY ROUTINE
C     IAPME    READ APMA EXTENSION  - DUMMY ROUTINE
C     OAPME    WRITE THE APMA EXTENSION  - DUMMY ROUTINE
C     IMAE     READ THE MA EXTENSION  - DUMMY ROUTINE
C     OMAE     WRITE THE MA EXTENSION REGISTER  - DUMMY ROUTINE
C     ABORT    SAME AS APRSET
C     HLITES   INPUT SAVED LITES VALUE
C
C****** MTSGO = STARTUP MTS SUPERVISOR   = REL B.1  , NOV 79 ******************
C
        SUBROUTINE MTSGO(PSSIZE,ID,CODE,CODSIZ)
        INTEGER PSSIZE,ID, CODSIZ, CODE(CODSIZ)
C
        INTEGER SUPER,START,BOOTST
        COMMON /SYSTEM/SUPER,START,BOOTST
C
        INTEGER DUMMY
C
C  PLACE BOOT LOADER IN HIGH PS
C
        START = PSSIZE-16
        CALL LOADBT
C
C   LOADBT SETS      BOOTST = PSSIZE-15
C          SET IAPEX TO SUPVERVISOR MODE
        SUPER = 1
C
C  LOAD IN LOAD MODULE
C
        CALL APLMLD(ID,CODE,CODSIZ)
C
C  START INITIALIZER
C
        CALL APRSET
        CALL RUNAP(PSSIZE-32,0,0,0)
C
C  CLEAR LITES REGISTER
C
        CALL APIN(DUMMY,3)
C
C  SET TO MTS-SUPER MODE
C
        CALL APSUPV(1)
C
        RETURN
        END
C
C****** RTSGO = STARTUP RTS SUPERVISOR   = REL B.1  , NOV 79 ******************
C
        SUBROUTINE RTSGO (PSSIZE)
        INTEGER PSSIZE
C
        INTEGER SUPER,START,BOOTST
        COMMON /SYSTEM/SUPER,START,BOOTST
C
        INTEGER DUMMY
C
C           THE LOAD MODULE IS NOT PLACED IN THE AP NOW.
C           THE NEXT HASI CALL DOES THAT.
C
C  PLACE BOOT LOADER IN HIGH PS
C
        START = PSSIZE-16
        CALL LOADBT
C
C   LOADBT SETS     BOOTST = PSSIZE-15
C           SET IAPEX TO SUPERVISOR MODE
        SUPER = -1
C
C  CLEAR LITES REGISTER
C    PUT 0 IN SWR
C    DEPOSIT 0 IN DPA
C    EXAM DPA TO GET 0 IN LITES
C
        CALL APOUT (0,1)
        CALL APOUT (520,2)
        CALL APOUT (1032,2)
        CALL APIN(DUMMY,3)
C
C  SET TO RTS-SUPER MODE
C
        CALL APSUPV(-1)
C
        RETURN
        END
C****** APINIT = ASSIGN AP, INITIALIZE APEX, CLEAR MD = REL B.1  , NOV 79 *****
C
        SUBROUTINE APINIT(APNUM,ACTION,STATUS)
        INTEGER APNUM,ACTION,STATUS
C
C       APINIT CALLS APASGN TO ASSIGN AN AP,
C              CALLS APXSET TO SET UP APEX,
C        AND CALLS CLRMD TO CLEAR MD FOR THE PURPOSES OF CLEARING ALL THE
C               POSSIBLE PARITY BITS
C           CALLS APOVIN TO LOAD THE OVERLAY HANDLER
C
C
C       UPON ENTRY:   APNUM = 0  (ATTACH ANY AVAILABLE AP)
C                             N  (ATTACH AP 'N')
C
C                     ACTION = 0  (WAIT FOR AP, IF BUSY)
C                              1  (RETURN STATUS IMMEDIATELY, DONT WAIT)
C
C       UPON EXIT     STATUS = -3  (A DIFFERENT AP IS ALREADY ATTACHED)
C                                   MULTIPLE ASSIGNS TO THE SAME AP WILL NOT
C                                   GIVE THIS STATUS
C                              -2  (REQUESTED AP IS OFF LINE OR NOT INSTALLED)
C                              -1  (REQUESTED AP IS ASSIGNED TO ANOTHER USER)
C                             > 0  (NUMBER OF AP ASSIGNED)
C
C       ROUTINES USED:  APASGN,APXSET,CLRMD,APOVIN
C
        CALL APASGN(APNUM,ACTION,STATUS)
        IF (STATUS.LT.0) RETURN
        CALL APXSET
        CALL CLRMD
        CALL APOVIN
        RETURN
        END
C
C****** APCLR = SAME AS APXSET = REL B.1  , NOV 79 ****************************
C
C       BEGINING WITH REL 2.0 APXSET REPLACES APCLR. TO MAINTAIN COMPATIBILITY
C       WITH EXISTING ROUTINES, APCLR HAS BEEN REWRITTEN TO DO A CALL APXSET
C       ONLY.
C
        SUBROUTINE APCLR
C
C
C       ROUTINES USED: APXSET
C
        CALL APXSET
        RETURN
        END
C
C
C****** APXSET = INITIALIZE APEX AND RESET THE AP = REL B.1  , NOV 79 *********
C
        SUBROUTINE APXSET
C
C       APXSET CLEARS THE HARDWARE AND SOFTWARE INTERFACE TO THE AP-120B,
C       AND THEN INITIALIZES 'APEX'.  'APXSET' MUST BE DONE BEFORE ANY OTHER
C       ACCESS IS MADE TO THE AP-120B VIA APEX.
C
C-------COMMON STORAGE
C
        INTEGER TBLPTR,RESSIZ,PSPTR,BREAK
        INTEGER HOSTBL(50),APTBL(50),PSSIZ,TBLSIZ
        COMMON /APXCOM/ TBLPTR,RESSIZ,PSPTR,BREAK,
     X  HOSTBL,APTBL,PSSIZ,TBLSIZ
        INTEGER SUPER,START,BOOTST
        COMMON /SYSTEM/ SUPER,START,BOOTST
C
C-------ROUTINES USED: APXCLR,APRSET,SIZEPS,LOADBT
C
C    CLEAR APEX TABLES
        CALL APXCLR
C    RESET THE AP
        CALL APRSET
C    SIZE PS
        CALL SIZEPS(PSSIZ)
C    LOAD THE BOOTSTRAP
C    START GIVES THE ADDRESS FOR LOADING THE BOOTSTRAP
        START = 0
        CALL LOADBT
        RETURN
        END
C
C****** CLRMD = CLEAR MD (AND POSSIBLE PARITY BITS) = REL B.1  , NOV 79 *******
C
        SUBROUTINE CLRMD
C
C       CLEAR ALL PAGES OF MD TO INITIALIZE THE PARITY BITS.
C       NOTE: THIS ROUTINE ALSO ERASES THE APEX TABLE OF P.S.
C
C       ROUTINE USED: ZMD, APRSET
C
C    FIRST RESET THE AP (AND CLEAR THE MASK AND MODE BITS)
        CALL APRSET
C    NOW ZERO MAIN DATA
        CALL ZMD
C   MAKE APEX FORGET ABOUT THE 'ZMD' ROUTINE
        CALL APXCLR
C    WAIT FOR ZMD TO BE DONE BEFORE RETURNING
        CALL APWR
        RETURN
        END
C
C****** APXCLR = CLEAR APEX TABLES = REL B.1  , NOV 79 ************************
C
        SUBROUTINE APXCLR
C
C       CLEAR THE APEX PS TABLE.  THIS ROUTINE MAY BE USED TO MAKE APEX FORGET
C       THE PROGRAMS THAT IT HAS LOADED INTO P.S.  ANY BREAKPOINT IS ALSO
C       CLEARED.
C
C-------COMMON STORAGE
C
        INTEGER TBLPTR,RESSIZ,PSPTR,BREAK
        INTEGER HOSTBL(50),APTBL(50),PSSIZ,TBLSIZ
        COMMON /APXCOM/ TBLPTR,RESSIZ,PSPTR,BREAK,
     X  HOSTBL,APTBL,PSSIZ,TBLSIZ
        COMMON /SYSTEM/ SUPER,START,BOOTST
C
C
C    SET TABLE SIZE
        TBLSIZ=50
C    EMPTY TABLE
        TBLPTR=1
C    SET RESSIZ TO LOWEST AVAILABLE P.S. LOCATION
        RESSIZ=15
        PSPTR=RESSIZ
C    CLEAR BREAKPOINTS
        BREAK=-1
        RETURN
        END
C
C****** LOADBT = LOAD THE BOOTSTRAP INTO 'PS' = REL B.1  , NOV 79 *************
C
        SUBROUTINE LOADBT
C
C       PUTS OUT THE STANDARD BOOTSTRAP CODE INTO AP-120B PROGRAM MEMORY
C       VIA THE FRONT PANEL
C
C-------ROUTINES USED: WREG,IP16
C
C-------LOCAL STORAGE
C
        INTEGER SUPER,START,BOOTST
        COMMON /SYSTEM/ SUPER,START,BOOTST
C
        INTEGER BT(60),I,J,K
C
        DATA BT( 1),BT( 2),BT( 3),BT( 4)/     3, -4096,     0,     0/
        DATA BT( 5),BT( 6),BT( 7),BT( 8)/  4192,     0, 16388,     0/
        DATA BT( 9),BT(10),BT(11),BT(12)/   896,     0,  1792,     0/
        DATA BT(13),BT(14),BT(15),BT(16)/     3,-29184,  1024,     4/
        DATA BT(17),BT(18),BT(19),BT(20)/  4851,-13824,   512,     0/
        DATA BT(21),BT(22),BT(23),BT(24)/   640,     0,     0,     0/
        DATA BT(25),BT(26),BT(27),BT(28)/  4855,-13394,   512,     1/
        DATA BT(29),BT(30),BT(31),BT(32)/     3, -4096,     0,     0/
        DATA BT(33),BT(34),BT(35),BT(36)/     3, -2048, 16388,     0/
        DATA BT(37),BT(38),BT(39),BT(40)/     1,-23552,   256,  5376/
        DATA BT(41),BT(42),BT(43),BT(44)/     1,-23552,   256,  5376/
        DATA BT(45),BT(46),BT(47),BT(48)/     0,     0,   256,  5376/
        DATA BT(49),BT(50),BT(51),BT(52)/  4631,-29696,  1024,    64/
        DATA BT(53),BT(54),BT(55),BT(56)/     3, -4096,     0,     0/
        DATA BT(57),BT(58),BT(59),BT(60)/     0,     0,     0,     0/
C
C         1.  ADDRESS  >  TMA
C         2.  THE FOUR 16-BIT QUARTER WORDS TO PS(TMA) AND INCTMA
C                 AFTER THE 4TH QUARTER OF EACH
C
C           THE CALLING PROGRAM MUST SET "START" TO THE PS ADDRESS
C           OF THE BOOTSTRAP.
C             START = 0           FOR LOW  PS  (LIKE THE AP-120B)
C             START = PSSIZE-16   FOR HIGH PS  (FOR SUPERVISOR)
C
        CALL WREG(START,515)
        DO 10 I=1,57,4
        CALL WREG(IP16(BT(I)),520)
        CALL WREG(IP16(BT(I+1)),536)
        CALL WREG(IP16(BT(I+2)),552)
10      CALL WREG(IP16(BT(I+3)),760)
C
C  NOW SET STARTING ADDRESS
C  AND SET TO 120B MODE
C
        BOOTST = START+1
        SUPER = 0
        CALL APSUPV (0)
C
        RETURN
        END
C
C****** APEX = P.S EXECUTIVE = REL B.1  , NOV 79 ******************************
C
        SUBROUTINE APEX(CODE,DISP,SLIST,NSPADS)
        INTEGER CODE(9999),DISP,SLIST(16),NSPADS
C
C    PARAMETERS:
C
C       CODE    AN INTEGER ARRAY CONTAINING THE PROGRAM WORDS FOR THE LOAD
C               MODULE.  THE FIRST LOCATION OF 'CODE' CONTAINS THE NUMBER
C               OF 'PS' WORDS IN THE ARRAY.
C       DISP    A ONE WORD INTEGER CONTAINING THE RELATIVE STARTING ADDRESS
C               OF THE ENTRY IN THE LOAD MODULE.
C       SLIST   AN 'NSPADS' LONG INTEGER ARRAY CONTAINING THE S-PAD PARAMETERS
C               FOR THE ENTRY.
C       NSPADS  THE NUMBER OF S-PAD PARAMETERS FOR THE ENTRY.
C
C-------PURPOSE: CALLED BY USER CALLED AP-120B ROUTINES
C         I.E. THE USER DOES A  CALL CFFT(A,B,C)
C             CFFT THEN DOES A  CALL APEX(.....)
C             AND APEX RUNS THE AP-120B
C
C       1. LOADS THE DESIRED ROUTINE INTO AP-120B PROGRAM MEMORY IF
C            IT IS NOT ALREADY THERE
C       2. PUTS THE PARAMETERS FOR THE CALLED ROUTINE INTO S-PAD, AND
C            THEN RUNS THE ROUTINE
C
C-------COMMON STORAGE
C
        INTEGER TBLPTR,RESSIZ,PSPTR,BREAK
        INTEGER HOSTBL(50),APTBL(50),PSSIZ,TBLSIZ
        COMMON /APXCOM/ TBLPTR,RESSIZ,PSPTR,BREAK,
     X  HOSTBL,APTBL,PSSIZ,TBLSIZ
C
C       TBLPTR - POINTS TO NEXT FREE TABLE LOCATION
C       RESSIZ - SIZE OF RESIDENT CODE
C       PSPTR  - POINTS TO NEXT FREE P.S. LOCATION
C       BREAK  - USER SET BREAKPOINT DISPLACEMENT
C       HOSTBL  - TABLE RECORDING PROGRAMS LOADED INTO P.S. MEMORY
C               CONTAINS HOST MEMORY ADDRESS OF ROUTINE
C       APTBL - TABLE OF AP MEMORY LOCATIONS
C       PSSIZ  - SIZE OF INSTALLED PROGRAM MEMORY
C       TBLSIZ - SIZE OF 'HOSTBL' (MUST AGREE WITH DIMENSION)
C
C-------ROUTINES USED: ILOC,APSTOP,LOADPS,SPLDGO,APWD
C
C-------LOCAL STORAGE
C
        INTEGER PSFWA,FOUND,HOSTAD,PROGSZ,I
C
C       PSFWA  - BASE ADDRESS OF A LOAD MODULE
C       FOUND  - USED IN TABLE SEARCH
C       HOSTAD  - ADDRESS IN HOST OF CODE ARRAY
C
C
C-------SEE IF PROGRAM IS ALREADY IN THE TABLE
C
C       GET LOCATION OF CODE ARRAY IN THE HOST
        HOSTAD=ILOC(CODE)
C
C       IF TABLE IS EMPTY DON'T SEARCH IT, BUT GO DIRECTLY TO ADD NEW
C          ENTRY TO THE TABLE
        IF (TBLPTR.EQ.1) GOTO 2000
C
C       NOW SEARCH THE TABLE
C
C ALREADY
C
        I=TBLPTR-1
        DO 20 FOUND=1,I
        IF (HOSTAD.EQ.HOSTBL(FOUND)) GO TO 1000
20      CONTINUE
C
C-------NOT IN THE TABLE, GO ADD IT
C
        GOTO 2000
C
C-------WAS IN THE TABLE, GET P.S. ADDRESS AND GO LOAD PARAMETERS
C
C MATCH
C
1000    PSFWA=APTBL(FOUND)
        GOTO 4000
C
C-------COME HERE IF IT'S NOT IN THE TABLE YET, SEE IF THERE'S ROOM
C
C       FIRST SEE IF IT'S TOO BIG TO FIT AT ALL
C
C ADPROG
C
2000    PROGSZ=CODE(1)
        IF (PROGSZ.GT.(PSSIZ-RESSIZ)) CALL APSTOP(1)
C
C       SEE IF THERE'S ROOM IN THE TABLE
C
        IF(TBLPTR.GT.TBLSIZ) GOTO 2500
C
C
C-------TAKE ENTRIES OUT OF THE TABLE UNTIL THERE'S ROOM IN P.S.
C
C PSFIT
C
2200    IF ((PSPTR+PROGSZ).LE.PSSIZ) GOTO 3000
C
C       THERE ISN'T ROOM YET, TAKE THE LAST ENTRY OFF OF THE TABLE
C
C TAKOUT
C
2500    TBLPTR=TBLPTR-1
        PSPTR=APTBL(TBLPTR)
        GOTO 2200
C
C-------COME HERE TO ADD AN ENTRY TO THE TABLE, AND TO LOAD IT INTO
C          P.S. MEMORY
C
C PUTIN
C
3000    HOSTBL(TBLPTR)=HOSTAD
        APTBL(TBLPTR)=PSPTR
        TBLPTR=TBLPTR+1
        PSFWA=PSPTR
        PSPTR=PSPTR+PROGSZ
        CALL LOADPS(CODE(2),PSFWA,PROGSZ)
        CALL APWD
C
C-------LOAD S-PAD PARAMETERS AND GO
C
C INTBL
C
4000    CALL SPLDGO(SLIST,NSPADS,PSFWA+DISP,PSFWA+BREAK)
        RETURN
        END
C
C
C****** APOVLD = HOST APOVLD CALL = REL B.1  , NOV 79 *************************
C
        SUBROUTINE APOVLD (OVID)
C
        INTEGER OVID
C
C       THIS ROUTINE IS CALLED TO ADD OVERLAY ID NUMBERS TO THE
C       LIST CONTAINED IN THIS IOVS ARRAY IN THE APLDCM COMMON.
C       THESE NUMBERS ARE PASSED TO THE OVERLAY HANDLER IN THE
C       AP BY THE NEXT APRUN CALL.  ANY NON-EXISTANT ID NUMBERS
C       WILL BE DISCOVERED AT THAT TIME.  IOVS(2) CONTAINS THE CURRENT
C       NUMBER OF PENDING APOVLD CALLS AND IOVS(3 ... ) CONTAINS THE
C       REQUESTED OVERLAY ID NUMBERS.  IOVS(1) IS USED BY APRUN.
C
C       CALL:
C
C       OVID   = THE ID NUMBER OF AN OVERLAY TO BE LOADED INTO PS
C
        COMMON /APLDCM/ IPAV(33),NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS(33),
     *                  LMT(10,3),LMTE
        INTEGER IPAV,NU2,IDLM,NU1,IPPAAD,IPPAND,IOVS,LMT,LMTE
C
        INTEGER OVSMAX,K
C
        DATA OVSMAX /31/
C
C       ADD OVID TO THE IOVS ARRAY - CHECK FOR OVERFLOW
C
        K=IOVS(2)
        IF (K+1 .GT. OVSMAX) GOTO 90000
        K=K+1
        IOVS(K+2)=OVID
        IOVS(2)=K
        RETURN
C
C       ERROR - IOVS ARRAY OVERFLOW
C
90000   CALL APSTOP (8)
        RETURN
        END
C****** LOADPS = LOAD PROGRAMS INTO 'PS' = REL B.1  , NOV 79 ******************
C
C       REV 2.1 DELETED CALL TO RUNAP, USE PANEL /AJR
        SUBROUTINE LOADPS(HOST,AP,N)
        INTEGER HOST(1),AP,N
C
C       WAIT UNTIL THE AP-120B IS DONE WITH ANY RUNS OR DMA'S, THEN
C       TRANSFER 'N' AP-120B PROGRAM WORDS FROM ARRAY 'HOST' INTO
C       AP-120B PROGRAM MEMORY STARTING AT ADDRESS 'AP'
C
C       PARAMETERS:
C       HOST   - ARRAY IN THE HOST COMPUTER OF AP-120B PROGRAM WORDS.
C       AP     - INITIAL ADDRESS IN PROGRAM MEMORY WHERE THE PROGRAM
C                  WORDS ARE TO BE PUT.
C       N      - NUMBER OF PROGRAM WORDS TO BE TRANSFERED.
C
C       ROUTINES USED: APWAIT, WREG, OFN, RUNDMA
C
C       LOCAL STORAGE
        INTEGER NS
C
C       1. WAIT FOR BOTH DMA AND RUNNING DONE
C       2. PUT PROGRAM P.S. ADDRESS INTO 'TMA'
C       3. RUN THE AP AT LOCATION 1 WITH THE P.S. WORD COUNT IN 'SWR'
C       4. START THE DMA
C
        INTEGER SUPER,START,BOOTST
        COMMON /SYSTEM/ SUPER,START,BOOTST
C
        CALL APWAIT
        CALL WREG(AP,515)
C       SET UP PSA, SW, AND FN TO START BOOTSTRAP
        CALL WREG(BOOTST,512)
        CALL WREG(N,8192)
C
C       NS=NUMBER OF 32-BIT PS HALFWORDS (FMT=0).
        NS=2*N
C
C-------NOTE: IF CONSECUTIVE CYCLES IS NOT APPROPRIATE,
C       THEN CHANGE THE CONSTANT '129' BELOW TO '1'
        CALL RUNDMA(HOST,0,NS,129)
        RETURN
        END
C
C****** APWAIT = WAIT FOR BOTH DMA AND RUNNING = REL B.1  , NOV 79 ************
C
        SUBROUTINE APWAIT
C
C       DOES A WAIT FOR BOTH DMA COMPLETION AND RUNNING COMPLETION,
C       I.E., A CALL APWD FOLLOWED BY A CALL APWR
C
C       ROUTINES USED: APWD, APWR
C
        CALL APWD
        CALL APWR
        RETURN
        END
C
C****** APWD = WAIT FOR DMA AND ERROR CHECK = REL B.1  , NOV 79 ***************
C
        SUBROUTINE APWD
C
C       A 'WAIT' IS DONE UNTIL THE LAST DMA TRANSFER STARTED BY 'APPUT',
C       'APGET' OR 'RUNDMA' IS COMPLETED.  IF A 'DATA LATE' ERROR IS
C       DETECTED BY THE HARDWARE THEN FATAL ERROR #3 IS INDICATED BY A
C       'PAUSE 3' FORTRAN STATEMENT.
C
C-------ROUTINES USED: WTDMA,APSTOP
C
C-------LOCAL STORAGE
C
        INTEGER IERR
C
        CALL WTDMA(IERR)
        IF(IERR.NE.0) CALL APSTOP(3)
        RETURN
        END
C
C****** APWR = WAIT FOR RUNNING AND ERROR CHECK = REL B.1  , NOV 79 ***********
C
        SUBROUTINE APWR
C
C       DOES A 'WAIT' UNTIL THE LAST RUN STARTED BY 'SPLDGO' OR 'RUNDMA'
C       IS COMPLETED.  IF A 'SUBROUTINE RETURN STACK OVERFLOW' ERROR
C       IS DETECTED BY THE HARDWARE THEN FATAL ERROR #4 IS INDICATED
C       BY CALLING APSTOP.
C       PARITY ERROR IS INDICATED BY ERROR #5.
C
C-------ROUTINES USED: WTRUN, APSTOP
C
C-------LOCAL STORAGE
        INTEGER IRR
C
       CALL WTRUN (IRR)
        IF (IRR .EQ. 0) RETURN
        IF (IRR .LT. 0) GO TO 366
        IF (IRR .GE. 76) GO TO 411
        IF (IRR .GE. 3) GO TO 366
        CALL APSTOP (IRR+3)
        RETURN
366     CALL APSTOP (64)
        RETURN
411     CALL APSTOP (IRR)
        RETURN
       END
C
C****** SETBRK = SET APEX BREAKPOINT = REL B.1  , NOV 79 **********************
C
        SUBROUTINE SETBRK(BRKLOC)
        INTEGER BRKLOC
C
C       SET A HARDWARE BREAKPOINT ADDRESS TO BE USED BY 'APEX' WHEN RUNNING
C       PROGRAMS.  HITTING THE BREAKPOINT CAUSES AN AP-120B PROGRAM TO 'HALT',
C       WHICH IS INTERPRETED BY 'APEX' AS THE END OF THAT PROGRAM.
C       THE BREAKPOINT REMAINS IN EFFECT UNTIL CLEARED BY 'CLRBRK' OR 'APXSET'.
C
C-------PARAMETER:
C       BRKLOC - RELATIVE AP-120B PROGRAM MEMORY ADDRESS ON WHICH TO BREAK.
C                THIS ADDRESS IS RELATIVE TO THE BASE P.S. LOCATION AVAILABLE
C                FOR DYNAMICALLY LOADED USER ROUTINES.
C
C-------COMMON
        INTEGER TBLPTR,RESSIZ,PSPTR,BREAK
        INTEGER HOSTBL(50),APTBL(50),PSSIZ,TBLSIZ
        COMMON /APXCOM/ TBLPTR,RESSIZ,PSPTR,BREAK,
     X  HOSTBL,APTBL,PSSIZ,TBLSIZ
C
C-------ROUTINES USED: NONE
C
        BREAK=BRKLOC
        RETURN
        END
C
C****** CLRBRK = CLEAR APEX BREAKPOINT = REL B.1  , NOV 79 ********************
C
        SUBROUTINE CLRBRK
C
C       CLEAR A BREAKPOINT PREVIOUSLY SET BY 'SETBRK'
C
C-------COMMON
C
        INTEGER TBLPTR,RESSIZ,PSPTR,BREAK
        INTEGER HOSTBL(50),APTBL(50),PSSIZ,TBLSIZ
        COMMON /APXCOM/ TBLPTR,RESSIZ,PSPTR,BREAK,
     X  HOSTBL,APTBL,PSSIZ,TBLSIZ
C
C-------ROUTINES USED: NONE
C
        BREAK=-1
        RETURN
        END
C
C****** APPUT = PUT DATA INTO 'MD' = REL B.1  , NOV 79 ************************
C
        SUBROUTINE APPUT(HOST,AP,N,FMT)
        INTEGER HOST(9999),AP,N,FMT
C
C       TRANSFER 'N' DATA ELEMENTS FROM ARRAY 'HOST' IN THE HOST COMPUTER
C       TO AP-120B MAIN DATA MEMORY STARTING AT ADDRESS 'AP' USING
C       FORMAT 'FMT'
C
C       PARAMETERS:
C       HOST   - CONSTANT, VARIABLE, OR ARRAY WHICH WILL BE THE INITIAL
C                  HOST DATA ITEM TO BE TRANSFERED
C       AP     - INITIAL MEMORY ADDRESS IN THE AP-120B FOR THE TRANSFER
C       N      - NUMBER OF DATA ELEMENTS TO BE TRANSFERED
C       FMT    - FORMAT NUMBER OF DATA
C
C       ROUTINES USED: RUNDMA, APSTOP
C
C-------LOCAL STORAGE
C
        INTEGER CTL
C
C       SET HOST ADDRESS, AP ADDRESS, WORD COUNT, AND GO
        IF (FMT.LT.0.OR.FMT.GT.3) CALL APSTOP(6)
C
C-------NOTE: IF CONSECUTIVE CYCLE DMA IS NOT TO BE USED
C       REPLACE THE CONSTANT '193' BELOW WITH '65'
        CTL=193+FMT+FMT
        CALL RUNDMA(HOST,AP,N,CTL)
        RETURN
        END
C
C****** APGET = GET DATA FROM 'MD' = REL B.1  , NOV 79 ************************
C
        SUBROUTINE APGET(HOST,AP,N,FMT)
        INTEGER HOST(9999),AP,N,FMT
C
C       TRANSFER 'N' DATA ELEMENTS FROM AP-120B MEMORY STARTING AT
C       ADDRESS 'AP' TO ARRAY 'HOST' IN THE HOST COMPUTER USING FORMAT
C       'FMT'.
C
C       PARAMETERS:
C       HOST   - VARIABLE OR ARRAY SPECIFING THE INITIAL HOST COMPUTER
C                  LOCATION TO RECEIVE THE DATA
C       AP     - INITIAL MEMORY ADDRESS IN THE AP-120B FROM WHICH THE DATA
C                  IS TRANSFERED
C       N      - NUMBER OF DATA ELEMENTS TRANSFERED
C       FMT    - FORMAT NUMBER OF DATA
C
C
C       ROUTINES USED: RUNDMA,APSTOP
C
C-------LOCAL STORAGE
C
        INTEGER CTL
C
C       CHECK FOR ILLEGAL FORMAT NUMBER
        IF (FMT.LT.0.OR.FMT.GT.3) CALL APSTOP(6)
C
C-------NOTE: IF CONSECUTIVE CYCLE DMA IS NOT TO BE USED,
C       CHANGE THE CONSTANT '225' BELOW TO '97'
        CTL=225+FMT+FMT
        CALL RUNDMA(HOST,AP,N,CTL)
        RETURN
        END
C
C****** APCHK = CHECK SOFTWARE ERROR STATUS = REL B.1  , NOV 79 ***************
C
        SUBROUTINE APCHK(IERR)
        INTEGER IERR
C
C       WAIT UNTIL THE LAST PROGRAM IS DONE EXECUTING, THEN SET 'IERR'
C       TO ANY ERROR INFORMATION RETURNED BY THE LAST AP-120B PROGRAM.
C       THIS IS VALID ONLY AFTER PROGRAMS THAT RETURN ERROR INFORMATION.
C
C       ROUTINES USED: APGSP
C
C       EXAMINE S-PAD 15., WHICH IS SET BY THE UCODE
        CALL APGSP(IERR,15)
        RETURN
        END
C
C****** APSTAT = CHECK HARDWARE ERROR STATUS = REL B.1  , NOV 79 **************
C
        SUBROUTINE APSTAT(IANY,ISTAT)
        INTEGER IANY, ISTAT(4)
C
C       WAIT UNTIL ANY PENDING DMA TRANSFERS OR PROGRAM EXECUTIONS ARE
C       COMPLETED, THEN SET 'IANY' TO 1 IF A NON-FATAL HARDWARE ERROR
C       IS INDICATED, ELSE SET 'IANY' TO 0. IF AN ERROR IS DETECTED,
C       SET THE ELEMENTS OF 'ISTAT' AS INDICATED BELOW, ELSE DO NOT
C       MODIFY 'ISTAT'
C
C       PARAMETERS:
C       IANY   - SET TO 1 IF ANY OF THE ERRORS BELOW ARE DETECTED, ELSE SET TO 0
C       ISTAT  - IF ANY ERRORS ARE DETECTED, THEN THE ELEMENTS OF
C                  'ISTAT' ARE SET TO 1 IF THE PARTICULAR ERROR OCCURED,
C                  ELSE THEY ARE SET TO 0:
C                ISTAT(1) - ARITHMETIC OVERFLOW
C                ISTAT(2) - ARITHMETIC UNDERFLOW
C                ISTAT(3) - DIVIDE BY ZERO
C                ISTAT(4) - DMA FORMAT CONVERSION OVERFLOW/UNDERFLOW
C
C       ROUTINES USED: APWAIT, ICTRL, RREG, IAND16, NAND16, NEGCHK
C
C-------LOCAL STORAGE
        INTEGER CTL,IISTAT
C
C       WAIT FOR EVERYTHING TO BE STOPPED ,THEN GET APSTATUS AND CTL
        CALL APWAIT
        CALL RREG(IISTAT,1030)
        CALL ICTRL(CTL)
        IANY=0
C
C       SEE IF ANY ERRORS
        IF ((IAND16(CTL,512).EQ.0).AND.
     X    NAND16(IISTAT,8191).EQ.0) RETURN
C
C       NOW SET THE ELEMENTS OF 'ISTAT'
        IANY=1
        ISTAT(1)=NEGCHK(IISTAT)
        IF (IAND16(IISTAT,16384).NE.0) ISTAT(2)=1
        IF (IAND16(IISTAT,8192).NE.0) ISTAT(3)=1
        IF (IAND16(CTL,512).NE.0) ISTAT(4)=1
        RETURN
        END
C
C****** APGSP = GET S-PAD VALUE = REL B.1  , NOV 79 ***************************
C
C
         SUBROUTINE APGSP(IN,NUM)
         INTEGER IN,NUM
C
C        GET THE VALUE OF S-PAD REGISTER 'NUM' AND PUT IT INTO 'IN'
C        NUM MAY RANGE FROM 0-15. THIS VERSION IS FOR 16 BIT MACHINES.
C
C        ROUTINES USED: APWAIT,APEX,APWR,WREG,RREG
C        HOST ROUTINES USED: MOD
C
C        CALL SEQUENCE
C        CALL APGSP(VALUE,NUMBER) WHERE
C        VALUE IS THE VALUE RETURNED AND NUMBER IS S-PAD NUMBER
C
C        1).  WAIT UNTIL ALL ACTIVITY IS DONE
C        2).  GET THE CORRECT CODE FROM TABLE TO MOV SP(NUM) TO SPFN
C        3).  USE APEX TO RUN THIS CODE
C        4).  NOW SET SPD TO 'NUM'
C        5).  NOW READ SPFN THROUGH FRONT PANEL
C
        INTEGER SUPER, START,BOOTST
        COMMON /SYSTEM/ SUPER, START,BOOTST
         INTEGER C(80)
         INTEGER SLIST
         INTEGER CD
         DATA C( 1),C( 2),C( 3),C( 4),C( 5)/1,16384,224,0,0/
         DATA C( 6),C( 7),C( 8),C( 9),C(10)/1,16452,224,0,0/
         DATA C(11),C(12),C(13),C(14),C(15)/1,16520,224,0,0/
         DATA C(16),C(17),C(18),C(19),C(20)/1,16588,224,0,0/
         DATA C(21),C(22),C(23),C(24),C(25)/1,16656,224,0,0/
         DATA C(26),C(27),C(28),C(29),C(30)/1,16724,224,0,0/
         DATA C(31),C(32),C(33),C(34),C(35)/1,16792,224,0,0/
         DATA C(36),C(37),C(38),C(39),C(40)/1,16860,224,0,0/
         DATA C(41),C(42),C(43),C(44),C(45)/1,16928,224,0,0/
         DATA C(46),C(47),C(48),C(49),C(50)/1,16996,224,0,0/
         DATA C(51),C(52),C(53),C(54),C(55)/1,17064,224,0,0/
         DATA C(56),C(57),C(58),C(59),C(60)/1,17132,224,0,0/
         DATA C(61),C(62),C(63),C(64),C(65)/1,17200,224,0,0/
         DATA C(66),C(67),C(68),C(69),C(70)/1,17268,224,0,0/
         DATA C(71),C(72),C(73),C(74),C(75)/1,17336,224,0,0/
         DATA C(76),C(77),C(78),C(79),C(80)/1,17404,224,0,0/
C
C    THIS FUNCTION IS NOT ALLOWED WITH MTS100 SUPERVISOR
        IF (SUPER .EQ. 1) GO TO 90000
         CALL APWAIT
         INUM=MOD(NUM,16)
         CD=((INUM)*5)+1
         CALL APEX(C(CD),0,SLIST,0)
         CALL APWR
         CALL WREG(INUM,513)
         CALL RREG(IN,1029)
         RETURN
C
90000   CALL APSTOP (71)
        RETURN
         END
C
C****** INMPGS = DETERMINE NUMBER OF PAGES OF MD = REL B.1  , NOV 79 **********
C
       INTEGER FUNCTION INMPGS(RSIZE)
       REAL RSIZE(17)
C
C      PURPOSE: TO DETERMINE THE TOTAL NUMBER OF PAGES IN AP
C               AND THE TOTAL NUMBER OF WORDS ON EACH PAGE.
C
C      PARAMATERS: RSIZE - 17 WORD REAL ARRAY
C                          NUMBER OF WORDS IN EACH PAGE IS RETURNED AS A REAL
C                          NUMBER IN RSIZE(1-16)
C                          RSIZE(17) RETURNS THE NUMBER OF PAGES (REAL)
C
C      RETURNS THE NUMBER OF PAGES IN INTEGER
C
C      ROUTINES USED: PAGESZ
C      LOCAL VARIBLES
       INTEGER I
C
C
       INMPGS=0
       DO 10 I=1,16
C
C      GET SIZE OF EACH PAGE 1-16
C
       RSIZE(I)=PAGESZ(I-1)
C
C      SEE IF PAGE WAS SIZE ZERO  IF SO DO NOT INCREMENT TOTAL NUMBER
C      OF PAGES.
C
       IF(RSIZE(I) .NE. 0.0) INMPGS=INMPGS+1
C
C      TRY NEXT PAGE
C
10     CONTINUE
C
C      SET REAL # PAGES
C
       RSIZE(17)=FLOAT(INMPGS)
       RETURN
       END
C
C****** PAGESZ = SIZE A PAGE OF MD = REL B.1  , NOV 79 ************************
C
       REAL FUNCTION PAGESZ(IPAGE)
       INTEGER IPAGE
C
C      PURPOSE: SIZES A GIVEN PAGE OF MAIN DATA MEMORY
C
C      PARAMETERS:  IPAGE - PAGE NUMBER TO SIZE - FROM 0 TO 15 (INTEGER)
C
C      RETURNS:  THE NUMBER OF WORDS ON THAT PAGE - FROM 0.0 TO 65536.0 (REAL)
C
C      ROUTINES USED: OMAE,WREG,RREG
C
C      LOCAL VARIBLES:
C
       INTEGER TVAL,TEST,ISIZE,SAVE,I
       REAL MEMINC
C
C      SAVE OLD PAGE NUMBER
C
       CALL IMAE(SAVE)
C
C      NOW SEE IF THE PAGE SELECT OPTION IS HERE, IF IT ISN'T, THEN RETURN
C         0.0 UNLESS ON PAGE 0
C
        PAGESZ=0.0
        TVAL=7
        CALL OMAE(TVAL)
        CALL IMAE(TEST)
        IF (TEST.NE.TVAL.AND.IPAGE.NE.0) RETURN
C
C
       CALL OMAE(IPAGE)
C
C      MEMINC IS MEMORY INCREAMENT OF MAIN DATA
C
       MEMINC=8192.
C
C      TVAL IS TEST VALUE TO WRITE TO MAIN DATA
C
       TVAL=7
C
C      START AT -1.0
C
       PAGESZ=-1.0
C
C      LOOP
C
       DO 20 I=1,8
       TEST=0
C
C      TEST NEXT SECTION MEMORY
C
       PAGESZ=PAGESZ+MEMINC
       ISIZE=IPFIX(PAGESZ)
C
C      PUT ADDRESS INTO MA
C
       CALL WREG(ISIZE,562)
C
C      PUT TEST VALUE INTO MAIN DATA
C
       CALL WREG(TVAL,541)
C
C      PUT ADDRES BACK INTO MA
C
       CALL WREG(ISIZE,562)
C
C      READ VALUE BACK
C
       CALL RREG(TEST,1053)
C
C      CHECK TO SEE IF MEMORY EXISTS
C
       IF (TEST .NE. TVAL) GOTO 200
20     CONTINUE
C
C      PAGE FULL
C
       PAGESZ=65536.0
       GO TO 300
C
C      WENT PAST BY 'MEMINC'
C
200    PAGESZ=PAGESZ-MEMINC+1.0
C
C      PUT 'MAE BACK AS WAS
C
300    CALL OMAE(SAVE)
       RETURN
       END
C
C****** SIZEMD = SIZE MAIN DATA MEMORY = REL B.1  , NOV 79 ********************
C
      SUBROUTINE SIZEMD(SIZE)
      INTEGER SIZE
C
C       SETS 'SIZE' TO THE NUMBER OF MAIN DATA WORDS INSTALLED,
C       BETWEEN 8192 AND 65536
C
C       NOTE: 65536 IS RETURNED AS 0
C
C----------PARAMETERS:
C          SIZE      THE SIZE OF MEMORY IS RETURN IN SIZE
C
C----------ROUTINES USED: WREG,RREG,IADD16,ISUB16,IP16
C
C------------LOCAL VARIBLES
      INTEGER MEMINC,TVAL,TEST,I
C
C MEMINC IS MEMORY INCREAMENTS OF MAIN DATA
      MEMINC=8192
C
C TVAL IS TEST VALUE TO BE USED
      TVAL=7
C
C     START AT -1
      SIZE=IP16(-1)
C
C-------LOOP
       DO 100 I=1,9
      TEST=0
      SIZE= IADD16(SIZE,MEMINC)
C
C PUT ADDRESS IN MA
      CALL WREG(SIZE,514)
C
C PUT TEST VALUE INTO MAIN DATA
      CALL WREG(TVAL,541)
C
C PUT ADDRESS INTO MA AGAIN
      CALL WREG(SIZE,514)
C
C GET BACK VALUE
      CALL RREG(TEST,1053)
C
C SEE IF THEY AGREE
C IF THEY DO AGREE CHECK TO SEE IF NEXT BLOCK IS PRESENT
C IF THEY DO NOT AGREE THEN MEMORY STOPPED AT PREVIOUS BLOCK
C
      IF (TEST.NE.TVAL) GO TO 200
100   CONTINUE
C
200   SIZE=IADD16(ISUB16(SIZE,MEMINC),1)
      RETURN
       END
C
C****** SZSVPS = SIZE PROGRAM MEMORY = REL B.1  , NOV 79 **********************
C
        SUBROUTINE SZSVPS(SIZE)
        INTEGER SIZE
C
        CALL SIZEPS (SIZE)
        RETURN
        END
C
C****** SIZEPS = SIZE PROGRAM MEMORY = REL B.1  , NOV 79 **********************
C
      SUBROUTINE SIZEPS(SIZE)
        INTEGER SIZE
C
C       SETS 'SIZE' TO THE NUMBER OF PROGRAM WORDS INSTALLED,
C       EITHER 1024 OR 4096 WORDS FOR THE FPS100.
C
C----------PARAMETERS:
C          SIZE      THE SIZE OF MEMORY IS RETURN IN SIZE
C
C       ROUTINES USED: RREG,WREG
C
C------------LOCAL VARIBLES
        INTEGER TVAL,TEST,RESUL
C
C       INITIALIZE SIZE
        SIZE = 1024
C
C PUT 1025 IN TMA
      CALL WREG(1025,515)
C
C  GET PRESENT VALUE OF PS
        CALL RREG(TVAL,1032)
C
C   WRITE A TEST VALUE  (OCTAL 52525)
        TEST = 21845
        CALL WREG(TEST,520)
C
C  NOW TEST RESULT
        CALL RREG(RESUL,1032)
        IF (RESUL .NE. TEST) RETURN
C
C  MUST BE A 4096 PS, SO REPLACE VALUE OF PS
        CALL WREG(TVAL,520)
        SIZE = 4096
C
      RETURN
      END
C
C****** APEXAM = EXAMINE FPS-100 REGISTERS & MEMORIES = REL B.1  , NOV 79 *****
C
        SUBROUTINE APEXAM(REG,OPEN,LOC)
        INTEGER REG(4),OPEN,LOC
C
C       PUT THE CONTENTS OF LOCATION 'LOC' OF FPS-100 REGISTER
C       OR MEMORY NUMBER 'OPEN' INTO HOST ARRAY 'REG'
C
C-------NOTE: THE INTERFACE REGISTERS MAY BE EXAMINED WHEN THE FPS-100
C       IS RUNNING, OTHERWISE THE FPS-100 MUST BE HALTED (I.E DO A 'CALL APWR')
C       FOR RESULTS FROM 'APEXAM' TO BE MEANINGFUL.
C
C       PARAMETERS:
C     REG  - WHERE THE EXAMINED DATA IS PUT:
C                16-BIT OR SMALLER REGISTERS:
C                                   IN REG(1)
C                38-BIT REGISTERS:  IN REG(1-3):
C                       EXPONENT:      REG(1)
C                       HIGH MANTISSA: REG(2)
C                       LOW MANTISSA:  REG(3)
C                64-BIT DATA:    IN REG(1-4)
C                       BITS 0-15:     REG(1)
C                       BITS 16-31:    REG(2)
C                       BITS 32-47:    REG(3)
C                       BITS 48-63:    REG(4)
C
C     OPEN - REGISTER NUMBER:
C            OPEN NAME   BIT-WIDTH
C            NUM.
C              1. PSA    16
C              2. SPD     4
C              3. MA     16
C              4. TMA    16
C              5. DPA     6
C              6. S-PAD  16
C              7. APSTAT 16
C              8. DA      6
C              9. PS     64
C             10. I/O    38
C             11. ------ --    NO-OP
C             12. DPX    38
C             13. DPY    38
C             14. MD     38
C             15. SPFN   16    READ ONLY
C             16. TM     38    WRITABLE ONLY IF TMRAM
C
C             17. SWR    16
C             18. FN     16
C             19. LITES  16
C             20. APMA   16
C             21. HMA    16
C             22. WC     16
C             23. CTRL   16
C             24. FMTH   16
C             25. FMTL   16
C             26. I/F RESET  --
C             27. I/F STATUS 16
C             28. MASK   6
C             29. APMAE  4
C             30. MAE    4
C             31. RTCCTR 16
C             32. RTCCST 16
C             33. RTCCTL 16
C             34. IMASK  16
C             35. ------ --
C             36. ------ --
C             37. APSTAT3  16
C             38. APSTAT2  16
C             39. SMA      16
C             40. MDR      38
C             41. TMR      38
C
C     LOC  - ADDRESS OF DESIRED LOCATION IN 'OPEN' (IGNORED IF NOT
C                A MEMORY)
C
C       ROUTINES USED: RREG,WREG,APIN,IAND16
C
C
C-----LOCAL STORAGE
C
      INTEGER I,TEMP,J,DEPADR,TSPD,TCODE(23),NOPN
      INTEGER C1(19),INST(2)
C
C-------NUMBER OF OPENABLE REGISTERS (41 FOR FPS-100)
      DATA NOPN / 41 /
C
C-------CODE TO READ SMA OR MA
C
C       REPLACE NOP WITH RMA IF DESIRED REGISTER IS ACTIVE
C       OTHERWISE USE ROMA.
C
C       NOP;  PN2DBL;  DPX(-4)<DB
C       HALT
C       NOP
C
        DATA C1(1),C1(2),C1(3),C1(4),C1(5),C1(6),C1(7)/0,0,0,0,0,0,0/
C
        DATA C1(8),C1(9),C1(10),C1(11)/4403,0,16384,0/
        DATA C1(12),C1(13),C1(14),C1(15)/3,-4096,0,0/
        DATA C1(16),C1(17),C1(18),C1(19)/0,0,0,0/
C
C
C-------REPLACEMENT INSTRUCTIONS TO MODIFY MICROPROGRAM C1.
C
C                            RMA    ROMA
        DATA INST(1),INST(2)/-27648,-18944/
C
C
C     ERROR IF 'OPEN' IS OUT OF RANGE
      IF (OPEN.LT.0.OR.OPEN.GT.NOPN) GO TO 28
      IF (OPEN.GE.17.AND.OPEN.LT.31) GO TO 4000
C
C-----GO DO IT . . .
        IF (OPEN.GE.31) GO TO 10
C
C             PSA   SPD    MA   TMA   DPA  SPAD  STAT    DA
      GO TO (1000, 1000, 6000, 1000, 1000, 1500, 1000, 1000,
     1       2000, 5000,  500, 3000, 3000, 3000,  990, 3000),OPEN
C              PS   I/O    CB   DPX   DPY  MD    SPFN  TM
C
C            RTCCTR      RTCCTL      CB        APSTAT3
C                  RTCCST      IMASK      CB         APSTAT2
10    GO TO (5000, 5000, 5000, 5000, 500, 500, 5000, 5000,
     1      6000,3000,3000), OPEN-30
C           SMA  MDR  TMR
C
C           ERROR.
28      CALL APSTOP (72)
        RETURN
C
C---NOP, I.E. CAN'T READ
500     RETURN
C
C---SPFN
990     CALL RREG(REG(1),1086)
        RETURN
C
C---16 BIT REGISTERS
1000  CALL RREG(REG(1),OPEN+1023)
      RETURN
C
C     S-PAD  (16-BITS)
C       1. SAVE SPD (S-PAD DESTINATION ADDRESS)
C       2. LOAD SPD WITH LOCATION OF DESIRED SPAD
C       3. READ SPAD THRU FUNCTION REGISTER
C       4. RESTORE SPD
C
C     SAVE SPD
1500    CALL RREG(TSPD,1025)
C     LOAD SPD WITH LOCATION
        CALL WREG(LOC,513)
C     READ SPAD THRU FUNCTION REGISTER
        CALL RREG(REG(1),1029)
C     RESTORE SPD
        CALL WREG(TSPD,513)
        RETURN
C
C---PROGRAM SOURCE (64 BITS)
C       1. SAVE TMA
C       2. SET TMA TO DESIRED LOC
C       3. READ IN BITS 0-15
C       4. READ IN BITS 16-31
C       5. READ IN BITS 32-47
C       6. READ IN BITS 48-63
C       7. RESTORE TMA
2000  CALL RREG(TEMP,1027)
      CALL WREG(LOC,515)
      CALL RREG(REG(1),1032)
      CALL RREG(REG(2),1048)
      CALL RREG(REG(3),1064)
      CALL RREG(REG(4),1080)
      CALL WREG(TEMP,515)
      RETURN
C
C
C   38-BIT MEMORIES (AND HD)
C     1. SAVE PROPER ADDRESS REGISTER
C     2. SET PROPER ADDRESS REGISTER TO DESIRED LOCATION
C     3. DO AN EXTRA DUMMY PANEL OP (EXAM PSA) IN CASE EXAMINING TM
C     4. READ EXPONENT PART OF WORD
C     5. READ HIGH MANTISSA (MANTISSA BITS 0-11)
C     6. READ LOW MANTISSA (NAMTISSA BITS 12-27)
C     7. RESTORE ADDRESS REGISTER TO ORIGINAL VALUE
C
C     DEPADR HAS DEP + WRTLMN
C
3000  I = LOC
      IF (OPEN.NE.12.AND.OPEN.NE.13) GO TO 3010
C     SPECIAL FOR DPX & DPY, USE LOC+4 FOR ADDRESS,
C     SET 'DEPADR' TO DEPOSIT INTO DPA
      I=I+36
      DEPADR=564
3010  IF (OPEN.EQ.14) DEPADR=562
      IF (OPEN.EQ.16) DEPADR=563
      CALL RREG(TEMP,DEPADR+464)
      CALL WREG(I,DEPADR)
      CALL RREG(J,1024)
      I=OPEN
      IF (OPEN.EQ.40) I=11
      IF (OPEN.EQ.41) I=8
      CALL RREG(REG(1),I+1039)
      CALL RREG(REG(2),I+1055)
      CALL RREG(REG(3),I+1071)
      CALL WREG(TEMP,DEPADR)
      RETURN
C
C     INTERFACE REGISTERS . . .
4000  CALL APIN(REG(1),OPEN-16)
      RETURN
C
C--- I/O DEVICES (38) BITS
C
C       1. SAVE STATE OF DA REGISTER
C       2. LOAD I/O ADDRESS (LOC) IN DA
C       3. EXAMINE I/O DEVICE THRU FUNCTION REGISTER
C       4. RESTORE STATE OF DA REGISTER
C
C    SAVE STATE OF DA
5000    CALL RREG(TEMP,1031)
C    LOAD LOCATION INTO DA
        CALL WREG(LOC,519)
C    EXAMINE I/O DEVICE
        CALL RREG(REG(1),1049)
        CALL RREG(REG(2),1065)
        CALL RREG(REG(3),1081)
C    IF I/O DEVICE IS 16 BITS LONG THEN RETURN ANSWER IN REG(1)
        IF (OPEN.GT.30) REG(1)=REG(3)
C    RESTORE STATE OF DA
        CALL WREG(TEMP,519)
        RETURN
C
C--- SMA OR MA REGISTER EXAM.
C
C       1. SAVE STATE (WITH PSFUNC)
C       2. DETERMINE WHICH IS ACTIVE SMA OR MA
C          PUT RMA OR ROMA INSTRUCTION IN PROGRAM
C       3. LOAD PROGRAM IN PS
C       4. RUN PROGRAM
C       5. READ DPX(DPA-4) INTO REG
C       6. RESTORE STATE WITH PSFUNC
C
C    SAVE STATE
6000    CALL PSFUNC(1,0,2,TCODE)
C    DETERMINE WHICH IS ACTIVE SMA OR MA
        CALL RREG(TEMP,1031)
        CALL WREG(255,519)
        CALL RREG(REG(3),1081)
        CALL WREG(TEMP,519)
        I=IAND16(REG(3),1024)/1024
C    ASSUME DESIRED ADDRESS REGISTER IS ACTIVE (RMA)
        C1(9)=INST(1)
C    IF DESIRED REGISTER IS NOT ACTIVE USE ROMA.
        IF (OPEN.EQ.39.AND.I.NE.1) C1(9)=INST(2)
        IF (OPEN.EQ.3 .AND.I.NE.0) C1(9)=INST(2)
C    LOAD PROGRAM
        CALL PSFUNC(2,0,2,C1)
C    RUN PROGRAM
        CALL PSFUNC(3,0,0,0)
C    READ DPX(DPA-4) INTO REG
        CALL RREG(REG(1),1083)
C    RESTORE STATE
        CALL PSFUNC(2,0,2,TCODE)
        RETURN
C
        END
C
C****** APDEP = DEPOSIT INTO FPS-100 REGISTERS & MEMORIES = REL B.1  , NOV 79 *
C
      SUBROUTINE APDEP(REG,OPEN,LOC)
      INTEGER REG(4),OPEN,LOC
C
C     PUT 'REG' INTO ADDRESS 'LOC' OF FPS-100 MEMORY OR REGISTER 'OPEN'
C
C-----NOTE: EXCEPT FOR CHANGING INTERFACE REGISTERS, THE FPS-100 MUST
C     BE HALTED (I.E. DO A 'CALL APWR') BEFORE USING 'APDEP'
C
C     PARAMETERS:
C       (SEE 'APEXAM' FOR MORE DETAILS)
C
C     REG  - DATA TO BE DEPOSITED, IN REG(1-4):
C               16-BIT REGISTERS:    IN REG(1)
C               38-BIT REGISTERS:    IN REG(1)-REG(3)
C               64-BIT REGISTERS:    IN REG(1)-REG(4)
C     OPEN - REGISTER NUMBER:  1-16, INTERNAL REGISTERS
C                              17-30, I/F REGISTERS
C                              31-39, FPS-100 REGISTERS
C     LOC  - ADDRESS OF DESIRED LOCATION IN 'OPEN' (IGNORED IF NOT A MEMORY)
C
C       ROUTINES USED: RREG,WREG,APOUT
C
C
C-----LOCAL STORAGE
C
      INTEGER I,TEMP,J,NOPN,DEPADR,TCODE(19)
      INTEGER C1(19),INST(2)
C
C       NUMBER OF PLACES THAT CAN BE OPENED
      DATA NOPN / 41 /
C
C-------CODE TO DEPOSIT INTO SMA OR MA
C
C       REPLACE NOP WITH LDMA IF DESIRED REGISTER IS ACTIVE
C       ELSE USE LDOMA.
C
C       NOP;  DB=DPX(-4)
C       HALT
C       NOP
C
        DATA C1(1),C1(2),C1(3),C1(4),C1(5),C1(6),C1(7)/0,0,0,0,0,0,0/
C
        DATA C1(8),C1(9),C1(10),C1(11)/3,0,1536,0/
        DATA C1(12),C1(13),C1(14),C1(15)/3,-4096,0,0/
        DATA C1(16),C1(17),C1(18),C1(19)/0,0,0,0/
C
C
C-------REPLACEMET INSTRUCTIONS TO MODIFY MICROPROGRAM C1
C
C                            LDMA   LDOMA
        DATA INST(1),INST(2)/-31744,-19456/
C
C-----ERROR IF 'OPEN' IS OUT OF RANGE
      IF (OPEN.LT.0.OR.OPEN.GT.NOPN) GO TO 28
      IF (OPEN.GE.17.AND.OPEN.LT.31) GO TO 4000
C
C-----GO DO IT . . .
      IF (OPEN.GE.31) GO TO 10
C
C             PSA   SPD    MA   TMA   DPA  SPAD  STAT    DA
      GO TO (1000, 1000, 7000, 1000, 1000, 1500, 1000, 1000,
     1       2000, 5000,  500, 3000, 3000, 3000,  500,  6000),OPEN
C              PS   I/O    CB   DPX   DPY  MD    SPFN    TM
C
C
C            RTCCTR      RTCCTL      CB        APSTAT3
C                  RTCCST      IMASK      CB         APSTAT2
10    GO TO (5000, 5000, 5000, 5000, 500, 500, 5000, 5000,
     1       7000,500,500),OPEN-30
C            SMA  MDR TMR
C
C          ERROR.
28      CALL APSTOP (73)
        RETURN
C
C---NO-OP, I.E CAN'T WRITE IT
500     RETURN
C
C---16 BIT REGISTERS
C
C     PUT 3 INTO THE 'WORD' FIELD SO THAT SETTING 'MA' WON'T TOUCH 'MAE'
1000  CALL WREG(REG(1),OPEN+559)
      RETURN
C
C     S-PAD  (16-BITS)
C       1. SAVE SPD (S-PAD DESTINATION REGISTER)
C       2. SET SPD TO THE DESIRED S-PAD LOC
C       3. STORE INTO THAT LOC
C       4. RESTORE SPD TO ORIGINAL VALUE
1500  CALL RREG(TEMP,1025)
      CALL WREG(LOC,513)
      CALL WREG(REG(1),517)
      CALL WREG(TEMP,513)
      RETURN
C
C---PROGRAM SOURCE (64 BITS)
C       1. SAVE TMA
C       2. SET TMA TO DESIRED LOC
C       3. WRITE BITS 0-15
C       4. WRITE BITS 16-31
C       5. WRITE BITS 32-47
C       6. WRITE BITS 48-63
C       7. RESTORE TMA
2000  CALL RREG(TEMP,1027)
      CALL WREG(LOC,515)
      CALL WREG(REG(1),520)
      CALL WREG(REG(2),536)
      CALL WREG(REG(3),552)
      CALL WREG(REG(4),568)
      CALL WREG(TEMP,515)
      RETURN
C
C
C   38-BIT MEMORIES (AND HD)
C     1. SAVE PROPER ADDRESS REGISTER
C     2. SET PROPER ADDRESS REGISTER TO DESIRED LOCATION
C     3. WRITE EXPONENT PART OF WORD
C     4. WRITE HIGH MANTISSA (MANTISSA BITS 0-11)
C     5. WRITE LOW MANTISSA (NAMTISSA BITS 12-27)
C     6. RESTORE ADDRESS REGISTER TO ORIGINAL VALUE
C
C      DEPADR HAS 3 IN THE WORD FIELD
3000  I = LOC
      IF (OPEN.NE.12.AND.OPEN.NE.13) GO TO 3010
C     SPECIAL CASE FOR DPX & DPY, MUST USE LOC+4 FOR ADDRESS,
C     SET 'DEPADR' TO DEPOSIT INTO TMA
      I=I+36
      DEPADR=564
      GO TO 3020
C
C     IT'S MD, SET 'DEPADR' TO DEPOSIT INTO MA
3010  DEPADR=562
C
3020  CALL RREG(TEMP,DEPADR+464)
      CALL WREG(I,DEPADR)
      CALL WREG(REG(1),OPEN+527)
      CALL WREG(REG(2),OPEN+543)
      CALL WREG(REG(3),OPEN+559)
      CALL WREG(TEMP,DEPADR)
      RETURN
C
4000  CALL APOUT(REG(1),OPEN-16)
      RETURN
C
C---I/O DEVICES (38) BITS
C
C       1. SAVE STATE OF DA REGISTER
C       2. LOAD LOCATION TO CHANGE INTO DA
C       3. DEPOSIT INTO I/O DEVICE THRU FUNCTION REGISTER
C       4. RESTORE STATE OF DA REGISTER
C       5. IF CHANGING TM THEN RESTORE TMA
C
C    SAVE STATE OF DA
5000    I=LOC
5010    CALL RREG(TEMP,1031)
C    LOAD LOCATION INTO DA
        CALL WREG(I,519)
C    IF I/O DEVICE IS 16 BITS LONG OUTPUT FROM REG(1)
        IF (OPEN.GT.30) REG(3)=REG(1)
C    DEPOSIT INTO I/O DEVICE
        CALL WREG(REG(1),537)
        CALL WREG(REG(2),553)
        CALL WREG(REG(3),569)
C    RESTORE STATE OF DA
        CALL WREG(TEMP,519)
C    IF CHANGING TM THEN RESTORE TMA
        IF (OPEN.EQ.16) CALL WREG(J,515)
        RETURN
C
C--- TM (38) BITS
C
C       USE DEPOSIT TO AN I/O DEVICE ABOVE
C
C       SET DA TO 5, AND TMA TO LOC
C
6000    I=5
        CALL RREG(J,1027)
        CALL WREG(LOC,515)
        GO TO 5010
C
C--- SMA OR MA DEPOSIT
C
C       1. SAVE STATE (WITH PSFUNC)
C       2. DETERMINE WHICH IS ACTIVE SMA OR MA
C          PUT LDMA OR LDOMA INSTRUCTION IN PROGRAM
C       3. LOAD PROGRAM AND DPX(DPA-4)
C       4. RUN PROGRAM
C       5. RESTORE STATE
C
C    SAVE STATE
7000    CALL PSFUNC(1,0,2,TCODE)
C    DETERMINE WHICH IS ACTIVE SMA OR MA
        CALL APEXAM(C1(5),38,255)
        I=IAND16(C1(7),1024)/1024
C    ASSUME DESIRED REGISTER IS ACTIVE
        C1(9)=INST(1)
C    IF DESIRED REGISTER IS NOT ACTIVE USE LDOMA
        IF (OPEN.EQ.39.AND.I.NE.1) C1(9)=INST(2)
        IF (OPEN.EQ. 3.AND.I.NE.0) C1(9)=INST(2)
C    LOAD PROGRAM AND DPX(DPA-4)
        C1(7)=REG(1)
        CALL PSFUNC(2,0,2,C1)
C    RUN PROGRAM
        CALL PSFUNC(3,0,0,0)
C    RESTORE STATE
        CALL PSFUNC(2,0,2,TCODE)
        RETURN
C
        END
C****** PSFUNC = DO P.S. FUNCTIONS: SAVE, RESTORE, RUN = REL B.1  , NOV 79 ****
C
        SUBROUTINE PSFUNC(ACTION,PSL,PSH,SAVE)
        INTEGER ACTION,PSA,PSL,PSH,SAVE(9999)
C
C       MAKE IT CONVENIENT TO PUT IN A SMALL PROGRAM INTO THE AP AND RUN IT
C       WITHOUT DISTURBING WHAT WAS THERE BEFORE
C
C       PARAMETERS:
C
C       ACTION  1       SAVE APSTAT, DA, PSA, TMA, DPX(DPA-4), AND P.S.
C                       FROM ARRAY 'SAVE' USING LIMITS PSL TO PSH
C               2       RESTORE P.S., DPX(DPA-4), TMA, AND PSA, DA, APSTAT
C                       FROM ARRAY 'SAVE' USING LIMITS PSL TO PSH
C               3       RUN AT LOCATION 'PSL', WITH 'PSH' IN THE SWITCHES,
C                       AND WAIT FOR COMPLETION
C
C       PSL     LOW ADDRESS FOR SAVING/RESTORING P.S.,
C               STARTING ADDRESS FOR RUNNING
C
C       PSH     HIGH ADDRESS FOR SAVING/RESTORING P.S.,
C               PUT IN SWR FOR RUNNING
C
C       SAVE    INTEGER ARRAY USED BY SAVE/RESTORE.  MUST BE DIMENSIONED
C               AT LEAST 4(PSH-PSL) + 11 LOCATIONS LONG IN THE CALLING ROUTINE.
C
C                       SAVE(1)         APSTATUS
C                       SAVE(2)         DA
C                       SAVE(3)         PSA
C                       SAVE(4)         TMA
C                       SAVE(5)         DPX(DPA-4)  EXPONENT
C                       SAVE(6)                     HIGH MANTISSA
C                       SAVE(7)                     LOW MANTISSA
C                       SAVE(8)         PS(PSL)     BITS 0-15
C                       . . .           . . .       . . .
C                       SAVE(4(PSH-PSL)+11)  PS(PSH)  BITS 48-63
C
C
        INTEGER SUPER, START,BOOTST
        COMMON /SYSTEM/ SUPER, START,BOOTST
C
C-------LOCAL STORAGE
C
        INTEGER L1,L2,LOC,I
C
C             ERROR IF MTS100 SUPERVISOR IN USE
        IF (SUPER .EQ. 1) GO TO 90000
C
C-------GO TO ACTION
C
        GO TO (100,200,300), ACTION
C
C
C------SAVE STATE
C
C    SAVE APSTAT
100     CALL RREG(SAVE(1),1030)
C    SAVE DA
        CALL RREG(SAVE(2),1031)
C    SAVE PSA
        CALL RREG(SAVE(3),1024)
C    SAVE TMA
        CALL RREG(SAVE(4),1027)
C    SAVE DPX(DPA-4)
        CALL RREG(SAVE(5),1051)
        CALL RREG(SAVE(6),1067)
        CALL RREG(SAVE(7),1083)
C
C    SAVE PS (LOW TO HIGH)
C
        L1=8
        L2=L1 + 4*(PSH-PSL)
        LOC=PSL
        DO 150 I=L1,L2,4
        CALL WREG(LOC,515)
        CALL RREG(SAVE(I),1032)
        CALL RREG(SAVE(I+1),1048)
        CALL RREG(SAVE(I+2),1064)
        CALL RREG(SAVE(I+3),1080)
150     LOC=LOC+1
        RETURN
C
C-------RESTORE STATE
C
C    RESTORE PS (LOW TO HIGH)
C
200     L1=8
        L2=L1 + 4*(PSH-PSL)
        LOC=PSL
        DO 250 I=L1,L2,4
        CALL WREG(LOC,515)
        CALL WREG(IP16(SAVE(I)),520)
        CALL WREG(IP16(SAVE(I+1)),536)
        CALL WREG(IP16(SAVE(I+2)),552)
        CALL WREG(IP16(SAVE(I+3)),568)
250     LOC=LOC+1
C
C    RESTORE DPX(DPA-4)
        CALL WREG(SAVE(5),539)
        CALL WREG(SAVE(6),555)
        CALL WREG(SAVE(7),571)
C    RESTORE TMA
        CALL WREG(SAVE(4),515)
C    RESTORE PSA
        CALL WREG(SAVE(3),512)
C    RESTORE DA
        CALL WREG(SAVE(2),519)
C    RESTORE APSTAT
        CALL WREG(SAVE(1),518)
        RETURN
C
C-------RUN
C
C    PUT 'PSL' INTO PSA, 'PSH' INTO SWR, AND CONTINUE
300     CALL WREG(PSL,512)
        CALL WREG(PSH,8192)
C    WAIT FOR DONE RUNNING
350     CALL IFN(LOC)
        IF (NEGCHK(LOC).EQ.0) GO TO 350
        RETURN
C
90000   CALL APSTOP (70)
        RETURN
        END
C
C****** RREG = READ THROUGH THE AP-120B FRONT PANEL = REL B.1  , NOV 79 *******
C
        SUBROUTINE RREG(LITES,FUNCT)
        INTEGER LITES,FUNCT
C
C       DO A PANEL FUNCTION AND THEN READ THE RESULTS IN THE LITES,
C       I.E. PUT 'FUNCT' INTO THE FUNCTION REGISTER, THEN READ
C       THE LITES REGISTER INTO 'LITES'
C
C       PARAMETERS:
C       FUNCT - FUNCTION FOR THE FUNCTION REGISTER
C       LITES  - DATA READ IN FROM THE LITES
C
C       ROUTINES USED: APIN, APOUT
C
        CALL APOUT(FUNCT,2)
        CALL APIN(LITES,3)
        RETURN
        END
C
C****** WREG = WRITE THROUGH THE AP-120B FRONT PANEL = REL B.1  , NOV 79 ******
C
        SUBROUTINE WREG(SWITCH,FUNCT)
        INTEGER SWITCH,FUNCT
C
C       PUT 'SWITCH' INTO THE SWITCH REGISTER AND THEN PUT 'FUNCT' INTO THE
C       FUNCTION REGISTER.
C       NOTE: THE AP-120B MUST BE HALTED TO ANY FUNCTION OTHER THAN
C       HALT OR RESET.
C
C       PARAMETERS:
C       SWITCH  - DATA FOR THE SWITCH REGISTER
C       FUNCT - FUNCTION FOR THE FUNCTION REGISTER
C
C       ROUTINES USED: APOUT
C
        CALL APOUT(SWITCH,1)
        CALL APOUT(FUNCT,2)
        RETURN
        END
C
C****** APPSEL = WRITE THE EXTENDED MEMORY SELECT REGISTERS = REL B.1  , NOV 79
C
        SUBROUTINE APPSEL(MASK,APMAE,MAE)
        INTEGER MASK,APMAE,MAE
C
C  THIS IS A DUMMY ROUTINE ONLY
C
C       PARAMETERS:
C       MASK = -1  (DONT CHANGE MASK VALUE)
C              0 TO 63  (MASK,I/O, AND MODE REGISTER FOR PROTECTION)
C       APMAE = -1  (DONT CHANGE)
C               0 TO 15  ( PAGE FOR AP ACCESSES)
C       MAE = -1  (DONT CHANGE)
C             0 TO 15  (PAGE FOR DMA ACCESSES)
C
C       SUBROUTINES USED: APWAIT,APOUT
C
CC         CALL APWAIT
CC         IF (MASK.NE.-1) CALL APOUT(MASK,12)
CC         IF (APMAE.NE.-1) CALL APOUT(APMAE,13)
CC         IF (MAE.NE.-1) CALL APOUT(MAE,14)
        RETURN
        END
C
C****** APRSLT = READ EXTENDED MEMORY SELECT REGISTERS = REL B.1  , NOV 79 ****
C
        SUBROUTINE APRSLT(MASK,APMAE,MAE)
        INTEGER MASK,APMAE,MAE
C
C  THIS IS A DUMMY ROUTINE ONLY
C
C       PARAMETERS:
C       MASK = MASK,I/O AND MODE REGISTER
C       APMAE = AP ACCESS PAGE REGISTER
C       MAE = DMA ACCESS PAGE REGISTER
C
C       ROUTINES USED: APWAIT,APIN
C
CC          CALL APWAIT
CC          CALL APIN(MASK,12)
CC          CALL APIN(APMAE,13)
CC          CALL APIN(MAE,14)
        MASK = 0
        APMAE = 0
        MAE = 0
        RETURN
        END
C
C****** ISWR = INPUT FROM THE SWITCH REGISTER = REL B.1  , NOV 79 *************
C
        SUBROUTINE ISWR(IN)
        INTEGER IN
C
C       PUT THE CURRENT CONTENTS OF THE SWITCH REGISTER INTO 'IN'.
C
C       ROUTINES USED: APIN
C
        CALL APIN(IN,1)
        RETURN
        END
C
C****** OSWR = OUTPUT TO THE SWITCH REGISTER = REL B.1  , NOV 79 **************
C
        SUBROUTINE OSWR(OUT)
        INTEGER OUT
C
C       PUT 'OUT' INTO THE SWITCH REGISTER
C
C       ROUTINES USED: APOUT
C
        CALL APOUT(OUT,1)
        RETURN
        END
C
C****** IFN = INPUT FROM THE FUNCTION REGISTER = REL B.1  , NOV 79 ************
C
        SUBROUTINE IFN(IN)
        INTEGER IN
C
C       READ THE CURRENT CONTENTS OF THE FUNCTION REGISTER INTO 'IN'
C
C       ROUTINES USED: APIN
C
        CALL APIN(IN,2)
        RETURN
        END
C
C****** OFN = OUTPUT TO FUNCTION REGISTER = REL B.1  , NOV 79 *****************
C
        SUBROUTINE OFN(OUT)
        INTEGER OUT
C
C       PUT OUT INTO THE FUNCTION REGISTER
C
C      ROUTINES USED: APOUT
C
        CALL APOUT(OUT,2)
        RETURN
        END
C
C****** ILITES = INPUT FROM LITES REGISTER = REL B.1  , NOV 79 ****************
C
        SUBROUTINE ILITES(IN)
        INTEGER IN
C
C       READ CURRENT CONTENTS OF LITES REGISTER INTO 'IN'
C
C       ROUTINES USED: APIN
C
        CALL APIN(IN,3)
        RETURN
        END
C
C****** OLITES = OUTPUT TO LITES REGISTER = REL B.1  , NOV 79 *****************
C
        SUBROUTINE OLITES(OUT)
        INTEGER OUT
C
C       OUTPUT 'OUT' TO THE LITES REGISTER
C
C       ROUTINES USED: APOUT
C
        CALL APOUT(OUT,3)
        RETURN
        END
C
C****** IAPMA = INPUT FROM APMA = REL B.1  , NOV 79 ***************************
C
        SUBROUTINE IAPMA(IN)
        INTEGER IN
C
C       READ CURRENT CONTENTS OF AP-120B DMA MEMORY ADDRESS REGISTER (APMA)
C       INTO 'IN'
C
C       ROUTINES USED: APIN
C
        CALL APIN(IN,4)
        RETURN
        END
C
C****** OAPMA = OUTPUT TO APMA = REL B.1  , NOV 79 ****************************
C
        SUBROUTINE OAPMA(OUT)
        INTEGER OUT
C
C       SET APMA REGISTER (AP DMA MEMORY ADDRESS REGISTER) TO 'OUT'
C
C       ROUTINES USED: APOUT
C
        CALL APOUT(OUT,4)
        RETURN
        END
C
C****** IHMA = INPUT FROM HMA = REL B.1  , NOV 79 *****************************
C
        SUBROUTINE IHMA(IN)
        INTEGER IN
C
C       READ THE CURRENT CONTENTS OF THE HOST MEMORY ADDRESS REGISTER (HMA)
C       INTO 'IN'
C
C       ROUTINES USED: APIN
C
        CALL APIN(IN,5)
        RETURN
        END
C
C****** OHMA = OUTPUT TO HMA = REL B.1  , NOV 79 ******************************
C
        SUBROUTINE OHMA(OUT)
        INTEGER OUT
C
C       OUTPUT 'OUT' TO HOST MEMORY ADDRESS REGISTER (HMA)
C
C       ROUTINES USED: APOUT
C
        CALL APOUT(OUT,5)
        RETURN
        END
C
C****** IWC = INPUT WORD COUNT = REL B.1  , NOV 79 ****************************
C
        SUBROUTINE IWC(IN)
        INTEGER IN
C
C       INPUT CURRENT CONTENTS OF WORD COUNT REGISTER (WC) INTO 'IN'
C
C       ROUTINES USED: APIN
C
        CALL APIN(IN,6)
        RETURN
        END
C
C****** OWC = OUTPUT TO WC = REL B.1  , NOV 79 ********************************
C
        SUBROUTINE OWC(OUT)
        INTEGER OUT
C
C       OUTPUT 'OUT' TO WORD COUNT REGISTER (WC)
C
C       ROUTINES USED: APOUT
C
        CALL APOUT(OUT,6)
        RETURN
        END
C
C****** ICTRL = INPUT CONTROL REGISTER = REL B.1  , NOV 79 ********************
C
        SUBROUTINE ICTRL(IN)
        INTEGER IN
C
C       READ CURRENT CONTENTS OF DMA CONTROL REGISTER (CTRL) INTO 'IN'
C
C      ROUTINES USED: APIN
C
        CALL APIN(IN,7)
        RETURN
        END
C
C****** OCTRL = OUTPUT TO CTRL = REL B.1  , NOV 79 ****************************
C
        SUBROUTINE OCTRL(OUT)
        INTEGER OUT
C
C       OUTPUT 'OUT' TO DMA CONTROL REGISTER (CTRL)
C
C       ROUTINES USED: APOUT
C
        CALL APOUT(OUT,7)
        RETURN
        END
C
C****** IFMTH = INPUT FROM FORMAT HIGH = REL B.1  , NOV 79 ********************
C
        SUBROUTINE IFMTH(IN)
        INTEGER IN
C
C       READ CURRENT CONTENTS OF HIGH PART OF DMA FORMAT CONVERSION
C       REGISTER (FMTH)
C
C       ROUTINES USED: APIN
C
        CALL APIN(IN,8)
        RETURN
        END
C
C****** OFMTH = OUTPUT TO FORMAT HIGH = REL B.1  , NOV 79 *********************
C
        SUBROUTINE OFMTH(OUT)
        INTEGER OUT
C
C       OUTPUT 'OUT' TO HIGH PART OF FORMAT CONVERSION REGISTER (FMTH)
C
C       ROUTINES USED: APOUT
C
        CALL APOUT(OUT,8)
        RETURN
        END
C
C****** IFMTL = INPUT FROM FORMAT LOW = REL B.1  , NOV 79 *********************
C
        SUBROUTINE IFMTL(IN)
        INTEGER IN
C
C       READ THE CURRENT CONTENTS OF THE LOW PART OF THE FORMAT CONVERSION
C       REGISTER (FMTL) INTO 'IN'
C
C       ROUTINES USED: APIN
C
        CALL APIN(IN,9)
        RETURN
        END
C
C****** OFMTL = OUTPUT TO FORMAT LOW = REL B.1  , NOV 79 **********************
C
        SUBROUTINE OFMTL(OUT)
        INTEGER OUT
C
C       OUTPUT 'OUT' TO LOW PART OF FORMAT CONVERSION REGISTER (FMTL)
C
C       ROUTINES USED: APOUT
C
        CALL APOUT(OUT,9)
        RETURN
        END
C
C****** ORESET = DO AN INTERFACE RESET = REL B.1  , NOV 79 ********************
C
        SUBROUTINE ORESET
C
C       DO AN INTERFACE RESET:
C       1. CLEAR ANY PENDING INTERRUPTS
C       2. HALT THE PROCESSOR
C
C       ROUTINES USED: APOUT
C
        CALL APOUT(0,10)
        RETURN
        END
C
C****** IFSTAT = READ INTERFACE STATUS = REL B.1  , NOV 79 ********************
C
        SUBROUTINE IFSTAT(IN)
        INTEGER IN
C
C       READ THE INTERFACE STATUS REGISTER (WHEN PRESENT) INTO 'IN'
C
C       ROUTINES USED: APIN
C
        CALL APIN(IN,11)
        RETURN
        END
C
C****** IMASK = READ MASK,I/O,MODE REGISTER = REL B.1  , NOV 79 ***************
C
        SUBROUTINE IMASK(IN)
        INTEGER IN
C
C  THIS IS A DUMMY ROUTINE ONLY
C
C       READ THE CURRENT CONTENTS OF THE MASK REGISTER INTO 'IN'
C
C       ROUTINES USED: APIN
C
CC        CALL APIN(IN,12)
        IN = 0
        RETURN
        END
C
C****** OMASK = WRITE MASK,I/O,MODE REGISTER = REL B.1  , NOV 79 **************
C
        SUBROUTINE OMASK(OUT)
        INTEGER OUT
C
C  THIS IS A DUMMY ROUTINE ONLY
C
C       WRITE THE CONTETS OF 'OUT' TO THE MASK REGISTER
C
CC        CALL APOUT(OUT,12)
        RETURN
        END
C
C****** IAPME = READ APMA EXTENSION = REL B.1  , NOV 79 ***********************
C
        SUBROUTINE IAPME(IN)
        INTEGER IN
C
C  THIS IS A DUMMY ROUTINE ONLY
C
C       READ THE APMA EXTENSION REGISTER INTO 'IN'
C
C       ROUTINES USED: APIN
C
CC          CALL APIN(IN,13)
        IN = 0
        RETURN
        END
C
C****** OAPME = WRITE THE APMA EXTENSION = REL B.1  , NOV 79 ******************
C
        SUBROUTINE OAPME(OUT)
        INTEGER OUT
C
C  THIS IS A DUMMY ROUTINE ONLY
C
C       WRITE THE APMA EXTENSION REGISTER WITH THE CONTENTS OF 'OUT'
C
C       ROUTINES USED: APOUT
C
CC          CALL APOUT(OUT,13)
        RETURN
        END
C
C****** IMAE = READ THE MA EXTENSION = REL B.1  , NOV 79 **********************
C
        SUBROUTINE IMAE(IN)
        INTEGER IN
C
C  THIS IS A DUMMY ROUTINE ONLY
C
C       READ THE DMA ACCESS PAGE REGISTER INTO 'IN'
C
C       ROUTINES USED: APIN
C
CC          CALL APIN(IN,14)
        IN = 0
        RETURN
        END
C
C****** OMAE = WRITE THE MA EXTENSION REGISTER = REL B.1  , NOV 79 ************
C
        SUBROUTINE OMAE(OUT)
        INTEGER OUT
C
C  THIS IS A DUMMY ROUTINE ONLY
C
C       WRITE THE MA EXTENSION REGISTER WITH THE CONTENTS OF 'OUT'
C
CC          CALL APOUT(OUT,14)
        RETURN
        END
C
C****** ABORT = SAME AS APRSET = REL B.1  , NOV 79 ****************************
C       APRSET REPLACED ABORT STARTING WITH REL 2.0. TO MAINTAIN COMPATIBILITY
C       WITH EXISTING ROUTINES THAT USE ABORT, ABORT WAS RE-WRITTEN TO ONLY
C       DO A CALL APRSET.
C
        SUBROUTINE ABORT
C
C
C       ROUTINES USED:  APRSET
C
        CALL APRSET
        RETURN
        END
C
C****** HLITES = INPUT SAVED LITES VALUE = REL 4.0  , NOV 79 ******************
C
        SUBROUTINE HLITES(IN)
        INTEGER IN
C
C        RETRIEVE SAVED VALUE OF LITES REGISTER
C
C        ROUTINES USED: APIN
C
        CALL APIN(IN,15)
        RETURN
        END
