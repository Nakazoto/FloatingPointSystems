$LIB
"****** SIGSRC = SIGNAL PROCESSING LIBRARY /FAST/ = REL 3.3, DEC 80 ****
"
"====================  CONDITIONAL ASSEMBLY SWITCHES  ==================
"
"    XADC   DETERMINES WHETHER ASSEMBLY WILL INCLUDE BOTH ADC AND UDC
"              ENTRY POINTS, OR ONLY UDC ENTRY POINTS
"           XADC $EQU 1    ASSEMBLE BOTH ADC AND UDC ENTRY POINTS (DEFAULT)
"           XADC $EQU 0    ASSEMBLE ONLY UDC ENTRY POINTS
"
"           TO CHANGE FROM THE DEFAULT (ADC AND UDC) TO UDC ONLY ASSEMBLY,
"           GLOBALLY EDIT THIS FILE TO CHANGE ALL OCCURRENCES (1 PER
"           ROUTINE) OF
"               XADC $EQU 1      TO     XADC $EQU 0
"
"==============================================================================
"
"     ---HISTORY---
"REV 3.3 AND 2A.3:  DEC 80
"       1. UNWRAP, CPSTRM, AND UNWCOR HAVE BEEN CORRECTED TO FIX
"          COMMUNICATION PROBLEMS BETWEEN THEM.  (SECO 80-0183, TAR 2242)
"
"REV 3.2 AND 2A.2:  AUG 80
"       1. ADDS THE FOLLOWING NEW ROUTINES:
"              LPAUTO  --  LINEAR PREDICTION AUTOCORRELATION
"              CFFTI   --  COMPLEX FFT WITH INTERPOLATION
"              RFFTI   --  REAL FFT WITH INTERPOLATION
"            INCLUDING THE FOLLOWING SUPPORT ROUTINES:
"              BITRVI  --  BIT REVERSE FOR CFFTI
"              IFFT4   --  FINAL RADIX 4 FOR CFFTI
"              IFFT4G  --  IFFT4 COMPUTATION KERNEL
"              IREALT  --  RFFTI UNRAVEL
"            CFFTI AND RFFTI ALLOW 32K FFTS TO BE PERFORMED WITH
"            4.5K TMROM (16K FFTS WITH 2.5K TMROM).  CFFTI AND RFFTI
"            ARE UPWARD COMPATIBLE WITH CFFT AND RFFT, RESPECTIVELY.
"        2. (REV 3.2 ONLY) CORRECTED THE ADC LINKAGE IN THE FOLLOWING ROUTINES:
"              VAVLIN
"              VAVEXP
"              CSPEC
"              PKVAL
"              UNWRAP
"              CPSTRM
"        3. (REV 3.2 ONLY) $RADIX 8 STATEMENT ADDED TO ALL ROUTINES SO
"           ROUTINES WILL ASSEMBLE CORRECTLY EVEN WHEN ASSEMBLER DEFAULT
"           IS BASE 10 OR 16.
"
"
"REV 3.1:  SEP 79
"       1. ZERO ARRAY SIZE TEST ADDED TO ALL THE ROUTINES.
"       2. THE BITMAP IN HIST CHANGED TO 32 (FROM 172).
"       3. THE FOLLOWING ROUTINES WERE ADDED:
"          DECFIR
"          ENVEL
"          HLBRT
"          PKVAL
"          VXCS
"          SHPHU
"          UNWRAP
"          CPSTRM
"          UNWCOR (APAL CALLABLE ONLY)
"          WIENER (BROUGHT IN FROM OLD BABSRC.)
"
"
"REV 3.0:  NOV 78
"       1. ADDS ENTRY POINTS FOR AP FORTRAN
"       2. MINOR MOD TO HANN FOR APAL3 COMPATIBILITY
"
"REV 2.2:  SEP 78
"       1. FIXES BUGS IN THE FOLLOWING ROUTINES:
"               HIST
"       2. FIXES PROBLEMS WHEN EXECUTING WITH N>32767 IN THE
"          FOLLOWING ROUTINES:
"               VAVLIN
"               VAVEXP
"
"==============================================================================
"
"****** VAVLIN = VECTOR LINEAR AVERAGING /FAST/ = REL 3.2, AUG 80 *****
        $TITLE VAVLIN
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VAVLIN,6                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV,SPUFLT
"
"       ---ABSTRACT---
"COMPUTES THE LINEAR AVERAGE OF VECTOR C WITH A VECTOR A
"WHERE B IS THE NUMBER OF FRAMES PREVIOUSLY USED TO OBTAIN
"VECTOR C.  B IS INCREMENTED, SINCE B+1 FRAMES MAKE UP
"THE NEW AVERAGE C.
"
"FORMULA: C(MK)=C(MK)*B/(B+1) + A(MI)/(B+1) FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH FAST MEMORY
"SIZE: 20 LOCATIONS + DIV (28) + SPUFLT (8) = 56 LOCATIONS
"SPEED: BEST:  42+3N  (A,B EVEN; C,I,K ODD)
"       WORST: 44+6N
"       TYPICAL: 44+5N  (A,B,C EVEN; I,K ODD)
"       COLUMNS/LOOP: 4
"       FLOPS/LOOP:   3
"SUBROUTINES USED: DIV,SPUFLT
"
"     ---HISTORY---
"ORIGINAL:  MAR 77  R.S. NORIN
" REVISED:  SEP 78  R.S. NORIN   HANDLES N>32767 CORRECTLY
" REVISED:  SEP 79  D.GANGULY.ZERO ARRAY SIZE TEST ADDED.
" REV 3.2:  AUG 80  R. GELLER    CORRECT ADC LINKAGE
"
"
"       ---USAGE---
"FORTRAN: CALL VAVLIN(A,I,B,C,K,N)
"APAL:    JSR VAVLIN
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "ADDRESS OF CURRENT NUMBER OF FRAMES
                                "IN AVERAGE C
     C  $EQU  3                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  4                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  5                 "NUMBER OF ELEMENTS IN C
"OTHER TEMP STORAGE:
     CC $EQU 17
"TABLE MEMORY
 ONE  $EQU  !ONE
"
"SCRATCH:  SP(0,3,14,15), DPX(0-2), DPY(0-1), FA,FM,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVAVLN,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  62
        $PARAM  6 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3/R/IP/OP,
                    P4(#5,#6)/R/IP/OP, P5/I/IP,
                    P6/I/IP
FVAVLN: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VAVLIN: MOV B,B; SETMA          "GET CURRENT NR FRAMES
        MOV N,17; LDTMA; DB=!ONE
        BGT .+2
        RETURN                    "RETURN IF N=0.
        JSR SPUFLT               "FLOAT ELEMENT COUNT N
        FADD TM,MD;             "FORM B+1
            DPY(1)<MD;          "SAVE B
            MOV A,A; SETMA      "FETCH A(0)
        FADD; DPX(2)<DPX(1)             "SAVE N
        MOV B,B; SETMA;MI<FA    "STORE UPDATED B
        DPX<FA; DPY<TM; JSR DIV "FORM 1/(B+1)
        MOV C,CC; SETMA;        "FETCH C(0)
            FMUL DPY(1),DPX     "B/(B+1)
PREP1:  ADD I,A; SETMA;         "1. FETCH A(1)
            FMUL;
            FADD DPX(2),ZERO    "   SET UP COUNTER
        ADD K,C; SETMA;         "2. FETCH C(1)
            FMUL DPX,MD;FADD    "   A(0)/(B+1)
        FMUL FM,MD;             "3. C(0)*B/(B+1)
            DPY<FM;             "   SAVE B/(B+1)
            SUB K,CC            "   BACK UP OUTPUT POINTER
PREP0:  ADD I,A;SETMA;          "1. FETCH A(2)
            FMUL DPX,MD         "   A(1)/(B+1)
        ADD K,C; SETMA;         "2. FETCH C(2)
            FSUBR TM,FA;        "   DECREMENT COUNTER
            DPY(1)<FM           "   SAVE A(0)/(B+1)
            FMUL DPY,MD         "3. C(1)*B/(B+1)
LOOP:   ADD I,A;SETMA;          "1. FETCH A(M+3)
            FMUL DPX,MD;        "   A(M+2)/(B+1)
                    FADD FM,DPY(1) "   FORM NEW RESULT C(M)
        ADD K,C; SETMA;         "2. FETCH C(M+3)
                FSUBR TM,FA;    "   DECREMENT COUNTER
                DPY(1)<FM       "   SAVE A(M)/(B+1)
            FMUL DPY,MD;        "3. C(M+2)*B/(B+1)
                    ADD K,CC;SETMA;MI<FA; "   STORE C(M)
                    BFNE LOOP   "   CONTINUE UNTIL
DONE:   RETURN                  "   DONE
        $END
"****** VAVEXP = VECTOR EXPONENTIAL AVERAGING /FAST/ = REL 3.2, AUG 80 *****
        $TITLE VAVEXP
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VAVEXP,6                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV,SPUFLT
"
"       ---ABSTRACT---
"COMPUTES THE EXPONENTIAL AVERAGE OF VECTOR C WITH A VECTOR A
"WHERE B IS THE DISCOUNT FACTOR (TIME CONSTANT) USED TO
"OBTAIN VECTOR C.
"
"FORMULA: C(MK)=C(MK)*(B-1)/B + A(MI)/B FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH FAST MEMORY
"SIZE: 21 LOCATIONS + DIV (28) + SPUFLT (8) = 57 LOCATIONS
"SPEED: BEST:  43+3N  (A,B EVEN; C,I,K ODD)
"       WORST: 45+6N
"       TYPICAL: 45+5N  (A,B,C EVEN; I,K ODD)
"       COLUMNS/LOOP: 4
"       FLOPS/LOOP:   3
"SUBROUTINES USED: DIV,SPUFLT
"    ---HISTORY---
"ORIGINAL:  MAR 77  R.S. NORIN
" REVISED:  SEP 78  R.S. NORIN   HANDLES N>32767 CORRECTLY
" REVISED:  SEP 79  D.GANGULY.   ZERO ARRAY SIZE TEST ADDED.
" REV 3.2   AUG 80  R. GELLER    CORRECT ADC LINKAGE
"
"
"       ---USAGE---
"FORTRAN: CALL VAVEXP(A,I,B,C,K,N)
"APAL:    JSR VAVEXP
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "ADDRESS OF DISCOUNT FACTOR
     C  $EQU  3                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  4                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  5                 "NUMBER OF ELEMENTS IN C
"OTHER TEMP STORAGE:
     CC $EQU 17
"TABLE MEMORY
 ONE  $EQU  !ONE
"
"SCRATCH:  SP(0,3,14,15), DPX(0-2), DPY(0-1), FA,FM,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVAVEX,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  62
        $PARAM  6 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3/R/IP/OP,
                    P4(#5,#6)/R/IP/OP, P5/I/IP,
                    P6/I/IP
FVAVEX: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VAVEXP: MOV B,B; SETMA          "GET DISCOUNT FACTOR
        MOV N,17
        BGT .+2
        RETURN                  "RETURN IF N=0.
        JSR SPUFLT               "FLOAT ELEMENT COUNT N
        DPX<MD; DPY(1)<MD;      "SAVE B
            MOV A,A; SETMA      "FETCH A(0)
        DPX(2)<DPX(1)             "SAVE N
        DPY<TM; JSR DIV         "FORM 1/B
        FSUBR TM,DPY(1)         "FORM B-1
        FADD
        MOV C,CC; SETMA;        "FETCH C(0)
            FMUL DPX,FA         "(B-1)/B
PREP1:  ADD I,A; SETMA;         "1. FETCH A(1)
            FMUL;
            FADD DPX(2),ZERO    "   SET UP COUNTER
        ADD K,C; SETMA;         "2. FETCH C(1)
            FMUL DPX,MD;FADD    "   A(0)/B
        FMUL FM,MD;             "3. C(0)*(B-1)/B
            DPY<FM;             "   SAVE (B-1)/B
            SUB K,CC            "   BACK UP OUTPUT POINTER
PREP0:  ADD I,A;SETMA;          "1. FETCH A(2)
            FMUL DPX,MD         "   A(1)/B
        ADD K,C; SETMA;         "2. FETCH C(2)
            FSUBR TM,FA;        "   DECREMENT COUNTER
            DPY(1)<FM           "   SAVE A(0)/B
            FMUL DPY,MD         "3. C(1)*(B-1)/B
LOOP:   ADD I,A;SETMA;          "1. FETCH A(M+3)
            FMUL DPX,MD;        "   A(M+2)/B
                    FADD FM,DPY(1) "   FORM NEW RESULT C(M)
        ADD K,C; SETMA;         "2. FETCH C(M+3)
                FSUBR TM,FA;    "   DECREMENT COUNTER
                DPY(1)<FM       "   SAVE A(M)/B
            FMUL DPY,MD;        "3. C(M+2)*(B-1)/B
                    ADD K,CC;SETMA;MI<FA; "   STORE C(M)
                    BFNE LOOP   "   CONTINUE UNTIL
DONE:   RETURN                  "   DONE
        $END
"
"****** HIST = HISTOGRAM /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE HIST
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY HIST, 7                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV
        $EXT SPUFLT
        "HISTOGRAM:    CALCULATES DATA POINTS PER UNIT INTERVAL
        "FORMULA:  C(J(M)) = C(J(M)) + 1.0   FOR M=0 TO N-1
        "                   WHERE J(M) = 0     IF A(MI)<HMIN
        "                              = NB-1  IF A(MI)>=HMAX
        "                              = FIX( NB*(A(MI)-HMIN)/(HMAX-HMIN) )
        "                                      IF HMIN<=A(MI)<HMAX
        "     ---HISTORY---
        "ORIGINAL:  DEC 76   J. THROOP
        "REV 2.1:   JUL 78   R.S. NORIN   HANDLES NUMBER OF BINS >32767
        "REV 2.2    SEP 79   D.GANGULY.   N=0 CHECK ADDED.
        "
        "SIZE:         36 + SPUFLT (8) + DIV (28) = 72 LOCATIONS
        "SPEED:        8 CYCLES PER POINT
        "SCRATCH:      SP(0,3,7,13-15),DPX(-1 TO 3), DPY(-2 TO 0),FA,FM,MD,TM
        "S PAD NAMES:
        A $EQU 0                                 "BASE ADDRESS, SOURCE VECTOR
        I $EQU 1                                 "SOURCE VECTOR INCREMENT
        C $EQU 2                                 "BASE ADDRESS, DEXTINATION VECT
        N $EQU 3                                 "LENGTH OF SOURCE VECTOR
        NB $EQU 4                                "NUMBER OF BINS
        HMX $EQU 5                                "MAXIMUM VALUE OF A(I)
        HMN $EQU 6                                "MINIMUM VALUE
        J $EQU 7
        "NAMES FOR DPX:
        HMAX $EQU -1
        D $EQU 3
        TA $EQU 1
        TB $EQU 2
        "NAMES FOR DPY:
        HMIN $EQU -2
        AMX $EQU -1
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FHIST,7                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  32
        $PARAM  7 , P1(#2,#4)/R/IP, P2/I/IP,
                    P3(#5)/R/IP/OP, P4/I/IP, P5/I/IP,
                    P6/R/IP, P7/R/IP
FHIST: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
HIST:   MOV NB,17
        JSR SPUFLT                  "GO FLOAT THE NUMBER OF BINS (7/78)
        MOV HMX,HMX;SETMA                         "FETCH HMAX
        MOV N,N;                                  "IS N=0?
        DPY<DPX(1);                              "FLOATED NUMBER OF BINS
        FSUBR TM,DPX(1)                           "NB - 1
        BGT .+2;                                  "YUP!RETURN.
        MOV HMN,HMN;SETMA;                        "FETCHH HMIN
        FADD
        RETURN                                   "N=0.THEREFORE,RETURN.
        DPX(HMAX)<MD;                            "STORE HMAX
        DPY(AMX)<FA                              "DPY(AMX) = NB - 1
        SPMDA;                                   "SPIN TIL DATA AVAILABLE
        DPY(HMIN)<MD                             "STORE HMIN
        FSUB DPX(HMAX),DPY(HMIN)                 "HMAX - HMIN
        FADD
        DPX<FA;                                  "HMAX - HMIN
        JSR DIV
        DPY(D)<DPX;                               "D=NB/(HMAX - HMIN)
                  MOV A,A;SETMA                   "FETCH A(0)
                  SPMDA;                         "SPIN TIL DATA AVAILAABLE
                  FSUBR DPY(HMIN),MD              "A(0) - HMIN
                  FSUBR DPX(HMAX),MD              "A(0) - HMAX
                  FMUL DPY(D),FA; FADD           "(A(0) -HMIN)*D
                  BFGE NM1; FMUL                 "BRANCH IF A(0)>= HMIN
                  FMUL
             ADD I,A;SETMA;                       "FETCH A(1)
                  DPX(TA)<ZERO; BR NEXT1         "SET FOR BIN ZERO
NM1:         BFGE AM1;FMUL                        "BRANCH IF A(0) >= HMAX
             ADD I,A;SETMA;                       "FETCH A(1)
             DPX(TA)<FM; BR NEXT1                "STORE (A(0)-HMIN)*D
AM1:    ADD I,A;SETMA;                           "FETCH A(1)
             DPX(TA)<DPY(AMX); BR NEXT1          "BIN = NB - 1
NEXT1:            NOP
                  FIXT DPX(TA)                    "FIX (A(0) - HMIN)*D
             FSUBR DPY(HMIN),MD                  "A(1) - HMIN
LOOP:        FSUBR DPX(HMAX),MD;                 "A(I+1) - HMAX
                  DPX(TB)<FA                     "FIXED (A(I+2) - HMIN)*D
             FMUL DPY(D),FA; FADD;
                  LDSPI J; DB=DPX(TB)            "J = BIN INDEX
             BFGE NMN; FMUL;                     "BRANCH IF A(I+1) >= HMIN
                  ADD C,J;SETMA                   "FETCH CONTENTS OF BIN(J)
             FMUL
        ADD I,A;SETMA;                           "FETCH A(I)
             DPX(TA)<ZERO                         "BIN(0)
NEXT:             FADD TM,MD                     "INCREMENT COUNT
             FIXT DPX(TA);                        "FIX (A(I+1) - HMIN)*D
                  DEC N
        FSUBR DPY(HMIN),MD;                       "A(I) - HMIN
                  MOV J,J;SETMA;MI<FA;           "STORE INCREMENTED COUNT
                  BNE LOOP                       "BRANCH IF NOT DONE
OUT:              RETURN                         "FINISHED
NMN:         BFGE AMAX; FMUL                     "BRANCH IF A(I+1) >= HMAX
        ADD I,A;SETMA;                            "FETCH A(I)
             DPX(TA)<FM; BR NEXT                 "STORRE (A(I+1) - HMIN)*D
AMAX:   ADD I,A;SETMA;                           "FETCH A(I)
             DPX(TA)<DPY(AMX); BR NEXT           "BIN = NB - 1
        $END
"****** HANN = HANNING WINDOW OF VECTOR /COMMON/ = REL 3.1, SEP 79 *****
"     FOR EITHER MEMORY
        $TITLE HANN
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY HANN,6                          "USER-DIRECTED-CALL ENTRY
        $EXT STSTAT, CLSTAT
"
"       ---ABSTRACT---
"MULTIPLIES VECTOR BY A HANNING WINDOW.
"FORMULA: C(MK)=W*A(MI)*(1.0-COS((2PI*M)/N))
"                               FOR M=0 TO N-1
"               WHERE W=0.5 FOR UNNORMALIZED HANNING
"                               (PEAK WINDOW VALUE=1.0)
"               AND   W=0.816496581 FOR NORMALIZED HANNING
"                               (PEAK WINDOW VALUE=SQRT(8/3)=1.633).
"                               NORMALIZED HANNING IS USED TO KEEP THE TOTAL
"                               POWER INVARIANT DURING THE WINDOWING OPERATION,
"                               SEE 'DIGITAL TIME SERIES ANALYSIS', ROBERT OTNES
"                               AND LOREN ENOCHSON, JOHN WILEY 1972, P. 294.
"
"NOTE: THIS ROUTINE USES THE TABLE MEMORY COSINE TABLE
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP120 WITH EITHER MEMORY
"SIZE:  24 LOCATIONS + STATUS (19 LOCATIONS) = 43 LOCATIONS
"SPEED: INTRO: 32+4LOG2(N) CYCLES
"       LOOP: 4-6 CYCLES
"       COLUMNS/LOOP: 3
"       FLOPS/LOOP: 3
"       (0.67-1.00)N + 5.33 + 0.67*LOG2(N) USEC FOR 167 NSEC CLOCK
"       MEGAFLOPS: 3.0-4.5
"SUBROUTINES USED: STSTAT,CLSTAT (IN STATUS)
"
"       --- HISTORY ---
"
"ORIGINAL:  NOV 76  R.S. NORIN
" REV 2.1:  JUL 77  R.S. NORIN        MINOR MOD TO SAVE 2 WORDS
" REVISED:  NOV 78  R.S. NORIN        LABEL !FFTX8 REPLACES TBLSZE*8
"                                       FOR APAL3 COMPATIBILITY
" REV 2.3:  SEP 79  D.GANGULY.  ADDED ZERO ARRAY SIZE TEST.
"
"       ---USAGE---
"FORTRAN: CALL HANN(A,I,C,K,N,F)
"APAL:    JSR HANN
"S-PAD PARAMETERS
"  NAME    NUMBER
    A  $EQU  0                  "BASE ADDRESS OF SOURCE VECTOR A
    I  $EQU  1                  "INCREMENT BETWEEN ELEMENTS OF A
    C  $EQU  2                  "BASE ADDRESS OF DESTINATION VECTOR C
    K  $EQU  3                  "INCREMENT BETWEEN ELEMENTS OF C
    N  $EQU  4                  "NUMBER OF ELEMENTS IN C
    F  $EQU  5                  "NORMALIZATION FLAG
                                "F=0 MEANS UNNORMALIZED HANNING WINDOW
                                    "(PEAK WINDOW VALUE=1.0)
                                "F=1 MEANS NORMALIZED HANNING WINDOW
                                    "(PEAK WINDOW VALUE=1.63)
"
"THE FOLLOWING ARE NOT ARGUMENTS:
 ANG  $EQU  15                  "ADDRESS OF COSINE TABLE VALUE
  WD  $EQU  16                  "COSINE TABLE ADDRESS INCREMENT
"
"RESTRICTIONS: N SHOULD BE A POWWER OF 2. IF N IS NOT, IT IS
"                SET TO THE NEXT LOWER POWER OF 2.
"              IN PLACE WINDOWING IS PERMITTED.
"
"SCRATCH: SP(0,2,4,15-17), DPX(0), DPY(0), DPA UNCHANGED
"
"TABLE MEMORY REFERENCES:
  TBLSZE  $EQU  !FFTSZ              "SIZE OF INSTALLED COS TABLE
  ONE     $EQU  !ONE                "ONE
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FHANN,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  72
        $PARAM  6 , P1(#2,#5)/R/IP, P2/I/IP,
                    P3(#4,#5)/R/OP, P4/I/IP,
                    P5/I/IP, P6/I/IP
FHANN: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
HANN:   MOV F,F                 "GET NORMALIZATION FLAG
        LDTMA; DB=ONE;          "GET 1.0 FROM TABLE MEMORY
            BGT NORM                "GET WEIGHTING FACTOR
UNNORM: RPSF FACU; DPY<DB;      "GET UNNORMALIZED WEIGHTING=0.5
            BR COMMON
NORM:   RPSF FACN; DPY<DB       "GET NORMALIZED WEIGHTING=0.816=SQRT(2/3)
COMMON: MOV A,A; SETMA;         "GET A(0)
            DPX<TM                  "SAVE 1.0
        LDSPI 16; DB=-1         "SET UP FFT MODE AND
        MOV N,17                    "BIT-REVERSE BITS
        BGT .+2
        RETURN                      "IF N<=0,RETURN.
        JSR STSTAT              "BY CALLING STSTAT WHICH
                                "RETURNS LOG2(N) IN SP(17).
        LDSPI WD; DB=!FFTX8      "GET ADDRESS FOR INCREMENT OF 2PI
        CLR ANG; SETTMA          "GET COS(0)
        DEC 17                  "GET ANGLE ADDRESS INCREMENT
        MOVR WD,WD; BGT .-1     "BY DIVIDING BY LOG2(N)+1
PREP1:  ADD WD,ANG; SETTMA;     "GET COS(WD)
            FMUL DPY,MD;            "W*A(0)
            FSUBR TM,DPX            "FORM 1-COS(0)
        ADD I,A; SETMA;         "GET A(I)
            FADD;FMUL               "PUSHERS
        SUB K,C;                "NULLIFY FIRST ADD K,C
            FMUL                    "PUSH
LOOP:   ADD WD,ANG; SETTMA;     "1. COS((M+2)WD)
            FSUBR TM,DPX;       "   1-COS((M+1)WD)
                FMUL FM,FA      "   W*A(M)*(1-COS(M*WD))
        ADD I,A; SETMA;         "2. GET A((M+2)I)
            FMUL DPY,MD;        "   W*A((M+1)I)
            FADD                    " PUSH
            FMUL;               "3. PUSH
                DEC N           "   DECREMENT COUNT
            FMUL;               "4. PUSH
                ADD K,C; SETMA; MI<FM; "STORE C(MK)
                BNE LOOP        "   CONTINUE UNTIL
DONE:   JMP CLSTAT              "DONE. CLEAR FFT STATUS.
                                "EXIT THRU CLSTAT
"FLOATING POINT CONSTANTS:
FACU:   $FP  0.5                    "UNNORMALIZED WEIGHTING FACTOR
FACN:   $FP  0.816496581            "NORMALIZED WEIGHTING FACTOR
"
        $END
"****** VDBPWR = VECTOR CONVERSION TO DB (POWER)  /COMMON/ = REL 3.1, SEP 79 **
        $TITLE VDBPWR
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY VDBPWR,6                          "USER-DIRECTED-CALL ENTRY
        $EXT DIV
"
"       ---ABSTRACT---
"COMPUTES THE DB (POWER) EQUIVALENT OF THE ABSOLUTE VALUES
"OF THE ELEMENTS OF A VECTOR, RELATIVE TO A REFERENCE SCALAR VALUE.
"
"FORMULA: C(MK)=10.0 * LOG10 (A(MI)/B) FOR M=0 TO N-1
"ACCURACY:  ERROR LESS THAN +- 0.1 DB.
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 50 LOCATIONS + DIV (28) = 78 LOCATIONS
"SPEED: FAST: 7N
"       STANDARD: 8N
"       COLUMNS/LOOP: 5
"SUBROUTINES USED: DIV
"AUTHOR: R.S. NORIN
"DATE:   APR 77
"
"       ---USAGE---
"FORTRAN: CALL VDBPWR(A,I,B,C,K,N)
"APAL:    JSR VDBPWR
"
"
"       --- HISTORY ---
"
"ORIGINAL:APR 77.  R.S.NORIN.
"REVISION: SEP 79.  D.GANGULY. ZERO ARRAY SIZE TEST ADDED.
"
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     I  $EQU  1                 "INCREMENT BETWEEN ELEMENTS OF A
     B  $EQU  2                 "ADDRESS OF SCALAR REFERENCE VALUE (0 DB)
     C  $EQU  3                 "BASE ADDRESS OF DESTINATION VECTOR C
     K  $EQU  4                 "INCREMENT BETWEEN ELEMENTS OF C
     N  $EQU  5                 "NUMBER OF ELEMENTS IN C
"OTHER TEMP STORAGE:
     C27 $EQU 15
     UE $EQU 16
     SE $EQU 17
"TABLE MEMORY
 ONE  $EQU  !ONE
 TEN  $EQU  !TEN
 LOGE $EQU  !LOGE
 LN2  $EQU  !LN2
"
"SCRATCH:  SP(0,3-5,13-15), DPX(-1 TO 2), DPY(-2 TO 3), FA,FM,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FVDBPR,6                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  62
        $PARAM  6 , P1(#2,#6)/R/IP, P2/I/IP,
                    P3/R/IP,
                    P4(#5,#6)/R/OP, P5/I/IP,
                    P6/I/IP
FVDBPR: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VDBPWR: MOV B,B; SETMA              "GET SCALAR 0 DB REF
        LDTMA; DB=ONE;              "GET 1.0
          MOV N,N
          BGT .+2
        RETURN                    "IS N=0?IF SO RETURN TO CALLER
        SUB K,C "BACK UP OUTPUT POINTER
        MOV A,A; SETMA;             "GET A(0)
          DPX(0)<MD                 "SAVE B
        DPY(0)<TM; JSR DIV          "FORM 1/B
        RPSF B0; DPY(0)<DB          "GET POLYNOMIAL CONSTANTS
        RPSF B1; DPY(1)<DB
        RPSF B2; DPY(2)<DB
        RPSF B3; DPY(3)<DB
        LDTMA; DB=TEN               "GET 10.0
        LDTMA; DB=LOGE              "GET LOG10(E)
        FMUL DPX(0),MD;             "A(0)/B=W(0)
          DPX(-1)<TM;               "SAVE 10.0
          DEC C                     "ADJUST OUTPUT POINTER
        FMUL TM,DPX(-1)             "10.0*LOG10(E)
        FMUL;
          DPX(-1)<TM;               "SAVE 10.0
          ADD I,A; SETMA            "GET A(1)
        DPY(-1)<FM;                 "SAVE W(0)
          LDSPI C27; DB=27.         "EXPONENT FOR FLOAT
S2:         FABS DPY(-1);           "2. X(0)=ABS(W(0))
            LDSPE SE; DB=DPY(-1)    "   GET S(0)=EXP(X(0))
        FMUL DPX(0),MD;             "3. A(1)/B
            FADD;                   "   PUSH
            MOV SE,SE; DPX(1)<SPFN  "   S(0) TO DPX(1)
            DPX(-1)<FA;             "4. SAVE X(0)
              LDTMA; DB=LN2         "   GET LN(2) FROM TM
        FMUL;                       "5. PUSH
            FADD ZERO,MDPX(-1);CLR UE; "   FLOAT U(0)
              DPX(2)<FM             "   SAVE 10.0*LOG10(E)
        FMUL;                       "6. PUSH
            FADD                    "   PUSH
        DPY(-1)<FM;                 "7. SAVE A(1)/B=W(1)
            FMUL DPY(3),FA;         "   U(0)*B3
            FADD ZERO,MDPX(1);MOV C27,C27; "   FLOAT S(0)
            DPX(-1)<FA              "   SAVE U(0)
S3:     ADD I,A;SETMA;              "1. GET A(2)
                FMUL DPX(-1),DPY(1); "   U(0)*B1
                FADD
            FABS DPY(-1);           "2. X(1)=ABS(W(1))
            LDSPE SE;DB=DPY(-1);    "   GET S(1)= EXP(X(1))
                FMUL DPX(-1),DPX(-1); "   U(0)*U(0)
                DPX(1)<FA           "   SAVE S(0)
            MOV SE,SE;DPX(1)<SPFN;  "3. S(1) TO DPX(1)
                FMUL TM,DPX(1);     "   S(0)*LN(2)
                FADD FM,DPY(2)      "   B2+B3*U(0)
        FMUL DPX(0),MD;             "4. A(2)/B=W(2)
            DPX(-1)<FA;             "   SAVE X(1)
                FADD FM,DPY(0)      "   B0+B1*U(0)
            FADD ZERO,MDPX(-1);CLR UE; "5. FLOAT U(1)
                FMUL FM,FA          "   U(0)*U(0)*(B2+B3*U(0))
        FMUL;                       "6. PUSH
                FADD FM,FA          "   B0+B1*U(0)+S(0)*LN(2)
        DPY(-1)<FM;                 "7. SAVE W(2)
            FMUL DPY(3),FA;         "   B3*U(1)
            FADD ZERO,MDPX(1);MOV C27,C27; "   FLOAT S(1)
            DPX(-1)<FA              "   SAVE U(1)
S4:     ADD I,A;SETMA;              "1. GET A(3)
                FMUL DPX(-1),DPY(1); "   B1*U(1)
                    FADD FM,FA      "   LN(X(0))
            FABS DPY(-1);           "2. X(2)=ABS(W(2))
            LDSPE SE;DB=DPY(-1);    "   S(2)=EXP X(1)
                FMUL DPX(-1),DPX(-1); "   U(1)*U(1)
                DPX(1)<FA           "   SAVE S(1)
            MOV SE,SE;DPX(1)<SPFN;  "3. S(2) TO DPX(1)
                FMUL TM,DPX(1);     "   S(1)*LN(2)
                FADD FM,DPY(2);     "   B2+B3*U(1)
                    DPY(-1)<FA      "   SAVE Y(0)=LN(X(0))
        FMUL DPX(0),MD;             "4. A(3)/B=W(3)
            DPX(-1)<FA;             "   SAVE X(2)
                FADD FM,DPY(0)      "   B0+B1*U(1)
            FADD ZERO,MDPX(-1);CLR UE; "5. FLOAT U(2)
                FMUL FM,FA          "   U(1)*U(1)*(B2+B3*U(1))
                FADD FM,FA;         "6. B0+B1*U(1)+S(1)*LN(2)
                    FMUL DPY(-1),DPX(2) "   10*LOG10(E)*Y(0)
        DPY(-1)<FM;                 "7. SAVE W(3)
            FMUL DPY(3),FA;         "   B3*U(2)
            FADD ZERO,MDPX(1);MOV C27,C27; "   FLOAT S(2)
            DPX(-1)<FA              "   SAVE U(2)
LOOP:   ADD I,A;SETMA;              "1. GET A(M+4)
                FMUL DPX(-1),DPY(1); "   B1*U(M+2)
                    FADD FM,FA      "   LN(X(M+1))
            FABS DPY(-1);           "2. X(M+3)=ABS(W(M+3))
            LDSPE SE;DB=DPY(-1);    "   S(M+3)=EXP X(M+2)
                FMUL DPX(-1),DPX(-1); "   U(M+2)*U(M+2)
                DPX(1)<FA;          "   SAVE S(M+2)
                        DPY(-2)<FM  "   SAVE C(M)
            MOV SE,SE;DPX(1)<SPFN;  "3. S(M+3) TO DPX(1)
                FMUL TM,DPX(1);     "   S(M+2)*LN(2)
                FADD FM,DPY(2);     "   B2+B3*U(M+2)
                    DPY(-1)<FA      "   SAVE Y(M+1)=LN(X(M+1))
        FMUL DPX(0),MD;             "4. A(M+4)/B=W(M+4)
            DPX(-1)<FA;             "   SAVE X(M+3)
                FADD FM,DPY(0);     "   B0+B1*U(M+2)
                        ADD K,C;SETMA            "   FALSE READ TO SET ADDRESS
            FADD ZERO,MDPX(-1);CLR UE; "5. FLOAT U(M+3)
                FMUL FM,FA;         "   U(M+2)*U(M+2)*(B2+B3*U(M+2))
                        INCMA;MI<DPY(-2) "   STORE RESULT
                FADD FM,FA;         "6. B0+B1*U(M+2)+S(M+2)*LN(2)
                    FMUL DPY(-1),DPX(2);"   10*LOG10(E)*Y(M+1)
                        DEC N       "   DECREMENT COUNT
        DPY(-1)<FM;                 "7. SAVE W(M+4)
            FMUL DPY(3),FA;         "   B3*U(M+3)
            FADD ZERO,MDPX(1);MOV C27,C27; "   FLOAT S(M+3)
            DPX(-1)<FA;             "   SAVE U(M+3)
                        BNE LOOP    "   LOOP UNTIL DONE
DONE:   RETURN                      "EXIT
"CONSTANTS:
B0:     $FP -2.1859335
B1:     $FP  4.2253087
B2:     $FP -2.9164778
B3:     $FP  0.87754422
        $END
"****** ASPEC = ACCUMUMULATING AUTO-SPECTRUM /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE ASPEC
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY ASPEC,3                          "USER-DIRECTED-CALL ENTRY
        $EXT SCJMA
"
"       ---ABSTRACT---
"
"PERFORMS ACCUMULATING AUTOSPECTRUM ON COMPLEX VECTOR.
"
"FORMULA:  C(M) = C(M) + A(2M)**2 + A(2M+1)**2    FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 9 + SCJMA (15) = 24
"EXECUTION      BEST     TYPICAL     WORST       SETUP(US)
"TIME/LOOP:     1.33       1.33       1.33        2.33        167 NS MEMORY
" (US)          1.5        1.5        1.67        2.33        333 NS MEMORY
"
"
"     --- HISTORY ---
"ORIGINAL:  JUL 77  R.S. NORIN
"REVISION:  SEP 79  D.GANGULY. ZERO ARRAY SIZE TEST ADDED.
"
"
"       ---USAGE---
"FORTRAN: CALL ASPEC(A,C,N)
"APAL:    JSR ASPEC
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR (COMPLEX)
     C  $EQU  1                 "BASE ADDRESS OF DESTINATION VECTOR C  (REAL)
     N  $EQU  2                 "NUMBER OF ELEMENTS IN C
"
"SCRATCH:  SP(0-6),DPX(0),FA,FM,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FASPEC,3                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  4
        $PARAM  3 , P1(2,#3)/R/IP, P2(2,#3)/R/IP/OP,
                    P3/I/IP
FASPEC: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ASPEC:  MOV N,6                 "REARRANGE THE S-PADS FOR CALL TO SCJMA
        BGT .+2;                "IS N=0 ?
        MOV C,4
        RETURN                  " YES.RETURN.
        MOV C,4
        MOV C,2
        LDSPI 1; DB=2
        LDSPI 3; DB=1
        MOV 3,5
        JMP SCJMA               "EQUIVALENT TO CALL SCJMA(A,2,C,1,C,1,N)
                                "EXIT THRU SCJMA
        $END
"****** CSPEC = ACCUMULATING CROSS-SPECTRUM /COMMON/ = REL 3.2, AUG 80 *****
        $TITLE CSPEC
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CSPEC,4                          "USER-DIRECTED-CALL ENTRY
        $EXT CVMA
"
"       ---ABSTRACT---
"
"ACCUMULATES COMPLEX RESULTS OF CROSS-SPECTRUM OF TWO VECTORS.
"MOST COMMONLY USED TO AVERAGE CROSS-SPECTRA OF TWO CHANNELS OF DATA OVER
"SEVERAL DATA FRAMES.
"
"FORMULA:  C(2M)+IC(2M+1) = (C(2M)+IC(2M+1)) + (A(2M)-IA(2M+1))*(B(2M)+IB(2M+1))
"                                         FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 12 + CVMA (30) = 42
"EXECUTION      BEST     TYPICAL     WORST       SETUP(US)
"TIME/LOOP:     2.67       2.67       2.67        3.17        167 NS MEMORY
" (US)          2.67       2.67       3.33        3.33        333 NS MEMORY
"
"
"     --- HISTORY ---
"ORIGINAL:  JUL 77  R.S. NORIN
"REVISION:  SEP 79  D.GANGULY. ZERO ARRAY SIZE TEST ADDED.
" REV 3.2:  AUG 80  R. GELLER   CORRECT ADC LINKAGE
"
"
"       ---USAGE---
"FORTRAN: CALL CSPEC(A,B,C,N)
"APAL:    JSR CSPEC
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR (COMPLEX)
     B  $EQU  1                 "BASE ADDRESS OF SOURCE VECTOR (COMPLEX)
     C  $EQU  2                 "BASE ADDRESS OF DESTINATION VECTOR C  (COMPLEX)
     N  $EQU  3                 "NUMBER OF COMPLEX ELEMENTS
"
"SCRATCH:  SP(0-8),DPX(0,1),DPY(0,1),FA,FM,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCSPEC,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  10
        $PARAM  4 , P1(2,#4)/R/IP, P2(2,#4)/R/IP,
                    P3(2,#4)/R/IP/OP,
                    P4/I/IP
FCSPEC: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CSPEC:  MOV N,10                 "REARRANGE THE S-PADS FOR CALL TO SCJMA
        BGT .+2                  "IS N =0 ?
        RETURN                   "YUP!.RETURN.
        MOV C,6
        MOV C,4
        MOV B,2
        LDSPI 1; DB=2
        MOV 1,3
        MOV 1,5
        MOV 1,7
        LDSPI 11; DB=-1
        JMP CVMA                "EQUIVALENT TO CALL CVMA(A,2,B,2,C,2,C,2,N,-1)
                                "EXIT THRU CVMA
        $END
"****** TRANS = TRANSFER FUNCTION /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE TRANS
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY TRANS,4                          "USER-DIRECTED-CALL ENTRY
        $EXT CRVDIV
"
"       ---ABSTRACT---
"
"CALCULATES THE COMPLEX TRANSFER FUNCTION BY DIVIDING THE COMPLEX CROSS-
"SPECTRUM OF TWO VECTORS BY THE REAL AUTO-SPECTRUM OF A VECTOR.
"
"FORMULA:  C(2M)+IC(2M+1) = (B(2M)+IB(2M+1)) / A(M)      FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 9  + CRVDIV (92) = 101
"EXECUTION      BEST     TYPICAL     WORST       SETUP(US)
"TIME/LOOP:     3.33       3.33       3.33        12.5        167 NS MEMORY
" (US)          3.33       3.33       3.33        12.5        333 NS MEMORY
"
"
"     --- HISTORY ---
"ORIGINAL:  JUL 77  R.S. NORIN
"REVISION:  SEP 79  D.GANGULY. ZERO ARRAY SIZE TEST ADDED.
"
"
"       ---USAGE---
"FORTRAN: CALL TRANS(A,B,C,N)
"APAL:    JSR TRANS
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF AUTOSPECTRUM VECTOR (REAL)
     B  $EQU  1                 "BASE ADDRESS OF CROSS-SPECTRUM VECTOR (COMPLEX)
     C  $EQU  2                 "BASE ADDRESS OF DESTINATION VECTOR C  (COMPLEX)
     N  $EQU  3                 "NUMBER OF COMPLEX ELEMENTS
"
"SCRATCH:  SP(0-15),DPX(-2 TO 3),DPY(-4 TO 2),FA,FM,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FTRANS,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  10
        $PARAM  4 , P1(#4)/R/IP, P2(2,#4)/R/IP,
                    P3(2,#4)/R/OP,
                    P4/I/IP
FTRANS: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
TRANS:  MOV N,6                 "REARRANGE THE S-PADS FOR CALL TO SCJMA
        BGT .+2;                "IS N = 0 ?
        MOV C,4
        RETURN                  "YES.RETURN.
        MOV A,2
        MOV B,0
        LDSPI 1; DB=2
        MOV 1,5
        LDSPI 3; DB=1
        JMP CRVDIV                "EQUIVALENT TO CALL CRVDIV(B,2,A,1,C,2,N)
                                "EXIT THRU CRVDIV
        $END
"****** COHER = COHERENCE FUNCTION /COMMON/ = REL 3.1, SEP 79 *****
        $TITLE COHER
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY COHER,5                          "USER-DIRECTED-CALL ENTRY
        $EXT CVMAGS,VDIV
"
"       ---ABSTRACT---
"
"COMPUTES COHERENCE FUNCTION OF TWO SIGNALS AS THE CROSS-SPECTRUM TIMES
"THE CONJUGATE OF THE CROSS-SPECTRUM, DIVIDED BY THE PRODUCT OF THE TWO
"AUTO-SPECTRUMS.
"
"FORMULA:  D(M) = (C(2M)**2 + C(2M+1)**2) / (A(M)*B(M))  FOR M=0 TO N-1
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 22 + VDIV (75) + CVMAGS (13 FAST, 18 SLOW) = 110 (FAST MEM), 115 (SLOW ME
"
"EXECUTION      BEST     TYPICAL     WORST       SETUP(US)
"TIME/LOOP:     4.0        4.0        4.17        13.5        167 NS MEMORY
" (US)          4.5        4.5        4.67        13.83       333 NS MEMORY
"
"
"     --- HISTORY ---
"ORIGINAL:  JUL 77  R.S. NORIN
"REVISION:  SEP 79  D.GANGULY. ZERO ARRAY SIZE TEST ADDED.
"
"
"       ---USAGE---
"FORTRAN: CALL COHER(A,B,C,D,N)
"APAL:    JSR COHER
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF AUTO-SPECTRUM VECTOR (REAL)
     B  $EQU  1                 "BASE ADDRESS OF AUTO-SPECTRUM VECTOR (REAL)
     C  $EQU  2                 "BASE ADDRESS OF CROSS-SPECTRUM VECTOR C  (COMPL
     D  $EQU  3                 "BASE ADDRESS OF DESTINATION VECTOR (REAL)
     N  $EQU  4                 "NUMBER OF ELEMENTS
"
"SCRATCH:  SP(0-15),DPX(-1 TO 3),DPY(-4 TO 2),FA,FM,MD,TM
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FCOHER,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  20
        $PARAM  5 , P1(#5)/R/IP, P2(#5)/R/IP,
                    P3(2,#5)/R/IP, P4(#5)/R/OP,
                    P5/I/IP
FCOHER: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
COHER:  MOV N,14                "REARRANGE THE S-PADS FOR CALLS TO CVMAGS AND VD
        BGT .+2;
        MOV D,13
        RETURN                  "IF N=0,RETURN.
        MOV B,12
        MOV A,6
        MOV C,0
        MOV D,2
        LDSPI 3; DB=1
        LDSPI 1; DB=2
        JSR CVMAGS              "EQUIVALENT TO CALL CVMAGS(C,2,D,1,N)
        MOV 6,0
        MOV 3,1
        MOV 3,5
        MOV 13,2
        MOV 13,4
        MOV 14,6
        JSR VDIV                "EQUIVALENT TO CALL VDIV(A,1,D,1,D,1,N)
        MOV 12,0
        MOV 13,2
        MOV 13,4
        MOV 14,6
        JMP VDIV                "EQUIVALENT TO CALL VDIV(B,1,D,1,D,1,N)
                                "EXIT THRU VDIV
        $END
"****** ACORT = AUTO-CORRELATION USING TIME-DOMAIN /COMMON/= REL 3.1, SEP 79
        $TITLE ACORT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY ACORT,4                          "USER-DIRECTED-CALL ENTRY
        $EXT TCONV
"
"       ---ABSTRACT---
"
"COMPUTES N LAGS OF THE AUTO-CORRELATION OF VECTOR A OF LENGTH M.
"PROGRAM USES TIME-DOMAIN TECHNIQUES (TCONV).
"
"FORMULA: C(P) = SUM FROM Q=0 TO M-P-1 (A(P+Q) * A(Q))  FOR M=0 TO N-1
"NOTE:   C MUST NOT OVERLAY A.
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 12 + TCONV (112) = 124
"
"EXECUTION TIMES (MS) FOR EITHER MEMORY:
"  N=8   M=128    0.29
"   32     128    0.76
"  128     128    3.0
"    8    1024    2.3
"   32    1024    5.9
"  128    1024   23.4
" 1024    1024   93.6
"
"
"
"     --- HISTORY ---
"ORIGINAL:  JUL 77  R.S. NORIN
"REVISION:  SEP 79  D.GANGULY. ZERO ARRAY SIZE TEST ADDED.
"
"
"       ---USAGE---
"FORTRAN: CALL ACORT(A,C,N,M)
"APAL:    JSR ACORT
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR
     C  $EQU  1                 "BASE ADDRESS OF DESTINATION VECTOR C
     N  $EQU  2                 "ELEMENT COUNT FOR C (NUMBER OF LAGS)
     M  $EQU  3                 "ELEMENT COUNT FOR A
"
"SCRATCH:  SP(0-15),DPA,DPX(0-31),DPY(0-31),FA,FM,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FTACOR,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  14
        $PARAM  4 , P1(#4)/R/IP, P2(#3)/R/OP,
                    P3/I/IP, P4/I/IP
FTACOR: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ACORT:  MOV M,10                "REARRANGE S-PAD PARAMETERS FOR CALL TO TCONV
        BEQ  RTRN               "RETURN IF M=0.
        MOV M,7
        MOV N,6
        BEQ RTRN                "RETURN IF N=0.
        LDSPI 5; DB=1
        MOV C,4
        MOV 5,3
        MOV A,2
        MOV 5,1
        JMP TCONV               "EQUIVALENT TO CALL TCONV(A,1,A,1,C,1,N,M,M)
                                "EXIT THRU TCONV
RTRN:   RETURN
        $END
"****** CCORT = CROSS-CORRELATION USING TIME-DOMAIN /COMMON= REL 3.1, SEP 79
        $TITLE CCORT
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CCORT,5                          "USER-DIRECTED-CALL ENTRY
        $EXT TCONV
"
"       ---ABSTRACT---
"
"COMPUTES N LAGS OF THE CROSS-CORRELATION OF VECTORS A AND B, EACH OF LENGTH M.
"PROGRAM USES TIME-DOMAIN TECHNIQUES (TCONV).
"
"FORMULA: C(P) = SUM FROM Q=0 TO M-P-1 (A(P+Q) * B(Q))  FOR M=0 TO N-1
"NOTE:   C MAY OVERLAY A, BUT NOT B.
"
"       ---STATISTICS---
"LANGUAGE: APAL
"EQUIPMENT: AP-120 WITH EITHER MEMORY
"SIZE: 12 + TCONV (112) = 124
"
"EXECUTION TIMES (MS) FOR EITHER MEMORY:
"  N=8   M=128    0.29
"   32     128    0.76
"  128     128    3.0
"    8    1024    2.3
"   32    1024    5.9
"  128    1024   23.4
" 1024    1024   93.6
"
"
"
"     --- HISTORY ---
"ORIGINAL:  JUL 77  R.S. NORIN
"REVISION:  SEP 79  D.GANGULY. ZERO ARRAY SIZE TEST ADDED.
"
"
"       ---USAGE---
"FORTRAN: CALL CCORT(A,B,C,N,M)
"APAL:    JSR CCORT
"S-PAD PARAMETERS
"   NAME     NUMBER
     A  $EQU  0                 "BASE ADDRESS OF SOURCE VECTOR (OPERAND)
     B  $EQU  1                 "BASE ADDRESS OF SOURCE VECTOR (OPERATOR)
     C  $EQU  2                 "BASE ADDRESS OF DESTINATION VECTOR C
     N  $EQU  3                 "ELEMENT COUNT FOR C (NUMBER OF LAGS)
     M  $EQU  4                 "ELEMENT COUNT FOR A AND B
"
"SCRATCH:  SP(0-15),DPA,DPX(0-31),DPY(0-31),FA,FM,MD
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FTCCOR,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  30
        $PARAM  5 , P1(#5)/R/IP, P2(#5)/R/IP, P3(#4)/R/OP,
                    P4/I/IP, P5/I/IP
FTCCOR: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CCORT:  MOV M,10                "REARRANGE S-PAD PARAMETERS FOR CALL TO TCONV
        BEQ RTRN                "IS M = 0 ?
        MOV M,7
        MOV N,6
        BEQ RTRN                "IS N= 0?
        LDSPI 5; DB=1
        MOV C,4
        MOV 5,3
        MOV B,2
        MOV 5,1
        JMP TCONV               "EQUIVALENT TO CALL TCONV(A,1,B,1,C,1,N,M,M)
                                "EXIT THRU TCONV
RTRN:   RETURN
        $END
"****** ACORF = AUTO-CORRELATION (FREQUENCY-DOMAIN) /COMMO= REL 3.1, SEP 79
        $TITLE ACORF    "DEFINE ACORF(A,C,N,M)
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $EXT SPADD
        $EXT VCLR
        $EXT RFFT
        $EXT VMUL
        $EXT SPSUB
        $EXT CVMAGS
        $EXT RFFTSC
        $EXT VMOV
        $EXT SAVESP,SETSP,SAVSP0
        $ENTRY ACORF,4                          "USER-DIRECTED-CALL ENTRY
"
"    --- ABSTRACT ---
"PERFORMS AUTO-CORRELATION USING FFT TECHNIQUES.
"FORMULA AND PARAMETERS ARE THE SAME AS ACORT.
"ROUTINE REQUIRES 2M WORDS FOR VECTOR A.
"PROGRAM WAS PRODUCED BY THE VECTOR FUNCTION CHAINER.
"
"
"    --- STATISTICS ---
"LANGUAGE: APAL
"EQUIPMENT:  AP120B WITH EITHER MEMORY
"SIZE:  82 + SETSP (28) + SAVESP (18) + SAVSP0 (10) + SPADD (1) + SPSUB (1)
"       + VCLR (13 FAST, 4 SLOW) + RFFT (253 FAST, 251 SLOW) + VMUL (17 FAST,
"       11 SLOW) + CVMAGS (13 FAST, 18 SLOW) + RFFTSC (59) + VMOV (14 FAST,
"       6 SLOW) - 2 * SPFLT (10 FAST)    =   499 FAST, 489 SLOW  TOTAL WORDS
"
"EXECUTION TIMES (MS):       167 NS MEM       333 NS MEM
"  N=8   M=128                  1.80             2.70
"   32     128                  1.82             2.73
"  128     128                  1.87             2.80
"    8    1024                 16.18            23.72
"   32    1024                 16.20            23.75
"  128    1024                 16.25            23.82
" 1024    1024                 16.70            24.53
"
"       --- HISTORY ---
"ORIGINAL:  JUL 77    R.S NORIN
"REVISION:  SEP 79  D.GANGULY. ZERO ARRAY SIZE TEST ADDED.
"
"
"     ---  EQUIVALENT VECTOR FUNCTION CHAINER CODE  ---
"     DEFINE ACORF(A,C,N,M)
"
"------PERFORMS AUTOCORRELATION FUNCTION ON A VECTOR
"      USING FFT TECHNIQUES.  GENERALLY RUNS FASTER THAN ACORT
"      BUT REQUIRES 2M STORAGE LOCATIONS INSTEAD OF M.
"
"      PARAMETERS: A = SOURCE VECTOR BASE ADDRESS
"                  C = DESTINATION VECTOR BASE ADDRESS
"                  N = ELEMENT COUNT FOR C (NUMBER OF LAGS)
"                  M = ELEMENT COUNT FOR A (POWER OF 2)
"
"      FORMULA:    C(PK)=SUM FROM Q=0 TO M-P-1 (A(P+Q)*A(Q))
"                              FOR P=0 TO N-1
"
"     INTEGER A,C,N,M
"------INSERT M ZEROS IN A
"       LOCAL APM
"       APM=A+M
"     CALL VCLR(APM,1,M)
"------DO A 2M FFT
"       LOCAL MPM
"       MPM=M+M
"     CALL RFFT(A,MPM,1)
"------PERFORM AN AUTO-SPECTRUM RETAINING THE ZEROS FOR IMAG PARTS
"------FIRST THE FUNNY COMPLEX PAIR
"     CALL VMUL(A,1,A,1,A,1,2)
"------THEN THE REMAINING M-1 COMPLEX PAIRS
"------   OPERATE ON REALS
"       LOCAL AP2,MM1
"       AP2=A+2
"       MM1=M-1
"     CALL CVMAGS(AP2,2,AP2,2,MM1)
"------   ZERO THE IMAGS
"       LOCAL AP3
"       AP3=A+3
"     CALL VCLR(AP3,2,MM1)
"------DO A 2M IFT
"------DIVIDE BY 4M TO SCALE PROPERLY
"     CALL RFFTSC(A,MPM,-1,-1)
"     CALL RFFT(A,MPM,-1)
"------MOVE FIRST N VALUES TO RESULT BUFFER
"     CALL VMOV(A,1,C,1,N)
"     RETURN
"     END
        L $EQU 0
        R $EQU 2000
        V $EQU 0
        C $EQU 4000
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FFACOR,4                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  14
        $PARAM  4 , P1(2,#4)/R/IP, P2(#3)/R/OP,
                    P3/I/IP, P4/I/IP
FFACOR: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ACORF:  MOV 2,2
        BGT .+2                         "RETURN IF N = 0.
        RETURN
        MOV 3,3
        BGT.+2                          "RTURN IF M = 0.
        RETURN
        JSR SAVESP
        $VAL 0,4,0,P-.
"
"LOCAL APM
        JSR SETSP       "APM=A+M
        $VAL 0,2,V+L,P-.+0
        $VAL V+R,P-.+1,0,0
        JSR SPADD
        JSR SAVSP0
        $VAL V+L,P-.+2,0,0
        JSR SETSP       "CALL VCLR(APM,1,M)
        $VAL 0,3,V+L,P-.+2
        $VAL C,1,V+R,P-.+1
        JSR VCLR
"LOCAL MPM
        JSR SETSP       "MPM=M+M
        $VAL 0,2,V+R,P-.+1
        $VAL V+R,P-.+1,0,0
        JSR SPADD
        JSR SAVSP0
        $VAL V+R,P-.+2,0,0
        JSR SETSP       "CALL RFFT(A,MPM,1)
        $VAL 0,3,V+L,P-.+0
        $VAL V+R,P-.+2,C,1
        JSR RFFT
        JSR SETSP       "CALL VMUL(A,1,A,1,A,1,2)
        $VAL 0,7,V+L,P-.+0
        $VAL C,1,V+L,P-.+0
        $VAL C,1,V+L,P-.+0
        $VAL C,1,C,2
        JSR VMUL
"LOCAL AP2,MM1
        JSR SETSP       "AP2=A+2
        $VAL 0,2,V+L,P-.+0
        $VAL C,2,0,0
        JSR SPADD
        JSR SAVSP0
        $VAL V+L,P-.+3,0,0
        JSR SETSP       "MM1=M-1
        $VAL 0,2,V+R,P-.+1
        $VAL C,1,0,0
        JSR SPSUB
        JSR SAVSP0
        $VAL V+R,P-.+3,0,0
        JSR SETSP       "CALL CVMAGS(AP2,2,AP2,2,MM1)
        $VAL 0,5,V+L,P-.+3
        $VAL C,2,V+L,P-.+3
        $VAL C,2,V+R,P-.+3
        JSR CVMAGS
"LOCAL AP3
        JSR SETSP       "AP3=A+3
        $VAL 0,2,V+L,P-.+0
        $VAL C,3,0,0
        JSR SPADD
        JSR SAVSP0
        $VAL V+L,P-.+4,0,0
        JSR SETSP       "CALL VCLR(AP3,2,MM1)
        $VAL 0,3,V+L,P-.+4
        $VAL C,2,V+R,P-.+3
        JSR VCLR
        JSR SETSP       "CALL RFFTSC(A,MPM,-1,-1)
        $VAL 0,4,V+L,P-.+0
        $VAL V+R,P-.+2,C,-1
        $VAL C,-1,0,0
        JSR RFFTSC
        JSR SETSP       "CALL RFFT(A,MPM,-1)
        $VAL 0,3,V+L,P-.+0
        $VAL V+R,P-.+2,C,-1
        JSR RFFT
        JSR SETSP       "CALL VMOV(A,1,C,1,N)
        $VAL 0,5,V+L,P-.+0
        $VAL C,1,V+R,P-.+0
        $VAL C,1,V+L,P-.+1
        JSR VMOV
        NOP
        RETURN
P:      $VAL 0,0,0,0    "A      C
        $VAL 0,0,0,0    "N      M
        $VAL 0,0,0,0    "APM    MPM
        $VAL 0,0,0,0    "AP2    MM1
        $VAL 0,0,0,0    "AP3
"
        $END
"****** CCORF = CROSS-CORRELATION (FREQUENCY-DOMAIN) /COMMON= REL 3.1, SEP 79
"
"
"
        $TITLE CCORF    "DEFINE CCORF(A,B,C,N,M)
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $EXT SPADD
        $EXT SPSUB
        $EXT VCLR
        $EXT RFFT
        $EXT VMUL
        $EXT CVMUL
        $EXT RFFTSC
        $EXT VMOV
        $EXT SAVESP,SETSP,SAVSP0
        $ENTRY CCORF,5                          "USER-DIRECTED-CALL ENTRY
"
"    --- ABSTRACT ---
"PERFORMS CROSS-CORRELATION USING FFT TECHNIQUES.
"FORMULA AND PARAMETERS ARE THE SAME AS CCORT.
"ROUTINE REQUIRES 2M WORDS FOR VECTOR A, AND 2M WORDS FOR VECTOR B.
"PROGRAM WAS PRODUCED BY THE VECTOR FUNCTION CHAINER.
"
"
"    --- STATISTICS ---
"LANGUAGE: APAL
"EQUIPMENT:  AP120B WITH EITHER MEMORY
"SIZE:  95 + SETSP (28) + SAVESP (18) + SAVSP0 (10) + SPADD (1) + SPSUB (1)
"       + VCLR (13 FAST, 4 SLOW) + RFFT (253 FAST, 251 SLOW) + VMUL (17 FAST,
"       11 SLOW) + CVMUL (25 FAST, 26 SLOW) + RFFTSC (59) + VMOV (14 FAST,
"       6 SLOW) - 2*SPFLT (10 FAST)    =   521 FAST, 510 SLOW  TOTAL WORDS
"
"EXECUTION TIMES (MS):       167 NS MEM       333 NS MEM
"  N=8   M=128                  2.58             3.93
"   32     128                  2.60             3.96
"  128     128                  2.65             4.03
"    8    1024                 23.30            34.66
"   32    1024                 23.32            34.69
"  128    1024                 23.35            34.76
" 1024    1024                 23.80            35.47
"
"       --- HISTORY ---
"ORIGINAL:  JUL 77    R.S NORIN
"REVISION:  SEP 79  D.GANGULY. ZERO ARRAY SIZE TEST ADDED.
"
"
"
"      ---  EQUIVALENT VECTOR FUNCTION CHAINER CODE  ---
"
"     DEFINE CCORF(A,B,C,N,M)
"
"------PERFORMS CROSSCORRELATION FUNCTION ON A VECTOR
"      USING FFT-TECHNIQUES.  THIS ROUTINE GENERALLY WILL RUN FASTER
"      FOR LARGE M AND N BUT REQUIRES 2M STORAGE LOCATIONS FOR BOTH
"      A AND B (4M TOTAL) INSTEAD OF M AS IN CCORT.
"
"
"      PARAMETERS: A = SOURCE VECTOR (OPERAND) BASE ADDRESS
"                  B = SOURCE VECTOR (OPERATOR) BASE ADDRESS
"                  C = DESTINATION VECTOR BASE ADDRESS
"                  N = ELEMENT COUNT FOR C (NUMBER OF LAGS)
"                  M = ELEMENT COUNT FOR A AND B (POWER OF 2)
"
"      FORMULA:    C(PK)=SUM FROM Q=0 TO M-P-1 (A(P+Q)*B(Q))
"                              FOR P=0 TO N-1
"
"     INTEGER A,B,C,N,M
"------INSERT M ZEROS IN A AND B
"       LOCAL APM,BPM,MPM,AP2,BP2,MM1
"       APM=A+M
"       BPM=B+M
"       MPM=M+M
"       AP2=A+2
"       BP2=B+2
"       MM1=M-1
"     CALL VCLR(APM,1,M)
"     CALL VCLR(BPM,1,M)
"------DO THE 2M FFTS ON A AND B
"     CALL RFFT(A,MPM,1)
"     CALL RFFT(B,MPM,1)
"------PERFORM CROSS-SPECTRUM
"------FIRST THE FUNNY COMPLEX PAIR
"     CALL VMUL(A,1,B,1,A,1,2)
"------THEN ON THE REMAINING M-1 COMPLEX PAIRS
"     CALL CVMUL(BP2,2,AP2,2,AP2,2,MM1,-1)
"------DO A 2M IFT
"------DIVIDE BY 4M TO SCALE PROPERLY
"     CALL RFFTSC(A,MPM,-1,-1)
"     CALL RFFT(A,MPM,-1)
"------MOVE N VALUES TO RESULT BUFFER
"     CALL VMOV(A,1,C,1,N)
"     RETURN
"     END
        L $EQU 0
        R $EQU 2000
        V $EQU 0
        C $EQU 4000
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FFCCOR,5                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  30
        $PARAM  5 , P1(2,#5)/R/IP, P2(2,#5)/R/IP, P3(#4)/R/OP,
                    P4/I/IP, P5/I/IP
FFCCOR: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CCORF:  MOV 3,3
        BGT .+2
        RETURN
        MOV 4,4
        BGT .+2
        RETURN
        JSR SAVESP
        $VAL 0,5,0,P-.
"
"LOCAL APM,BPM,MPM,AP2,BP2,MM1
        JSR SETSP       "APM=A+M
        $VAL 0,2,V+L,P-.+0
        $VAL V+L,P-.+2,0,0
        JSR SPADD
        JSR SAVSP0
        $VAL V+R,P-.+2,0,0
        JSR SETSP       "BPM=B+M
        $VAL 0,2,V+R,P-.+0
        $VAL V+L,P-.+2,0,0
        JSR SPADD
        JSR SAVSP0
        $VAL V+L,P-.+3,0,0
        JSR SETSP       "MPM=M+M
        $VAL 0,2,V+L,P-.+2
        $VAL V+L,P-.+2,0,0
        JSR SPADD
        JSR SAVSP0
        $VAL V+R,P-.+3,0,0
        JSR SETSP       "AP2=A+2
        $VAL 0,2,V+L,P-.+0
        $VAL C,2,0,0
        JSR SPADD
        JSR SAVSP0
        $VAL V+L,P-.+4,0,0
        JSR SETSP       "BP2=B+2
        $VAL 0,2,V+R,P-.+0
        $VAL C,2,0,0
        JSR SPADD
        JSR SAVSP0
        $VAL V+R,P-.+4,0,0
        JSR SETSP       "MM1=M-1
        $VAL 0,2,V+L,P-.+2
        $VAL C,1,0,0
        JSR SPSUB
        JSR SAVSP0
        $VAL V+L,P-.+5,0,0
        JSR SETSP       "CALL VCLR(APM,1,M)
        $VAL 0,3,V+R,P-.+2
        $VAL C,1,V+L,P-.+2
        JSR VCLR
        JSR SETSP       "CALL VCLR(BPM,1,M)
        $VAL 0,3,V+L,P-.+3
        $VAL C,1,V+L,P-.+2
        JSR VCLR
        JSR SETSP       "CALL RFFT(A,MPM,1)
        $VAL 0,3,V+L,P-.+0
        $VAL V+R,P-.+3,C,1
        JSR RFFT
        JSR SETSP       "CALL RFFT(B,MPM,1)
        $VAL 0,3,V+R,P-.+0
        $VAL V+R,P-.+3,C,1
        JSR RFFT
        JSR SETSP       "CALL VMUL(A,1,B,1,A,1,2)
        $VAL 0,7,V+L,P-.+0
        $VAL C,1,V+R,P-.+0
        $VAL C,1,V+L,P-.+0
        $VAL C,1,C,2
        JSR VMUL
        JSR SETSP       "CALL CVMUL(BP2,2,AP2,2,AP2,2,MM1,-1)
        $VAL 0,8.,V+R,P-.+4
        $VAL C,2,V+L,P-.+4
        $VAL C,2,V+L,P-.+4
        $VAL C,2,V+L,P-.+5
        $VAL C,-1,0,0
        JSR CVMUL
        JSR SETSP       "CALL RFFTSC(A,MPM,-1,-1)
        $VAL 0,4,V+L,P-.+0
        $VAL V+R,P-.+3,C,-1
        $VAL C,-1,0,0
        JSR RFFTSC
        JSR SETSP       "CALL RFFT(A,MPM,-1)
        $VAL 0,3,V+L,P-.+0
        $VAL V+R,P-.+3,C,-1
        JSR RFFT
        JSR SETSP       "CALL VMOV(A,1,C,1,N)
        $VAL 0,5,V+L,P-.+0
        $VAL C,1,V+L,P-.+1
        $VAL C,1,V+R,P-.+1
        JSR VMOV
        NOP
        RETURN
P:      $VAL 0,0,0,0    "A      B
        $VAL 0,0,0,0    "C      N
        $VAL 0,0,0,0    "M      APM
        $VAL 0,0,0,0    "BPM    MPM
        $VAL 0,0,0,0    "AP2    BP2
        $VAL 0,0,0,0    "MM1
"
        $END
"
"
"
"****** TCONV = POST-TAPERED CONVOLUTION /COMMON/ = REL 3.1, SEP 79 *****
      $TITLE TCONV
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
      $ENTRY TCONV,9.                          "USER-DIRECTED-CALL ENTRY
"              ---ABSTRACT---
"THIS DOES A TAPERED CONVOLUTION (J<0) OR CORRELATION (J>0), WITH THE
"OPERATOR POINTS IN VECTOR B, THE TRACE POINTS (DATA POINTS) IN
"VECTOR A, AND THE ANSWER POINTS IN VECTOR C.
"TAPERED CONVOLUTION IS EQUIVALENT TO CONVOLUTION IN WHICH N+M-1-L ZEROS
"ARE ADDED TO THE END OF THE TRACE A.  TCONV, HOWEVER, INSERTS THE
"ZEROS AUTOMATICALLY SO THAT TRACE A NEED BE ONLY L ELEMENTS LONG.
"
"FORMULA: C(PK)=SUM FROM Q=0 TO R (A((P+Q)I)*B(QJ)
"                                     FOR P=0 TO N-1
"                 WHERE R=MIN(M-1,L-P-1)
"              ---STATISTICS---
"LANGUAGE:     AP-120B ASSEMBLER
"EQUIPMENT:    AP-120B
"STORAGE:      PS - 126
"              MD - NONE
"              TM - NONE
"              DPX - 32.
"              DPY - 32.
"              SP - 8.
"AUTHOR:      R.S. NORIN
"DATE:         NOV 1976
"REV 2: MAY 77 -- ADDS 9TH PARAMETER L TO SPECIFY TRACE LENGTH.
"                   IT WAS PREVIOUSLY ASSUMED TO BE N.
"              ---USAGE---
"FORTRAN: CALL TCONV(A,I,B,J,C,K,N,M,L)
"APAL:    JSR TCONV
"ARGUMENTS:    IN S-PAD
"                0     A - BASE ADDRESS OF A (TRACE)
"                1     I - INCREMENT FOR A
"                2     B - BASE ADDRESS OF B (OPERATORS)
"              3     J - INCREMENT FOR B
"              4     C - BASE ADDRESS OF C (ANSWER)
"              5     K - INCREMENT FOR C
"              6     N - NUMBER OF ANSWERS (C)
"              7     M - NUMBER OF OP POINTS (B)
"             10     L - NUMBER OF TRACE POINTS (A)
"SCRATCH:      SP(0-15.), DPX(0-31), DPY(0-31),DPA,FA,FM,MD
"              DPA(0-31)
"RESTRICTIONS: I>0, N>0, M>0, L>0
"              ---ALGORITHM---
"LOOP1A MULTIPLIES THE FIRST OPERATOR POINT BY EACH
""OF THE FIRST 32. TRACE POINTS, AND PUTS THE PRODUCTS
"IN THE FIRST 32. ANSWER POINTS. THEN IT GETS THE
"NEXT OP. PT., MULTIPLIES IT BY TRACE PTS. 2-33, ADDS
"THE PRODUCTS TO THE PREVIOUS ANSWERS, AND PUTS THEM
"BACK IN ANSWER POINTS 1-32.  THE NEXT OP. PT. IS
"MULTIPLIED BY TRACE PTS. 3-34, THE PRODUCTS ARE
"ADDED TO ANSWER PTS. 1-32, AND THEN PUT BACK THERE.
"THIS CONTINUES UNTIL IT HAS RUN OUT OF OP. PTS.
"ZEROS ARE INSERTED IN PLACE OF TRACE POINTS AFTER THE L TRACE
"POINTS HAVE BEEN USED.
"ANSWER PTS. 1-32 NOW REPRESENT THE FINAL BLOCK
"OF THE FIRST 32 ANSWERS.
"
"IF THERE IS ANOTHER BLOCK OF 32 (OR MORE) ANSWER
"POINTS TO DETERMINE, THEN IT WILL START OVER WITH THE
"FIRST OP. PT. TRACE PTS. 33-64, AND PUT THE PRODUCTS
"IN ANSWER PTS. 33-64.  IT FOLLOWS THE ABOVE PATTERN
"UNTIL IT RUNS OUT OF OP. PTS.
"ZEROS ARE INSERTED AFTER TRACE POINT 100
"LOOP2 ROUTES THE PROBLEM TO LOOP1A AS MANY TIMES AS
"THERE ARE BLOCKS OF 32 ANSWERS DESIRED.  WHEN THERE
"ARE LESS THAN 32 LEFT TO DO, THE PROBLEM GOES TO
"LOOP1B, WHICH GENERALLY DOES THE SAME THING AS
"LOOP1A EXCEPT THAT IT HANDLES THE TRACE AND ANSWER PTS.
"IN BLOCKS OF LESS THAN 32.
"EXAMPLE:  100 ANSWER PTS. ARE DESIRED.
"LOOP2 PUTS THE FIRST 32 TRACE PTS. IN DPX. LOOP1A
"MULTIPLIES EACH BY THE FIRST OP. PT., PUTS THE
"PRODUCTS IN THE 32 DPY REGISTERS.  DPX(2-32)
"ARE MOVED INTO DPX(1-31), AND THE NEXT TRACE PT.(33)
"IS MOVED INTO DPX(32).  THUS, THE NEXT OP. PT. IS
"MULTIPLIED BY TRACE PTS. 2-33, THE PRODUCTS ARE ADDED
"TO DPY(1-32), AND THESE SUMS GO BACK INTO DPY(1-32).
"WHEN ALL OP. PTS. HAVE BEEN USED, DPY(1-32) IS STORED
"INTO THE FINAL ANSWER VECTOR.
"LOOP2 DETERMINES THAT THERE IS ANOTHER BLOCK OF
"32 ANSWER PTS. TO BE DONE, PUTS TRACE PTS. 33-64 INTO
"DPX(1-32), AND LETS LOOP1A TAKE OVER AGAIN.  THIS
"MULTIPLIES DPX(1-32) BY THE FIRST OP. PT., PUTS THE
"PRODUCTS INTO DPY(1-32) (DPY WAS INITIALIZED TO ZERO
"BY LOOP2), MOVES DPX(2-32) INTO DPX(1-31), GETS THE
"NEXT TRACE PT.(65), AND PUTS IT INTO DPX(32),
"MULTIPLIES DPX(1-32) BY THE NEXT OP. PT., ADDS THE 32
"PRODUCTS TO DPY(1-32), MOVES DPX(2-32) INTO DPX(1-31), GETS
"THE NEXT TRACE PT.(66) AND PUTS IT INTO DPX(32), ETC.
"WHEN IT RUNS OUT OF OP. PTS., DPY(1-32) IS STORED INTO
"FINAL ANSWER PTS. 33-64.
"LOOP2 PUTS TRACE PTS. 65-96 INTO DPX(1-32) AND GIVES IT
"TO LOOP1A ONCE MORE. WHEN LOOP1A RUNS OUT OF OP.
"PTS., DPY(1-32) IS STORED INTO ANSWER PTS. 65-96.
"NOW LOOP2 FINDS THAT THERE ARE ONLY 4 ANSWER PTS. LEFT TO
"DO.  IT PUTS TRACE PTS. 97-100 INTO DPX(1-4), THEN GOES
"TO LOOP1B.  THIS MULTIPLIES DPX(1-4) BY THE FIRST OP. PT.,
"PUTS THE PRODUCTS INTO DPY(1-4), MOVES DPX(2-4) INTO
"DPX(1-3), GETS A ZERO SINCE THE NEXT TRACE PT WOULD HAVE BEEN
"(101) AND PUTS THE ZERO INTO
"DPX(1-3), GETS THE NEXT TRACE PT.(101) AND PUTS IT INTO
"DPX(4), MULTIPLIES DPX(1-4) BY THE NEXT OP. PT., ETC.
"FINALLY, DPY(1-4) ARE STORED INTO ANSWER PTS. 97-100,
"AND THE PROBLEM IS DONE.
"ACTUALLY, THE CONSTRUCTION OF LOOP1B REQUIRES A
"MINIMUM OF 6 ANSWER PTS. DESIRED.  IF THERE ARE LESS
"THAN THAT TO DO, IT BRANCHES OFF TO 5 SPECIAL CASES
"(ELSE 1-ELSE5).
"S-PAD PARAMETERS:
A = 0
I = 1
B = 2
J = 3
C = 4
K = 5
N = 6
M = 7
L = 10
"THE FOLLOWING ARE NOT PARAMETERS:
ALWA = 10
SAVEB = 11
SAVEA = 12
SAVEM = 13
JUNK = 14
ITT = 15
CCTR = 16
TEMP = 16
TT = 17
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FTCONV,9.                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  752
        $PARAM  9., P1(#2,#11)/R/IP, P2/I/IP,
                    P3(#4,#10)/R/IP, P4/I/IP,
                    P5(#6,#7)/R/OP, P6/I/IP,
                    P7/I/IP, P8/I/IP, P9/I/IP
FTCONV: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
TCONV:  MOV B,SAVEB
        MOV A, SAVEA
        MOV M,SAVEM
        BGT .+2
        RETURN                          "RETURN IF M=0.
        MOV N,N
        BGT .+2
        RETURN                          "RETURN IF N=0.
        MOV L,L
        BGT .+2
        RETURN                          "RETURN IF L=0.
        LDSPI TT; DB=32.
        CLR ITT                         "DO I
        MOV A,TEMP
        MOV I,JUNK                      "    *
        SUB K,C;                        "BACK UP OUTPUT POINTER
          BEQ J0
        ADD L,TEMP              "GET LAST ADDRESS +1 OF TRACE
        DEC JUNK                        "     32.
        ADD TT,ITT; BGT .-2             "     =ITT
J0:     MOV TEMP,ALWA                   "SAVE LAST ADDRESS +1 OF TRACE
LOOP2:  SUB# TT,N                       "TEST IF NEED TO DO
        BGE .+2                          "BLOCK OF 32 OR LESS
                                        "IF LESS,
        CFL1; MOV N,CCTR; BR .+2        " USE REMAINING N
        SFL1; MOV TT,CCTR                "OTHERWISE, USE 32.
        DB=ZERO; LDDPA; MOV CCTR,JUNK
       MOV SAVEA,A; SETMA;             "GET FIRST TR PT FROM BLOCK
        DPY<ZERO
GET:    SUB# ALWA,A                "THIS LOOP PUTS TR POINTS
        DPY<ZERO; DEC JUNK;        "OR ZEROS INTO DPX(1-32)
          BGE T00               "AND ZEROS INTO DPY(1-32)
        ADD I,A;SETMA; DPX<MD; INCDPA;
          BGT GET
        BR .+2
T00:    ADD I,A;SETMA; DPX<ZERO; INCDPA;
          BGT GET
        BFL1 .+2                        "CHECK IF DOING 32 OR LESS
        JMP LESS
"IF BLOCK OF 32:
        MOV SAVEB,B; SETMA              "GET FIRST OP PT
        DB=2; LDDPA                     "DPA=2
        DB=24.; LDSPI CCTR
        FMUL DPX(-2),MD;                "DO FIRST TR PT
          SUB I,A                       " * FIRST OP PT
"HEREAFTER, THE NTH TRACE PT AND OP PT WILL BE
"REFERRED TO AS TR(N) AND OP(N)
        FMUL DPX(-1),MD;                "DO TR(2)*OP(1)
          DPX(-2)<DPX(-1);              "MOVE TR(2) INTO TR(1)
                                        " POSITION FOR NEXT
          MOV CCTR,JUNK                 " TIME AROUND
        FMUL DPX,MD;                    "DO TR(3)*OP(1)
          DPX(-1)<DPX                   "MOVE TR(3) INTO TR(2)
"NTH ANSWER PT = ANS(N)
LOOP1A: FADD FM,DPY(-2);                "DO ANS(1)+TR(1)*OP(L)
          FMUL DPX(1),MD;               "DO TR(4)*OP(L)
          DPX<DPX(1)                    "MOVE TR(4) INTO TR(3)
        FADD FM,DPY(-1);                "DO ANS(2)+TR(2)*OP(L)
          FMUL DPX(2),MD;               "DO TR(5)*OP(L)
          DPX(1)<DPX(2);                "MOVE TR(5) INTO TR(4)
          DEC JUNK
        DPY(-2)<FA;  INCDPA;            "STORE ANS(P-2)
          FADD FM,DPY;                  "ANS(P)+TR(P)*OP(L)
          FMUL DPX(3),MD; DPX(2)<DPX(3); "TR(P+3)*OP(L)
          DEC JUNK; BGT .               " MOVE TR(P+3) INTO TR(P+2)
        DPY(-2)<FA; INCDPA;             "SAME AS ABOVE
          FADD FM,DPY;                  " FOR P=P+1
          FMUL DPX(3),MD; DPX(2)<DPX(3);
          ADD I,A; SETMA                "GET NEXT TR PT
        DPY(-2)<FA; INCDPA;             "STORE ANS(26)
          FADD FM,DPY;                  "ANS(28)+TR(28)*OP(L)
          FMUL DPX(3),MD;               "DO TR(31)*OP(L)
          SUB# ALWA,A;          "TEST FOR END OF TRACE
          DPX(2)<DPX(3)                  "MOVE TR(31) INTO TR(30)
        DPY(-2)<FA; INCDPA;             "SAME AS ABOVE,
          FADD FM,DPY;                  " INCREMENTING NUMERAL
          FMUL DPX(3),MD; DPX(2)<DPX(3);" INDICES BY ONE
          ADD J,B; SETMA;               "GET OP(L+1)
          BGE T32               "STORE ZERO IF END OF TRACE
        DPY(-2)<FA; INCDPA;             "STORE ANS(28)
          FADD FM,DPY;                  "ANS(30)+TR(30)*OP(L)
          DPX(2)<MD; FMUL;              "MOVE NEW TR PT INTO  TR(32)
          BR COM32
T32:    DPY(-2)<FA; INCDPA;     "STORE ANS(28)
          FADD FM,DPY;          "ANS(30)+TR(30)*OP(L)
          DPX(2)<ZERO; FMUL     "MOVE ZERO INTO TR(32)
COM32:  DPY(-2)<FA; INCDPA;             "STORE ANS(29)
          FADD FM,DPY;                  "ANS(31)+TR(31)*OP(L)
          FMUL
        DPY(-2)<FA; INCDPA;             "STORE ANS(30)
          FADD FM,DPY;                  "ANS(32)+TR(32)*OP(L)
          FMUL DPX(1),MD;               "NEW TR(1)*OP(L+1)
          MOV CCTR,JUNK                 "RE-INIT INNER COUNTER
        DPY(-2)<FA; INCDPA;             "STORE ANS(31)
          FADD; FMUL DPX(1),MD;          "NEW TR(2)*OP(L+1)
          DPX<DPX(1);                   "MOVE TR(2) INTO TR(1)
          DEC M
        DPY(-2)<FA; INCDPA;             "STORE ANS(32)
          FMUL DPX(1),MD;               "TR(3)*OP(L+1)
          DPX<DPX(1);                   "MOVE TR(3) INTO TR(2)
          BGT LOOP1A                    "TEST IF DONE ALL OP PTS
        DB=ZERO; LDDPA;                 "IF SO, SUBTRACT
          SUB TT,N                      " 32 FROM N
        BGT .+2; MOV TT,JUNK    "COUNT=32
        JMP STORE
        DEC JUNK
        ADD K,C; SETMA; MI<DPY;         "STORE BLOCK OF
          INCDPA; BGT .-1               " 32 ANSWERS
        MOV SAVEM,M                     "RESTORE OP PT COUNTER
                                        "SET NEXT TR PT BLOCK
        ADD ITT,SAVEA                   " STARTING PT
        JMP LOOP2                       "BACK TO LOOP2
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY ONE ANSWER
        FMUL DPX(-2),MD
ELSE1:  FMUL; ADD I,A; SETMA
        FMUL; SUB# ALWA,A       "TEST FOR END OF TRACE
        FADD FM,DPY(-2);
          ADD J,B; SETMA; BGE T1
        FADD; DPX(-2)<MD; DEC M;
          BR COMM1
T1:     FADD; DPX(-2)<ZERO; DEC M "ZERO IF END OF TRACE
COMM1:  DPY(-2)<FA; MOV CCTR,JUNK;
          BGT ELSE1 - 1
        JMP OUT
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY TWO ANSWERS
        FMUL DPX(-2),MD
        FMUL DPX(-1),MD;
          DPX(-2)<DPX(-1)
ELSE2:  FMUL; ADD I,A; SETMA
        FMUL; FADD FM,DPY(-2);
          SUB# ALWA,A           "TEST FOR END OF TRACE
        FADD FM,DPY(-1);
          ADD J,B; SETMA; BGE T2
        DPY(-2)<FA; FADD;
          DPX(-1)<MD; DEC M;
          BR COM2
T2:     DPY(-2)<FA; FADD;
          DPX(-1)<ZERO; DEC M   "ZERO IF END OF TRACE
COM2:   DPY(-1)<FA; MOV CCTR,JUNK;
          BGT ELSE2 - 2
        JMP OUT
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY THREE ANSWERS
T3:     DPY(-1)<FA; FADD;
          DPX<ZERO; DEC M;      "ZERO IF END OF TRACE
          BR COM3               "RETURN TO MAIN PART OF LOOP
ELSE3:  FADD FM,DPY(-2); FMUL;
          ADD I,A; SETMA
        FADD FM,DPY(-1); FMUL;
          SUB# ALWA,A           "TEST FOR END OF TRACE
        DPY(-2)<FA;
          FADD FM,DPY;
          ADD J,B; SETMA; BGE T3
        DPY(-1)<FA; FADD;
          DPX<MD; DEC M
COM3:   DPY<FA; MOV CCTR,JUNK;
          BGT LOOP1B
        JMP OUT
JUMP1:  JMP ELSE1
JUMP2:  JMP ELSE2
"LEADING INTO LOOP1B...THE PROGRAM HAS JUMPED HERE
"IF THERE WERE LESS THAN 32 ANSWER PTS (LEFT) TO DO
LESS:   SUB I,A
        MOV SAVEB,B; SETMA              "GET OP(1)
        DEC CCTR
        DB=2; LDDPA; MOV CCTR,JUNK      "DPA=2
LOOP1B: FMUL DPX(-2),MD;                 "TR(1)*OP(L)
                                        "TEST IF GO TO
          DEC JUNK; BEQ JUMP1           " SPECIAL CASE 1
        FMUL DPX(-1),MD;                "TR(2)*OP(L)
          DPX(-2)<DPX(-1);              "MOVE TR(2) INTO TR(1)
          DEC JUNK; BEQ JUMP2           "TEST SPEC CASE 2
        FMUL DPX,MD;                    "TR(3)*OP(L)
          DPX(-1)<DPX;                     "MOVE TR(3) INTO TR(2)
          DEC JUNK; BEQ ELSE3           "TEST SPEC CASE 3
        FADD FM,DPY(-2);                "ANS(1)+TR(1)*OP(L)
          FMUL DPX(1),MD;               "TR(4)*OP(L)
          DPX<DPX(1);                   "MOVE TR(4) INTO TR(3)
          DEC JUNK; BEQ ELSE4           "TEST SPEC CASE 4
        FADD FM,DPY(-1);                "ANS(2)+TR(2)*OP(L)
          FMUL DPX(2),MD;               "TR(5)*OP(L)
          DPX(1)<DPX(2);                "MOVE TR(5) INTO TR(4)
          DEC JUNK; BEQ ELSE5           "TEST SPEC CASE 5
        DPY(-2)<FA; INCDPA;             "STORE ANS(P)
          FADD FM,DPY;                  "ANS(P+2)+TR(P+2)*OP(L)
          FMUL DPX(3),MD; DPX(2)<DPX(3); "TR(P+5)*OP(L)
          DEC JUNK; BGT .               "TR(P+5) INTO TR(P+4)
        DPY(-2)<FA; INCDPA;             "STORE ANS(P+1)
          FADD FM,DPY; FMUL;            "ANS(P+3)+TR(P+3)*OP(L)
          ADD I,A; SETMA                "GET NEXT TR PT
        DPY(-2)<FA; INCDPA;             "STORE ANS(P+2)
          FADD FM,DPY; FMUL;            "ANS(P+4)+TR(P+4)*OP(L)
          SUB# ALWA,A           "TEST FOR END OF TRACE
        DPY(-2)<FA; INCDPA;             "STORE ANS(P+3)
          FADD FM,DPY;                  "ANS(P+5)+TR(P+5)*OP(L)
          ADD J,B; SETMA;               "GET OP(L+1)
          BGE T31
        DPY(-2)<FA; INCDPA;              "STORE ANS(P+4)
          FADD; DPX(-1)<MD;             "MOVE NEXT TR PT
          DEC M;                        " INTO TR(P+5)
          BR COM31
T31:    DPY(-2)<FA; INCDPA;     "STORE ANS(P+4)
          FADD; DPX(-1)<ZERO;   "MOVE ZERO
          DEC M                 " INTO TR(P+5)
COM31:  DB=2; LDDPA;                       "DPA=2
          DPY(-2)<FA;                    "STORE ANS(P+5)
          MOV CCTR,JUNK;
          BGT LOOP1B                    "TEST IF DONE ALL OP PTS
OUT:    DB=ZERO; LDDPA; BR STORE;       "IF SO, GO TO STORE
          INC JUNK
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY 4 ANSWERS
ELSE4:  FADD FM,DPY(-1); FMUL;
          ADD I,A; SETMA
        DPY(-2)<FA;
          FADD FM,DPY; FMUL;
          SUB# ALWA,A           "TEST FOR END OF TRACE
        DPY(-1)<FA;
          FADD FM,DPY(1);
          ADD J,B; SETMA; BGE T4
        DPY<FA; FADD;
          DPX(1)<MD; DEC M
COM4:   DPY(1)<FA;
          MOV CCTR,JUNK;
           BGT BLP1B
        JMP OUT
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULAGE ONLY 5 ANSWERS
ELSE5:  DPY(-2)<FA;
          FADD FM,DPY; FMUL;
          ADD I,A; SETMA
        DPY(-1)<FA;
          FADD FM,DPY(1); FMUL;
          SUB# ALWA,A           "TEST FOR END OF TRACE
        DPY<FA;
          FADD FM,DPY(2);
          ADD J,B; SETMA; BGE T5
        DPY(1)<FA; FADD;
          DPX(2)<MD; DEC M
COM5:   DPY(2)<FA;
           MOV CCTR,JUNK;
          BGT .+2
        JMP OUT
BLP1B:  JMP LOOP1B
"THE PROGRAM HAS JUMPED HERE IF THE LAST ANSWERS
"ARE READY TO STORE
STORE:  DEC JUNK
        ADD K,C; SETMA; MI<DPY;         "STORE THEM
          INCDPA; BGT STORE
        RETURN
"THE NEXT IS A PIECE OF ELSE4 LOOP, PUT HERE FOR AVOIDING BRANCH ADDRESS
"OUT OF RANGE ELSEWHERE IN THE PROGRAM
T4:     DPY<FA; FADD;
          DPX(1)<ZERO; DEC M; BR COM4 "ZERO IF END OF TRACE
"NEXT COMES A PIECE OF ELSE5 LOOP
T5:     DPY(1)<FA; FADD;
          DPX(2)<ZERO; DEC M; BR COM5 "ZERO IF END OF TRACE
        $END
"****** DECFIR = CONVOLUTION WITH DECIMATION /COMMON/ = REL 3.0, SEP 79
        $TITLE DECFIR
        $RADIX 8
        XADC $EQU 1         "CONDITIONAL ASSEMBLY PARAM.FOR ADC/APFTN.
        $ENTRY DECFIR,6         "UDC MODE ENTRY POINT.
        $EXT SPDIV,SPMUL
"              ---ABSTRACT---
"FIR FILTERS AN INPUT VECTOR USING A CONVOLUTION TECHNIQUE INCORPORATING
"DECIMATION BY A FACTOR D. THE UNDECIMATED INPUT SIGNAL IS IN VECTOR A,
"THE FILTER COEFFS ARE IN VECTOR B & THE RESULTS ARE IN VECTOR C.
"
"FORMULA:
"              C(K) = SUM (A(D*K+Q)*B(Q)) FROM Q = 0 TO M-1 &
"              K = 0 TO (N/D)-1.
"              NOTE: THIS ASSUMES THAT THE OPERATOR ARRAY,B
"              IS LOADED WITH THE ELEMENTS ARRANGED IN REVERSE
"              ORDER.
"
"REFERENCES:  (1) A.PELED & B.LIU, "DIGITAL SIGNAL PROCESSING.
"                 THEORY,DESIGN & IMPLEMENTATION ."
"             (2) R.E.CROCHIERE & L.R.RABINER, "OPTIMUM FIR
"                 DIGITAL FILTER IMPLEMENTATION FOR DECIMATION,
"                 INTERPOLATION & NARROW BAND FILTERING.  "IEEE
"                 TRNS. ACCOUST. SPEECH SIGN. PROCESS. VOL
"                 ASSP-23 PP 444-456, OCT.1975.
"              ---STATISTICS---
"LANGUAGE:     AP-120B ASSEMBLER
"EQUIPMENT:    AP-120B WITH EITHER MEMORY
"STORAGE:      PS - 257
"              DPX - 32.
"              DPY - 32.
"              SP - 8.
"AUTHOR:       D.GANGULY (MODIFIED  S.CAMLEY'S CONV ROUTINE)
"DATE:         JAN 1979
"              ---USAGE---
"SAMPLE CALL:  CALL CONV (A,B,C,D,N,M)
"ARGUMENTS:    IN S-PAD
"                0     A - BASE ADDRESS OF A (UNDECIMATED SIGNAL)
"                1     B - BASE ADDRESS OF B (OPERATORS)
"                2     C - BASE ADDRESS OF C (ANSWER)
"                3     D - DECIMATION FACTOR (INTEGRAL)
"                4     N - ELEMENT COUNT OF C WHEN CONVOLVING W/O DECIMATION
"                5     M - NUMBER OF OP POINTS (ELEMENT COUNT FOR B)
"                6     I - ELEMENT COUNT FOR A.(USED ONLY IN ADC MODE.)
"SCRATCH:      SP(0-16.), DPX(0-31), DPY(0-31)
"              DPA(0-31)
"
"EXTERNALS:    SPDIV,SPMUL
"
"
"------------------------------------------------------------------------
"   S-PAD ASSIGNMENTS.
"------------------------------------------------------------------------
A = 0                           "UNDECIMATED VECTOR BASE ADDRESS.(INPUT).
B = 1                           "OPERATOR VECTOR BASE ADDRESS.
C = 2                           "DESTINATION VECTOR BASE ADDRESS.
D = 3                           "DECIMATION FACTOR.
N = 4                           "ELEMENT COUNT EXPECTED FOR C WHEN
                                "WHEN CONVOLVING WITHOUT DECIMATION.
M = 5                           "ELEMENT COUNT FOR B.
"THE FOLLOWING ARE NOT PARAMETERS:
I = 6                           "IN ADC MODE,CONTAINS THE ELEMENT COUNT
                                " FOR A.AFTER THE CALL,IT CAN BE ERASED.
J = 7
TT = 10
SAVEB = 11
SAVEA = 12
SAVEM = 13
JUNK = 14
ITT = 15
CCTR = 16
TF = 17
"
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
" *** CONDITIONAL ASSEMBLY ***
"
        $IF XADC = 1
        $SUBR FDECFR,7
        $EXT RESLVE
        BITMAP $EQU 170
        $PARAM 7, P1(#7)/R/IP,P2(#6)/R/IP,
                  P3(#5)/R/OP,P4/I/IP,
                  P5/I/IP,P6/I/IP,P7/I/IP
FDECFR: LDSPI 17;DB = BITMAP
        JSR RESLVE
        $ENDIF
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
"---------------------------------------------------------------------------
"              THE MAIN PROGRAMME.
"---------------------------------------------------------------------------
DECFIR: DEC C
        MOV B,SAVEB
        MOV A, SAVEA
        MOV M,SAVEM
        BGT .+2                         "IS M=0 ?
        JMP RTRN                        "YES.RETURN.
        MOV D,D                         "VERIFY THAT D>0
        BGT DECOUT
        LDSPI 15;DB=1                   "IF NOT,SET SP(15)=1.
        JMP RTRN                        "EXIT IF 0 OR LESS.
"---------------------------------------------------------------------------
"       DECIMATE THE NUMBER OF OUTPUT POINTS.
"---------------------------------------------------------------------------
DECOUT: MOV N,0                         "<SP(0)>=ORG.N.
        BGT .+2                         "IS N =0 ?
        JMP RTRN                        "YES.RETURN.
        MOV D,1                         "D,THE DEC.FACTOR-> SP(1).
        JSR SPDIV                       "DO <SP(0)>=INT(N/D)
        MOV 0,N                         "N=DECIMATED NO.OF OUTPUT PTS.
"---------------------------------------------------------------------------
"       COMPUTE THE SIZE OF THE INPUT DATA TO BE TRANSFERRED INTO DP'S.
"---------------------------------------------------------------------------
CBLKSZ: LDSPI 0;DB=32.                  "<SP(0)>=32.
        MOV D,1                         "<SP(1)>=D=DEC.FACTOR.
        JSR SPDIV                       "DO 32/D
        JSR SPMUL                       "DO INT(32/D)*D=BLK.SIZE.
        MOV 0,TT                        "TT=BLOCK SIZE.
"-------------------------------------------------------------------------
"  COMPUTE THE ADDRESS INCREMENT ASSOCIATED WITH THE BLOCK BOUNDARIES OF
"                               A.
"--------------------------------------------------------------------------
CAADDI: MOV TT,0                        "SP(0) CONTAINS BLK.SIZE.
        MOV D,1                         "SP(1)    ''    D.
        JSR SPMUL                       "DO BLK.SIZE*D=A'S ADDR.INC.
        MOV 0,ITT                       "ITT = A'S ADD.INCREMENT.
        LDSPI TF;DB=-8.                 "SET TF,THE INNERMOST LOOP CNTR.,
        ADD TT,TF                       " TO TT-8.
        MOV SAVEM,J                     "SET J,THE LOOP1A CNTR.
        ADD SAVEB,J                     " = M+BASE ADDR.OF H
                                        " =UPPER LIMIT OF H'S TO BE ACCESSED.
"----------------------------------------------------------------------------
"       CHECK THE SIZE OF THE X-ARRAY REMAINING.
"                 PARAMETER CHECKED:CURRENT N.
"----------------------------------------------------------------------------
LOOP3:  MOV D,M                         "SET,M,THE LOOP2 CNTR.,
        DEC M                           " TO D-1.
        SUB# TT,N                       "TEST IF NEED TO DO
        BGE .+2                         "BLOCK OF TT OR LESS.
                                        "IF LESS,
        CFL1; MOV N,CCTR; BR .+2        " USE REMAINING N
        SFL1; MOV TT,CCTR               " OTHERWISE, USE 32.
        LDSPI I;DB=-1.                  "SET I=-1
"-----------------------------------------------------------------------------
"THIS LOOP INCREMENTS THE STARTING ADDR.OF THE BLOCK OF X'S TO BE TRANSFERRED.
"                       ASSOCIATED COUNTER:I
"------------------------------------------------------------------------------
        "----------------------------------------------------------------------
        "THIS SUB LOOP DOES THE FOLLOWING:
        " (1)TRANSFERS X(0),X(D),X(2D),..TT SUCH VALUES INTO DPX'S.
        " (2)ZEROES TT DPY'S.
        "----------------------------------------------------------------------
LOOP2I: MOV SAVEB,B                     "SET B.
        MOV SAVEA,A;SETMA               "FETCH X(0).
        DB=ZERO; LDDPA; MOV CCTR,JUNK
        ADD D,A; SETMA; DPY<ZERO        "GET X(D).
GETI:   DPX<MD;                         "THIS LOOP PUTS
          INCDPA;                       " X(JUNK*D) INTO DPX(1-TT)
          DEC JUNK                      " AND 0'S INTO DPY(1-TT)
        ADD D,A; SETMA; BGT GETI;       "SAME
          DPY<ZERO
        BR DOCONV;INC I                 "BY-PASS LOOP2.
        "---------------------------------------------------------------
        "THIS SUB-LOOP DOES THE SAME THING AS GETI WITH THE FOLLOWING
        "EXCEPTIONS:
        " (1) X(I),X(I+D),X(I+2D),..TT SUCH VALUES -->DPX'S (HERE I>0)
        " (2) THE DPY'S ARE LEFT INTACT.
        "--------------------------------------------------------------
LOOP2:  INC I                           "I=I+1;INITIAL I=0.
        MOV SAVEA,A                     "RE-SET A.
        MOV SAVEB,B                     "RE-SET B.
        ADD I,A;SETMA                   "FETCH X(I)
        DB=ZERO;LDDPA;MOV CCTR,JUNK     "DPA=0;JUNK=TT OR N
        ADD D,A;SETMA                   "FETCH X(I+D).
GET:    DPX<MD;
          INCDPA;
            DEC JUNK
        ADD D,A;SETMA;BGT GET
"---------------------------------------------------------------------
"       START THE CONVOLUTION HERE.
"---------------------------------------------------------------------
DOCONV: ADD I,B;SETMA                   "INITIATE THE FETCH OF H(I).
        BFL1 .+2                        "CHECK IF DOING TT OR LESS.
        JMP LESS
"IF BLOCK OF TT:
        DB=2; LDDPA; SUB D,A            "DPA=2
        FMUL DPX(-2),MD;                " X(0)*H(J)
          SUB D,A                       "ADJUST A'S BASE ADDRESS TO THE ORIGINAL
        FMUL DPX(-1),MD;                "DO X(IDEC)*H(J)
         DPX(-2)<DPX(-1)                "X(I)->DPX(I)
                                        " POSITION FOR NEXT
          MOV TF,JUNK                   " TIME AROUND
        FMUL DPX,MD;                    "DO X(2*D)*H(J)
          DPX(-1)<DPX                    "MOVE X(2*I*D) -> DPX(I+1).
LOOP1A: FADD FM,DPY(-2);                "DO Y(0)+X(0)*H(J)
        FMUL DPX(1),MD;                 "DO X(3*IDEC)*H(J).
          DPX<DPX(1)                   "MOVE X(3*IDEC+1) -> DPY(3*IDEC)
        FADD FM,DPY(-1);                "DO Y(1)*H(J)
          FMUL    DPX(2),MD;            "DO X(4*IDEC)*H(J)
          DPX(1)<DPX(2);                "BRING IN THE NEXT DTH X.
          DEC JUNK
        DPY(-2)<FA;                    "STORE Y(L-2)
          FADD FM,DPY;                  "Y(L)+X((P-1)*IDEC)*H(J)
          FMUL DPX(3),MD; DPX(2)<DPX(3);  "X((P+3)*IDEC)*H(J)
              INCDPA;
             DEC JUNK;BGT .             " CONTINUE TT-9 TIMES.
        DPY(-2)<FA; INCDPA;             "SAME AS ABOVE
          FADD FM,DPY;                  " FOR P=P+1
          FMUL DPX(3),MD; DPX(2)<DPX(3);
          ADD D,A; SETMA                "GET NEXT TR PT
        DPY(-2)<FA; INCDPA;             "STORE ANS(TT-6)
          FADD FM,DPY;                  "ANS(TT-4)+TR(TT-4)*OP(L)
          FMUL DPX(3),MD;               "DO TR(TT-1)*OP(L)
          DPX(2)<DPX(3)                  "MOVE TR(TT-1) INTO TR(TT-2)
        DPY(-2)<FA; INCDPA;             "SAME AS ABOVE,
          FADD FM,DPY;                  " INCREMENTING NUMERAL
          FMUL DPX(3),MD; DPX(2)<DPX(3);" INDICES BY ONE
          ADD D,B; SETMA                "GET OP(L+1)
        DPY(-2)<FA; INCDPA;             "STORE ANS(28)
          FADD FM,DPY;                  "ANS(30)+TR(30)*OP(L)
          DPX(2)<MD; FMUL               "MOVE NEW TR PT INTO  TR(32)
        DPY(-2)<FA; INCDPA;             "STORE ANS(29)
          FADD FM,DPY;                  "ANS(31)+TR(31)*OP(L)
          FMUL
        DPY(-2)<FA; INCDPA;             "STORE ANS(30)
          FADD FM,DPY;                  "ANS(32)+TR(32)*OP(L)
          FMUL DPX(1),MD;               "NEW TR(1)*OP(L+1)
          MOV TF,JUNK                   "RE-INIT INNER COUNTER
        DPY(-2)<FA; INCDPA;             "STORE ANS(31)
          FADD; FMUL DPX(1),MD;          "NEW TR(2)*OP(L+1)
          DPX<DPX(1);                   "MOVE TR(2) INTO TR(1)
          SUB# B,J                      "END OF H-ARRAY ?
        DPY(-2)<FA; INCDPA;             "STORE ANS(TT)
          FMUL DPX(1),MD;               "TR(3)*OP(L+1)
          DPX<DPX(1);                   "MOVE TR(3) INTO TR(2)
          BGT LOOP1A                    "TEST IF DONE ALL OP PTS
          SUB# I,M                      "KEEP COUNT OF NO.H'S .
        BGT .+2                         "H'S EXHAUSTED? NO.LOOP BACK.
        BR .+2                          "YES.EXIT FROM LOOP2.
        JMP LOOP2
        DB=ZERO; LDDPA;                 "IF SO, SUBTRACT
          SUB TT,N                      " TT FROM N
        BGT .+2
        JMP STORE
        DEC CCTR
        INC  C; SETMA; MI<DPY;          "STORE BLOCK OF
          INCDPA; BGT .-1               " TT ANSWERS
                                        "SET NEXT TR PT BLOCK
        ADD ITT,SAVEA                   " STARTING PT
        JMP LOOP3                       "BACK TO LOOP3
"-----------------------------------------------------------------------------
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY ONE ANSWER
"-----------------------------------------------------------------------------
        FMUL DPX(-2),MD
ELSE1:  FMUL; ADD D,A; SETMA
        FMUL
        FADD FM,DPY(-2);
          ADD D,B; SETMA
        FADD;DPX(-2)<MD;SUB# B,J
        DPY(-2)<FA;
          BGT ELSE1 - 1
        SUB# I,M                        "KEEP COUNT OF THE NO.OF H'S.
        BGT .+2                         "ALL H'S CONVOLVED ?
        JMP OUT
        JMP LOOP2                       "NO.PROCEED WITH THE NEXT.
"---------------------------------------------------------------------------
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY TWO ANSWERS
"---------------------------------------------------------------------------
        FMUL DPX(-2),MD
        FMUL DPX(-1),MD;
          DPX(-2)<DPX(-1)
ELSE2:  FMUL; ADD D,A; SETMA
        FMUL; FADD FM,DPY(-2)
        FADD FM,DPY(-1);
          ADD D,B; SETMA
        DPY(-2)<FA; FADD;
          DPX(-1)<MD; SUB# B,J
        DPY(-1)<FA;
          BGT ELSE2 - 2
        SUB# I,M                        "ALL H'S CONVOLVED ?
        BGT .+2
        JMP OUT
        JMP LOOP2                       "NO.PROCEED WITH THE NEXT.
"--
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY THREE ANSWERS
ELSE3:  FADD FM,DPY(-2); FMUL;
          ADD D,A; SETMA
        FADD FM,DPY(-1); FMUL;
          MOV CCTR,JUNK
        DPY(-2)<FA;
          FADD FM,DPY;
          ADD D,B; SETMA
        DPY(-1)<FA; FADD;
          DPX<MD; SUB# B,J
        DPY<FA; DEC JUNK;
          BGT LOOP1B
        SUB# I,M                        "ALL H'S CONVOLVED ?
        BGT .+2
        JMP OUT
        JMP LOOP2                       "NO.PROCEED WITH THE NEXT .
JUMP1:  JMP ELSE1
JUMP2:  JMP ELSE2
JUMP3:  JMP ELSE3
"LEADING INTO LOOP1B...THE PROGRAM HAS JUMPED HERE
"IF THERE WERE LESS THAN 32 ANSWER PTS (LEFT) TO DO
LESS:   SUB D,A
        SUB D,A
        MOV SAVEM,J                     "SET J,THE LOOP1B COUNTER=
        ADD B,J                         " M+BASE ADDR.OF THE H-ARRAY=
                                        " THE UPPER LIMIT OF THE H'S TO BE
                                        " ACCESSED.
        DB=2; LDDPA; MOV CCTR,JUNK      "DPA=2
        DEC JUNK
LOOP1B: FMUL DPX(-2),MD;                 "TR(1)*OP(L)
                                        "TEST IF GO TO
          DEC JUNK; BEQ JUMP1           " SPECIAL CASE 1
        FMUL DPX(-1),MD;                "TR(2)*OP(L)
          DPX(-2)<DPX(-1);              "MOVE TR(2) INTO TR(1)
          DEC JUNK; BEQ JUMP2           "TEST SPEC CASE 2
        FMUL DPX,MD;                    "TR(3)*OP(L)
          DPX(-1)<DPX;                     "MOVE TR(3) INTO TR(2)
          DEC JUNK; BEQ JUMP3           "TEST SPEC CASE 3
        FADD FM,DPY(-2);                "ANS(1)+TR(1)*OP(L)
          FMUL DPX(1),MD;               "TR(4)*OP(L)
          DPX<DPX(1);                   "MOVE TR(4) INTO TR(3)
          DEC JUNK; BEQ ELSE4           "TEST SPEC CASE 4
        FADD FM,DPY(-1);                "ANS(2)+TR(2)*OP(L)
          FMUL DPX(2),MD;               "TR(5)*OP(L)
          DPX(1)<DPX(2);                "MOVE TR(5) INTO TR(4)
          DEC JUNK; BEQ JUMP5           "TEST SPEC CASE 5
        DPY(-2)<FA; INCDPA;             "STORE ANS(P)
          FADD FM,DPY;                  "ANS(P+2)+TR(P+2)*OP(L)
          FMUL DPX(3),MD; DPX(2)<DPX(3); "TR(P+5)*OP(L)
          DEC JUNK; BGT .               "TR(P+5) INTO TR(P+4)
        DPY(-2)<FA; INCDPA;             "STORE ANS(P+1)
          FADD FM,DPY; FMUL;            "ANS(P+3)+TR(P+3)*OP(L)
          ADD D,A; SETMA                "GET NEXT TR PT
        DPY(-2)<FA; INCDPA;             "STORE ANS(P+2)
          FADD FM,DPY; FMUL;            "ANS(P+4)+TR(P+4)*OP(L)
          MOV CCTR,JUNK                 "RE-INIT INNER COUNTER
        DPY(-2)<FA; INCDPA;             "STORE ANS(P+3)
          FADD FM,DPY;                  "ANS(P+5)+TR(P+5)*OP(L)
          ADD D,B; SETMA                "GET OP(L+1)
        DPY(-2)<FA; INCDPA;              "STORE ANS(P+4)
          FADD; DPX(-1)<MD;             "MOVE NEXT TR PT
          SUB# B,J                      " INTO TR(P+5)
        DB=2; LDDPA;                       "DPA=2
          DPY(-2)<FA;                    "STORE ANS(P+5)
          DEC JUNK;
          BGT LOOP1B                    "TEST IF DONE ALL OP PTS
        SUB# I,M                        "ALL H'S EXHAUSTED ?
        BGT .+2
        BR.+2
        JMP LOOP2                       "NO.GO BACK TO LOOP2.
OUT:    DB=ZERO; LDDPA; BR .+1        "IF SO, GO TO STORE
        JMP STORE
JUMP5:  JMP ELSE5
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULATE ONLY 4 ANSWERS
ELSE4:  FADD FM,DPY(-1); FMUL;
          ADD D,A; SETMA
        DPY(-2)<FA;
          FADD FM,DPY; FMUL;
          MOV CCTR,JUNK
        DPY(-1)<FA;
          FADD FM,DPY(1);
          ADD D,B; SETMA
        DPY<FA; FADD;
          DPX(1)<MD; SUB# B,J
        DPY(1)<FA;
          DEC JUNK;
          BGT .+2
        BR.+2
        JMP LOOP1B
        SUB# I,M
        BGT .+2
        JMP OUT
        JMP LOOP2
"THE FOLLOWING IS THE SPECIAL CASE WHERE LOOP1B IS
"REQUIRED TO CALCULAGE ONLY 5 ANSWERS
ELSE5:  DPY(-2)<FA;
          FADD FM,DPY; FMUL;
          ADD D,A; SETMA
        DPY(-1)<FA;
          FADD FM,DPY(1); FMUL;
          MOV CCTR,JUNK
        DPY<FA;
          FADD FM,DPY(2);
          ADD D,B; SETMA
        DPY(1)<FA; FADD;
          DPX(2)<MD; SUB# B,J
        DPY(2)<FA;
          DEC JUNK;
          BGT JUMP1B
        SUB# I,M                        "ALL H'S CONVOLVED ?
        BGT .+2
        JMP OUT
        JMP LOOP2
JUMP1B: JMP LOOP1B
"THE PROGRAM HAS JUMPED HERE IF THE LAST ANSWERS
"ARE READY TO STORE
STORE:  DEC CCTR
        INC C; SETMA; MI<DPY;            "STORE THEM
          INCDPA; BGT STORE
        LDSPI 15;DB=0                   "SET SP(0)=0.
RTRN:   RETURN
        $END
"****** ENVEL = ENVELOPE DETECTOR /COMMON/  = REL 3.0, SEP 79
       $TITLE  ENVEL
        $RADIX 8
       XADC    $EQU 1                  "CONDITIONAL ASSEM.PRAM. FOR ADC.
       $ENTRY  ENVEL,3                    "UDC MODE ENTRY POINT.
"
"
"        --- ABSTRACT ---
"THIS SUBROUTINE EXTRACTS THE ENVELOPE OF A VECTOR .
"FORMULA USED:  E(T)=SQRT ( X**2 + H(X)**2 ).
"
"
"        --- STATISTICS ---
"
"LANGUAGE:   APAL.
"HARDWARE:   AP120B WITH EITHER KIND OF MEMORY.
"SIZE:       42 APAL WORDS.
"SPEED: BEST :    20.3
"       TYPICAL:  20.3
"       WORST:    21.6
"SUBROUTINES USED: HLBRT,SAVESP,SETSP,VADD,VSQ,VSQRT.
"SCRATCH:       ALL S-PADS.
"AUTHORS:       R.L.KIRLIN,D.GANGULY.
"DATE:          NOV.'78.
"
"
"        --- USAGE ---
"FORTRAN CALL:  CALL ENVEL(IX,IE,N).
"APAL CALL:     JSR ENVEL.
"
"
"------------------------------------------------------------------------------
$EXT    HLBRT
$EXT    SAVESP,SETSP
$EXT    VSQ,VADD,VSQRT
"S-PAD ASSIGNMENTS.
IX      $EQU    0                       "BASE ADDR.X(T)
IE      $EQU    1                       "BASE ADDR OF ENVELOPE & H(X(T)).
 N      $EQU    2                       "ARRAY SIZE INFORMATION.
IXT     $EQU    7                       "TEMPORARY STORAGE FOR IX
IET     $EQU    10                      "TEMPORARY STORAGE FOR IE.
 NT     $EQU    11                      "    "        "     "   N.
"
" CONSTANTS.
"
  L     $EQU    0                       "FLAG FOR THE LEFT HALF WORD.
  R     $EQU    2000                    "FLAG FOR THE RIGHT HALF WORD.
"
"--------------------------------------------------------------------------
"
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
" *** CONDITIONAL ASSEMBLY ***
"
        $IF XADC = 1
        $SUBR FENVEL,3
        $EXT RESLVE
        BITMAP $EQU 4
        $PARAM 3 ,P1(#3)/R/IP,P2(#3)/R/OP,
                  P3/I/IP
FENVEL: LDSPI 17;DB = BITMAP
        JSR RESLVE
        $ENDIF
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
"---------------------------------------------------------------------
"  START BY CHECKING THE ARRAY SIZE.
"---------------------------------------------------------------------
ENVEL:  MOV N,N                         "IS N NON ZERO ?
        BGT .+2                         "YES.GET ON WITH ENVEL.
        JMP RTRN                        "NO.RETURN TO THE CALLER.
        JSR SAVESP                      "SAVE SP-S 0-4.
        $VAL 0,4,0,BUFF-.
        JSR HLBRT                       "OBTAIN H(X(T)).
        JSR SETSP                       "RESTORE SP-S 0-4.
        $VAL 0,4,L,BUFF-.
        $VAL R,BUFF-.,L,BUFF+1-.
        $VAL R,BUFF+1-.,L,BUFF+2-.
"-------------------------------------------
"       SAVE IX,IE & N IN TEMP.LOCS.
"-------------------------------------------
        MOV IX,IXT
        MOV IE,IET
        MOV  N,NT
"------------------------------------------
"       OBTAIN X(T)**2
"------------------------------------------
                                        "<SP(0)>,ALREADY=BASE ADDR.OF X(T).
        LDSPI 1;DB=1                    "<SP(1)>=ADDR.INC FOR X(T)=1
        MOV IXT,2                        "<SP(2)>=BASE ADDR.OF X(T)**2
        MOV 1,3                         "<SP(3)>=ADDR INC FOR X(T)**2=1
        MOV NT,4                        "<SP(4)>=ELEMENT COUNT.
        JSR VSQ                         "DO X(T)**2
"------------------------------------------
"       OBTAIN (H(X(T)))**2.
"------------------------------------------
        MOV IET,0                        "<SP(0)>=BASE ADDR.OF H(X(T)).
        MOV 0,2                         "<SP(2)>= "     "  "  (H(X(T)))**2.
        MOV NT,4                         "<SP(4)>=ELEMENT COUNT.
                                        "<SP(1)>=<SP(3)>=1,(ALREADY SET).
        JSR VSQ                         "DO (H(X(T)))**2
"--------------------------------------------
"       OBTAIN THE SUM OF SQUARES.
"---------------------------------------------
        MOV IXT,0                        "SET A.
        MOV IET,2                        "SET B.
        MOV IXT,4                        "SET C.
        MOV  1,5                        "SET K.I & J ALREADY SET TO 1.
        MOV NT,6                         "SET N.
        JSR VADD                        "DO THE SUMMING.
"--------------------------------------------
"       OBTAIN THE SQUARE ROOT OF THE SUM OF SQUARES.
"--------------------------------------------
        MOV IXT,0                       "SET A.
        MOV  0,2                        "SET B.
        MOV NT,4                         "SET N.
        JSR VSQRT                       "DO THE SQUARE ROOT.
        NOP                             "PREPARE TO RETURN.
RTRN:   RETURN
"
"       BUFFER FOR S-PAD STORAGE.
"
BUFF:   $VAL 0,0,0,0
        $VAL 0,0,0,0
        $VAL 0,0,0,0
        $VAL 0,0,0,0
$END
"****** HLBRT = HILBERT TRANSFORMER /COMMON/ = REL 3.0, SEP 79
        $TITLE HLBRT
        $RADIX 8
        XADC    $EQU 1                  "COND.ASSEMBLY PARAMETER FOR ADC
                                        " OR APFTN ENTRY.
        $ENTRY HLBRT,3                  "UDC MODE ENTRY POINT.
"
"------------------------------------------------------------------------------
"     --- ABSTRACT ---
"
"THIS SUBROUTINE OBTAINS THE HILBERT TRANSFORM OF A X(T) BY EXPLOITING THE
"FOLLOWING PROPERTY OF ANALYTIC SIGNALS:
"   F{H{X(T)}}=-J*F{X(T)}.
"   WHERE: F{FUNCT1(T)} -> FOURIER TRANSFORM OF THE TIME DOMAIN FUNCTION
"                            FUNCT1(T).
"          H{FUNCT2(T)} -> HILBERT TRANSFORM OF THE FUNCTION FUNCT2(T).
"
"COMPUTATIONALLY,THIS IS ACCOMPLISHED BY DOING THE FOLLOWING:
" (1)A REAL TO COMPLEX FFT OF X(T) IS OBTAINED.
" (2)THE REAL COMPONENTS OF THE RESULT ARE MULTIPLIED BY -1.
" (3)THE POSITIONS OF THE REAL AND IMAGINARY COMPONENTS ARE SWITCHED.
" (4)A COMPLEX TO REAL INVERSE FFT IS PERFORMED ON THE RESULTS OF STEP 3.
"
"     --- STATISTICS ---
"LANGUAGE: APAL
"SIZE:     72 LOCATIONS
"SPEED:    BEST:     7.8
"(US)      WORST:    8.2
"          TYPICAL:  7.8
"
"SUBROUTINES USED: RFFT,RFFTB,RFFTSC,SAVESP,VMOV,VNEG
"
"SCRATCH: SP(0-15),DPX(-4 TO 3),DPY(-4 TO 3),FA,FM,MD,TM.
"
"AUTHORS:  R.L.KIRLIN ,D.GANGULY.
"
"               --- USAGE ---
"FORTRAN CALL:  CALL HLBRT (IX,IH,N)
"
"------------------------------------------------------------------------------
"
"
"
$EXT    RFFT
$EXT    RFFTB
$EXT    RFFTSC
$EXT    SAVESP
$EXT    SETSP
$EXT    VMOV
$EXT    VNEG
"
"S-PAD ASSIGNMENTS.
"
IX      $EQU    0                       "BASE ADDRESS OF X(T).
IH      $EQU    1                       "BASE ADDRESS OF H{X(T)}.
N       $EQU    2                       "LOC.FOR ARRAY SIZE.
IHT     $EQU    6                       "TEMP.LOC.FOR IH.
 NT     $EQU    7                       "TEMP.LOC.FOR N.
L       $EQU    0                       "FLAG FOR LEFT HALF OF THE WORD.
R       $EQU    2000                    "FLAG FOR THE RIGHT HALF OF THE WORD.
"
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
" *** CONDITIONAL ASSEMBLY ***
"
        $IF     XADC=1
        $SUBR   FHLBRT,3
        $EXT    RESLVE
        BITMAP  $EQU 4
        $PARAM  3  ,    P1(#3)/R/IP,P2(#3)/R/OP,
                        P3/I/IP
FHLBRT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
"
"
"---------------------------------------------------------------------
" START BY CHECKING THE ARRAY SIZE.
"---------------------------------------------------------------------
"
HLBRT:  MOV N,N                         "IS N NON ZERO ?
        BGT .+2                         "YES.GET ON WITH HLBRT.
        JMP RTRN                        "NO.RETURN TO THE CALLER.
"---------------------------------------------------------------------
"  START THE PROGRAMME HERE.
"---------------------------------------------------------------------
"
        MOV 0,IX                        "<SP(0)> -> SP(IX)
        MOV 1,IHT                        "<SP(1)>->SP(IHT).
        MOV 2,NT                         "<SP(2)>->SP(NT).
        INC 1                           "<SP(1)>=<SP(1)>+1.
        LDSPI 3;DB=1                    "<SP(3)>=<DB>=1.
        JSR SAVESP                      "SAVE THE S-PAD REGISTERS.
        $VAL 0,10,0,ADDR-.
        JSR RFFTB                       "DO THE REAL FFT (NOT IN PLACE).
        JSR SETSP                       "RESTORE THE S-PAD REGISTERS.
        $VAL 0,10,L,ADDR-.
        $VAL R,ADDR-.,L,ADDR+1-.
        $VAL R,ADDR+1-.,L,ADDR+2-.
        $VAL R,ADDR+2-.,L,ADDR+3-.
        $VAL R,ADDR+3-.,L,ADDR+4-.
"
" CHANGE FROM THE SPECIAL RFFT FORMAT TO THE NORMAL CFFT FORMAT.
"
"        "LOAD THE S-PADS WITH THE NECESSARY PARAMETERS.
"
        MOV IHT,0                       "SET C.
        MOV N,1                         "SET N.
        LDSPI 2;DB=3                    "SET F =3=>TYPE 2 UNPACKING.
        LDSPI 3;DB=1                    "SET FS=1=> SCALE BY 1/2*N.
        JSR RFFTSC                      "DO THE REFORMATTING & SCALING.
"
" EFFECTIVELY MULTIPLY THE RESULTS BY -J*SGN(F).
"
        MOV IHT,0                       "SET A,SOURCE VECTOR BASE ADDR.
        INC 0                           "INCREMENT BY 1.
        LDSPI 1;DB=2                    "SET I,A ADDR.INC,TO 2.
        MOV 0,2                         "SET C,THE DESTINATION VECT.BASE ADDR.
        MOV 1,3                         "SET K,C'S ADDR.INC.TO 2
        MOVR NT,4                       "SET N TO HALF THE SOURCE VECTOR'S SIZE.
        DEC 4                           "CREATE N/2-1
        JSR VNEG                        "DO THE VECTOR NEGATE.
"
"   SWITCH THE POSITIONS OF THE REAL & IMAGINARY COMPONENTS.
"
        MOV IHT,0                       "<SP(0)>=BASE ADDRESS OF SOURCE VECT.
        ADD 1,0                         "START MOVING AT IH+2
        MOV IHT,2                       "ESTABLISH THE DEST.VECTOR BASE ADDR.
        MOVR NT,4                       "SET NO.OF ELEMENTS TO BE MOVED=N/2.
        JSR VMOV                        "DO THE MOVE.
"
"   CHANGE FROM THE NORMAL CFFT FORMAT TO THE RFFT FORMAT.
"
"        LOAD THE S-PADS WITH THE REQUIRED PARAMS.
"
"
        MOV IHT,0                       "SET C.
        MOV NT,1                        "SET N
        LDSPI 2;DB=-3                   "SET F=-3=>TYPE 2 PACKING.
        LDSPI 3;DB=0                    "SET FS=0=>NO SCALING.
        JSR RFFTSC                      "DO THE REFORMATTING.
"
"    OBTAIN THE INVERSE FFT.
"
        JSR SAVESP                      "PRESERVE THE S-PAD CONTENTS.
        $VAL 0,10,0,ADDR-.
        MOV IHT,0                       "SET THE BASE ADDRESS FOR H.
        MOV NT,1                        "SET THE ARRAY SIZE
        LDSPI 2;DB=-1                   "SET INV.FFT FLAG.
        JSR RFFT                        "DO THE INV.FFT (IN PLACE).
        JSR SETSP                       "RESTORE THE S-PADS.
        $VAL 0,10,L,ADDR-.
        $VAL R,ADDR-.,L,ADDR+1-.
        $VAL R,ADDR+1-.,L,ADDR+2-.
        $VAL R,ADDR+2-.,L,ADDR+3-.
        $VAL R,ADDR+3-.,L,ADDR+4-.
        NOP                             "AVOID MESSING UP THE SRS.
RTRN:   RETURN
"
"  S-PADS ARE SAVED IN THESE LOCATIONS.
"
ADDR:   $VAL 0,0,0,0
        $VAL 0,0,0,0
        $VAL 0,0,0,0
        $VAL 0,0,0,0
        $VAL 0,0,0,0
        $VAL 0,0,0,0
        $VAL 0,0,0,0
        $VAL 0,0,0,0
$END
"****** PKVAL = PEAK AND VALLEY PICKER /COMMON/ = REL 3.1, AUG 80
"       FOR EITHER MEMORY
 $TITLE PKVAL
        $RADIX 8
 XADC $EQU 1                   "CONDITIONAL ASSEMBLY PARA. FOR ADC/APFTN.
 $ENTRY PKVAL,7                        "UDC MODE ENTRY POINT.
"        EXTERNALS
 $EXT DIV
 $EXT SPFLT
"
"
"
"
"
"       --- USAGE ---
"       FORTRAN CALL:
"         CALL PKVAL(A,B,N,C,NP,R,MODE)
"       APAL CALL:
"         JSR PKVAL
"         WHERE
"         A = BASE ADDR OF INPUT ARRAY OF NON-NEGATIVE REAL VALUES
"         N = LENGTH OF A
"         B = BASE ADDR OF OUTPUT ARRAY OF PEAKS AND VALLEYS
"         C = BASE ADDR OF ARRAY OF INDICES OF B ELEMENTS
"         NP = #OF PEAKS AND VALLEYS SOUGHT, LENGTH OF B & C
"         R = ADDR OF RATIO BY WHICH MAX OR MIN MUST DIFFER FROM FOLLOWING
"                DATA TO BE DESIGNATED PEAK OR VALLEY.  ROUGHLY,
"                RATIO IS A SIGNAL-TO-NOISE RATIO.
"                UPON OUTPUT, THE VALUE AT R IS THE NUMBER OF PEAKS AND
"                VALLEYS FOUND.
"         MODE = 1 IF PEAK SOUGHT FIRST, -1 IF VALLEY SOUGHT FIRST
"
"
"       --- ABSTRACT ---
"       THIS ROUTINE WILL FIND PEAKS AND VALLEYS IN THE VECTOR OF
"       NON-NEGATIVE VALUES.
"       THE VARIABLE 'MODE' DETERMINES WHETHER A PEAK OR A VALLEY IS
"       TO BE FOUND FIRST.  PEAKS AND VALLEY VALUES ARE RETURNED IN THE
"       VECTOR B,  AND THEIR INDICES, 1 THRUOUGH NP, ARE RETURNED IN
"       THE VECTOR C.
"       THE INPUT R IS A RATIO BY WHICH A PEAK OR VALLEY MUST DIFFER
"       FROM THE LAST PEAK OR VALLEY; IF IT DOES, IT IS DECLARED.  ONCE
"       A VALLEY (PEAK) IS DECLARED, A PEAK (VALLEY) IS SOUGHT.
"
"
"
"       FORMULA:
"               PEAK MODE:
"                         B(J)=A(I) IF A(I+K)<=A(I)/R
"               VALLEY MODE:
"                         B(J)=A(I) IF A(I+K)>=A(I)*R
"               WHERE;
"                    1<=J<=NP
"                    0<I<=N-2
"                    1<=K<=N-I-1
"               BOTH MODES:
"                          C(M)=I+J FOR THOSE A(I) SELECTED FOR B.
"
"
"
"       --- HISTORY ---
"       ORIGINAL:  JUL 79  R.L. KIRLIN
"        REV 3.1:  AUG 80  R.S. NORIN     MODIFIED $PARAM TO EXTEND
"                                         TO TWO SOURCE LINES. NO
"                                         FUNCTIONAL CHANGE.
"
"       --- STATISTICS ---
"       SIZE:76+41 EXTERNALS = 137
"                                                    (167 NS MEMORY)
"           SAME                                     (333 NS MEMORY)
"
"       SPEED: (APPROXIMATE UPPER BOUND)
"                (33+11*(N-NF)+20*NF)/6 USEC
"                 WHERE NF=#PEAKS+VALLEYS FOUND
"                                                    (167 NS MEMORY)
"                SAME
"                                                    (333 NS MEMORY)
"       DESTROYS SP(0-2,4,10,11,12,16,17),DPX(-1 THRU 2),DPY(-4,-2 THRU 2)
"
"
"
"
"       SPADS:
        M $EQU 0         "BASE ADDR. OF INPUT NON NEGATIVE VECTOR.
        PEAK $EQU 1      "BASE ADDRESS OF OUTPUT VECTOR OF PEAKS & VALLEYS.
        N $EQU 2         "NUMBER OF ELEMENTS OF A & B.
        MP $EQU 3        "BASE ADDRESS OF INDICIES OF A ELEMENTS PLACED IN B.
        NP $EQU 4        "THE NUMBER OF PEAKS & VALLEYS SOUGHT.
        R $EQU 5         "ADDR. OF RATIO OF LAST EXTREMUM TO CURRENT POINT.
        MODE $EQU 6      "PEAK OR VALLEY SEARCH FLAG.
        M0 $EQU 7
        MINDX $EQU 10
        MAX $EQU 11
        TWO $EQU 12
"
"
"       DATA PADS:
"          X           Y
" -4                 P+V FOUND
" -3
" -2                  1/RATIO
" -1   MIN OR MAX     RATIO
"  0
"  1
"  2   INDEX          VALUE
"  3
"
"---------------------------------------------------------------
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
" *** CONDITIONAL ASSEMBLY ***
 $IF XADC=1
 $SUBR FPKVAL,7
 $EXT RESLVE
 BITMAP $EQU 124
 $PARAM 7, P1(#3)/R/IP, P2(#5)/R/OP, P3/I/IP, P4(#5)/R/OP,
           P5/I/IP, P6/R/OP/IP, P7/I/IP
 FPKVAL: LDSPI 17;DB=BITMAP
 JSR RESLVE
 $ENDIF
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
"
"
"----------------------------------------------------------------
"  START BY CHECKING ARRAY SIZES.
"----------------------------------------------------------------
PKVAL:  MOV N,N
        BGT .+2                 "IF N>0 CHECK NP.
        RETURN                  "IF NOT.RETURN.
        MOV NP,NP               "IS NP NON ZERO ?
        BGT .+2                 "YES.GET ON WITH PKVAL.
        RETURN                  "ELSE.RETURN.
"-------------------------------------------------------------------
"  START PKVAL HERE.
"--------------------------------------------------------------------
        MOV R,R;SETMA;                 "GET RATIO
          DPY(-4)<ZERO                  "START 0 PEAKS FOUND
        LDSPI TWO;DB=2
        CLR MINDX
        INC NP;LDTMA;DB=!ONE           "PRESET NP, STEP 1
        MOV M,M;SETMA                     "GET FIRST VALUE
        DEC PEAK;                  "INITIATE PEAK ADDR
          DPY(-1)<MD                   "RATIO IN DPY(-1)
        DPY(0)<TM;                      "1 IN DPY(0)
          DEC MP                       "INITIATE INDEX ADDR
        DPX(0)<DPY(-1)                 "RATIO IN DPX(0) FOR RECIPR;
          INC NP                       "PRESET NP
        JSR DIV;DPX(-1)<MD                   "FIRST VALUE IN DPX(-1)
        DPY(-2)<DPX(0);                "1/RATIO IN DPY(-2)
          MOV MODE,MODE                  "PEAK OR VALLEY FIRST?
        BGT PEAKS;
          LDSPI MAX;DB=1                 "INDEX FIRST MAX/MIN
        JMP VALLEY
PEAKS:  INC M;SETMA                    "GET NEXT VALUE
        FMUL DPX(-1),DPY(-2);          "MAX*(1/RATIO)
          DEC NP                       "QUIT IF PEAK ARRAY FILLED
        FMUL;BEQ RTRN;
          INC MINDX
MX1:    INC M;SETMA;
                 FSUBR DPX(-1),MD;FMUL  "VALUE-MAX
        FMUL DPX(-1),DPY(-2);
                 FSUB FM,MD            "MAX/RATIO-VALUE>=0?
        FMUL;
                 FADD;INC MINDX;        "MOV INDEX FOR FLOAT
                   DPY(2)<MD           "TEMP STORE VALUE
MXLOOP: INC M;SETMA;                   "1.GET VALUE
                 FSUBR DPX(-1),MD;FMUL;"  VALUE-MAX>0?
                          BFGT NEWMAX  "  REPLACE MAX IF VALUE>MAX
        FMUL DPX(-1),DPY(-2);          "2.MAX*(1/RATIO)
                 FSUB FM,MD;           "  MAX/RATIO-VALUE>=0?
                          BFGE NWPEAK; "  ANNOUNCE PEAK IF VALUE<MAX/RATIO
                            DEC N      "  TEST ELEM CTR
        FMUL;  FADD;INC MINDX;         "3.MOV INDEX FOR FLOAT
                   DPY(2)<MD;          "  TEMP STORE VALUE
                          BGT MXLOOP   "  LOOP IF VECTOR NOT DONE
RTRN:   RETURN;MOV R,R;SETMA;MI<DPY(-4)
NEWMAX: MOV MINDX,MAX;
          DPX(-1)<DPY(2)              "STORE NEW MAX
        SUB TWO,M                         "RESET M
        DEC N
        DEC MINDX;
          BGT PEAKS
        RETURN;MOV R,R;SETMA;MI<DPY(-4)
NWPEAK: INC PEAK;SETMA;MI<DPX(-1)           "STORE PEAK
        MOV MAX,17
        JSR SPFLT
        INC MP;SETMA;MI<DPX(1);        "STORE INDEX OF PEAK
          FADD TM,DPY(-4)                  "INC #P+V FOUND
        SUB TWO,M;FADD                   "RESET M
        MOV MINDX,MAX;                 "STORE INDEX NEW MIN
          DPY(-4)<FA                    "STORE #P+V
        DPX(-1)<DPY(2);                "STORE NEW MIN
          MOV N,N
        BGT VALLEY;DEC MINDX
RTRN2:  RETURN;MOV R,R;SETMA;MI<DPY(-4)
VALLEY: INC M;SETMA                   "GET NEXT VALUE
        FMUL DPX(-1),DPY(-1);           "MIN*RATIO
          DEC NP
        FMUL;BEQ RTRN2;          "QUIT IF PEAK ARRAY FILLED
          INC MINDX
MN1:    INC M;SETMA;
                 FSUB DPX(-1),MD;FMUL  "MIN-VALUE
        FMUL DPX(-1),DPY(-1);
                 FSUBR FM,MD            "VALUE-MIN*RATIO
        FMUL;    FADD;INC MINDX;        "  MOV INDEX FOR FLOAT
                   DPY(2)<MD           "  TEMP STORE VALUE
MNLOOP: INC M;SETMA;                   "1.GET VALUE
                 FSUB DPX(-1),MD;FMUL; "  MIN-VAL
                          BFGT NEWMIN  "  REPLACE MIN IF VALUE<MIN
        FMUL DPX(-1),DPY(-1);          "2.MIN*RATIO
                 FSUBR FM,MD;          "  VALUE-MIN*RATIO
                          BFGE NWVALY; "  ANNOUNCE NEW VALLEY IF VALUE>MIN*RATIO
                            DEC N      "  TEST ELEM CTR
        FMUL;  FADD;INC MINDX;         "3.MOV INDEX FOR FLOAT
                   DPY(2)<MD;          "  TEMP STORE VALUE
                          BGT MNLOOP   "  LOOP IF VECTOR NOT DONE
        RETURN;MOV R,R;SETMA;MI<DPY(-4)
NEWMIN: MOV MINDX,MAX;
          DPX(-1)<DPY(2)              "STORE NEW MIN
        SUB TWO,M                         "RESET M
        DEC N
        DEC MINDX;
          BGT VALLEY
        RETURN;MOV R,R;SETMA;MI<DPY(-4)
NWVALY: INC PEAK;SETMA;MI<DPX(-1)           "STORE VALLEY
        MOV MAX,17
        JSR SPFLT
        INC MP;SETMA;MI<DPX(1);        "STORE INDEX OF VALLEY
          FADD TM,DPY(-4)              "INC #P+V
        SUB TWO,M;FADD
        MOV MINDX,MAX;                 "STORE INDEX OF NEW MAX
          DPY(-4)<FA                    "STORE #P+V
        DPX(-1)<DPY(2);                "STORE NEW MAX
          MOV N,N
        BGT CONT;DEC MINDX
        RETURN;MOV R,R;SETMA;MI<DPY(-4)
CONT:    JMP PEAKS
        $END
"****** VXCS = VECTOR TIMES COS AND SIN (TABLE LOOKUP)/COMMON/ = REL 3.0, JUL 79
"
    "               READ SIN AND COS VALUES FROM TABLE MEMORY
    "               THUS THE PRECISION OF THESE VALUES IS LIMITED
    "
"FORMULA:
"               C(MI) = A(M) * COS(M*F+P)
"               C(MI+1) = A(M) * SIN(M*F+P)
"
"                       FOR M=0 TO N-1
"
            $TITLE VXCS
        $RADIX 8
            XADC  $EQU 0    " CONDITIONAL ASSEMBLE PARAMETER FOR ADC/APFTN
            $ENTRY VXCS,6      "USER DIRECTED CALL ENTRY
"       --- ABSTRACT --
"TO MULTIPLY A VECTOR IN APMD WITH THE SIN AND COSINE OF A
"LINEARLY INCREASING ARGUMENT WITH A GIVEN INITIAL PHASE.
"USES TABLE ROM LOOKUP ONLY FOR SIN AND COSINE VALUES.
"
"
"       --- STATISTICS --
"LANGUAGE: APAL
"EQUIPMENT: AP 120 WITH EITHER MEMORY
"SIZE: 42 LOCATIONS
"EXECUTION    BEST        TYPICAL      WORST     SETUP(US)
"TIME/LOOP:    1.O         1.0         1.0         5.20    (167 NS MEM)
" (US)         1.3         1.3         1.3         5.20    (333 NS MEM)
"SUBROUTINE USED : NONE
"AUTHOR: P. PINCUS
"DATE JUL 1979
"
"        --- USAGE ---
"FORTRAN: CALL VXCS(A,B,I,F,P,N)
"APAL:  JSR VXCS
"
    "S-PAD PARAMETERS
          XADD    $EQU    0   "BASE ADDRESS OF SOURCE VECTOR
          YB      $EQU    1   "BASE ADDRESS OF DESTINATION VECTOR
          YINC    $EQU    2   "ADDRESS INCREMENT ON DESTINATION VECTOR
          WADD    $EQU    3   "ADDRESS OF FREQUENCY PARAMETER
          T0      $EQU    4   "ADDRESS OF INITIAL PHASE
          N       $EQU    5   "NUMBER OF ELEMENTS IN SOURCE
          MASK    $EQU    17  "SCRATCH
          STATUS  $EQU    16  "SCRATCH
          TBL1    $EQU    17  "SCRATCH
"
" SCRATCH SP(14,15),DPX(0,3),DPY(-1,2,3),TM,FM,FA
"
"
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC =1             "AUTO DIRECTED CALL
        $SUBR FVXCS,6
        $EXT RESLVE
        BITMAP  $EQU    44
        $PARAM 6,   P1(#6)/R/IP , P2(#3,#6)/R/OP,
                    P3/I/IP,  P4/R/IP,
                    P5/R/IP/OP,  P6/I/IP
FVXCS:  LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VXCS:           LDTMA; DB=4371;                 "FETCH VALUE FROM TM ROM
                                                "ZERO FOR 2.5 K AND NON-ZERO
                                                "FOR 4K
                 MOV N,N                        "CHECK N FOR ZER0
                MOV WADD,WADD;SETMA;            "FETCH FREQ PARAMETER
                 BEQ RETR                       "BR IF N=0
                RAPS; LDSPNL STATUS;            "SAVE STATUS
                 DB=TM                        "PUT TM ON DB TO TEST FOR
                                                "ZERO ( 2K) OR NOT ZERO (4K)
                BDBZ TWOK                       "BR IF 2K ROM
FOURK:         RPSF SCL4K;                     "READ SCALE CONSTANT FOR 4K
                  DPY(3)<DB
                RPSF INSC4K;
                  DPY(2)<DB; BR CONT            "GET INVERSE SCALE CON
TWOK:           RPSF SCL2K;                     "READ SCALE CONSTANT FOR 2K
                  DPY(3)<DB
                RPSF INSC2K;
                  DPY(2)<DB; BR CONT            "GET INVERSE SCALE CON
RETR:           RETURN                          "RETURN IF N=0
CONT:           MOV T0,T0; SETMA;               "FETCH INITIAL PHASE
                  FMUL DPY(3),MD                "SCALE CON * FREQ
                LDSPI MASK; DB=30
                FMUL                            "PUSH
                OR MASK,STATUS;
                  LDAPS; DB=SPFN                " SET APSTATUS
                FMUL DPY(3),MD;                 "SCALE CON * PHASE
                  SUB YINC,YB                   "SET Y ADDRESS
                FMUL ;                           "PUSH
                  DPY(-1)<FM                    "SAVE FREQ*SCALE CON
                FMUL                            "PUSH
  OUTLP:     FADD FM,ZERO;                           "T=T+T0
                  MOV XADD,XADD;SETMA;                      "FETCH X
                        DPX(3)<FM                       "SAVE PHASE
          FADD                                         "PUSH
          FIX FA;                                 "CALC TABLE ADD
                  DPX(3)<FA                       "SAVE W*T
          FADD                                    "PUSH
          DPX(0)<FA                               "STORE ADD
          INC XADD;SETMA                         "FETCH NEXT VECTOR ELEMENT
                  LDSPI TBL1; DB=DPX(0)                  "LOAD INT TMROM ADD
                          FADD DPX(3),DPY(-1)
          FADD;
                  MOVL TBL1,TBL1                 "2*TBL1
          FIX FA; DPX(3)<FA;
                  MOV TBL1, TBL1;SETTMA                "FETCH COSINE VALUE
          FADD;
                  INCTMA;                           "FETCH SINE
                        MOV N,N                 "SET SPFN NOT EQUAL TO ZERO
  LP:     INC XADD; SETMA;                            "FETCH NEXT SOURCE VECTOR
                  FADD DPX(3),DPY(-1);                       "CALCULATE NEXT ANG
                          FMUL TM,MD; DPX(0)<FA; BEQ FINISHUP  "SINE*X
          FADD;
                  LDSPI TBL1; DB=DPX(0);          "INT TMROM ADDRESS
                          FMUL TM,MD                     "COS*X
          FIX FA; MOVL TBL1,TBL1;                     "TBL1*2
                  DPX(3)<FA;
                          FMUL                    "PUSH
          FADD;
             MOV TBL1, TBL1; SETTMA                   "FETCH COSINE
            ADD YINC,YB; SETMA; MI<FM;      "SAVE X*SINE
                          FMUL
          INCTMA; INCMA; MI<FM;               "FETCH SIN, SAVE X*COS
                  DEC N;
                          BR LP
  FINISHUP:   RAPS; LDSPNL STATUS;              "READ STATUS
                FMUL DPX(3),DPY(2)              "PHASE * 1/SCALECONSTANT
          LDSPI MASK; DB=177740
                FMUL
          AND MASK, STATUS;                           "RETURN STATUS VALUE
                  LDAPS; DB=SPFN;
                        FMUL
        MOV T0,T0; SETMA ; MI<FM;               "SAVE NEXT INITIAL PHASSE
                RETURN
  SCL2K :        $FP     0.1303797294E4          "(2/PI)*TABLE SIZE
  SCL4K:         $FP     0.2607594588E4          " CONSTANT FOR 4K TMROM
  INSC2K:        $FP     0.7669903938E-3        "INVERSE SCALECON 2K
  INSC4K:        $FP     0.3834951969E-3        "INVERSE SCALECON 4K
          $END
"****** SHPHU = SCHAFER'S PHASE UNWRAPING /COMMON/ = REL 3.0, SEP 79
"
        $TITLE SHPHU
        $RADIX 8
        XADC   $EQU 1           "COND. ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY SHPHU, 6         "USER-DIRECTED-CALL ENTRY
"
"               --- ABSTRACT ---
"MAKES A VECTOR OF PHASE ANGLES CONTINUOUS, I.E. REMOVES THE DISCONTINUITIES
"CAUSED BY THE ARCTANGENT GIVING ONLY THE PRINCIPLE VALUE OF AN ANGLE
"
"FORMULA:
"       C(M) = A(M) + COR(M)
"         WHERE:
"              COR(M) = COR(M) -2*PI IF DELTA>LIMIT.
"              COR(M) = COR(M) +2*PI IF DELETA<-LIMIT.
"              COR(M) = COR(M-1) IF -LIMIT <= DELTA <=LIMIT.
"              C(0)   = A(0)
"              COR(0) = 0
"              DELTA  = A(M) - A(M-1)
"              LIMIT  = 2*PI - EPSILON (RECOMMENDED EPSILON = PI)
"
"
"
"
"NOTE:  IF THE DC COMPONENT IN THE TIME DATA IS NEGATIVE THE DATA SHOULD BE
"       NEGATED TO FORCE PHASE(0) = C(0) = 0
"
"               --- STATISTICS ---
"LANGUAGE:      APAL
"EQUIPMENT:     AP-120B
"SIZE:          20 LOCATIONS
"EXECUTION      BEST    TYPICAL         WORST           SETUP (US)
"TIME/LOOP:     1.2     1.3             1.5             1.5        167NS MEMORY
"  (US)         1.2     1.3             1.5             1.5        333NS MEMORY
"SUBROUTINES USED: NONE
"AUTHOR:        A.E. CHARELSWORTH, DEC, 75
"REL. X.X:       R. COLYAR, JUN 79    NOTES ADDED TO DOCUMENTATION
"
"               --- USAGE ---
"FORTRAN:       CALL SHPHU (A,I,B,C,K,N)
"APAL:          JSR SHPHU
"S-PAD PARAMETERS
"       NAME            NUMBER
        A       $EQU    0       "BASE ADDRESS OF VECTOR A
        I       $EQU    1       "INCREMENT FOR A
        B       $EQU    2       "ADDRESS OF EPSILON
        C       $EQU    3       "BASE ADDRESS OF VECTOR C
        K       $EQU    4       "INCREMENT FOR C
        N       $EQU    5       "COUNT OF C
"
"SCRATCH:  SP(0,1,2,3,4,5,6), DPX(0,1,2), DPY(0,1), FA, FM, MD, TM
"TABLE MEMORY ADDRESS:
        TWOPI   $EQU    !TWOPI          "TWO PI
"               --- ALGORITHM ---
"  1.   C(0) = A(0),  COR(0) = 0.0
"       LIMIT = 2*PI - EPSILON
"  2.   FOR M = 1 TO N-1:
"          DELTA = A(M) - A(M-1)
"          IF DELTA .GT. LIMIT THEN COR(M) = COR(M-1) - 2*PI    (1.17 US)
"          IF DELTA .LT. -LIMIT THEN COR(M) = COR(M-1) + 2*PI    (1.5 US)
"          OTHERWISE  COR(M) = COR(M-1)                         (1.17 US)
"       IN EITHER CASE:  C(M) = A(M) + COR(M)
"NOTE:  ON SETTING LIMIT
"EPSILON IS AN INPUT PARAMETER THAT SETS LIMIT, LIMIT = 2*PI-EPSILON. LIMIT
"IS USED AS A TEST OF THE PHASE CHANGE FROM THE LAST PRINCIPLE PHASE VALUE
"(A(M-1)) TO THE CURRENT PRINCIPLE PHASE VALUE (A(M)). AN ADDITION OF +/- TWO
"PI IS MADE TO THE CUMULATIVE CORRECTION TERM IF ABS (A(M)-A(M-1)) > LIMIT,
"IE IF DELTA > LIMIT. LIMIT SHOULD BE AS LARGE AS POSSIBLE TO HANDLE RAPID
"PHASE CHANGES, BUT THIS CAN LEAD TO INCORRECT UNWRAPPING WHEN A(M) IS WITHIN
"LIMIT BUT SHOULD HAVE A +/- 2*PI CORRECTION FACTOR. THIS INDICATES THAT
"SETTING LIMIT = PI IS A LOGICAL CHOICE. FOR THIS ALGORITHM THIS MEANS SETTING
"EPSILON = PI.
"
"A IS A VECTOR OF PRINCIPLE VALUES OF PHASE ANGLES, I. E. BETWEEN -PI AND +PI
"
"DATA PAD MNEMONICS
"       DPX  ......................
        DELTA $EQU 0                    "DELTA = A(M+1)-A(M)
        COR   $EQU 1                    "CORRECTION FACTOR
        T     $EQU 2                    "HOLDS A(M) + COR
"
"       DPY  ......................
        LAST  $EQU 0                    "HOLDS A(M)
        LIMIT $EQU 1
"
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FSHPHU,6                           "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU 62
        $PARAM 6, PA(#2,#6)/R/IP, PI/I/IP,
                  PB/R/IP,
                  PC(#5,#6)/R/OP,PK/I/IP,
                  PN/I/IP
FSHPHU:  LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
"---------------------------------------------------------------------
" BEGIN BY CHECKING THE SIZE OF THE ARRAY.
"---------------------------------------------------------------------
SHPHU:  MOV N,N                         "IS N NON ZERO ?
        BGT .+2                         "YES.GET ON WITH SHPHU.
        JMP DONE                        "NO.RETURN TO THE HOST RTNE.
"
"INITIALIZE AND FETCH FIRST TWO DATA POINTS:
"
         MOV B,B;SETMA;                 "FETCH EPSILON
          DPX(COR)<ZERO                 "SET COR TO 0.0
        LDTMA;DB=TWOPI                  "FETCH TWOPI
        MOV A,A;SETMA                   "FETCH A(B)
        NOP                             "FOR UPWARD COMPATABILITY
        ADD I,A;SETMA;                  "FETCH A(1)
          FSUB TM,MD                    "LIMIT = TWOPI - EPSILON
        NOP                             "FOR UPWARD COMPATIBLITY
        DPY(LAST)<MD;MI<MD;             "SAVE A(0)
          MOV C,C;SETMA;FADD            "C(0) = A(B)
        NOP                             "FOR UPWARD COMPATIBILITY
        FSUBR DPY(LAST),MD;             "DELTA = A(1) - A(0)
          DPY(LIMIT)<FA;                "SAVE LIMIT
          DEC N;
          BR LOOP                       "GET INTO THE LOOP
"
"COME HERE IF (A(M) - A(M-1)) IS BETWEEN LIMIT AND -LIMIT ................
"
SAME:   MI<DPX(T);ADD K,C;SETMA;        "STORE C(M) = A(M) + COR
          FSUBR DPY(LAST),MD;           "DELTA = A(M+1)-A(M)
          BEQ DONE                      "BRANCH IF DONE
"
"THE LOOP......ALL BRANCHES COME BACK TO HERE.............................
"
LOOP:   FADD DPX(COR),MD                "A(M) + COR
        FSUBR DPY(LIMIT),FA;            "DELTA - LIMIT
          DPX(DELTA)<FA                 "SAVE DELTA
        FADD DPX(DELTA),DPY(LIMIT);     "DELTA + LIMIT
          DPX(T)<FA;                    "SAVE A(M) + COR
          ADD I,A;SETMA                 "FETCH A(M+1)
        FSUBR TM,DPX(COR);              "COR - TWOPI
          DPY(LAST)<MD                  "SAVE A(M)
        FSUBR TM,DPX(T);                "A(M) + COR - TWOPI
          DEC N;                        "COUNT ITERATIONS
          BFGT BIG                      "BRANCH IF DELTA .GT. LIMIT
        FADD TM,DPX(COR);               "COR + TWOPI
          BFGE SAME                     "BRANCH IF DELTA .GE. -LIMIT
"
"COME HERE IF DELTA WAS .LT. -LIMIT ................................
"
SMALL:  FADD TM,DPX(T)                  "A(M) + COR + TWOPI
"
"BRANCH TO HERE IF DELTA WAS .GT. LIMIT  ...........................
"
BIG:    DPX(COR)<FA;                    "SAVE THE NEW COR
          MOV N,N;FADD                  "TEST N FOR DONE
        MI<FA;ADD K,C;SETMA;            "STORE C(M)
          FSUBR DPY(LAST),MD;           "DELTA = A(M+1)-A(M)
          BNE LOOP                      "BRANCH IF NOT DONE
DONE:   RETURN
        $END
"****** UNWRAP = ADAPTIVE PHASE UNWRAPPING /COMMON/ = REL 3.2, DEC 80
"       FOR EITHER MEMORY
        $TITLE UNWRAP
        $RADIX 8
        XADC $EQU 1         "CONDITIONAL ASSEMBLY PARAM.FOR ADC/APFTN.
        $ENTRY UNWRAP,3         "UDC MODE ENTRY POINT.
"
"
"         EXTERNALS.
"
        $EXT RFFT
        $EXT UNWCOR
        $EXT VMOV
"
"  --- HISTORY ---
"ORIGINAL:  JUN 79  R. L. KIRLIN
"REVISED:   SEP 79  D. GANGULY      'UNWCOR' EXTRACTED
" REV 3.1:  AUG 80  D. GANGULY      MODIFIED $PARAM STMT TO ALLOW
"                                   W TO BE BOTH INPUT AND OUTPUT
" REV 3.2:  DEC 80  T. E. SKINNER   MODS FOR TAR #2242 --
"                                   UNWCOR-UNWRAP COMMUNICATION
"
"  --- USAGE ---
"       FORTRAN CALL:
"         CALL UNWRAP(A,W,NT2)
"       APAL CALL
"         JSR UNWRAP
"
"       WHERE
"       A = BASE ADDR OF FOURIER TRANSFORM, X(F),  INPUT.
"           FOR BOTH INPUT AND OUTPUT THIS VECTOR IS IN SPECIAL
"           PACKED FORM, WITH THE REAL FOLDING FREQUENCY VALUE
"           PLACED IN THE SECOND ELEMENT (OR THE DC 'IMAG' SPOT).
"           THE LENGTH OF THIS VECTOR IS NT.
"           UPON RETURN, TWO DIAGNOSTIC PARAMETERS, SGNX AND SHFT
"           (DESCRIBED BELOW) ARE APPENDED TO THE A VECTOR AT MD
"           ADDRESSES A+NT AND A+NT+1.
"           LOGMAG(X(F)) IS RETURNED IN REALS, UNWRAPPED PHASE IS
"           RETURNED IN IMAGINARIES.FIRST & SECOND ELEMENTS ARE DC &
"           FOLDING FREQUENCY REALS LOGMAGNITUDE.
"       W = B = WORKSPACE
"           IF DESIRED, THE VALUES OF THE PHASE DERIVATIVE CAN BE
"           RETRIEVED FROM MD AT B+2*NT THRU B+5*NT/2, IN ORDER DC
"           THRU FOLDING FREQUENCY (NT/2+1 POINTS).
"       NT2 = NT+2.  NT=# ELEMENTS IN TIME VECTOR = # REAL + # IMAGINARY
"            PARTS OF X(F); NT IS A POWER OF 2.
"       SGNX = A+NT = ADDRESS OF
"               SIGN OF DC COMPONENT  X(F), F=0, RETURNED AS +1 OR -1 TO
"              INDICATE UNWRAPPING HANDLED ACCORDINGLY.  IF NEGATIVE,
"              X(T) AND X(F) ARE NEGATED BEFORE RETURNING.
"               ADDITIONALLY, IF THE ALGORITHM FAILS TO CONVERGE, SGNX IS
"              RETURNED AS A ZERO, AND THE CALLING PROGRAM SHOULD CHECK
"              FOR THIS CONDITION.
"        SHFT = A+NT+1 = ADDRESS OF
"               # OF SHIFTS OF X(T) WHICH IS EQIVALENT TO THE PHASE
"               TREND REMOVAL; IF PROGRAM FAILS, INDEX OF LAST ACCEPTABLE PHASE
"               IS RETURNED HERE
"
"              --- ABSTRACT ---
"
"       THE UNWRAPPED PHASE OF A FOURIER TRANSFO~ORM IS A FUNCTION
"       OF FREQUENCY WHICH IS NOT CONSTRAINED TO PRINCIPLE VALUES,
"       BUT IS ZERO AT DC AND TAKES ON VALUES EQUAL TO THE PRN-
"       CIPLE VALUES PLUS + L*2PI SUCH THAT L GIVES THE BEST INTEGER
"       MATCH TO THE INTEGRATION OF THE PHASE DERIVATIVE.  IF
"       X(F) = R+JI AND DX(F)/DF =U+JV,THE PRINCIPLE VALUE IS
"       ARCTAN I/R AND THE PHASE DERIVATIVE IS (R*V-I*U)/(R*R+I*I).
"       DX(F)/DF IS FOUND BY TRANSFORMING T*X(T), (N*X(N)), AND
"       MULTIPLYING BY -J.  LETTING THE TRANSFORM OF T*X(T)=
"       RP+J*IP, THE PHASE DERIVATIVE=-(R*RP+I*IP)/(R*R+I*I),
"       AT FREQUENCIES K, 0<=K<=NT/2.
"       A DIRECT INTEGRATION OF THE PHASE DERIVATIVE IS USUALLY NOT
"       SUFFICIENTLY ACCURATE NEAR RAPID PHASE CHANGES.  THE ADAPTIVE
"       METHOD OF TRIBOLET, "A PHASE UNWRAPPING ALGORITHM," IEEE
"       TRANS ASSP,APRIL 77, IS IMPLEMENTED HERE.
"
"       IF THE DC COMPONENT OF X IS NEGATIVE, A -1 IS FACTORED OUT
"       AND THE SIGN IS RETURNED IN SGNX.  THE UNWRAPPED PHASES OF
"       NON DC FREQUENCIES ARE ACCOORDINGLY SHIFTED BY PI.
"
"     --- SPAD ASSIGNMENTS ---
"
"     NAME       SPAD        USE
"   ----------  -------    ------------
        A $EQU    0        "BASE ADDR OF X(T)
        B $EQU    1        "BASE ADDR OF X(F) AND LOGMAG/PHASE OUT
        NT $EQU   2        "NO. OF ELEMENTS IN X(T)
                           "  WITH ACCEPTED PHASE STORED HERE (VALUE OF K)
      SGNX $EQU   3        "ADDRESS OF  SIGN OF DC COMPONENT =B+NT
      SHFT $EQU   4       "ADDRESS OF # SHIFTS TO DETREND =B+NT+1
        M $EQU    6         "ADDR OF NT*2**12, M=D+NT/2+1
       NR $EQU    7         "BASE ADDR OF NR(I):
"                            (NR/M=FREQ); NR=PHIP+NT
        C $EQU   10        "BASE ADDR OF TX(T) = B+NT
        D $EQU   11        "BASE ADDR OF J*XP(F) = DX(F)/DF = RP+JIP, D=C+NT
"                                 GETS REPLACED BY PHASE DERIVATIVE PHI'(F)
        E $EQU   12        "BASE ADDR OF POLAR X(F)=MAG(X(F)),PRNCPL VALUES,
"                                 E=D+NT
      PHIP $EQU  13        "BASE ADDR OF INTERMEDIATE PHIP(I),PRNCPL VALUES
"                                 PHIP=E+NT
     PHIDVT $EQU 14        "BASE ADDR OF INTERMEDIATE PHI'(I),PHASE DERIV'S
"                                 PHIDVT=PHIP+13.
"
"         --- OTHER MD LOCATIONS ---
"       D+NT/2+1       M
"       E+NT           F          BASE ADDR OF 1/X(F)=(R-I)/(R*R+I*I)
"
"
"     --- DATA PAD USAGE ---
"            DPX       DPY
"          -------   -------
"      -7     DPA
"      -6     A      X(F),F=0
"      -5     K         I
"      -4   PHILFT    PHDVTL
"      -3    NL         NR
"      -2  PHIDVT(I)   DVTMN
"      -1     H          H1
"       0                A1
"       1                NT
"       2              ELPINC
"       3  IM,PHIP(I)  RE,A2
"
"         SIZE:735 UNWRAP+1464 EXTERNALS=2421 (BASE 8)
"                                                        (167 NS MEMORY)
"              735 UNWRAP+1440 EXTERNALS=2375 (BASE 8)
"                                                        (333 NS MEMORY)
"         SPEED: 25.4*NT+2*RFFT(NT)+(130.+1.7*NT)*C
"                                                        (167 NS MEMORY)
"                28.3*NT+2*RFFT(NT)+(130.+1.7*NT)*8.2
"                                                        (333 NS MEMORY)
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
" *** CONDITIONAL ASSEMBLY ***
  $IF XADC=1
  $SUBR FUNWRP,3
  $EXT RESLVE
  BITMAP $EQU 4
  $PARAM 3,P1(#3)/R/IP/OP,P2(6,#3)/R/IP/OP,P3/I/IP
  FUNWRP: LDSPI 17;DB=BITMAP
  JSR RESLVE
  $ENDIF
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
"-----------------------------------------------------------------------
"    BEGIN BY CHECKING THE SIZE OF THE ARRAY.
"-----------------------------------------------------------------------
UNWRAP: MOV NT,NT                            "IS NT NON ZERO ?
        BGT .+2                              "YES.THEN GET ON WITH UNWRAP.
        JMP RTRN                             "NO.RETURN TO THE CALLING RTNE.
"----------------------------------------
"      MOVE X(F) TO B,GET X(T) INTO A
"---------------------------------------
        MOV A,6                              "SAVE A
        DEC NT
        DEC NT                               "NT NT2-2
        MOV NT,7                             "SAVE NT
        MOV NT,4
        MOV B,2;                             "DEST IS B
          DPY(-4)<SPFN;INCDPA                "SAVE B IN DPY(-4)
        LDSPI 1;DB=1                         "INC
        MOV 1,3
        JSR VMOV
        MOV 6,0                              "A
        MOV 7,1                              "NT
        LDSPI 2;DB=-1                        "INVERSE FFT
        JSR RFFT                             "X(T) IN A. SCR SP(2-17)
        DECDPA;MOV 1,2                       "NT IN NT
        LDSPI 6;DB=DPY(-4)                   "RESTORE B
"---------------------------
"       GET T*X(T) INTO C
"---------------------------
"           GET T FIRST
"
"
        RDPA;LDSPNL 17
        MOV 17,17;DPX(-4)<SPFN               "INITIAL DPA IN DPX(-4) TEMP
        MOV 6,B;SETMA                        "GET DC VALUE, AND B IN B
        LDDPA;DB=-6. ;
          MOV A,5                            "SAVE A
        MOV NT,7;                            "SAVE NT
          DPX(-1)<DPX(2)                     "STORE INITIAL DPA IN DPX(-7)
        MOV NT,4;                            "COUNT
          DPY(0)<MD                          "STORE DC VALUE IN DPY(-6)
        LDTMA;DB=!ONE;
          ADD B,NT                           "B+NT=C=BASE ADDR OF T AND T*X(T)
        JSR UNWCOR                           "CALL THE CORE ROUTINE.
        LDDPA;DB=DPX(-1)                     "SET INITIAL DPA FROM DPX(-7)
"
"           MOVE LOG(X(F)) TO A FOR OUTPUTTING
"
        MOV 17,17                            "SP(17)=0 IMPLIES CONVERGENCE
        BEQ NOFAIL
        RETURN
NOFAIL: MOV 7,0                              "B IS SOURCE
        MOV 11,2                             "A IS DEST
        MOV 10,4                             "NT IS COUNT
        DEC 3
        JSR VMOV
        NOP
RTRN:   RETURN
        $END
"****** CPSTRM = COMPLEX CEPSTRUM /COMMON/ = REL 3.2, DEC 80
"       FOR EITHER MEMORY
        $TITLE CPSTRM
        $RADIX 8
        XADC $EQU 1         "CONDITIONAL ASSEMBLY PARAM.FOR ADC/APFTN
        $ENTRY CPSTRM,3         "UDC MODE ENTRY POINT.
"
"       EXTERNALS
"
        $EXT VMOV
        $EXT RFFT
        $EXT RFFTSC
        $EXT UNWCOR
"
"  --- HISTORY ---
"ORIGINAL:  JUN 79  R. L. KIRLIN
"REVISED:   SEP 79  D. GANGULY       'UNWCOR' EXTRACTED
" REV 3.1:  AUG 80  D. GANGULY       MODIFIED $PARAM STMT TO ALLOW
"                                    W TO BE BOTH INPUT AND OUTPUT
" REV 3.2:  DEC 80  T. E. SKINNER    MODS FOR TAR #2242 --
"                                    UNWCOR-CPSTRM COMMUNICATION
"
"  --- USAGE ---
"       FORTRAN CALL:
"         CALL CPSTRM(A,W,NT2)
"       APAL CALL
"         JSR CPSTRM
"
"       WHERE
"       A = BASE ADDR OF TIME VECTOR INPUT & CEPSTRUM OUTPUT.
"           UPON RETURN, TWO DIAGNOSTIC PARAMETERS, SGNX AND SHFT
"           (DESCRIBED BELOW) ARE APPENDED TO THE A VECTOR AT MD
"           ADDRESSES A+NT AND A+NT+1.
"       W = B = BASE ADDR OF  FOURIER TRANSFORM, X(F), AND WORKSPACE.
"           IF  OUTPUT, THE FIRST NT WORDS ARE LOGMAG(X(F))  IN SPECIAL
"           PACKED FORM, WITH THE REAL FOLDING FREQUENCY VALUE
"           PLACED IN THE SECOND ELEMENT (OR THE DC 'IMAG' SPOT).
"           THE LENGTH OF THIS VECTOR IS NT, BUT AN ADDITIONAL
"           WORKSPACE OF 5*NT IS APPENDED.
"           LOG MAG X(F) IS RETURNED IN REALS, UNWRAPPED PHASE IS
"           RETURNED IN IMAGINARIES.FIRST & SECOND ELEMENTS ARE DC &
"           FOLDING FREQUENCY REALS LOGMAGNITUDE.
"           IF DESIRED, THE VALUES OF THE PHASE DERIVATIVE CAN BE
"           RETRIEVED FROM MD AT W+2*NT THRU W+5*NT/2, IN ORDER DC
"           THRU FOLDING FREQUENCY (NT/2+1 POINTS).
"       NT2 = NT+2.  NT= # ELEMENTS IN TIME VECTOR = NO. REAL + NO. IMAGINARY
"            PARTS OF X(F); NT IS A POWER OF 2.THE NEED FOR THE
"            ADDITIONAL 2 WORDS IS TO RETURN SGNX AND SHFT AS DES-
"            CRIBED BELOW.
"       SGNX = A+NT = ADDRESS OF
"               SIGN OF DC COMPONENT  X(F), F=0, RETURNED AS +1 OR -1 TO
"              INDICATE UNWRAPPING HANDLED ACCORDINGLY.  IF NEGATIVE,
"              X(T) AND X(F) ARE NEGATED BEFORE RETURNING.
"               ADDITIONALLY, IF THE ALGORITHM FAILS TO CONVERGE, SGNX IS
"              RETURNED AS A ZERO, AND THE CALLING PROGRAM SHOULD CHECK
"              FOR THIS CONDITION.
"        SHFT = A+NT+1 = ADDRESS OF
"               # OF SHIFTS OF X(T) WHICH IS EQIVALENT TO THE PHASE
"               TREND REMOVAL;  IF PROGRAM FAILS, INDEX OF LAST ACCEPTABLE PHASE
"               IS RETURNED HERE
"
"              --- ABSTRACT ---
"
"       THE CEPSTRUM IS COMPUTED BY FIRST FFT'ING THE TIME DATA TO
"       GET X(F); THE REALS ARE CHANGED TO LOGMAG, AND THE PHASES
"       ARE UNWRAPPED; THE RESULT IS INVERSE FFT'D TO GIVE CEPSTRUM.
"       THE UNWRAPPED PHASE OF A FOURIER TRANSFO~ORM IS A FUNCTION
"       OF FREQUENCY WHICH IS NOT CONSTRAINED TO PRINCIPLE VALUES,
"       BUT IS ZERO AT DC AND TAKES ON VALUES EQUAL TO THE PRN-
"       CIPLE VALUES PLUS + L*2PI SUCH THAT L GIVES THE BEST INTEGER
"       MATCH TO THE INTEGRATION OF THE PHASE DERIVATIVE.  IF
"       X(F) = R+JI AND DX(F)/DF =U+JV,THE PRINCIPLE VALUE IS
"       ARCTAN I/R AND THE PHASE DERIVATIVE IS (R*V-I*U)/(R*R+I*I).
"       DX(F)/DF IS FOUND BY TRANSFORMING T*X(T), (N*X(N)), AND
"       MULTIPLYING BY -J.  LETTING THE TRANSFORM OF T*X(T)=
"       RP+J*IP, THE PHASE DERIVATIVE=-(R*RP+I*IP)/(R*R+I*I),
"       AT FREQUENCIES K, 0<=K<=NT/2.
"       A DIRECT INTEGRATION OF THE PHASE DERIVATIVE IS USUALLY NOT
"       SUFFICIENTLY ACCURATE NEAR RAPID PHASE CHANGES.  THE ADAPTIVE
"       METHOD OF TRIBOLET, "A PHASE UNWRAPPING ALGORITHM," IEEE
"       TRANS ASSP,APRIL 77, IS IMPLEMENTED HERE.
"
"       IF THE DC COMPONENT OF X IS NEGATIVE, A -1 IS FACTORED OUT
"       AND THE SIGN IS RETURNED IN SGNX.  THE UNWRAPPED PHASES OF
"       NON DC FREQUENCIES ARE ACCOORDINGLY SHIFTED BY PI.
"
"     --- SPAD ASSIGNMENTS ---
"
"     NAME       SPAD        USE
"   ----------  -------    ------------
        A $EQU    0        "BASE ADDR OF X(T) & CEPSTRUM OUTPUT.
        B $EQU    1        "BASE ADDR OF X(F) AND LOGMAG/PHASE OUT
        NT $EQU   2        "NO. OF ELEMENTS IN X(T)
                           "  WITH ACCEPTED PHASE STORED HERE (VALUE OF K)
      SGNX $EQU   3        "ADDRESS OF  SIGN OF DC COMPONENT =B+NT
      SHFT $EQU   4       "ADDRESS OF # SHIFTS TO DETREND =B+NT+1
        M $EQU    6         "ADDR OF NT*2**12, M=D+NT/2+1
       NR $EQU    7         "BASE ADDR OF NR(I):
"                            (NR/M=FREQ); NR=PHIP+NT
        C $EQU   10        "BASE ADDR OF TX(T) = B+NT
        D $EQU   11        "BASE ADDR OF J*XP(F) = DX(F)/DF = RP+JIP, D=C+NT
"                                 GETS REPLACED BY PHASE DERIVATIVE PHI'(F)
        E $EQU   12        "BASE ADDR OF POLAR X(F)=MAG(X(F)),PRNCPL VALUES,
"                                 E=D+NT
      PHIP $EQU  13        "BASE ADDR OF INTERMEDIATE PHIP(I),PRNCPL VALUES
"                                 PHIP=E+NT
     PHIDVT $EQU 14        "BASE ADDR OF INTERMEDIATE PHI'(I),PHASE DERIV'S
"                                 PHIDVT=PHIP+13.
"
"         --- OTHER MD LOCATIONS ---
"       D+NT/2+1       M
"       E+NT           F          BASE ADDR OF 1/X(F)=(R-I)/(R*R+I*I)
"
"
"     --- DATA PAD USAGE ---
"            DPX       DPY
"          -------   -------
"      -7     DPA
"      -6     A      X(F),F=0
"      -5     K         I
"      -4   PHILFT    PHDVTL
"      -3    NL         NR
"      -2  PHIDVT(I)   DVTMN
"      -1     H          H1
"       0                A1
"       1                NT
"       2              ELPINC
"       3  IM,PHIP(I)  RE,A2
"
"         SIZE:750 UNWRAP+1464 EXTERNALS=2434 (BASE 8)
"                                                        (167 NS MEMORY)
"              750 UNWRAP+1440 EXTERNALS=2410 (BASE 8)
"                                                        (333 NS MEMORY)
"         SPEED: 25.7*NT+3*RFFT(NT)+(130.+1.7*NT)*C
"                                                        (167 NS MEMORY)
"                28.6*NT+3*RFFT(NT)+(130.+1.7*NT)*C
"                                                        (333 NS MEMORY)
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
" *** CONDITIONAL ASSEMBLY ***
  $IF XADC=1
  $SUBR FCPSTR,3
  $EXT RESLVE
  BITMAP $EQU  4
  $PARAM 3,P1(#3)/R/IP/OP,P2(6,#3)/R/IP/OP,P3/I/IP
  FCPSTR: LDSPI 17;DB=BITMAP
  JSR RESLVE
  $ENDIF
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
"---------------------------------------------------------------------
"  BEGIN BY CHECKING THE ARRAY SIZE.
"---------------------------------------------------------------------
CPSTRM: MOV NT,NT                      "IS NT NON ZERO
        BGT .+2                        "YES.
        JMP RTRN                       "NO.EXIT.
"
"
"---------------------------------------------------------------------
"   BEGIN PROGRAMME.
"--------------------------------------------------------------------
        RDPA;LDSPNL 17
        MOV 17,17;DPX(-4)<SPFN         "INITIAL DPA IN DPX(-4) TEMP
"------------------------------------------------
"          MOVE X(T) TO B, GET FFT AND SCALE
"------------------------------------------------
        MOV A,A;DPY(-4)<SPFN;INCDPA    "TEMP STORE A
        DEC NT
        DEC NT                         "NT=NT2-2
        MOV B,6                        "SAVE B
        MOV NT,7                       "SAVE NT
        MOV NT,4
        LDSPI 1;DB=1                   "INC
        MOV 6,2                        "DEST
        MOV 1,3
        JSR VMOV
        MOV 6,0                        "B
        MOV 7,1                        "NT
        LDSPI 2;DB=1                   "FORWARD FFT
        JSR RFFT                       "SCR SP(2-17)
        LDSPI 3;DB=1                   "SCALE BY 1/2NT
        LDSPI 2;DB=ZERO                "NO FORMAT CHANGE
        JSR RFFTSC
        DECDPA;MOV 1,2                 "NT IN NT
        MOV 0,6;SETMA                  "B IN 6, GET DC VALUE
        LDSPI 0;DB=DPY(-4)             "RESTORE A
"---------------------------
"       GET T*X(T) INTO C
"---------------------------
"           GET T FIRST
"
"
        LDDPA;DB=-6. ;
          MOV A,5                      "SAVE A
        MOV NT,7;                      "SAVE NT
          DPX(-1)<DPX(2)               "STORE INITIAL DPA IN DPX(-7)
        MOV NT,4;                      "COUNT
          DPY(0)<MD                    "STORE DC VALUE IN DPY(-6)
        LDTMA;DB=!ONE;
          ADD 6,NT                     "B+NT=C=BASE ADDR OF T AND T*X(T)
        JSR UNWCOR                     "CALL UNAWRAP CORE (UNWCOR).
        MOV 17,17                      "SP(17)=0 IMPLIES CONVERGENCE
        BEQ NOFAIL
        BR FAIL
"-------------------------------------------------------
"         GET CEPSTRUM HERE
"-------------------------------------------------------
NOFAIL: MOV 7,0                        "B
        MOV 10,4                       "NT
        LDSPI 2;DB=DPX(0)              "GET A
        LDSPI 1;DB=1
        MOV 1,3
        JSR VMOV                       "MOV LOGMAG(X(F)) TO A
        LDSPI 0;DB=DPX(0)              "A
        LDDPA;DB=8.
        MOV 10,1                       "NT
        LDSPI 2;DB=-1                  "INVERSE FFT
        JSR RFFT
FAIL:   LDDPA;DB=-7
        LDDPA;DB=DPX(0)                "SET INITIAL DPA FROM DPX(-7)
RTRN:   RETURN
        $END
"****** UNWCOR = UNWRAP & CPSTRM CORE CODE /COMMON/ = REL 3.1, DEC 80 ****
"
" THIS SECTION OF CODE IS COMMON TO BOTH UNWRAP & CPSTRM.
" IT IS CALLABLE ONLY FROM OTHER APAL ROUTINES.
"
"
        $TITLE UNWCOR
        $RADIX 8
        $ENTRY UNWCOR
"
"       EXTERNALS
"
        $EXT DIV
        $EXT SPFLT
        $EXT VSUB
        $EXT VNEG
        $EXT RDFT
        $EXT ATN2
        $EXT VRAMP
        $EXT VMUL
        $EXT VLOG
        $EXT POLAR
        $EXT CVRCIP
        $EXT VMMSB
        $EXT VDIV
        $EXT SVE
        $EXT RFFT
        $EXT RFFTSC
        $EXT VMOV
"
"       S-PAD ASSIGNMENTS ARE IDENTICAL TO THAT OF THE CALLING ROUTINES.
"
        A = 0
        B = 1
        NT = 2
        SGNX = 3
        SHFT = 4
        M = 6
        NR = 7
        C = 10
        D = 11
        E = 12
        PHIP = 13
        PHIDVT = 14
"
"  --- HISTORY ---
"ORIGINAL:  SEP 79  D. GANGULY     'UNWCOR' EXTRACTED, AS COMMON TO
"                                  BOTH 'CPSTRM' AND 'UNWRAP'
" REV 3.1:  DEC 80  T. E. SKINNER  MODS FOR TAR #2242 --
"                                  UNWCOR-CPSTRM AND UNWCOR-UNWRAP
"                                  COMMUNICATIONS
"
UNWCOR: MOV NT,C;                      "SAVE C
          DB=DPY(0)
        LDDPA;DB=ZERO;
          BDBN NEGATE                  "IF DC VALUE <0,NEGATE X(T) AND X(F)
POS:    MOVL 7,A                       "GET B+NT*2
        ADD 6,A;SETMA;MI<ZERO          "ADDR OF INITIAL ZERO
        MOV A,B                        "GET B+2*NT+1
        INC B;SETMA;MI<TM              "B+2*NT+1=ADDR OF ONE FOR INCR
        LDSPI SGNX;DB=1                "1=INC
        JSR VRAMP                      "SCRATCH SP 2,4
        JMP TXT
"
"          DC IS <0,NEGATE X(T) AND X(F)
"
NEGATE: MOV A,NT                       "A IS DESTINATION AND SOURCE, X(T)
        LDSPI B;DB=1                   "1 IS INC
        MOV B,SGNX
        JSR VNEG                       "DESTROY SP 0,2,4,15
        MOV 6,A                        "B IS SOURCE, X(F)
        MOV A,NT                       "DESTIN
        MOV 7,4                        "NT IS COUNT
        JSR VNEG                       "DESTROY SP 0,2,4,17
        MOV 7,4;                       "RELOAD COUNT , NT
          LDTMA;DB=!ONE
        MOV C,2
        JMP POS                        "GO BACK & GET T VECTOR
"
"           SETUP VMUL, GET T*X(T)
"
TXT:    MOV 5,A                        "A IS SOURCE 1
        MOV A,13                       "SAVE A
        MOV C,NT                       "C IS SOURCE 2
        MOV 6,12                       "SAVE B
        MOV C,4                        "C IS DESTINATION BASE
        MOV SGNX,B
        MOV SGNX,5                     "INC = 1 IN SP 1,3,5
        MOV 7,6                        "NT IS COUNT
        JSR VMUL                       "SCRATCH SP 0,2,4,6,17
"------------------------------------------
"       GET (FFT OF T*X(T)) = XP(F) INTO D
"------------------------------------------
        MOV C,A                        "C IS SOURCE
        MOV 7,2                        "GET NT+C
        ADD A,2                        "NT+C=D=ADDR OF XP(F)
        MOV 2,D                        "D IN SP 11
        MOV 7, 4                       "NT IS COUNT
        JSR VMOV                       "DESTR SP(0,2,4,17)
              "
              "  SETUP RFFT
              "
        MOV D,0                        "SOURCE
        MOV 7,1;                       "NT
          DECDPA
        MOV 3,2;                       "FORWARD FLAG = 1
          DECDPA
        MOV 13,13;DPX(-4)<SPFN         "SAVE A IN DPX(-6)
        LDDPA;DB=1
        JSR RFFT                       "SCRATCH SP (2-17),DP(-4TO 3)
"
"             SCALE F-DOMAIN T*X(T) BY 1/(2*NT)
"
        MOV 2,1                        "MOV NT TO 1 , #PTS
        LDSPI 2;DB=ZERO                "FLAG, NO FORMAT CHANGE
        LDSPI 3;DB=1                   "FLAG, SCALE BY 1/(2*NT)
        JSR RFFTSC                     "DESTROYS SP(10-15)
        DECDPA;                        "RESET DPA TO ZERO
          MOV A,10                     "D IN SP10
        MOV B,7                        "NT IN 7
        MOVL B,B                       "2NT
        SUB B,A                        "D-2NT=B
        MOV A,6                        "B IN SP6
"------------------------------------
"       GET POLAR OF X(F) INTO E
"------------------------------------
        LDSPI B;DB=2                   "2 IS INC
        MOV B,SGNX
        ADD B,A                        "B+2, AVOID DC
        MOVR 7,4                       "NT/2-1 IS COUNT
        DEC 4
        MOV 7,NT                       "NT IN SP 2
        ADD 10,NT                      "D+NT=E=POLAR X(F) BASE ADDR
        MOV NT,11                      "SAVE E
        ADD B,NT                       "E+2, AVOID DC
        JSR POLAR                      "SCRATCH 0,2,4,5,12-17
"-----------------------------------------------------------------------
"       NOW GET PHI'(F)=-(R*RP+I*IP)/(R*R+I*I)
"                      = -(R/(R*R+I*I))*RP-(I/(R*R+I*I))*IP INTO D
"----------------------------------------------------------------------
"           GET 1/(R+JI)=(R-JI)/(R*R+I*I) OF X(F) INTO ADDR F+2,
"                   AVOID DC &FOLDING FREQUENCY
"
        MOV 6,A                        "B IS SOURCE
        ADD B,A                        "B+2, AVOID DC
        MOV 11,NT                      "GET F=E+NT = ADDR OF RECIP X(F)
        ADD 7,NT                       "E+NT=F
        ADD B,NT                       "F+2, AVOID DC
        MOV NT,12                      "SAVE F+2
        MOVR 7,4                       "NT/2-1 IS COUNT
        DEC 4
        JSR CVRCIP                     "RECIPROCAL,SCRATCH SP 0,2,4,5,15-17
        MOV 6,14                       "SAVE B
        MOV 7,15;FADD                  "SAVE NT
"
"           SET UP FOR MUL,MUL,SUB
"
        MOV 12,4                       "F+2 IS BASE OF R/(R*R+I*I)
        MOVR 7,12                      "NT/2-1 IS COUNT
        DEC 12
        MOV 10,6                       "GET D+2 = XP(F) BASE OF RP
        ADD B,6
        INC 10;                        "D+1 IS DESTINATION
          SETMA                        "GET RP(FF) TO STORE
        MOV 10,NT                      "GET D+3=XP(F),BASE OF IP
        ADD B,NT
        MOV 4,0;                       "GET F+3=BASE OF -I/(R*R+I*I)
          DPY(-4)<MD                   "STORE RP(FF)
        INC 0
        MOV B,3
        MOV B,5
        MOV B,7                        "INCS ARE 2,2,2,1
        LDSPI 11;DB=1
        JSR VMMSB                      "DESTROYS SP 0,2,4,6,10,12,17
                                       "PUTS PHI'(F) AT D+1=B+2*NT+1
"
"             NOW GET PHI'(F)=-RP/R AT F=0 & F=FOLDING FREQ
"
        MOV 14,A                       "GET B,X(F)
        MOVL 15,NT                     "2NT
        ADD A,NT                       "B+2*NT=D,XP(F)
        MOV NT,4                       "D IS DESTINATION
        MOV B,6                        "2 IS COUNT
        DEC B                          "1 IS INC
        MOVR 15,5                      "NT/2 IS INC FOR DESTIN
        MOV 5,SGNX                     "ALSO INC FOR RP AT D+1
        ADD# 15,NT;SETMA;MI<DPY(-4)    "PUT RP(FF) IN D+NT/2
        MOV 15,13                      "SAVE NT
        INCDPA                         "SAVE A IN DPX(-4) FROM VDIV
        JSR VDIV                       "RP/R IN D,D+NT/2; DC & FF,
                                       "DESTROYS SP(0,2,4,6-11,15-17)
                                       "& DPY(-4 TO 2),DPX(-1 TO 3)
        DECDPA;
"
"               NOW GET MINUS SIGN
"
          MOVL 13,A                    "2NT
        ADD 14,A                       "B+2*NT=D
        MOV A,2
        MOV 5,SGNX                     "NT/2 IS INC
        MOV 5,B
        LDSPI 4;DB=2                   "2 IS COUNT
        JSR VNEG                       "DESTROYS SP 0,2,4,17
                                       "NOW HAVE PHI'(K), 0<=K<=NT/2 , AT D
"------------------------------------------------------
"       GET LOGMAG(X(F)) INTO B REALS
"-----------------------------------------------------
        MOV 13,6                       "SAVE NT
        MOV 14,NT                      "GET B
        MOV 14,7                       "SAVE B
        LDSPI B;DB=2                   "INC =2
        MOV B,SGNX
        ADD B,NT                       "B+2 IS DESTIN ADDR
        MOV NT,A                       "GET B+2, START E
        ADD 13,A
        ADD 13,A                       "B+2*NT+2
        ADD 13,A                       "E+2=B+3*NT+2=SOURCE ADDR
        MOVR 13,4                      "NT/2
        DEC 4                          "NT/2-1 IS COUNT
        JSR VLOG                       "DESTROYS SP 0,2,4,13-17
"
"            NOW GET DC AND FOLDING FREQ LOGMAGS
"
        MOV 7,A                        "GET B=SOURCE
        DEC B                          "INC IS 1
        MOV A,NT                       "DESTINATION IS B
        MOV B,SGNX                     "INC IS 1
        MOVL B,4                       "COUNT IS 2
        JSR VLOG                       "DESTROYS SP 0,2,4,13-17
"------------------------------------------------------------
"              FIND AVERAGE PHASE DERIVATIVE,
"           DVTMN = (2*(SUM PHI'(K))-PHI'(0)-PHI'(NT/2))/NT
"-------------------------------------------------------------
"                SET UP SVE , SUM OF ELEMENTS
"
        MOVL 6,A                       "2NT
        ADD 7,A                        "D=B+2*NT
        MOV A,10                       "STORE D=ADDR PHI'(0)
        MOVR 6,SGNX                    "NT/2
        MOV A,NT                       "D+NT/2+1=ADDR OF SUM
        ADD SGNX,NT                    "D+NT/2
        MOV NT,11                      "STORE ADDR PHI'(NT/2)=D+NT/2
        INC NT                         "D+NT/2+1
        MOV NT,12                      "STORE ADDR RESULT
        INC SGNX                       "NT/2+1=COUNT
        JSR SVE                        "SUM. DESTROY SP(0,2,3)
        MOV 12,12;SETMA                "GET SUM
        LDTMA; DB=!TWO
        MOV 10,10;SETMA                "GET PHI'(0)
        FMUL TM,MD;                    "GET 2*SUM
          MOV 11,11;SETMA              "GET PHI'(NT/2)
        FMUL;MOV 10,11                 "PUT D IN D
        FMUL;MOVL 6,PHIP               "GET PHIP=D+2*NT;2NT
        FSUB FM,MD;                    "2*SUM-PHI'(0)
          ADD  D,PHIP                  "PHIP IN PHIP
        FADD;DPX(0)<MD;
          MOV 7,C                      "GET C=B+NT
        FSUBR DPX(0),FA;               "2*SUM-PHI'(0)-PHI'(NT/2)
          ADD 6,C                      "C=B+NT
        FADD;MOV 6,17                  "MOVE NT FOR FLOAT
        DPY(0)<FA;                     "STORE
          JSR SPFLT                    "DESTROY SP(16,17)
        DPX(0)<DPX(1);DPY(1)<DPX(1)    "SAVE FLT NT IN DPY(1)
        JSR DIV                        "GET DVTMN INTO DPY(-2)
        LDTMA;DB=!TWOPI
                                       "DESTROY SP(15-17),DPX(0,1),DPY(0)
        DPY(-2)<DPX(0);                      "STORE DVTMN IN DPY(-2)
          DECDPA
"-------------------------------------------------------------
"             GET AVERAGE PHASE CHANGE
"           ELPINC=2PI*DVTMN/NT
"--------------------------------------------------------------
        FMUL TM,DPX(1);                "2PI*DVTMN
          DECDPA
        FMUL;LDSPI A;DB=DPX(-4);       "MOV A TO A FROM DPX(-6)
          INCDPA
        FMUL;MOV 6,NT;                 "MOV NT TO NT
          INCDPA                       "RESET DPA TO 0
        DPY(0)<FM;DPX(0)<DPY(1)        "SET UP DIV
        JSR DIV
        DPY(2)<DPX(0)                  "STORE ELPHINC IN DPY(2)
"-------------------------------------------------------------------
"           GET H=PI/NT AND H1=PI/M=H/4096
"-------------------------------------------------------------------
        MOV NT,17                      "GET NT INTO DPX(0)
        JSR SPFLT                      "FLOAT NT INTO DPX(1)
        MOV 7,B;                       "MOV B INTO B
          LDTMA;DB=!PI
        RPSF CON3;DPY(-1)<DB           "4096
        MOV D,E;                       "GET E=D+NT
          DPY(0)<TM                    "PI IN DPY(0)
        DPX(0)<DPX(1);                 "NT INTO DPX(0)/
          ADD NT,E                     "E INTO E
        JSR DIV                        "SCRATCH SP 15-17
        DPX(-1)<DPX(0);                "STORE H  IN DPX(-1)
          DPY(0)<DPX(0);               "SETUP H/4096
          MOV PHIP,NR                  "GET NR=PHIP+NT
        DPX(0)<DPY(-1);                "LOAD 4096 FOR DIVIDE
          ADD NT,NR                    "NR IN NR
        JSR DIV
"       END SET UP,  BEGIN PHASE INTEGRATION
"--------------------------------------------------------------
"          PREPARE FOR INTEGRATING PHI'(F) AND TESTING
"--------------------------------------------------------------
"
"            GET PHIDVT=PHIP+13, AND M=NT*2**12
"
        LDSPI 14;DB=13.
        ADD PHIP,PHIDVT;               "PHIDVT=PHIP+13,IN SP 14
          DPY(-1)<DPX(0)               "STORE H1 IN DPY(-1)
        RPSF CON3; DPX(0)<DB           "GET 4096
        FMUL DPY(1),DPX(0);            "GET M=NT*2**12
          MOVR NT,M                    "NT/2 IN M
        FMUL;ADD D,M                   "D+NT/2 IN M
        FMUL;INC M                     "M IN MD AT D+NT/2+1
        MOV M,M;SETMA;MI<FM;           "STORE NT*2**12
"
"
"-------------------------------------------------------------------
"            BEGIN PHI' INTEGRATION, K IS INDEX
"-------------------------------------------------------------------
          DECDPA
        LDTMA;DB=!ONE
        DPY(-4)<ZERO                   "INITIAL HALVING LEVEL I S ZERO;
                                       "I IS STACK COUNTER
        DPX(-4)<TM;                    "INITIAL K IS 1
          INCDPA
"
"    ASSUME IN PLACE: SP(0,1,2,6,7,10,13,14),DPX(-7,-6,-5,-1),DPY(-6,-2,-1,1,2)
"                   NEWK IS MAIN LOOP, NO ADAPTIVE
"
NEWK:   DECDPA
        FIX  DPX(-4);                  "GET K
          MOVL NT,D;INCDPA             "START TO GET D
        ADD  B,D;FADD                  "D=B+2*NT
        DPX(0)<FA;                     "K IN DPX(0)
          INC# M;SETMA;MI<DPY(1)       "STORE FLOATED NT AT M+1
        LDSPI SGNX;DB=DPX(0)           "K IN SGNX
        ADD SGNX,D;SETMA               "GET PHI' AT D+K
        NOP
        DEC# D;SETMA                   "GET PHI'(K-1)
        SUB SGNX,D                     "D
        DPX(-2)<MD                     "PHI'(K) IN DPX(-2)
        FADD DPX(-2),MD;               "GET PHI'(K)+PHI'(K-1)
          DPY(-4)<MD                   "PHI'(K-1) IN DPY(-4)
        FADD
        FMUL DPX(-1),FA                "GET H*(PHI'(K-1)+PHI'(K))=PHIINC
        FMUL
        FMUL
        FSUB FM,DPY(2);                "PHIINC-ELPINC
          DPY(0)<FM                    "PHIINC IN DPY(0)
        FADD;MOVL SGNX,4               "2K
        FABS FA;ADD  B,4               "B+2K
        FADD;RPSF CON1;DPX(0)<DB       "GET 0.8PI
        FSUB DPX(0),FA;                "-ABS(PHIINC-ELPINC)+0.8PI
          DEC 4;SETMA                  "GET LAST PHI AT B+2K-1
        FADD;INC 4                     "RESET B+2K
        INC 4;                         "B+2K+1 IN SP 4
          LDTMA;DB=!TWOPI
        BFGT CONT3;                    "IF PHIINC TOO GREAT,HALVE INTERVAL
          MOVL NT,E                    "2NT
        ADD NT,E                       "3NT
        ADD 4,E;SETMA                  "PHIP(I=0) AT B+2K+1+3NT
        MOVR NT,17                     "NT
        DPX(-3)<MD;                    "STORE  PHI(K-1)=PHILFT
          DEC# SGNX
        DPX(3)<MD;                     "STORE PHIP(I=0)=PHIP(K)
          BEQ PHLZRO;                  "PHILFT OK UNLESS K=1
          SUB SGNX,17                  "NT/2-K
        BGT GOH
        DPX(3)<ZERO;BR GOH             "PHIP(I=0)=ZERO IF K=NT/2
PHLZRO: DPX(-3)<ZERO                   "PHI(K-1)=0 IF K=1
GOH:    JMP HALVE
"
"          CONTINUE IF PHASE INCREMENT SUITABLY SMALL
"
CONT3:  ADD  4,E                       "B+2K+1+2NT=D+2K+1
        DEC# SGNX                      "TEST FOR K-1=0
        ADD NT,E;SETMA;                "E+2K+1, GET PRNCPL VALUE PHIP(K)
          FADD DPY(0),MD;              "GET PHIHAT=PHIINC+PHI(K-1)
          DPX(-3)<MD;                  "LAST PHI IN DPX(-3)
          BGT KK                       "CONTINUE NORMALLY IF K-1>0
        FADD DPY(0) ,ZERO;             "SUBSTITUTE ZERO FOR PHI(0)
          DPX(-3)<ZERO
KK:     FADD;DPX(0)<DB;RPSF CON5       "1/2PI IN DPX(0)
        MOVR NT,17                     "NT/2
        DPY(3)<FA;                     "PHIHAT IN DPY(3)
          SUB SGNX,17                  "NT/2-K
        FSUB DPY(3),MD;                "GET  PHIHAT-PHIP
          DPX(3)<MD;                   "PHIP(K) IN DPX(3)
          BGT MOREK
        FSUB DPY(3),ZERO;
          DPX(3)<ZERO                  "PHIP(NT/2)=ZERO
MOREK:  FADD
        DPY(0)<FA;                     "A0*2PI IN DPY(0)
          FMUL DPX(0),FA               "GET A0=  (PHIHAT-PHIP)/2PI
        FMUL
        FMUL
        DPX(0)<FM;
          LDTMA;DB=!PI2
        FIXT DPX(0);DPX(0)<TM          "2PI IN DPX(0)
        FADD
        FADD ZERO,FA
        FADD
        DPY(-3)<FA
        FMUL DPX(0),DPY(-3)            "GET 2PI*INTEG((PHIHAT-PHIP)/2PI)
        FMUL
        FMUL
        FADD FM,DPX(3);                "A1=2PI*INTEG(A0/2PI)+PHIP
          DB=DPY(0)                    "TEST A0
        FADD;BDBN NEGA0
        FADD DPX(0),FA;                "GET A2=A1+2PI
          DPY(0)<FA;DPX(0)<FA;         "A1 IN DPY(0) & DPX(0)
          BR CONT
"
"           IF PHIHAT < PHIP, MUST SUBTRACT 2PI
"
NEGA0:  FSUBR DPX(0),FA;               "A1-2PI
          DPY(0)<FA;                   "A1 IN DPY(0)
          DPX(0)<FA                    "AND IN DPX(0)
"
"        NOW SEE WHICH ,A1 OR A2, IS CLOSER TO PHIHAT
"
CONT:   FSUB DPY(3),DPX(0)             "PHIHAT-A1
        FSUB DPY(3),FA;                "PHIHAT-A2
          DPY(3)<FA                    "A2 IN DPY(3)
        FABS FA;                       "A3= MAG(PHIHAT-A1)
          DPX(2)<TM
        FABS FA                        "A4=MAG(PHIHAT-A2)
        FSUB DPX(2),FA                 "PI/2-A3
        FSUB DPX(2),FA                 "PI/2-A4
        FADD
        BFGE TESTA;                    "DO LAST TEST IF A3<PI/2
          LDTMA;DB=!PI
        BFGE TESTA;                    "IF A3>PI/2 & A4>PI/2 HALVE INTERVAL
          DPY(0)<DPY(3)                "MOVE A2 TO DPY(0) FOR TEST
        JMP HALVE
"
"             TEST A1 OR A2 HERE
"
TESTA:  FSUB DPX(-3),DPY(0);           "PHI(K-1)-A1 (OR A2)
          DECDPA                       "TO GET K
        FADD;DPX(3)<TM                 "PI IN DPX(2)
        LDTMA;DB=!ONE
        FABS FA                        "MAG(PHI(K-1)-A1)
        FADD TM,DPX(-4)                "INCREMENT K
        FSUB DPX(3),FA                 "PI-MAG(PHI(K-1)-A1)
        DPX(1)<FA;                     "TEMP STORE INC'D K
          FSUBR DPY(2),FA              "K-NT
        FADD;MOVL SGNX,SGNX            "2K
        BFLT HALVE;                    "HALVE INTERV IF CHANGE TOO GREAT
          FADD DPX(1),FA;              "2K-NT
          INCDPA                       "RESET DPA
        INC B;FADD;                    "DEC TO GET K
          DECDPA
        ADD# SGNX,B;SETMA;MI<DPY(1)    "STORE A1 (OR A2) =PHI(K) AT B+2K+1
        DPX(-4)<DPX(1);                "STORE NEXT K
          INCDPA                       "RESET DPA
        BFGT DONEK;                    "IF NEW 2K>NT, REMOVE TREND
          DEC B;                       "RESET B
            DPX(-4)<DPY(0)             "LAST PHI IN DPX(-4)
        JMP NEWK
DONEK:  JMP TREND
"       END INTEGRATION LOOP  ,  BEGIN ADAPTIVE SECTION
"
"------------------------------------------------------
"       ACCURACY INSUFFICIENT, HALVE THE INTERVAL
"------------------------------------------------------
HALVE:  RPSF CON3;DPY(0)<DB            "2**12 IN DPY(0);(DPY(1) AFTER DECDPA)
        DECDPA
        FMUL DPX(-4),DPY(1)            "GET K*2**12=NR
        FMUL;INCDPA
        FMUL;DPX(-4)<DPX(-3)           "PUT PHI(K-1) IN DPX(-4)=PHILFT
        DPY(-3)<FM;                    "NR IN DPY(-3)
          FSUB  FM,DPY(0)              "GET NL=NR-2**12
        FADD;MOV NR,NR;SETMA;MI<FM     "STORE NR IN NR(0)
        DPX(-3)<FA                     "NL IN DPX(-3)
"              ASSUMES A,B,C,NT,M,NR,PHIP,PHIDVT ARE SET IN SP'S
"                       & NL,NR,DVTMN, AND ELPINC ARE IN DP'S
"
"
"          I,THE SOFTWARE STACK INDEX, IS INCREMENTED WHEN INTERVAL IS HALVED
"             NR(I) IS # OF SUBINTERVALS TO ESTIMATE, NL IS # OF SUBINTER-
"             VALS TO LAST ACCEPTED ESTIMATE.  (THERE ARE M TOTAL SUB-
"             INTERVALS).
"
INCI:   MOV PHIP,PHIP;SETMA;MI<DPX(3)  "STORE PHIP(I-1)
        INC NR;                        "NEW NR(I) ADDRESS
          LDTMA;DB=!HALF
        MOV PHIDVT,PHIDVT;SETMA;MI<DPX(-2) "STORE PHIDVT(I-1)
        INC PHIDVT;
          FADD DPX(-3),DPY(-3)         "NL+NR
        FSUB DPY(-3),DPX(-3)           "NR-NL
        FMUL TM,FA;                    "GET (NL+NR)/2
          MOV B,16;                    "SAVE B FROM DFT
          FADD
        FMUL;INC PHIP                  "SETUP FOR NEW INTERM. FREQ
        MOV PHIP,B;LDTMA;DB=!ONE       "PHIP(I) IN SP1
        MOV NT,4;FMUL                  "#PTS
        DPY(-3)<FM;                    "STORE NEW NR
          MOV NR,NT;SETMA;MI<FM;       "STORE IN MD TOO
            FSUB TM,FA                 "TEST NR-NL<1
        DECDPA;                        "TO GET DPY(-5)=I
          CLR 5;                       "NO. FREQ = 1
          FADD
        INC 5;                         "SET UP FOR DFT
          FADD TM,DPY(-4)              "INC I
        MOV M,6;FADD;                  "M=2**12*NT
          BFGT JFAIL                   "FAIL IF NR-NL<1
        RPSF CON6;DPX(1)<DB            "13.
        MOV C,SGNX;                    "GET C=,ADDR OF T0=0, USE TX(T),T=0
          FSUB DPX(1),FA;              "TEST 13.-I FOR STACK DEPTH TEST
          DPY(-4)<FA                   "STORE NEW I
        LDSPI 7;DB=-1;                 "-1 FOR FORWARD DFT
          FADD
        LDDPA;DB=8.                    "MOVE DP POINTER FOR DFT
        BFGT  DFT
JFAIL:  JMP FAIL
"
"             RDFT NEEDS (A,PHIP,NR,C,NT,1,M,-1); FREQ=NR/M
"               RDFT TO GET INTERMEDIATE PRINC. PHASE AND PHASE SLOPE
"
DFT:    JSR RDFT                       "X(F) IS IN PHIP,PHIP+1
                                       "SCRATCH SP (5,10-13,15-17),DPX&Y(-4TO3)
                                       "LOSES SP(C,D,E)
        INC B;SETMA                    "GET I FROM PHIP+1
        LDDPA;DB=ZERO                  "RESET POINTER
        DEC B;SETMA                    "GET REAL=R IN PHIP
        DPY(0)<MD;                     "SET UP ATAN2
          DPX(3)<MD;                   "STORE I
          CLR 5
        MOV 3,A                        "GET C IN A FOR DFT
        DPX(0)<MD;                     "STORE R
          DPY(3)<MD                    "STORE R
          INC 5
        JSR ATN2                       "SCRATCH SP (12-17),DPX(0-2),DPY(0,1)
        MOV B,B;SETMA;MI<DPX(0)        "STORE PRINCIPLE PHASE,PHIP
        LDSPI PHIDVT;DB=13.
        ADD PHIDVT,B;                  "GET PHIDVT IN B (=PHIP+13.)
          DPX(1)<-13.                  "TO GET PHIP FROM PHIDVT
        MOV B,PHIDVT;                  "PHIDVT IN PHIDVT
          LDDPA;DB=8.                  "MOV DP POINTER FOR DFT
"
"              RDFT NEEDS (C,PHIDVT,NR,C,NT,1,M,-1); FREQ=NR/M
"
        JSR RDFT                       "GET XP(F), SCR SP(5,10-13,15-17)DPX&Y(-4
        LDDPA;DB=32                    "SET DPA AT DPX(-6) FOR A BASE
        LDSPI 0;DB=DPX(0)              "A IN SP 0
        LDDPA;DB=ZERO                  "RESET DP POINTER
        INC B;SETMA                    "GET IP
        FMUL DPY(3),DPY(3);            "GET R*R
          MOV 2,NR                     "PUT NR IN PLACE
        FMUL DPX(3),DPX(3);            "GET I*I
          DEC B;SETMA                  "GET RP
        FMUL DPX(3),MD                 "GET I*IP
        FMUL;DPX(0)<FM                 "STORE R*R
        FADD FM,DPX(0);                "GET R*R+I*I
          FMUL DPY(3),MD               "GET R*RP
        FADD;FMUL;DPY(0)<FM            "STORE I*IP
        DPX(0)<FA;FMUL;                "R*R+I*I IN DPX(0)
          LDSPI PHIP;DB=DPX(1)
        FADD FM,DPY(0)                 "GET R*RP+I*RP
        FADD;ADD PHIDVT,PHIP;SETMA     "GET PHIP
        FSUB ZERO,FA                   "GET -(R*RP+I*IP)
        FADD
        DPY(0)<FA;DPX(3)<MD            "STORE MOST RECENT PHIP
        JSR DIV                        "GET PHIDVT(I), SCR SP(15-17),DPX(0,1),DP
        DPX(-2)<DPX(0)                 "STORE PHIDVT(I)
"----------------------------------------------------------------
"          NOW TRY TO GET NEW INTERMEDIATE PHI
"----------------------------------------------------------------
        FSUB DPY(-3),DPX(-3)           "GET NR-NL
        FADD DPX(-2),DPY(-4)           "GET PHIDVL+PHI'(I)
COMM:   FMUL DPY(-1),FA                "GET H1*(NR-NL)=DELTA
        LDTMA;DB=!TWO
        FMUL
        FMUL;FADD
        FMUL FM,FA;                    "GET DELTA*SLOPE
          DPX(0)<FM                    "DELTA IN DPX(0)
        FMUL DPX(0),DPY(-2)            "GET DELTA*DVTMN
        FMUL
        FADD FM,DPX(-4);FMUL;          "GET PHIHAT=PHILFT+PHIINC
          DPY(0)<FM                    "PHIINC IN DPY(0)
        FADD;DPX(0)<FM;                "DELTA*DVTMN IN DPX(0)
          DPY(3)<DPX(3)                "TEMP MOVE PHIP
        FSUBR DPY(3),FA;               "GET PHIHAT-PHIP
          DPY(3)<FA;                   "PHIHAT IN DPY(3)
          FMUL TM,DPX(0)               "GET 2*DELTA*DVTMN
        RPSF CON5;DPX(0)<DB            "1/2PI
        FADD;FMUL
        FMUL DPX(0),FA                 "GET A0=(PHIHAT-PHIP)/2PI
        RPSF CON1;DPX(2)<DB            "0.8PI
        LDTMA;DB=!TWOPI
        FMUL;FSUB FM,DPY(0)            "GET 2*DELTA*DVTMN-PHIINC
        FMUL;DPX(0)<TM
        DPY(0)<FM                      "A0 IN DPY(0)
        FIXT DPY(0)                    "GET INTEG(A0)
        DPX(1)<FA;                     "(2*DELTA*DVTMN-PHIINC) IN DPX(1)
          MOV 3,B;                     "C IN B
            FADD
        FADD ZERO,FA;
          SUB 4,B                      "B=C-NT
        FADD
        FMUL TM,FA;                    "GET INTEG(A0)*2PI
          MOV 3,C;FADD                 "RESTORE C
        FMUL
        FMUL;FABS DPX(1)               "TEST ABS PHIINC DIFF FROM MEAN
        FADD FM,DPX(3)                 "A1= INTEG(A0)*2PI+PHIP
        FSUB DPX(2),FA;                "GET 0.8PI-ABS(2*DELTA*DVTMN-PHIINC)
               DB=DPY(0);              "TEST SIGN OF A0
          MOV 4,NT                     "RESTORE NT
        FADD;BDBN NEG2PI;              "BRANCH IF A0 NEGATIVE
          DPY(0)<FA;                   "A1 IN DPY(0)& DPX(1)
          DPX(1)<FA
        FADD DPY(0),DPX(0);            "GET A2=A1+2PI
          BR CONT2                     "JMP OVER A1-2PI
"         IF PHIHAT < PHIP, SUBTRACT 2PI FROM A1
"
NEG2PI: FSUB DPY(0),DPX(0)             "A2=A1-2PI
CONT2:  FSUB  DPX(1),DPY(3);           "GET A1-PHIHAT
          BFGT CONTI                   "HALVE AGAIN IF ABS(PHIINC) TOO BIG
        JMP INCI
"
"          IF PHIINC USABLE, CONTINUE TESTING
"
CONTI:  FSUBR DPY(3),FA;               "A2-PHIHAT
          DPY(3)<FA                    "A2 IN DPY(3)
        LDTMA;DB=!PI2                  "PI/2
        FABS FA                        "A3=ABS(A1-PHIHAT)
        FABS FA;                       "A4=ABS(A2-PHIHAT)
          DPX(2)<TM                    "PI/2 IN DPX(2)
        FSUB DPX(2),FA                 "PI/2-A3
        FSUB DPX(2),FA                 "PI/2-A4
        FADD
        BFGE TESTAI;                   "DO LAST TEST IF A3<PI/2
          LDTMA;DB=!PI
        BFGE TESTAI;                   "DO LAST TEST IF A4<PI/2
          DPY(0)<DPY(3)                "MOVE A2 TO DPY(0) FOR TEST
        JMP INCI                       "IF A3>PI/2 & A4>PI/2, HALVE AGAIN
"
"            LAST TEST FOR PHI
"
TESTAI: FSUB DPX(-4),DPY(0)            "PHILFT-A1 (OR A2)
        FADD;DPX(2)<TM                 "PI
        FABS FA                        "ABS(PHILFT-A1)
        LDTMA;DB=!ONE
        FADD;INC# M;SETMA              "GET NT TO CHECK K IF GO STRTK
        FSUBR DPX(2),FA;               "-PI+MAG(PHILFT-A1)
          DECDPA                       "TO GET I
        FSUBR TM,DPY(-4)               "GET I-1. DEC I IF SUCCESSFUL
        FADD TM,DPX(-4);               "START TO INC K,IN CASE STACK EMPTY
          DPY(2)<MD                    "NT IN DPY(1)
        BFLT CONT4                     "HALVE AGAIN IF CHANGE TOO BIG
        INCDPA
         JMP INCI
"
"          NEW ESTIMATE IS ACCEPTED, IS STACK EMPTY?
"
CONT4: BFLT STRTK;                     "IF I=O,STACK IS DONE,STRT NEW K
          DPY(-4)<FA;                  "STORE DEC'D I
          DPX(-3)<DPY(1);              "NEW PHI BECOMES PHILFT IN DPX(-4)
          FIX DPX(-4)                  "GET K FOR ADDR OF PHI(I=0)
        DPX(-2)<DPY(-2);               "NEW NL IS OLD NR
          INCDPA
        DPY(-4)<DPX(-2)                "NEW PHIDVL=OOLD PHIDVT(I)
        JMP DECI
"
"          IF STACK EMPTY, CONTINUE INTEGRATION WITH INDEX K
"
STRTK:  DPX(-4)<FA;                    "STORE NEW K
          FSUB DPY(2),FA               "NT-K
        FADD;DPY(1)<FA                 "TEMP STORE LAST K
        FSUBR DPX(-4),FA;              "NT-2K
          LDSPI SGNX;DB=DPY(1)         "LAST K IN SP 3
        FADD;MOVL SGNX,SGNX;           "2K
          DPY(-4)<ZERO                 "RESET I=0
        INCDPA;
          ADD B,SGNX                   "B+2K
        BFLT TREND
        INC SGNX;SETMA;MI<DPX(-4)      "OUTPUT PHI(K)
        JMP NEWK
"
"----------------------------------------------------------------
"            COME HERE TO UNSTACK INTERMEDIATE RESULTS
"----------------------------------------------------------------
DECI:   DEC PHIP;SETMA                 "GET NEW PHIP(I) FROM STACK
        NOP
        DEC NR;SETMA                   "GET NEW NR
        DPX(3)<MD                      "STORE PHIP
        DEC PHIDVT;SETMA               "GET NEW PHIDVT FROM STACK
        FSUBR DPX(-3),MD               "GET NR-NL
        DPY(3)<MD                      "STORE NR
        FADD DPY(-4),MD;               "PHIDVL+PHIDVT(I)
          DPX(-2)<MD;                  "STORE NEW PHIDVT(I)
          JMP COMM
"        END ADAPTIVE SECTION,  BEGIN TREND REMOVAL,  FINISH
"----------------------------------------------------------------
"         SUBTRACT TREND FROM PHI(K) HERE AFTER GETTING FOLDING FREQ PHI
"----------------------------------------------------------------
TREND:  RPSF CON5;DPY(0)<DB            "1/(2PI)
        FMUL DPY(0),DPX(-4)            "GET PHI(NT/2+1)/2PI
        LDTMA;DB=!HALF
        LDTMA;DB=!TENTH;
          MOV B,14                     "SAVE B
        FMUL TM,DPY(1);                "GET NT/2
          DB=DPX(-4);                  "TEST SIGN OF PHI
          MOVL NT,13                   "2NT
        FMUL;BDBN NGTRND;              "IF NEGATIVE, SUBTRACT TREND
          DPY(0)<TM                    "0.1 IN DPY(0) TO GET INTEGER AFTER DIVID
        FADD FM,DPY(0);                "0.1+PHI(NT/2+1)/2PI
          BR SHIFT;FMUL
NGTRND: FSUB FM,DPY(0);                "PHI(NT/2+1)/2PI-0.1
          FMUL
SHIFT:  FADD;DPY(0)<DPX(-4);           "PHI(NT/2+1) INTO DPY(0)
          DPX(0)<FM;                   "NT/2 INTO DPX(0)
          INC 13                       "2NT+1
        FIXT FA;                       "FIX # OF SHIFTS NECESSARY TO DETREND
          INC 13                       "2NT +2
        FADD;INC A                     "A+1
        FADD ZERO,FA;                  "FLOAT SHIFT
          MOV NT,10                    "SAVE NT IN SP 10
        FADD;MOVR NT,4                 "NT/2-1 IS COUNT FOR VRAMP
        ADD# NT,A;SETMA;MI<FA          "STORE SHIFT IN MD A+NT+1
        DEC A
        JSR DIV                        "GET PHI(NT/2+1)/(NT/2)
                                       "DESTROY SP(15-17),DPX(0),DPY(0)
        ADD B,13;
         SETMA;MI<DPX(0)               "TREND INCREM IN B+2NT+2
"----------------------------------------------------------------
"           BUILD THE RAMP
"----------------------------------------------------------------
        MOV A,11                       "SAVE A
        MOV 13,0                       "ADDR OF INIT VALUE=INCREMENT
        MOV B,7                        "SAVE B
        MOV 13,1                       "ADDR OF INC
        DEC 4                          "NT/2-1
        MOV 0,2                        "B+2NT+2
        INC 2                          "B+2NT+3=ADDR OF RESULT
        LDSPI 3;DB=1                   "1 IS INCR OF DESTIN
        JSR VRAMP                      "DESTROY SP(2,4),DPX(0),DPY(0)
"----------------------------------------------------------------
"          SUBTRACT RAMP FROM PHI,START AT B+3
"----------------------------------------------------------------
        MOV 1,0                        "B+2NT+2
        INC 0                          "B+2NT+3=ADDR OF RAMP
        MOV 3,1                        "1 IS SOURCE INCR
        MOVR 10,6                      "NT/2-1 IS COUNT
        DEC 6
        MOV 0,2                        "B+2NT+3
        SUB 10,2                       "B+NT+3
        SUB  10,2                      "B+3 IS SOURCE (PHI(K))
        MOV 2,4                        "B+3 IS DESTINATION
        MOVL 1,3                       "2 IS DEST INCR
        MOV 3,5                        "DITTO
        JSR VSUB                       "DESTROYS SP(0,2,4,6,15)
        LDTMA;DB=!ONE
        LDDPA;DB=-6                    "MOVE POINTER TO GET DC VALUE
        FADD DPY(0),ZERO               "GET DC VALUE
        FSUBR TM,ZERO;                 "GET -1
          ADD# 10,11;SETMA;MI<TM       "+1 AT A+NT IF DC>0
        FADD
        BFGT RTN;
          DPY(-1)<FA
        ADD# 10,11;SETMA;MI<DPY(-1)    "-1 AT A+NT IF DC<0
RTN:    CLR 17                         "SP(17)=0 IMPLIES CONVERGENCE
        RETURN
"----------------------------------------------------------------
"             IF UNWRAP FAILS, RETURN SGNX = 0
"----------------------------------------------------------------
FAIL:   LDDPA;DB=-6.
        MOV A,SGNX;                    "A
          FADD ZERO,DPX(1)             "GET INDEX K OF LAST ACCEP'D PHI
        ADD 4,SGNX;SETMA;MI<ZERO;      "A+NT=ADDR SGNX;STORE ZERO-FAILED
          FADD
        MOV 4,SHFT;
          LDDPA;DB=DPX(-1)             "SET INITIAL DPA
        INC SHFT;SETMA;MI<FA           "A+NT+1=ADDR SHIFT;STORE LAST K
        CLR 17
        INC 17                         "SP(17)=1 IMPLIES NO CONVERGENCE
        RETURN
CON1:   $FP 2.513274                   "0.8 PI
CON3:   $FP 4096.
CON5:   $FP 0.1591549                  "1/(2PI)
CON6:   $FP 13.
        $END
"
"****** RDFT = REAL DISCRETE FOURIER TRANSFORM /COMMON/ = REL 3.0, SEP 79
"        FOR EITHER MEMORY
         $TITLE RDFT
        $RADIX 8
         XADC $EQU 1         "CONDITIONAL ASSEMBLY PARAM FOR ADC/APFTN.
         $ENTRY RDFT, 8.       "UDC MODE ENTRY POINT.
          $EXT SPFLT
          $EXT COS
          $EXT SIN
          $EXT DIV
"
"
"
"
"
"         EXTERNALS:  SPFLT,COS,SIN,DIV
"
"       --- USAGE ---
"       FORTRAN CALL:
"         CALL RDFT(A,B,F0,T0,NT,NF,M,I)
"       APAL CALL:
"         JSR RDFT
"
"       WHERE
"            A=BASE ADDRESS OF TIME VECTOR, NT ELEMENTS
"            B=BASE ADDRESS OF FREQUENCY VECTOR, NF COMPLEX ELEMENTS
"            F0=ADDR OF THE MULTIPLIER OF DF THAT EQUALS THE LEAST NON-NEGATIVE
"                 FREQUENCY VALUE, WHERE DF IS THE FREQUENCY-SAMPLING INTERVAL
"            T0=ADDR OF THE MULTIPLIER OF DT THAT EQUALS THE MOST NEGATIVE TIME
"                 VALUE, WHERE DT IS THE TIME-SAMPLING INTERVAL
"            NT= THE NO. OF TIME POINTS
"            NF=THE NO. OF POS. FREQUENCIES
"            M=ADDR OF THE NUMBER OF ELEMENTS IN THE INPUT VECTOR PLUS
"                 ANY ASSUMED APPENDED ZEROS.
"                 THIS ALLOWS FOR NON-HARMONIC EVALUATION IN THE
"                 OPPOSITE DOMAIN.  NORMALLY M=NT OR 2*NF AS DISCUSSED
"                 BELOW, BUT GENERALLY M>=NT OR 2*(NF+F0-1).
"            I=  1 IF FORWARD TRANSFORM IS DESIRED,OR
"               -1 IF INVERSE TRANSFORM IS DESIRED
"
"       --- ABSTRACT ---
"
"       THE DFT IS PRODUCED BY THE MODIFIED GOERTZEL METHOD AS DESCRIBED IN
"       (1) A.V. OPPENHEIM & SCHAFER,'DIGITAL SIGNAL PROCESSING'
"       (2) F. BONZANIGO,'AN IMPROVEMENT OF TRIBOLETS PHASE UNWRAPPING
"           ALGORITHM',IEEE TRANS. ASSP FEB. 1978,PP 104,105.
"
"       THE DISCRETE FOURIER INTEGRAL (TRANSFORM) OF THE TIME SERIES X(R) IS
"            X(K)=X(K*DF)=SUM(X(R*DT-T0*DT)*EXP(-J*2PI*K*DF*R*DT))*DT
"                 WHERE USUALLY DF=1/(NT*DT) RESULTING IN THE EXPONENTIAL
"                 EXP(-J*2PI*K*R/NT)=WN**(K*R), WN=EXP(-J*2PI/NT).
"            BUT MORE GENERALLY DF=1/(M*DT), M>=N, & WM=EXP(-J*2PI/M).
"            MULTIPLYING AND DIVIDING X(K,WM) BY EXP(-J*2PI*K*NT/M)
"            ALLOWS THE FOLLOWING (OMITTING THE EXTERNAL DT FACTOR OR
"            SCALING DT=1),
"       X(K)=EXP(-J*2PI*K*(NT+T0)/M)*SUM(X(R)*EXP((J*2PI*K/M)*(NT-R)))
"          =WM**(NT*K)*(X(R) CONVOLVED WITH H(R),EVALUATED AT R=NT)
"                 *(1-WM**K)
"
"           WHERE
"                 H(Z)=1/(1-2*COS(2PI*K/M)*Z**(-1)+Z**(-2))
"       FOR COMPUTATION, RADIAN FREQUENCY W=2PI*K/M
"
"       IN MANY CASES M=NT AND THERE IS NO EXTRA PHASE FACTOR, WM**(NT*K),
"       BUT PHASE UNWRAPPING VIA TRIBOLET FOR EXAMPLE USES
"       FREQUENCIES WHICH ARE NOT MULTIPLES OF THE FUNDAMENTAL 1/NT,
"       BUT ARE K/M, M>=NT, 0<=K<=M/2.
"       NO SPECIAL ARRANGEMENT IS MADE FOR K=0, AND AN IMAGINARY
"       VALUE WILL BE COMPUTED.
"
"       FOR THE INVERSE TRANSFORM,
"       X(L)=X(L*DT)=SUM(X(R*DF-F0*DF)*EXP(J*2PI*R*DF*L*DT))*DF,
"       WHEREIN IT IS SEEN THAT TO USE THE SAME ALGORITHM WN OR
"       WM MUST BE REDEFINED TO HAVE A POSITIVE EXPONENT, AND
"       THE EXTERIOR FACTOR DF IS EITHER DROPPED OR SET TO UNITY.
"       ALTERNATELY, THE 'RADIAN TIME' W=-2PI*L/M MAY BE DEFINED WITH THE
"       MINUS SIGN, AND THIS METHOD IS USED IN THE PROGRAM.
"       BECAUSE THE POSITIVE-FREQUENCY COEFFICIENTS X(R*DF) ARE
"       COMPLEX, TWO PASSES ARE NEEDED. THE PASS ON THE REALS GIVES
"       R=R1+J*R2; THE PASS ON THE IMAGINARIES GIVES I=I1+J*I2.
"       THE RESULTING TIME-DOMAIN SOLUTION, INCLUDING CONTRIBUTION
"       FROM NEGATIVE FREQUENCIES, IS X(L*DT)=2*(R1-I2).  BECAUSE THE
"       COMPLEX COEFFICIENTS OF ONLY THE POSITIVE FREQUENCIES NEED BE
"       INPUT, THE EFFECTIVE BANDWIDTH, M*DF, IS AT LEAST TWICE
"       THAT OCCUPIED BY THE POSITIVE FREQUENCIES.  THUS USUALLY
"       M=2*NF, WHICH GIVES THE TRUE RESOLUTION IN THE TIME DOMAIN.
"       TO ESTIMATE VALUES AT TIMES K/M BETWEEN TIMES K/(2*NF),
"       SET M>2*NF.
"       IF A DC FREQUENCY IS INPUT, A ZERO IMAGINARY PART MUST
"       BE PROVIDED.
"
"
"       --- SPAD ASSIGNMENTS ---
"           SP    OLD      NEW
"          -----  ----    ----
"            0     A
"            1     B
"            2     F0
"            3     T0
"            4     NT
"            5     NF
"            6     M
"            7     I
"           10              X
"           11              NX
"           12              DX
"           13              Y
"           14             DXI
"           14
"           15
"           16
"           17
"
        A $EQU 0         "BASE ADDRESS OF THE TIME VECTOR.
        B $EQU 1         "BASE ADDRESS OF TIME VECTOR.
        F0 $EQU 2        "THE ADDROF THE LEAST NON-NEGATIVE FREQUENCY VALUE.
        T0 $EQU 3        "ADDR. OF MOST NEGATIVE TIME VALUE.
        NT $EQU 4         " THE NUMBER OF TIME PONTS.
        NF $EQU 5       "THE NUBMER OF POSITIVE FREQUENCIES.
        M $EQU 6        "THE ADDRESS OF THE TOTAL INPUT DATA INTERVAL.
        I $EQU 7        "DIRECTION FLAG.
        X $EQU 10
        NX $EQU 11
        DX $EQU 12
        Y $EQU 13
        DXI $EQU 14
"
"    --- DATA PAD USAGE ---
"          DPX         DPY
"        -------   ---------
"  -4 SIN((NT+T0)*W)    U(N-1)
"  -3    IM(X(T))     +-2PI/M
"  -2     TEMP          U(N-2)
"  -1 COS((NT+T0)*W)   2*COS(W)
"   0                  B1
"   1                  A1
"   2     SIN(W)       TEMP
"   3     COS(W)     RE(X(T))
"
  "        SIZE: 305  (BASE 8)
 "        SPEED: TYPICAL
 "                  FORWARD:  7.17+30.67*NF+0.83*NF*NT  MICROSECONDS
 "                  INVERSE:  7.67+35.83*NT+1.67*NF*NT  MICROSECONDS
 "        EQUIPMENT: 167 OR 333 NS MEMORY
 "        HISTORY: AUTHOR R. L. KIRLIN, MARCH,1979
 "
"
"
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
" *** CONDITIONAL ASSEMBLY ***
 $IF XADC=1
 $SUBR FRDFT,10
 $EXT RESLVE
        BITMAP  $EQU 260
 $PARAM  10, P1(#5)/R/IP/OP, P2(2,#6)/R/IP/OP, P3/R/IP, P4/R/IP,
                   P5/I/IP, P6/I/IP, P7/I/IP,P8/I/IP
 FRDFT:  LDSPI 17;DB=BITMAP
        JSR RESLVE
 $ENDIF
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"
"---------------------------------------------------------------------
" START BY CHECKING ARRAY SIZES.
"---------------------------------------------------------------------
RDFT:   MOV NT,NT                       "IS NT NON ZERO ?
        BGT .+2                         " YES.CHECK NF.
        JMP DONE                        "NO.RETURN TO THE CALLING RTNE.
        MOV NF,NF                       "IS NF NON ZERO ?
        BGT .+2                         "YES.GET ON WITH RDFT.
        JMP DONE                        "NO.RETURN.
 " ------------------------------------------------------------------
 "       START PROGRAM, DETERMINE DIRECTION, GET SIN'S, COS'S
 " -------------------------------------------------------------------
 "
         CLR DX
         INC DX
         MOV I,I
         BGE FORWRD                     "TEST FOR INVERSE
         JMP INVRSE
 FORWRD: MOV NT,NX                      "NT TERMS IN SUM
         MOV B,Y                        "FREQ VECTOR IS OUTPUT
         MOV M,M;SETMA                  "GET TOTAL INPUT INTERVAL
         MOV A,X                        "TIME VECTOR IS INPUT
         LDTMA;DB=!TWOPI
         DPX(0)<MD                      "SET UP FOR DIVIDE
         DPY(0)<TM
         JSR DIV                        "GET 2PI/M
         DPY(-3)<DPX(0);                "TEMP STORE
           MOV F0,F0;SETMA              "GET FIRST FREQ
         LDTMA;DB=!ONE
         DEC Y                          "DEC FOR SUBSEQUENT INC
         FSUBR TM,MD                    "DEC FREQ FOR LATER INC
         FADD
         MOV F0,F0;SETMA;MI<FA          "STORE DEC'D FREQ
 "      ---------------------------------------
 "           LOOP FOR FOURIER COEFFICIENTS
 "      ---------------------------------------
 NFLOOP: MOV F0,F0;SETMA
         LDTMA;DB=!ONE
         NOP
         FADD TM,MD                    "INC FREQUENCY
         FADD
         MOV F0,F0;SETMA;MI<FA;         "STORE INC'D FREQ
           FMUL DPY(-3),FA
         FMUL;MOV NT,17                 "GET NT+T0=N1 FOR PHASE SHIFT
         FMUL
         DPY(2)<FM                      "TEMP STORE W
         JSR SPFLT                      "FLOAT NT+T0
         MOV T0,T0;SETMA
         NOP
         NOP
         FADD DPX(1),MD                  "GET T0+NT FOR PHASE SHIFT
         FADD
 " --------------------------------------------------------------------
 "   DFT SETUP COMMON TO DFT & INVERSE; 'NT+T0' FOR DFT,'NF+F0' FOR INVERSE
 " --------------------------------------------------------------------
 COMMON: FMUL DPY(2),FA                  "GET (NT+T0)*W
         FMUL
         FMUL
         DPX(0)<FM;                     "TEMP STORE
           DPY(3)<FM
         JSR COS                        "GET COS((NT+T0)*W)
         DPX(-1)<DPX(0)                 "STORE COS((NT+T0)*W) INTO DPX(-1)
         DPX(0)<DPY(3)
         JSR SIN                        "GET SIN((NT+T0)*W)
         DPX(-4)<DPX(0)                 "STORE SIN((NT+T0)*W) IN DPX(-4)
         DPX(0)<DPY(2)                  "LOAD W
         JSR COS
         DPX(3)<DPX(0)                  "STORE COS(W) IN DPX(3)
         DPX(0)<DPY(2)                  "LOAD W
         JSR SIN                        "GET SIN(W)
         DPX(2)<DPX(0)                  "STORE SIN(W) IN DPX(2)
         JMP DFT                         "GO DO DFT
 "
 INVRSE: INC DX                         "SET ADDR INC =2
         MOV DX,DXI                     "TO COUNT REAL & IMAG PASSES
         MOV NF,NX                      "NO. OF TERMS IN EA SUM
         MOV M,M;SETMA                  "GET TOTAL INPUT INTERVAL
         MOV A,Y                        "TIME VECTOR IS OUTPUT
         MOV B,X                        "FREQ VECTOR IS INPUT
         LDTMA;DB=!TWOPI
         DPX(0)<MD                      "SET UP DIVIDE
         DPY(0)<TM
         JSR DIV                        "GET -2PI/M
         FSUB ZERO,DPX(0);                "GET -2*PI/M
           MOV T0,T0;SETMA              "GET INITIAL TIME
         LDTMA;DB=!ONE
         DEC Y                          "DEC FOR LATER INC
         FSUBR TM,MD                    "DEC BEFORE INC IN LOOOP
         FADD;DPY(-3)<FA                "STORE -2*PI/M
         MOV T0,T0;SETMA;MI<FA          "STORE DEC'D T0
 "-----------------------------------------------
 "    LOOP FOR TIME VALUES (SYNTHESIS)
 "-----------------------------------------------
 NTLOOP: MOV T0,T0;SETMA                      "GET TIME
         LDTMA;DB=!ONE
         NOP
         FADD TM,MD                          "INC TIME
         FADD
         MOV T0,T0;SETMA;MI<FA;              "STORE INC'D TIME
           FMUL DPY(-3),FA                "GET 'RADIAN' TIME W=-2PI*K/M,K=T0
         FMUL;MOV NF,17                 "GET NF+FO=N1 FOR TIME-PHASE SHIFT
         FMUL
         DPY(2)<FM
         JSR SPFLT                       "FLOAT NF
         MOV F0,F0;SETMA                 "GET F0
         NOP
         NOP
         FADD DPX(1),MD                  "GET F0+NF FOR 'TIME-PHASE' SHIFT
         FADD
         JMP COMMON
 "---------------------------------------------------------------
 "     GOERTZEL ALGORITHM STARTS HERE FOR BOTH DIRECTIONS
 "---------------------------------------------------------------
 DFT:    LDTMA;DB=!TWO
         NOP
         FMUL TM,DPX(3)                 "GET 2*COS(W)
         FMUL
         FMUL
         DPY(-1)<FM                     "STORE IN DPY(-1)
 "-----------------------------------------------------------------
 "    PASS ON IMAGINARIES STARTS HERE FOR INVERSE
 "-----------------------------------------------------------------
 DFT1:   MOV X,X;SETMA                  "GET FIRST DATA POINT
         DPY(-2)<ZERO                       "U(N-2)=0=U(N-1),N=0
         ADD DX, X;SETMA                     "GET NEXT X
         FADD ZERO,MD                    "GET FIRST U(N)=X(N)-0+0=NEXT U(N-1)
         FADD
 "       ------------------------------------------------
 "         FILTER LOOP, U(N) ARE RECURSIVE OUTPUTS, 0<=N<=NX
 "       ------------------------------------------------
 GRTZL:       FMUL DPY(-1),FA;          "1.GET 2*COS(W)*U(N-1)
                DPX(-2)<FA;             "  STORE MOST RECENT U(N)
                DEC# NX                 "  TEST LAST CYCLE
              FSUBR DPY(-2),MD;         "2.GET X(N)-U(N-2) FOR NEXT U(N)
                DPY(-4)<DPX(-2);FMUL;   "  TEMP STORE LAST U(N-1)
                BGT THREE               "  CONTINUE UNLESS LAST CYCLE
              FSUBR DPY(-2),ZERO        "2A.USE X(NX)=0. IF LAST TIME THROUGH
 THREE:  ADD DX,X;SETMA;                "3.ADDR NEXT POINT
              FMUL DPX(3),DPY(-4);      "  GET COS(W)*U(NX-1) TO EXIT LOOP
               FADD;DPY(-2)<DPY(-4)       "  MOVE U(N-1) TO U(N-2)
              FADD FM,FA;               "4.GET X(N)+2*COS(W)*U(N-1)-U(N-2)
                DEC NX;                 "       =NEW U(N)
                FMUL DPX(2),DPY(-4)     "  GET SIN(W)*U(NX-1)=B1 TO EXIT LOOP
              FADD;FMUL; BGT GRTZL      "5.EVALUATE OUTPUT AT N=NX
 "       ------------------------------------------------
 "         GET U(NX)-EXP(-J*2PI*K/M)*U(NX-1), AND
 "         GET TRUE PHASE, MULTIPLY BY EXP(-J*2PI*K*(NT+T0)/M)
 "             (READ NT+T0 FOR DFT,NF+F0 FOR INVERSE)
 "       -----------------------------------------------
         FSUBR FM,FA;FMUL                "GET U(NX)-COS(W)*U(NX-1)=A1
         FMUL FM,DPX(-4);                " GET B1*SIN((NT+T0)*W)
           DPY(0)<FM;FADD               "STORE B1 IN DPY(0)
         FMUL DPX(-1),FA;               "GET A1*COS((NT+T0)*W)
           DPY(1)<FA                    "STORE A1 IN DPY(1)
         FMUL DPY(0),DPX(-1)            "GET B1*COS((NT+T0)*W)
         FMUL DPY(1),DPX(-4);            "GET A1*SIN((NT+T0)*W)
           DPY(2)<FM                    "STORE B1*SIN((NT+T0)*W)
         FADD FM,DPY(2);FMUL;           "GET A1*COS((NT+T0)*W)+B1*SIN((NT+T0)*W)
           MOV I,I                      "TEST DIRECTION
         DPY(2)<FM;FMUL;FADD;           "STORE B1*COS((NT+T0)*W)
              BGT INVR                  "FOR INVERSE,STORE DIFFERENTLY
 "----------------------------------------
 "   STORE DFT RESULTS
 "----------------------------------------
         FSUBR FM,DPY(2);               "GET -A1*SIN((NT+T0)*W)+B1*COS((NT+T0)*W
           INC Y;SETMA;MI<FA             "STORE REAL OF COEFFICIENT
         FADD;MOV A,X                     "RENEW INPUT VECTOR BASE ADDRESS
         INC Y;SETMA;MI<FA               "STORE IMAG OF COEFFICIENT
         MOV NT,NX                      "RENEW TERM CTR
         DEC NF
         BEQ .+2
         JMP NFLOOP
         RETURN
 "---------------------------------------------------
 "  STORE INVERSE RESULTS,PARTIAL OR FINAL
 "---------------------------------------------------
 INVR:   DEC DXI;                       "DEC TO PASS ON IMAG'S
           FSUBR FM,DPY(2);         "START -A1*SIN((NF+F0)*W)+B1*COS((NF+F0)*W)
           DPY(0)<FA                "TEMP STORE REAL PART
         BEQ IMAG;FADD                  "IF IMAG PASS, GET RESULT R1-I2
         DPY(3)<DPY(0);                   "STORE R1 ON REAL PASS
           MOV B,X                      "RENEW INITIAL INPUT VECTOR BASE ADDRESS
         MOV NF,NX                      "RENEW TERM CTR
         INC X                          "INC TO IMAG'S
         JMP DFT1                       "START DFT ON IMAG'S
 IMAG:   FSUB DPY(3),FA                 "GET R1-I2
         FADD;MOV DX,DXI                "RENEW PASS CTR
         FMUL TM,FA                     "GET 2*(R1-I2)=TIME DOMAIN RESULT
         FMUL;MOV B,X                     "RENEW INITIAL INPUT VECTOR BASE ADDR
         FMUL;MOV NF,NX                   "RENEW TERM CTR
         INC Y;SETMA;MI<FM              "STORE X(K*DT)
         DEC NT
         BEQ DONE
         JMP NTLOOP
 DONE:   RETURN
          $END
"****** WIENER = WIENER LEVINSON ALGORITHM /COMMON/ = REL 3.0, SEP 79 ****
         $TITLE WIENER
        $RADIX 8
         XADC   $EQU 1                  "CONDITIONAL ASSM.PARA.FOR ADC.
         $ENTRY WIENER, 6
         $EXT DIV
"WIENER-LEVENSON ALGORITHM
"                  --- ABSTRACT ---
"FINDS THE SOLUTION OF THE SO-CALLED SINGLE CHANNEL NORMAL EQUATIONS
"       WHICH ARISE IN LEAST-SQUARES FILTERING AND PREDICTION PROBLEMS
"       FOR SINGLE CHANNEL TIME SERIES.  SEE PAGES 44-46 OF
"       "MULTICHANNEL TIME SERIES WITH DIGITAL COMPUTER PROGRAMS", BY
"       ENDERS ROBINSON, 1967 FOR MORE DETAILS
"                  --- STATISTICS ---
"LANGUAGE:         AP-120B ASSEMBLER
"EQUIPMENT:        AP-120B WITH EITHER MEMORY
"SIZE:             67 LOCATIONS PLUS DIVIDE
"SCRATCH:          SP:0-15.;  DPX: -3 TO +3;  DPY: -3 TO +3 (REL TO DPA)
"SUBROUTINE USED:  DIVIDE
"AUTHOR:           A.E CHARLESWORTH
"DATE:             NOV 75
"                  --- USEAGE ---
"S-PAD INPUT PARAMETERS:
        LR       $EQU     0     "LENGTH OF FILTER
        R        $EQU     1     "ADDRESS OF AUTO-CORRELATION COEFF.
        G        $EQU     2     "ADDRESS OF RIGHT-HAND SIDE COEFFICIENTS
        F        $EQU     3     "ADDRESS OF FILTER COEFFICIENTS
        A        $EQU     4     "ADDRESS OF PREDICTION ERROR OPERATOR
        ISW      $EQU     5     "SWITCH: +1 FOR GENERAL ALGORITHM,
                                "  0 FOR SPIKE DECONVOLUTION
"                  --- ERROR CONDITION ---
"       IF THE ALGORITHM "BLOWS UP" S-PAD 15. IS SET TO "L"  AND THE
"         COMPUTATION ABORTED.  OTHERWISE S-PAD 15. IS SET TO 0
"WHAT THIS SUBROUTINE DOES:-------------------------------
"GIVEN THE SET OF SIMULTANEOUS EQUATIONS:
"       SUM, S=0 TO LR OF (F(S)*R(T-S)) = G(T)  FOR T = 0,1,2,...,LR,
"       WHERE THE MATRIX:
"                  R(0)      R(1)      ...       R(M)
"                  R(0)      R(1)      ...       R(M)
"                  R(-1)     R(0)      ...       R(M-1)
"                  ...       ...       ...       ...
"                  R(-M)     R(-M+1    ...       R(0)
"       IS SYMMETRIC, POSITIVE DEFINITE, AND TOPLITZ (I.E. HAS EQUAL
"         ELEMENTS ALONG ANY DIAGONAL.
"IN TIME SERIES APPLICATIONS, THE COEFFICIENTS R(T), FOR T = 0 TO LR,
"       ARE THE AUTO-CORRELATION COEFFICIENTS, WHICH ARE KNOWN.  ALSO
"       KNOWN ARE THE RIGHT-HAND SIDE COEFFICIENTS, G(T).
"THE UNKNOWNS ARE THE COEFFICIENTS F(S), FOR S = 0 TO LR, WHICH ARE
"       CALLED THE FILTER COEFFICIENTS.  AN ADDITIONAL OUTPUT IS THE
"       SET OF COEFFICIENTS A(S) WHICH REPRESENT THE SOLUTION OF THE
"       EQUATIONS:
"       SUM, FROM S = 0 TO LR, OF (A(S)*R(T-S)) = V * DELTA
"                    FOR T = 0,1,2,...,LR,   WHERE
"       A(0) = 1
"       DELTA = 1 WHEN T = 0, ELSE 0   AND
"       V = A(0)*R(0) + A(1)*R(-1) + ... + A(LR)*R(-LR)
"IN TIME SERIES APPLICATIONS, THE COEFFICIENTS A(0),A(1),A(2),...A(LR)
"       ARE THE COEFFICIENTS OF THE PREDICTION ERROR OPERATOR ( OR
"         EQUIVALENTLY, THE HINDSIGHT ERROR OPERATOR, AS THESE TWO ARE
"         THE SAME FOR THE SINGLE-CHANNEL CASE)
"SUBROUTINE INPUTS:
"       LR - LENGTH OF FILTER
"       R - AUTO-CORRELATION COEFFICIENTS = (R(0),R(1),...,R(LR))
"       G - RIGHT-HAND SIDE COEFFICIENTS = (G(0),G(1),...,G(LR))
"SUBROUTINE OUTPUTS:
"       F - FILTER COEFFICIENTS = (F(0),F(1),...F(LR))
"       A - PREDICTION ERROR OPERATOR = (1.0,A(1),A(2),...A(LR))
"                  --- ALGORITHM ---
"CODING WAS DONE FROM A FORTRAN PROGRAM, WHICH IS INCLUDED BELOW FOR
"       REFERENCE.
"       FOR EASE OF ARRAY INDEXING, VARIABLES THAT GO FROM 1 TO N
"         IN FORTRAN, GO FROM 0 TO N-1 IN THE AP-120B CODE
"       DIMENSION R(LR),G(LR),F(LR),A(LR)
"       IFLAG=0
"       V=R(1)
"       D=R(2)
"       A(1)=1.0
"       F(1)=G(1)/V
"       Q=F(1)*R(2)
"       DO 600 L=2,LR
"         A(L)=-D/V
"         AL=A(L)
"         IF (V.LE.0.0) IFLAG = L
"         IF (ISW.EQ.0) F(L)=V
"         V=V+AL*D
"         D=R(L+1)+AL*R(2)
"         L2=L/2
"         IF (L.LE.3) GO TO 150
"         DO 100 J=2,L2
"           K=L-J+1
"           HOLD=A(J)
"           A(J)=A(J)+AL*A(K)
"           D=D+A(J)*R(K+1)
"           A(K)=A(K)+AL*HOLD
"100        D=D+A(K)*R(J+1)
"150      IF (2*L2.EQ.L)  GO TO 200
"         LH=L2+1
"         A(LH)=A(LH)+AL*A(LH)
"         D=D+A(LH)*R(LH+1)
"200      IF (ISW.EQ.0) GO TO 600
"         F(L)=(G(L)-Q)/V
"         FL=F(L)
"         L1=L-1
"         Q=FL*R(2)
"         DO 300 J=1,L1
"           K=L-J+1
"           F(J)=F(J)+FL*A(K)
"300        Q=Q+F(J)*R(K+1)
"600    CONTINUE
"       END
"OTHER S-PAD REGISTERS:
        L        $EQU     7
        AJP      $EQU     10
        RJP      $EQU     11
        FJRP     $EQU     10
        FJWP     $EQU     11
        AKP      $EQU     12
        RKP      $EQU     13
        T        $EQU     17
"DATA PAD X NAMES:
        RJ       $EQU     -3
        RK       $EQU     -2
        ONE      $EQU     -1
        INV      $EQU     0
        TEMP     $EQU     1
        AL       $EQU     2
        D        $EQU     3
"DATA PAD Y NAMES
        AJ       $EQU     -3
        AK       $EQU     -2
        V       $EQU     -1
        Y        $EQU     0
        Q        $EQU     1
        FL       $EQU     2
        R2       $EQU     3
"ASSEMBLY PARAMETER!!!!!!!!!!!!
        ONEADR $EQU !ONE                "ADDRESS OF 1.0 IN TM
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC = 1
        $SUBR FWIENR,6
        $EXT RESLVE
        BITMAP $EQU 41
        $PARAM  6  ,  P1/I/IP,
                      P2(#1)/R/IP, P3(#1)/R/IP,
                      P4(#1)/R/OP, P5(#1)/R/OP,
                      P6/I/IP
FWIENR: LDSPI 17;DB = BITMAP
        JSR RESLVE
        $ENDIF
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"INITIALIZE FOR  L600 LOOP
WIENER: LDTMA;  DB=ONEADR       "FETCH 1.0
        MOV R,T; SETMA          "FETCH R(1)
        NOP                        "FOR UPWARD COMPATIBILITY
        INC T;   SETMA;         "FETCH R(2)
          DPX(ONE)<TM;          "  INITIALIZE "ONE"
          DPY(Y)<TM             "  SET DIVIDEND FOR DIVIDE
        NOP                        "FOR UPWARD COMPATIBILITY
        MOV G,G;  SETMA;        "FETCH G(1)
          DPY(V)<MD;            "  INITIALIZE V
          DPX(INV)<MD           "  SET DIVISOR
        NOP                        "FOR UPWARD COMPATIBILITY
        JSR DIV;                        "DO 1.0/V
          DPX(D)<MD;            "  SET D TO R(2)
          DPY(R2)<MD            "  KEEP R(2) IN R2
        FMUL DPX(INV),MD        "G(1)*(1/V)
        FMUL;  MI<DPX(ONE);
          MOV A,A; SETMA        "  STORE 1.0 INTO A(1)
        FMUL
        FMUL FM,DPY(R2);        "F(1)*R(2)
          MI<FM; MOV F,F; SETMA "  STORE F(1)=G(1)/V
        FMUL; CLR L             "SET L TO 0
        FMUL
        DPY(Q)<FM;              "SAVE Q=F(1)*R(2)
          FSUB ZERO,DPX(D)      "   -D
"L600 LOOP ... DO IT LR-1 TIMES
"       L GOES FROM 1 TO LR-1
"NOTE...L IS ONE LESS THAN IT WOULD BE IN FORTRAN,
"        SINCE THIS MAKES L USEABLE DIRECTLY
"        AS A SUBSCRIPT
"WE SET UP THE ADDRESS POINTERS NEEDED FOR L100:
"                        INITIAL INITIAL
"POINTER         ARRAY    VALUE    ACCESS
"AJP             A(J)     A        A(1)
"RJP             R(J+1)   R+1      R(2)
"AKP             A(K)     A+L      A(L-1)
"RKP             R(K+1)   R+L+1    R(L)
L600:   FADD; INC L;            "INCREMENT L
          DPY(Y)<DPX(ONE)       "  SET DIVIDEND TO ONE
        FMUL DPX(INV),FA;       "-D*(1/V)
          SUB# L,LR             "  SEE IF WE'RE DONE
        FMUL;  FADD ZERO,DPY(V);"FOR TESTING V LATER
          MOV R,RKP;            "WE WANT RKP=R+L+1
          BGT .+2               "  BRANCH IF L .GT. LR
       RETURN; CLR 17           "WE'RE DONE!!!!!!!!!!
        ADD# L,G; SETMA;        "FETCH G(L)
          FMUL; FADD
        FMUL FM,DPX(D);         "AL*D
          DPX(AL)<FM;           "  SAVE AL
          ADD L,RKP
        MOV R,RJP               "SET RJP TO R+1
        FMUL DPX(AL),DPY(R2);   "AL*R(2)
          INC RKP; SETMA;       "  FETCH R(L+1)
          BFGT OK               "  BRANCH IF V .GT.0
"COME HERE ONLY IF THINGS HAVE BLOWN UP.......
        MOV L,17; RETURN                "RETURN L AND GET OUT
".........................................................
OK:     FSUBR DPY(Q),MD; FMUL;  "G(L)-Q
          INC RJP
        MOV A,AJP               "SET AJP TO A
        FADD FM,DPY(V); FMUL;   "V+(AL*D)
          MI<DPY(V);            "  STORE F(L)=V
          ADD# L,F; SETMA
        FADD FM,MD;             "R(L+1)+(AL*R(2))
          DPY(FL)<FA;           "  SAVE G(L)-Q IN FL
          MOV A,AKP             "  SET AKP TO A+L
        ADD L,AKP
        MI<DPX(AL);             "STORE AL INTO A(L)
          ADD# L,A; SETMA;      "  STORE V INTO A(L)
          DPY(V)<FA; FADD;      "  SAVE V
          DPX(INV)<FA           "  PUT IN DIVISOR
        JSR DIV;                "DO 1.0/V
          DPX(D)<FA             "  SAVE D=P(L+1)+AL*R(2)
        FMUL DPX(INV),DPY(FL);  "(G(L)-Q)*(1/V)
          DPY(Y)<ZERO           "  WE NEED A ZERO LATER
        FMUL DPY(Y),DPY(Y)      "WE WANT A ZERO IN FM
        FMUL; MOVR L,T          "COUNT=L/2
        DPY(FL)<FM;             "FL=(G(L)-Q)/V
          DPX(TEMP)<FM;         "  SAVE HERE ALSO
          FMUL DPY(Y),DPY(Y);   "  WE NEED ANOTHER ZERO
          BGT L100              "  BRANCH IF L.GE.2
"COME HERE ONLY IF L IS 1.................
        MOV ISW,ISW;            "SEE IF SPIKE OR GENERAL
          FADD ZERO,DPX(D)      "  D=D
        JMP L200; FADD
"L100 LOOP......................................
"       WE DO THIS L/2 TIMES
L100:   DEC AKP; SETMA;         "FETCH A(K)
          FADD FM,DPX(D); FMUL  "  SUM+R(K+1)*A'(J)
        NOP                        "FOR UPWARD COMPATIBILITY
        INC AJP; SETMA;         "FETCH A(J)
          FADD; FMUL
        DPY(AK)<MD;             "SAVE A(K)
          FMUL DPX(AL),MD;      "  AL*A(K)
          FADD FM,FA            "  SUM+R(J+1)*A'(K)
        DEC RKP; SETMA;         "FETCH R(K+1)
          FMUL; FADD
        DPY(AJ)<MD;             "SAVE A(J)
          FMUL DPX(AL),MD;      "  AL*A(J)
          DPX(D)<FA             "  SAVE SUM
        INC RJP; SETMA;         "FETCH R(J+1)
          FADD FM,DPY(AJ); FMUL "  (AL*A(K))+A(J)
        DPX(RK)<MD; FADD; FMUL  "SAVE R(K)
        MOV AJP,AJP; SETMA;     "STORE A'(J)
          MI<FA;
          FADD FM,DPY(AK);      "  (AL*A(J))+A(K)
          FMUL DPX(RK),FA       "  R(K+1)*A'(J)
        DPX(RJ)<MD; DEC T;      "SEE IF DONE WITH L100
          FADD; FMUL
        MOV AKP,AKP; SETMA;     "STORE A'(K)
          MI<FA;
          FMUL DPX(RJ),FA;      "  R(J+1)*A'(K)
          BNE L100
"WE GO THROUGH ODD OR EVEN, DEPENDING ON THE STATE
"       OF L
"NOW...IF L WAS EVEN, WE DON'T WANT TO ADD
"       THE SECOND TERM TO SUM
        MOVR# L,L;              "TEST CARRY
          FADD FM,DPX(D); FMUL  "  SUM+R(K+1)*A'(J)
        BZC EVEN; FMUL          "SKIP AROUND IF EVEN
ODD:    FADD
        FADD FM,FA              "ADD IN LAST TERM
EVEN:   MOV ISW,ISW; FADD       "SEE IF SPIKE OR GENERAL CASE
"TEST HERE WHETHER SPIKE OR GENERAL CASE
L200:    DPX(D)<FA;             "SAVE D
          MOV A,AKP;            "  FOR GENERAL CASE
          BNE GENERAL           "  BRANCH IF NOT ZERO
"IF SPIKE CASE GO BACK TO L600.........
        JMP L600; FSUB ZERO,DPX(D)      "-D
"HERE IS THE EXTRA STUFF FOR THE GENERAL CASE................
"WE SET ADDRESS POINTERS FOR L300:
"                       INITIAL INITIAL
"POINTER         ARRAY    VALUE    ACCESS
"FJRP           F(J)    F       F(0)
"FJWP            F(J)     F-1      F(0)
"AKP             A(K)     A+L      A(A+L)
"RKP            R(K+1)  R+L+1   R(L+1)
GENERAL: FMUL DPX(TEMP),DPY(R2); "FL*R(2)
          ADD# L,F; SETMA;      "  STORE F(L)=FL
          MI<DPX(TEMP)
        FMUL; ADD L,AKP; SETMA  "SET AKP TO A+L, FETCH A(K)
        FMUL; MOV R,RKP         "SET RKP TO R+L+1
        MOV F,FJRP; SETMA;      "SET FJRP TO F, FETCH F(J)
          DPY(Q)<FM             "  SAVE Q
        ADD L,RKP;
          FMUL DPY(FL),MD       "  FL*A(K)
        INC RKP; SETMA; FMUL    "FETCH R(K+1)
        FMUL; MOV L,T    "COUNT IS L
        FADD FM,MD;             "F(J)+FL*A(K)
          MOV FJRP,FJWP         "FJWP=FJRP
        DEC FJWP
"L300 LOOP...........................
"       WE DO THIS LOOP L TIMES
L300:   DEC AKP; SETMA;         "FETCH A(K)
          FADD; DPX(RK)<MD      "  SAVE R(K+1)
         FMUL DPX(RK),FA;       "F'(J)*R(K+1)
          DPY(Y)<FA             "  SAVE F'(J)
        INC FJRP; SETMA; FMUL   "FETCH F(J)
        FMUL DPY(FL),MD         "FL*A(K)
        DEC RKP; SETMA; FMUL;   "FETCH P(K+1)
          FADD FM,DPY(Q)        "  Q+F'(J)*R(K+1)
        DEC T; FMUL; FADD       "SEE IF DONE WITH L100
        INC FJWP; SETMA;        "STORE F'(J)
          MI<DPY(Y);
          FADD FM,MD;           "(J)+FL*A(K)
          DPY(Q)<FA;            "  SAVE Q
          BNE L300              "  BRANCH RACK IF NOT DONE
"DONE...GO BACK TO L600...................
        JMP L600; FSUB ZERO,DPX(D)       "-D
        $END
"****** LPAUTO = LINEAR PREDICTION AUTOCORRELATION /COMMON/ = REL 3.0, AUG 80
$TITLE LPAUTO
$RADIX 8
         XADC $EQU 1           "CONDITIONAL ASSEMBLY PARAMETER FOR ADC
$ENTRY LPAUTO,11
$EXT   DIV
"""""
"FUNCTION:  PERFORMS A LINEAR PREDICTION ANALYSIS
"           USING THE AUTOCORRELATION METHOD; I.E.,
"           CALCULATES AUTOCORRELATION, FILTER, AND REFLECTION
"           COEFFICIENTS USING LEVINSON'S METHOD;
"           COMMONLY USED IN SPECTRAL ANALYSIS OF
"           SPEECH SIGNALS (POST 1972), AS IT PRODUCES
"           A SMOOTHED, ALL-POLE MODEL, WHICH IS USEFUL
"           FOR ANALYSIS, SYNTHESIS, AND COMPRESSION;
"           ALSO USED IN IMAGE AND SEISMIC PROCESSING.
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH STANDARD OR FAST MEMORY
"SIZE:      115 + EXTERNALS = 171 LOCATIONS
"SPEED:      .38 MS (FAST),  .47 MS (STRD);  FOR M=6,  N=64
"           1.10 MS (FAST), 1.35 MS (STRD);  FOR M=10, N=128
"           2.80 MS (FAST), 3.47 MS (STRD);  FOR M=14, N=256
"SCRATCH:   SP(0,1,4,11-15),DPX(-4,-3,-1,0,1,2),DPY(-4 TO 3),FA,FM,TM,MD
"EXTERNALS: DIV
"HISTORY:   ORIGINAL  AUG 80  T.E. SKINNER
"
"S-PAD PARAMETERS:  (I=INPUT,O=OUTPUT)
"    CALL LPAUTO(N,IXADR,M,IRCADR,MP1,IAADR,IALADR,IRADR,IERADR)
" (I)  N      $EQU  0  LENGTH OF TIME SERIES
" (I)  IXADR  $EQU  1  BASE ADDRESS OF TIME SERIES SAMPLES
" (I)  M      $EQU  2  LENGTH OF REFLECTION COEFFICIENT VECTOR
" (O)  IRCADR $EQU  3  BASE ADDRESS OF REFLECTION COEFFICIENTS
" (I)  MP1    $EQU  4  M+1
" (O)  IAADR  $EQU  5  BASE ADDRESS OF FILTER COEFFICIENTS
" (O)  IALADR $EQU  6  BASE ADDRESS OF ENERGY TERMS PER ITERATION
" (O)  IRADR  $EQU  7  BASE ADDRESS OF AUTOCORRELATION COEFFICIENTS
" (O)  IERADR $EQU 10  ADDRESS OF ERROR STATUS
"""""
"  AN ORIGINAL VERSION (1) OF THIS ROUTINE APPEARED IN:
"      PROGRAMS FOR DIGITAL SIGNAL PROCESSING,
"      EDITED BY THE DIGITAL SIGNAL PROCESSING COMMITTEE,
"      IEEE ACOUSTICS, SPEECH, AND SIGNAL PROCESSING SOCIETY, 1979.
"      ''LINEAR PREDICTION ANALYSIS PROGRAMS (AUTO-COVAR)'',
"      A. H. GRAY AND J. D. MARKEL, SIGNAL TECHNOLOGY INC.,
"      PAGES 4.1-1 THROUGH 4.1-7.
"
"  A LATER VERSION (2) WAS OBTAINED DIRECTLY FROM JOHN MARKEL
"  AT SIGNAL TECHNOLOGY INC.  THIS FORTRAN PROGRAM APPEARS HERE
"  FOR REFERENCE.  NOTEWORTHY CHANGES FROM VERSION (1) ARE:
"        (A) THE SCALAR ALPHA IS NOW A VECTOR,
"    AND (B) THE ''SINGULAR MATRIX'' WARNING IS ABSENT.
"
"  THE VERSION (3), WHICH IS CODED HERE IN APAL, HAS THE
"  FOLLOWING CHARACTERISTICS:
"        (A) THE APAL CODE WAS ESSENTIALLY GENERATED USING THE
"            VERSION (2) FORTRAN PROGRAM,
"        (B) THE AUTOCORRELATION COEFFICIENT VECTOR WAS ADDED AS
"            AN OUTPUT ARGUEMENT,
"            SINCE IT IS COMPUTED INTERNALLY AND MAY BE OF
"            INTEREST TO THE USER,
"            AND IT MUST HAVE STORAGE EXPLICITLY ALLOCATED,
"    AND (C) THE ERROR STATUS HAS BEEN REINSERTED.
"""""
"      SUBROUTINE AUTO(N,X,M,A,ALPHA,RC)
"C
"C     DESCRIPTION OF ARGUEMENTS
"C
"C     N           NUMBER OF DATA POINTS
"C     X(N)        INPUT DATA SEQUENCE
"C     M           ORDER OF FILTER
"C     A(M+1)      FILTER COEFFICIENTS
"C     ALPHA(M+1)  RESIDUAL ENERGY TERMS PER ITERATION
"C     RC(M)       REFLECTION COEFFICIENTS
"C
"      DIMENSION X(1),A(2),RC(2),ALPHA(2),R(30)
"C
"C     AUTOCORRELATION
"C
"      MP=M+1
"      DO 12 K=1,MP
"      SUM=0.
"      KM1=K-1
"      NPEND=N-KM1
"      DO 10 NP=1,NPEND
"      IDX=NP+KM1
"10    SUM=SUM+X(NP)*X(IDX)
"12    R(K)=SUM
"C
"C     MATRIX INVERSION
"C
"      A(1)=1.
"      ALPHA(1)=R(1)
"      IF(M.EQ.0) GO TO 60
"      IF(R(1).LE.0.0) GO TO 60
"      RC(1)=-R(2)/R(1)
"      A(2)=RC(1)
"      ALPHA(2)=R(1)+R(2)*RC(1)
"      IF(M.EQ.1) GO TO 60
"      DO 40 MINC=2,M
"      S=0.
"      MINC2=MINC+2
"      ALPMIN=ALPHA(MINC)
"      DO 20 IP=1,MINC
"      IDX=MINC2-IP
"20    S=S+R(IDX)*A(IP)
"      RCMINC=-S/ALPMIN
"      MH=MINC/2+1
"      DO 30 IP=2,MH
"      IB=MINC2-IP
"      AIP=A(IP)
"      AIB=A(IB)
"      A(IP)=AIP+RCMINC*AIB
"30    A(IB)=AIB+RCMINC*AIP
"      A(MINC+1)=RCMINC
"      ALPHA(MINC+1)=ALPMIN-ALPMIN*RCMINC*RCMINC
"      RC(MINC)=RCMINC
"      IF(ALPMIN) 50,50,40
"40    CONTINUE
"50    CONTINUE
"60    RETURN
"      END
"""""
"""""S-PAD NAMES:
     N      $EQU  0     "LENGTH OF TIME SERIES
     X      $EQU  1     "VECTOR OF TIME SAMPLES
     M      $EQU  2     "ORDER OF FILTER
     RC     $EQU  3     "VECTOR OF REFLECTION COEFFICIENTS
     MP1    $EQU  4     "M+1
     A      $EQU  5     "VECTOR OF FILTER COEFFICIENTS
     ALPHA  $EQU  6     "VECTOR OF ENERGY TERMS PER ITERATION
     R      $EQU  7     "VECTOR OF AUTOCORRELATION COEFFICIENTS
     IERADR $EQU 10     "ADDRESS OF ERROR STATUS
     K      $EQU 11     "LOOP12 INDEX
     NPEND  $EQU 12     "LOOP10 ITERATIONS
     BASEX  $EQU 13     "LOOP10 BASE ADDRESS OF X(1)
     BASEXK $EQU 14     "LOOP10 BASE ADDRESS OF X(1+K)
     MM1    $EQU  0     "LOOP40 ITERATIONS
     MINC   $EQU  1     "LOOP40 INDEX
     MINC2  $EQU 11     "MINC+2
     MINC20 $EQU 13     "LOOP20 ITERATIONS
     BASEA  $EQU 17     "LOOP20 BASE ADDRESS OF A(1)
     BASER  $EQU 14     "LOOP20 BASE ADDRESS OF R(MINC2-1)
     MH     $EQU 13     "LOOP30 ITERATIONS
     BASEIP $EQU 17     "LOOP30 BASE ADDRESS OF A(2)
     BASEIB $EQU 14     "LOOP30 BASE ADDRESS OF A(MINC2-2)
     MINC1  $EQU 12     "MINC+1
     FLAG17 $EQU 17     "PROBLEM PASS NUMBER
"""""DATA PAD X NAMES:
     SUM    $EQU -4     "SUM
     RCMINC $EQU -3     "RCMINC
     S      $EQU -1     "S
     DENOM  $EQU  0     "JSR DIV ARGUEMENT
     DUMMY  $EQU  1     "JSR DIV SCRATCH
     PPASSN $EQU  2     "PROBLEM PASS NUMBER
"""""DATA PAD Y NAMES:
     R1     $EQU -4     "R(1)
     ALPMIN $EQU -3     "ALPMIN
     RIDX   $EQU -2     "R(IDX)
     R2     $EQU -1     "R(2)
     NUM    $EQU  0     "JSR DIV ARGUEMENT
     XNP    $EQU  1     "X(NP)
     AIP    $EQU  2     "A(IP)
     AIB    $EQU  3     "A(IB)
"""""TABLE MEMORY CONSTANTS:
     ONEADR $EQU !ONE
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC = 1
        $SUBR FLPAUT,11
        $EXT RESLVE
         BITMAP $EQU 25
        $PARAM 11, P1/I/IP,
                   P2(#1)/R/IP,
                   P3/I/IP,
                   P4(#3)/R/OP,
                   P5/I/IP,
                   P6(#5)/R/OP,
                   P7(#5)/R/OP,
                   P8(#5)/R/OP,
                   P9/I/OP
 FLPAUT: LDSPI 17;DB = BITMAP
         JSR RESLVE
        $ENDIF
"
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
"""""
 LPAUTO: CLR K                              "K=0
         DEC K                              "K=-1
 LOOP12: INC K                              "K=K+1
 INTR10: MOV X,BASEX;SETMA;                 "FETCH X(1)
           DPX(SUM)<ZERO                    "SUM=0.
         MOV X,BASEXK
         ADD K,BASEXK;SETMA                 "FETCH X(K+1)
         DPY(XNP)<MD;                       "XNP=X(1)
           MOV N,NPEND                      "NPEND=N
         INC BASEX;SETMA                    "FETCH X(2)
         FMUL DPY(XNP),MD;                  "X(1)*X(K+1)
           SUB K,NPEND                      "NPEND=N-K
         INC BASEXK;SETMA;                  "FETCH X(K+2)
           FMUL
         DPY(XNP)<MD;                       "XNP=X(2)
           FMUL;
           DEC NPEND                        "NPEND=N-K-1
         INC BASEX;SETMA;                   "FETCH X(3)
           FADD FM,DPX(SUM)                 "SUM+X(1)*X(K+1)
         FMUL DPY(XNP),MD;                  "X(2)*X(K+2)
           FADD;
           DEC NPEND                        "NPEND=N-K-2
         INC BASEXK;SETMA;                  "FETCH X(K+3)
           FMUL;
           DPX(SUM)<FA                      "SUM=SUM+X(1)*X(K+1)
 LOOP10: DPY(XNP)<MD;                       "XNP=X(NP+1)
           FMUL
         INC BASEX;SETMA;                   "FETCH X(NP+2)
           FADD FM,DPX(SUM)                 "SUM+X(NP)*X(K+NP)
         FMUL DPY(XNP),MD;                  "X(NP+1)*X(K+NP+1)
           FADD;
           DEC NPEND                        "NPEND ITERATIONS OF LOOP10
         INC BASEXK;SETMA;                  "FETCH X(K+NP+2)
           FMUL;
           DPX(SUM)<FA;                     "SUM=SUM+X(NP)*X(K+NP)
           BNE LOOP10                       "CHECK FOR DONE WITH LOOP10
 NEXTR:  ADD# K,R;SETMA;MI<DPX(SUM)         "R(K)=SUM
         DEC MP1                            "MP1 ITERATIONS FOR LOOP12
         BEQ ACDONE                         "CHECK FOR DONE WITH LOOP12
         JMP LOOP12
 ACDONE: LDTMA;DB=ONEADR                    "FETCH 1.0 FROM TM
         NOP
         MOV A,A;SETMA;MI<TM                "A(1)=1.0
         MOV R,R;SETMA                      "FETCH R(1)
         NOP
         INCMA                              "FETCH R(2)
         DPY(R1)<MD                         "R1=R(1)
         MOV ALPHA,ALPHA;SETMA;MI<DPY(R1)   "ALPHA(1)=R(1)
         DPY(R2)<MD;                        "R2=R(2)
           MOV M,M
         BNE MNE0                           "IF M=0, SET (IERADR)=1, RETURN
         JMP R55
 MNE0:   FADD ZERO,DPY(R1)                  "R(1)+0.
         FADD
         NOP
         BFGT R1GT0                         "IF R(1) LE 0, SET (IERADR)=1,
         JMP R55                            "RETURN
 R1GT0:  FSUB ZERO,DPY(R2)                  "-R(2)
         FADD;
           DPX(DENOM)<DPY(R1)               "DPX(0)=R(1)
         DPY(NUM)<FA;                       "DPY(0)=-R(2)
           JSR DIV                          "DPX(0)=-R(2)/R(1)
         MOV RC,RC;SETMA;MI<DPX(DENOM);     "RC(1)=-R(2)/R(1)
           FMUL DPY(R2),DPX(DENOM)          "R(2)*RC(1)
         FMUL;
           MOV M,MM1                        "MM1=M
         INC# A;SETMA;MI<DPX(DENOM);        "A(2)=RC(1)
           FMUL
         FADD FM,DPY(R1);                   "R(1)+R(2)*RC(1)
           DEC MM1                          "MM1=M-1
         FADD;
           CLR MINC                         "MINC=0
         INC# ALPHA;SETMA;MI<FA             "ALPHA(2)=R(1)+R(2)*RC(1)
         DEC# M
         BNE LOOP40                         "IF M=1, RETURN
         JMP R60
 LOOP40: INC MINC;                          "MINC=MINC+1
           DPX(S)<ZERO                      "S=0.
         MOV MINC,MINC2                     "MINC2=MINC
         ADD# MINC,ALPHA;SETMA              "FETCH ALPHA(MINC)
         INC MINC2                          "MINC2=MINC+1
         INC MINC2                          "MINC2=MINC+2
         DPY(ALPMIN)<MD;                    "ALPMIN=ALPHA(MINC)
           MOV MINC,MINC20                  "MINC20=MINC
         INC MINC20                         "MINC20=MINC+1 (MINC STARTS AT 0)
 INTR20: MOV R,BASER
         ADD MINC2,BASER
         DEC BASER;SETMA                    "FETCH R(MINC2-1)
         NOP
         MOV A,BASEA;SETMA                  "FETCH A(1)
         DPY(RIDX)<MD                       "RIDX=R(MINC2-1)
         DEC BASER;SETMA                    "FETCH R(MINC2-2)
         FMUL DPY(RIDX),MD                  "R(MINC2-1)*A(1)
         INC BASEA;SETMA;                   "FETCH A(2)
           FMUL
 LOOP20: DPY(RIDX)<MD;                      "RIDX=R(MINC2-IP-1)
           FMUL
         DEC BASER;SETMA;                   "FETCH R(MINC2-IP-2)
           FADD FM,DPX(S)                   "S+R(MINC2-IP)*A(IP)
         FMUL DPY(RIDX),MD;                 "R(MINC2-IP-1)*A(IP+1)
           FADD;
           DEC MINC20                       "MINC20 ITERATIONS OF LOOP20
         INC BASEA;SETMA;                   "FETCH A(IP+2)
           FMUL;
           DPX(S)<FA;                       "S=S+R(MINC2-IP)*A(IP)
           BNE LOOP20                       "CHECK FOR DONE WITH LOOP20
 DONE20: FSUB ZERO,DPX(S);                  "-S
           MOV MINC,MH                      "MH=MINC
         FADD;
           DPX(DENOM)<DPY(ALPMIN);          "DPX(0)=ALPMIN
           INC MH                           "MH=MH+1 (MINC STARTS AT 0)
         DPY(NUM)<FA;                       "DPY(0)=-S
           MOVR MH,MH                       "MH=MINC(+1)/2
         JSR DIV                            "DPX(0)=-S/ALPMIN
         DPX(RCMINC)<DPX(DENOM)             "RCMINC=-S/ALPMIN
 INTR30: MOV A,BASEIP
         MOV A,BASEIB
         ADD MINC2,BASEIB
         DEC BASEIB
         INC# BASEIP;SETMA                  "FETCH A(2)
         INC BASEIP
         DEC# BASEIB;SETMA                  "FETCH A(MINC2-2)
         DEC BASEIB
         DPY(AIP)<MD                        "AIP=A(2)
         DPY(AIB)<MD                        "AIB=A(MINC2-2)
         FMUL DPX(RCMINC),DPY(AIP);         "RCMINC*A(2)
           DEC BASEIP                       "RESOLVES NEXT INC BASEIP
 LOOP30: FMUL DPX(RCMINC),DPY(AIB);         "RCMINC*AIB
           INC BASEIP                       "RESOLVES DEC(#) AT END OF LOOP
         INC# BASEIP;SETMA;                 "FETCH A(IP+1)
           FMUL
         INC BASEIP;
           FADD FM,DPY(AIB)                 "AIB+RCMINC*AIP
         DEC# BASEIB;SETMA;                 "FETCH A(IB-1)
           FMUL
         DEC BASEIB;
           FADD FM,DPY(AIP)                 "AIP+RCMINC*AIB
         DPY(AIP)<MD;                       "AIP=A(IP+1)
           INC# BASEIB;SETMA;MI<FA          "STORE A(IB)
         DPY(AIB)<MD;                       "AIB=A(IB-1)
           FADD;
           DEC MH                           "MH ITERATIONS OF LOOP30
         FMUL DPX(RCMINC),DPY(AIP);         "RCMINC*AIP
           DEC BASEIP;SETMA;MI<FA;          "STORE A(IP)
           BNE LOOP30                       "CHECK FOR DONE WITH LOOP30
 DONE30: MOV MINC,MINC1;                    "MINC1=MINC
           FMUL DPY(ALPMIN),DPX(RCMINC)     "ALPMIN*RCMINC
         INC MINC1;                         "MINC1=MINC+1
           FMUL
         ADD# MINC1,A;SETMA;MI<DPX(RCMINC); "A(MINC+1)=RCMINC
           FMUL
         FMUL FM,DPX(RCMINC)                "ALPMIN*RCMINC*RCMINC
         FMUL
         FMUL
         FSUBR FM,DPY(ALPMIN)               "ALPMIN-ALPMIN*RCMINC*RCMINC
         FADD DPY(ALPMIN),ZERO;             "BRANCH ON VALUE OF ALPMIN
           ADD# MINC,RC;SETMA;MI<DPX(RCMINC)"RC(MINC)=RCMINC
         ADD# MINC1,ALPHA;SETMA;MI<FA;      "ALPHA(MINC+1)=ALPMIN
           FADD                             "      -ALPMIN*RCMINC*RCMINC
         BFGT C40                           "IF ALPMIN LE 0, DIVISOR TOO SMALL
         JMP R50
 C40:    DEC MM1                            "MM1 ITERATIONS OF LOOP40
         BEQ R60                            "CHECK FOR DONE WITH LOOP40
         JMP LOOP40
 R55:    DPX(PPASSN)<1;                     "PROBLEM ON 1ST PASS,
           BR SAME                          "  SET (IERADR)=1
 R50:    MOV M,FLAG17                       "PROBLEM WITH DIVISOR TOO SMALL,
         SUB MM1,FLAG17                     "  SET (IERADR)=PASS NUMBER,
         INC FLAG17;
           DPX(PPASSN)<SPFN
 SAME:   MOV IERADR,IERADR;SETMA;MI<DPX(PPASSN);
           BR DONE                          "  AND RETURN
 R60:    MOV IERADR,IERADR;SETMA;MI<ZERO    "NORMAL COMPLETION, SET (IERADR)=0
 DONE:   RETURN                             "RETURN
$END
"****** CFFTI = COMPLEX FFT WITH INTERPOLATION /COMMON/ = REL 3.0, AUG 80 *****
        $TITLE CFFTI
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY CFFTI,3          "USER-DIRECTED-CALL ENTRY
        $EXT   FFT2,FFT4,STSTAT,CLSTAT,ADV2,ADV4,BITREV,BITRVI,IFFT4
"""""
"FUNCTION:  PERFORMS A COMPLEX FFT;
"           UPWARD COMPATIBLE WITH CFFT,
"           ALLOWING FOR ONE FURTHER STAGE
"           (N=16384 WITH 2.5K TMROM,
"            N=32768 WITH 4.5K TMROM),
"           VIA INTERPOLATION IN THE COSINE TABLE
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH EITHER MEMORY
"SIZE:      32 + FFT2 (16) + FFT4 (79) + STATUS (19) + ADV (7)
"              + BITREV (45 FAST, 43 STRD) + BITRVI (55 FAST, 52 STRD)
"              + IFFT4 (37) + IFFT4G (48) + RESLVE (27)
"           = 364 (FAST), 359 (STRD)
"SPEED:     FOR N=1024, STRD=8.30 MS, FAST=5.62 MS
"SCRATCH:   SP(2-15), DPX(-4 TO 3), DPY(-4 TO 3), FA,FM,MD,TM
"EXTERNALS: FFT2,FFT4,STSTAT,CLSTAT,ADV2,ADV4,BITREV,BITRVI,IFFT4,RESLVE
"HISTORY:   ORIGINAL  AUG 80  T.E. SKINNER
"""""
"
"""""ALGORITHM:
"
"1.   CALL 'STSTAT'       THIS TAKES 'N' AND 'F', AND SETS THE BIT-REVERSE
"                         AND FFT-MODE BITS IN THE STATUS REGISTER,  AND
"                         LEAVES 2**N IN SPAD(17)
"2.   PARAMETER INITIALIZE: SET THE FOUR 'PASS VARIABLES'
"                         WD = TBLSZE * 2
"                         MDEL = 2
"                         JCOUNT = 1
"                         ICOUNT = N/4  IF N A POWER OF 4
"                                = N/2 IF N A POWER OF 2
"                         AND SET MINC = 2
"3.  DO THE FIRST PASS:   RADIX 2 (FFT2) IF N WAS A POWER OF 2
"                            AND ADVANCE (ADV2)
"                         RADIX 4 (FFT4) IF N WAS A POWER OF 4
"                            AND ADVANCE (ADV4)
"4.  DO THE REST OF THE RADIX 4 PASSES:
"                         CALL FFT4  (TO DO THE NEXT FFT PASS)
"                         CALL ADV4  (TO ADVANCE TO THE NEXT PASS)
"                         TEST ICOUNT (SPFN AFTER ADV4) FOR ZERO TO TEST
"                              FOR DONE;
"4.5                      OR, IF WD IS  =1,
"                              THEN AN ADDITIONAL INTERPOLATION PASS
"                              (CALL IFFT4), IS PERFORMED BEFORE DONE
"5.  WHEN DONE, CALL 'CLSTAT' TO CLEAR THE BIT-REVERSE AND FFT-MODE
"                         STATUS BITS
"
"""""S-PAD NAMES:
     C      $EQU  0          "BASE ADDRESS OF ARRAY
     N      $EQU  1          "NUMBER OF COMPLEX PTS IN THE ARRAY
     F      $EQU  2          "DIRECTION: 1= FOWARD, -1= INVERSE
     MINC   $EQU 13          "ARRAY INCREMENT BETWEEN REAL ELEMENTS (2)
     WD     $EQU 14          "W DELTA
     MDEL   $EQU 15          "MEMORY DELTA
     ICOUNT $EQU 16          "I-LOOP COUNT
     JCOUNT $EQU 17          "J-LOOP COUNT
     FP     $EQU 16          "PARAMETER FOR STSTAT (F)
     NP     $EQU 17          "FOR STSTAT (N)
     M      $EQU 17          "FROM STSTAT (M = LOG2(N))
"""""
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FICFFT,3                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  6
        $PARAM  3 , P1(2,#2)/R/IP/OP, P2/I/IP, P3/I/IP
FICFFT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CFFTI:  MOV N,NP                "IS ELEMENT COUNT = 0?
        MOV F,FP;               "SET-UP FOR STSTAT
          BNE .+2               "BRANCH OVER IF COUNT NOT 0
ZDONE:  RETURN                  "RETURN WHEN N=0
        JSR STSTAT              "SET FFT STATUS BITS
        MOVL# N,N               "TEST FOR 32K CASE
        BEQ THRTWO
        JSR BITREV              "NORMAL BIT-REVERSE
        BR CONTIN
THRTWO: JSR BITRVI              "32K BIT-REVERSE
CONTIN: LDSPI WD; DB=!FFTX2     "SET WD=!FFTSZ*2
        LDSPI MDEL; DB=2
        LDSPI MINC; DB=2        "PUT 2 INTO MINC
        MOVR M,M                "WAS LOG2(N) ODD ?????
        BNC R2                  "IF SO, DO A RADIX 2 PASS FIRST
"
"SET UP FOR FIRST RADIX 4 PASS
R4:     MOVRR N,ICOUNT          "SET ICOUNT=N/4
        LDSPI JCOUNT; DB=1;     "SET COUNT=1
          BR LOOP
"
"DO A RADIX 2 PASS FIRST
R2:     MOVR N,ICOUNT           "SET ICOUNT=N/2
        JSR FFT2
        LDSPI JCOUNT; DB=1      "SET JCOUNT=1
        JSR ADV2                "RADIX 2 ADVANCE
        BEQ DONE                "SEE IF DONE
"
"LOOP HERE TO DO ALL THE PASES
LOOP:   JSR FFT4                "DO A RADIX 4 PASS
        JSR ADV4                "RADIX 4 PASS ADVANCE
"
"DONE IF 'ADV' HAS SHIFTED ICOUNT TO ZERO
"
        BEQ DONE
"""""IF WD=1, SEQUENTIAL ENTRIES IN THE COSINE TABLE
"""""WILL BE REFERENCED AS NEW INCREMENTS;
"""""BUT THEY ARE ACTUALLY R,I,R,I,R,I,R,I,...
"""""THUS, WD=1 IS THE FLAG TO INTERPOLATION REQUIREMENT
        DEC# WD
        BEQ INT
        BR LOOP
INT:    JSR IFFT4
"
"WHEN DONE, CLEAR FFT MODE BITS
"
DONE:   JMP CLSTAT              "CLEAR STATUS REGISTER
                                "AND EXIT THRU CLSTAT
        $END
"****** RFFTI = REAL FFT WITH INTERPOLATION /COMMON/ = REL 3.0, AUG 80 *****
        $TITLE RFFTI
        $RADIX 8
        XADC   $EQU 1           "COND.ASSEMBLY PARAMETER FOR ADC/APFTN ENTRY
        $ENTRY RFFTI,3          "USER-DIRECTED-CALL ENTRY
        $EXT   REALTR,CFFT,IREALT
"""""
"FUNCTION:  PERFORMS A REAL FFT;
"           UPWARD COMPATIBLE WITH RFFTI,
"           ALLOWING FOR ONE FURTHER STAGE
"           (N=16384 WITH 2.5K TMROM,
"            N=32768 WITH 4.5K TMROM),
"           VIA INTERPOLATION IN THE COSINE TABLE
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH EITHER MEMORY
"SIZE:      35 + REALTR (49) + CFFT (187 FAST, 185 STRD) + IREALT (99)
"              + RESLVE (27)
"           = 397 (FAST), 395 (STRD)
"SPEED:     FOR N=1024, STRD=4.89 MS, FAST=3.13 MS
"SCRATCH:   SP(2-15), DPX(-4 TO 3), DPY(-4 TO 3), FA,FM,MD,TM
"EXTERNALS: CFFT,REALTR,IREALT,RESLVE
"HISTORY:   ORIGINAL  AUG 80  T.E. SKINNER
"
"""""ALGORITHM:
"    DIRECT:  FIRST DOES AN N/2-POINT FOWARD COMPLEX FFT.
"             THEN DOES AN N-POINT FOWARD REAL FFT;
"             IF N=8*TMROM, THE REAL FFT IS DONE WITH
"             IREALT, VS REALTR.
"    INVERSE: FIRST DOES AN N-POINT INVERSE REAL FFT;
"             IF N=8*TMROM, THE REAL FFT IS DONE WITH
"             IREALT, VS REALTR.
"             THEN DOES AN N/2-POINT INVERSE COMPLEX FFT.
"
"""""S-PAD NAMES:
     C      $EQU   0     "BASE ADDRESS OF REAL DATA VECTOR
     N      $EQU   1     "NUMBER OF REAL POINTS IN THE VECTOR
     F      $EQU   2     "DIRECTION: 1= FOWARD, -1= INVERSE
"""""
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
" *** CONDITIONAL ASSEMBLY ***
        $IF XADC=1
        $SUBR FIRFFT,3                         "AUTO-DIRECTED-CALL ENTRY
        $EXT RESLVE
        BITMAP  $EQU  6
        $PARAM  3 , P1(#2)/R/IP/OP, P2/I/IP, P3/I/IP
FIRFFT: LDSPI 17;DB=BITMAP
        JSR RESLVE
        $ENDIF
" . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
 RFFTI: MOV N,N
        BNE CONT
        JMP DONE
CONT:   MOV F,F                         "SEE IF DIRECT OR INVERSE
        BGT DIRECT                      "BRANCH IF DIRECT
INVRSE: MOV F,3                         "SET PARAMETERS FOR REALTR
        MOV N,2
        MOV C,1
"CHECK FOR INTERPOLATION REQUIREMENT
"N=8*COSINE TABLE SIZE
        LDSPI 5; DB=!FFTX4
        MOVL 5,5
        SUB 2,5
        BNE INORM
        JSR IREALT
        BR ICOM
INORM:  JSR REALTR                      "GO DO THE REAL PASS
ICOM:   MOVR 2,N                        "MAKE N THE # OF COMPLEX POINTS
        MOV 3,F                         "PUT PARAMETERS BACK FOR CFFT
        JSR CFFT                        "DO AN N/2 POINT COMPLEX FFT
        MOVL N,N; BR DONE               "RESTORE N REAL AND RETURN
DIRECT: MOVR N,N                        "MAKE N # OF COMPLEX POINTS
        JSR CFFT                        "DO AN N/2 POINT COMPLEX FFT
        LDSPI 3; DB=1                   "SET 'F' FOR REALTR, ETC.
        MOVL N,2                        "RESTORE N TO BE # REAL POINTS
        MOV C,1
"CHECK FOR INTERPOLATION REQUIREMENT
"N=8*COSINE TABLE SIZE
        LDSPI 5; DB=!FFTX4
        MOVL 5,5
        SUB 2,5
        BNE DNORM
        JSR IREALT
        BR DCOM
DNORM:  JSR REALTR                      "DO THE REAL PASS
DCOM:   MOV 2,N                         "PUT N BACK IN SPAD(1)
DONE:   RETURN
        $END
"****** BITRVI = BIT REVERSE FOR CFFTI /FAST/ = REL 3.0, AUG 80 *****
        $TITLE BITRVI
        $RADIX 8
        $ENTRY BITRVI
"""""
"FUNCTION:  TAKES A COMPLEX DATA ARRAY AND PUTS IT IN BIT-REVERSED
"           (RADIX 2) ORDER;  HANDLES THE CASE OF N=32768;
"           ADOPTED FROM, AND UPWARD COMPATIBLE WITH BITREV.
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH STANDARD MEMORY
"SIZE:      55 LOCATIONS
"SPEED:     40.40 MS FOR N=32768
"SCRATCH:   SP(11-16), FA,MD
"EXTERNALS: NONE
"HISTORY:   ORIGINAL  AUG 80  T.E. SKINNER
"""""
"""""S-PAD NAMES:
     BASE   $EQU  0     "ARRAY BASE ADDRESS
     N      $EQU  1     "N (NUMBER OF COMPLEX POINTS)
     BASEP1 $EQU 11     "BASE + DI
     BASEP2 $EQU 12     "BASE + 2 * DI
     I      $EQU 13     "ARRAY SUBSCRIPT
     T      $EQU 14     "ARRAY SUBSCRIPT SHIFTED LEFT 8 (*256)
     I2     $EQU 14     "I/2
     BRI2   $EQU 15     "&I/2
     DT     $EQU 15     "DELTA FOR T (2 * 256 = 512)
     DI     $EQU 16     "DELTA FOR I (2)
"""""
BITRVI: LDSPI DI; DB=2                  "SET MEMORY INCREMENT = 2
        MOV BASE,BASEP1                 "SET MEMORY BASE ADDRESSES
        ADD DI,BASEP1
        MOV BASEP1,BASEP2
        LDSPI T; DB=256.                "FOR TESTING N
        SUB# T,N                        "SEE IF N .GE. 256
        BGE BIGINT;                     "YES, A 'BIG' ARRAY
          ADD DI,BASEP2
        MOVL N,I                        "2*N IS VALID
        JMP SMALL                       "NO, A SMALL ARRAY
"""""
"   ARRAY 256 ELEMENTS OR LARGER........................................
"   BIT-REVERSE BITS OF STATUS REGISTER SET TO 15.-LOG2(N)
BIGINT: MOV N,I                         "(N-1)*2 VS (2*N)-2
        DEC I                           "     SINCE, IF N=32768, 2*N=0
        MOVL I,I;
          BR CKBIG
BIG:    SUB DI,I;                       "START IN THE CHECKING LOOP
          BR CKBIG
"
DONEJP: JMP DONBIG
"
"   FINISH A SWAP AND THEN CHECK THE NEXT ELEMENT
NOSWAP: ADD# I,BASEP2; SETMA; MI<FA;    "STORE NEW RE(I)
          FADD
        MOV I2,I2                       "DONE WHEN I2 EQUALS 0
        INCMA; MI<FA;                   "STORE NEW IM(I)
          BEQ DONEJP
"
"   SUBSCRIPT CHECKING LOOP, COMPARE THE SUBSCRIPT AGAINST ITSELF
"   BIT-REVERSED - SWAP COMPLEX ELEMENTS ONLY IF BIT-REVERSED
"   VALUE IS LOWER.  I.E. SWAP THE PAIR THE SECOND TIME
"   WE PASS IT ON OUR WAY DOWN FROM THE TOP OF THE ARRAY
"
"   I, AND THUS &I, ARE EVEN;  THEREFORE THE RIGHT-MOST BIT IS ZERO.
"   SINCE THE LEFT-MOST BIT OF I AND/OR &I MAY BE SIGNIFICANT WITH
"   RESPECT TO MAGNITUDE (AND NOT SIGN), BOTH I AND &I ARE
"   RIGHT-SHIFTED BEFORE THEY ARE COMPARED.
CKBIG:  MOVR &I,BRI2
        MOVR I,I2
        SUB BRI2,I2                     "TEST BITREV(I) AGAINST I
        SUB DI,I;                       "DECREMENT I ONE COMPLEX LOCATION
          BGE BIG                       "BRANCH IF BITREV(I).LT.I
"
"   WE COME HERE IF WE HAVE TO SWAP ELEMENTS
"   NOTE THAT I WAS BEEN DECREMENTED ONE ELEMENT BELOW THE PAIR
"   THAT MUST BE SWAPPED
SWAPBG: MOVR &I,BRI2
        MOVR I,I2
        ADD# I,BASEP1; SETMA            "FETCH RE(I)
        INCMA;                          "FETCH IM(I)
          ADD DI,I                      "BACK UP I TO CURRENT ELEMENT
        ADD# &I,BASE; SETMA             "FETCH RE(BITREV(I))
        INCMA;                          "FETCH IM(BITREV(I))
          FADD ZERO,MD;                 "SAVE RE(I)
          SUB DI,I                      "RESTORE I BACK TO WHERE IT WAS
        FADD ZERO,MD                    "SAVE IM(I)
        DECMA; MI<FA;                   "STORE NEW RE(BITREV(I))
          FADD ZERO,MD;                 "SAVE OLD RE(BITREV(I))
          SUB# BRI2,I2                  "TEST NEXT PAIR
        INCMA; MI<FA;                   "STORE NEW IM(BITREV(I))
          FADD ZERO,MD;                 "SAVE OLD IM(BITREV(I))
          SUB DI,I;                     "DECREMENT TO NEXT ELEMENT
          BGE NOSWAP                    "BRANCH IF DON'T SWAP NEXT PAIR
        ADD# I,BASEP2; SETMA; MI<FA;    "STORE NEW RE(I)
          FADD
        INCMA; MI<FA;                   "STORE NEW IM(I)
          BR SWAPBG                     "GO SWAP NEXT PAIR
"
"   DONE WITH BIG BIT-REVERSE:
DONBIG: RETURN
"""""
"   ARRAY SMALLER THAN 256 ELEMENTS.....................................
"   BIT-REVERSE FIELD OF STATUS REGISTER SET TO 7-LOG2(N)
SMALL:  LDSPI DT; DB=512.               "DELTA FOR T
        MOVL I,T                        "SHIFT I LEFT 8 PLACES TO GET T
        ADDL T,T                        "!!!
        ADDL T,T                        "!!!
        ADDL T,T                        "!!!
        MOVL T,T
        SUB DI,I                        "DECREMENI I
CKSML:  SUB DT,T; BEQ DONBIG            "DECREMENT T; QUIT IF NO REVERSING TO DO
        SUB# &T,I                       "COMPARE BITREV(T) AND I
        SUB DI,I;                       "DECREMENT I TO NEXT ELEMENT
          BGE CKSML                     "BRANCH IF DON'T SWAP THIS ONE
"
"   SWAP ELEMENTS
        ADD# I,BASEP1; SETMA            "FETCH RE(I)
        INCMA                           "FETCH IM(I), DECREMENT T
        ADD# &T,BASE; SETMA             "FETCH RE(BITREV(I))
        INCMA;                          "FETCH IM(BITREV(I))
          FADD ZERO,MD                  "SAVE RE(I))
        FADD ZERO,MD                    "SAVE IM(I)
        DECMA; MI<FA;                   "STORE NEW RE(BITREV(I))
          FADD ZERO,MD;                 "SAVE OLD RE(BITREV(I))
          MOV I,I                       "FOR TESTING I DOWN TO ZERO
        INCMA; MI<FA;                   "STORE NEW IM(BITREV(I))
          FADD ZERO,MD;                 "SAVE OLD IM(BITREV(I))
          BEQ DONSML                    "BRANCH IF DONE
        ADD# I,BASEP1; SETMA; MI<FA;    "STORE RE(I)
          FADD
        INCMA; MI<FA;                   "STORE IM(I)
          SUB DT,T;                     "DECREMENT T
          BR CKSML + 1                  "LOOP BACK
"
"   FINISH OFF LAST SWAP AND RETURN
DONSML: ADD# I,BASEP1; SETMA; MI<FA; FADD
        INCMA; MI<FA; RETURN
        $END
"****** IFFT4 = FINAL RADIX-4 FOR CFFTI /COMMON/ = REL 3.0, AUG 80 *****
$TITLE IFFT4
$RADIX 8
$ENTRY IFFT4
$EXT   IFFT4G
"""""
"FUNCTION:  PERFORMS THE FINAL RADIX-4 FOR THE INTERPOLATED
"           COMPLEX FFT; THIS ROUTINE DOES THE APPROPRIATE
"           REFERENCING AND INTERPOLATING IN THE TM COSINE TABLE,
"           AND CALLS ROUTINE 'IFFT4G' TO PERFORM THE
"           ARITHMETIC COMPUTATIONS
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP120B WITH STANDARD OR FAST MEMORY
"SIZE:      37 LOCATIONS
"SPEED:     29 CYCLE LOOP, N/8 ITERATIONS; PLUS TWO IFFT4G CALLS/LOOP
"SCRATCH:   SP(2,5,10,11,12,14), DPX(-4 TO 1),
"           DPY(-4 TO -2), FA,FM,TM
"EXTERNALS: IFFT4G
"HISTORY:   ORIGINAL  AUG 80  T.E. SKINNER
"""""
     POINT5: $FP 0.5    "INTERPOLATION MULTIPLIER
"""""
"""""S-PAD NAMES:
     BASE   $EQU  0     "BASE ADRS OF I/O DATA ARRAY (R,I,R,I...; 2*N VALUES)
     N      $EQU  1     "SIZE OF COMPLEX FFT
     LPBASE $EQU  2     "POINTER TO 1ST OF 4 RADIX-4 DATA VALUES
"    READ   $EQU  3     "DATA INPUT POINTER
"    WRITE  $EQU  4     "DATA OUTPUT POINTER
     ITCNT  $EQU  5     "LOOP CNTR = N/4/2 RADIX-4 FFT BUTTERFLIES
     W1     $EQU 10     "TM POINTER FOR FIRST ANGLE
     W2     $EQU 11     "TM POINTER FOR SECOND ANGLE
     W3     $EQU 12     "TM POINTER FOR THIRD ANGLE
     MINC   $EQU 13     "BASIC DATA MEMORY ADR INCR = 2 (R,I)
     WD     $EQU 14     "TABLE MEMORY ADDRESSING INCREMENT = 2 (R,I)
"    MDEL   $EQU 15     "DATA MEMORY ADR INCR WITHIN EACH RADIX-4 = N/2
"""""
"""""DATA PAD X NAMES:
     W1R    $EQU -4     "W1 REAL
     W1I    $EQU -3     "W1 IMAGINARY
     W2R    $EQU -2     "W2 REAL
     W2I    $EQU -1     "W2 IMAGINARY
     W3R    $EQU  0     "W3 REAL
     W3I    $EQU  1     "W3 IMAGINARY
"""""
"""""DATA PAD Y NAMES:
     HALF   $EQU -4     "0.5 INTERPOLATION MULTIPLIER
     W3RT   $EQU -3     "TEMPORARY W3R USED DURING INTERPOLATION
     W3IT   $EQU -2     "TEMPORARY W3I USED DURING INTERPOLATION
"""""
 IFFT4:  MOVL WD,WD                        "SET WD=2
         MOVRR N,ITCNT                     "SET LOOP CNTR = N/8
         MOVR ITCNT,ITCNT
         MOV BASE,LPBASE                   "SET I/O POINTER
         SUB MINC,LPBASE
         CLR W1                            "SET W POINTER
         SUB WD,W1
 LOOP:   ADD WD,W1;SETTMA                  "FETCH W'S -- NO INTERPOLATION
         INCTMA
         MOVL W1,W2;SETTMA;
           DPX(W1R)<TM                     "W1R
         INCTMA;
           MOV W2,W3;
           DPX(W1I)<TM                     "W1I
         ADD W1,W3;SETTMA;
           DPX(W2R)<TM                     "W2R
         INCTMA;
           DPX(W2I)<TM                     "W2I
         DPX(W3R)<TM                       "W3R
         DPX(W3I)<TM                       "W3I
"""""
         JSR IFFT4G
"""""
         RPSF POINT5; DPY(HALF)<DB         "LOAD 0.5 INTERP MULTIPLIER
"""""
" W1 INCREMENTS BY 1/2 TM UNITS --
"      I. E., INTERPOLATE BETWEEN CURRENT AND NEXT INCREMENT VALUE
" W2 INCREMENTS BY 1 TM UNIT --
"      I. E., NO INTERPOLATION NECESSARY, JUST INCREMENT
"      (VERSUS INTERPOLATING BETWEEN CURRENT VALUE AND +2 INCREMENT VALUE)
" W3 INCREMENTS BY 1+1/2 TM UNITS --
"      I. E., INTERPOLATE BETWEEN +1 AND +2 INCREMENT VALUES
"      (VERSUS INTERPOLATING BETWEEN CURRENT VALUE AND +3 INCREMENT VALUE)
"""""
         ADD WD,W1;SETTMA                  "FETCH W'S -- INTERPOLATION
         INCTMA
         ADD WD,W2;SETTMA;
           FADD TM,DPX(W1R)                "W1R(+1)+W1R
         INCTMA;
           FADD TM,DPX(W1I)                "W1I(+1)+W1I
         ADD WD,W3;SETTMA;
           FMUL DPY(HALF),FA;              "0.5*(W1R(+1)+W1R)
           DPX(W2R)<TM;                    "W2R'
           FADD
         INCTMA;
           FMUL DPY(HALF),FA;              "0.5*(W1I(+1)+W1I)
           DPX(W2I)<TM                     "W2I'
         ADD WD,W3;SETTMA;
           DPY(W3RT)<TM;                   "W3R(+1)
           FMUL
         INCTMA;
           DPY(W3IT)<TM;                   "W3I(+1)
           DPX(W1R)<FM;                    "W1R'
           FMUL
         DPX(W1I)<FM;                      "W1I'
           FADD TM,DPY(W3RT)               "W3R(+1)+W3R(+2)
         FADD TM,DPY(W3IT)                 "W3I(+1)+W3I(+2)
         FMUL DPY(HALF),FA;                "0.5*(W3R(+1)+W3R(+2))
           FADD
         FMUL DPY(HALF),FA                 "0.5*(W3I(+1)+W3I(+2))
         FMUL
         DPX(W3R)<FM;                      "W3R'
           FMUL
         DPX(W3I)<FM;                      "W3I'
           SUB WD,W1                       "RESTORE W1
"""""
         JSR IFFT4G
"""""
         DEC ITCNT                         "CHECK FOR DONE
         BEQ DONE
         JMP LOOP
 DONE:   RETURN
$END
"****** IFFT4G = IFFT4 COMPUTATION KERNEL /COMMON/ = REL 3.0, AUG 80 *****
$TITLE IFFT4G
$RADIX 8
$ENTRY IFFT4G
"""""
"FUNCTION:  PERFORMS THE ARITHMETIC COMPUTATIONS
"           IN THE FINAL RADIX-4 OF THE INTERPOLATED
"           COMPLEX FFT
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH STANDARD OR FAST MEMORY
"SIZE:      48 LOCATIONS
"SPEED:     44 CYCLES, NO LOOPS
"SCRATCH:   SP(2,3,4), DPX(-4 TO 3), DPY(2,3), FA,FM,MD
"EXTERNALS: NONE
"HISTORY:   ORIGINAL  AUG 80  T.E. SKINNER
"""""
"""""S-PAD NAMES:
"    BASE   $EQU  0     "BASE ADRS OF I/O DATA ARRAY (R,I,R,I...; 2*N VALUES)
"    N      $EQU  1     "SIZE OF COMPLEX FFT
     LPBASE $EQU  2     "POINTER TO 1ST OF 4 RADIX-4 DATA VALUES
     READ   $EQU  3     "DATA INPUT POINTER
     WRITE  $EQU  4     "DATA OUTPUT POINTER
"    ITCNT  $EQU  5     "LOOP CNTR = N/4/2 RADIX-4 FFT BUTTERFLIES
"    W1     $EQU 10     "TM POINTER FOR FIRST ANGLE
"    W2     $EQU 11     "TM POINTER FOR SECOND ANGLE
"    W3     $EQU 12     "TM POINTER FOR THIRD ANGLE
     MINC   $EQU 13     "BASIC DATA MEMORY ADR INCR = 2 (R,I)
"    WD     $EQU 14     "TABLE MEMORY ADDRESSING INCREMENT = 2 (R,I)
     MDEL   $EQU 15     "DATA MEMORY ADR INCR WITHIN EACH RADIX-4 = N/2
"""""
"""""DATA PAD X NAMES:
     W1R    $EQU -4     "W1 REAL
     W1I    $EQU -3     "W1 IMAGINARY
     W2R    $EQU -2     "W2 REAL
     W2I    $EQU -1     "W2 IMAGINARY
     W3R    $EQU  0     "W3 REAL
     W3I    $EQU  1     "W3 IMAGINARY
     BRW    $EQU  2
     BPDI   $EQU  2
     AMCRZ  $EQU  2
     APCRZ  $EQU  2
     BIW    $EQU  3
     BPDR   $EQU  3
     AMCIZ  $EQU  3
     APCIZ  $EQU  3
"""""
"""""DATA PAD Y NAMES:
     CRR    $EQU -4
     CRW    $EQU -4
     APCI   $EQU -4
     CIR    $EQU -3
     CIW    $EQU -3
     AMCI   $EQU -3
     BRR    $EQU -2
     JBMDI  $EQU -2
     BIR    $EQU -1
     JBMDR  $EQU -1
     DRR    $EQU  0
     DRW    $EQU  0
     BPDIW  $EQU  0
     DIR    $EQU  1
     DIW    $EQU  1
     BPDRW  $EQU  1
     APCR   $EQU  2
     AMCR   $EQU  3
""""""""""""""""""""
"(1): FETCH DATA FOR RADIX-4 AS THOUGH STORED ORDER IS -- A,C,B,D
"(2): B=B*W
"                   BR=BRR-BII=W1R*BR-W1I*BI
"                   BI=BRI+BIR=W1R*BI+W1I*BR
"     C=C*W**2
"                   CR=CRR-CII=W2R*CR-W2I*CI
"                   CI=CRI+CIR=W2R*CI+W2I*CR
"     D=D*W**3
"                   DR=DRR-DII=W3R*DR-W3I*DI
"                   DI=DRI+DIR=W3R*DI+W3I*DR
"(3): APC=A+C
"                   APCI=AI+CI
"                   APCR=AR+CR
"     AMC=A-C
"                   AMCR=AR-CR
"                   AMCI=AI-CI
"     BPD=B+D
"                   BPDR=BR+DR
"                   BPDI=BI+DI
"     JBMD=J*(B-D)
"                   JBMDR=DI-BI
"                   JBMDI=BR-DR
"(4): A'=APC+BPD
"                   AR'=APCR+BPDR
"                   AI'=APCI+BPDI
"     C'=APC-BPD
"                   CR'=APCR-BPDR
"                   CI'=APCI-BPDI
"     B'=AMC-+JBMD
"                   BR'=AMCR-+JBMDR
"                   BI'=AMCI-+JBMDI
"     D'=AMC+-JBMD
"                   DR'=AMCR+-JBMDR
"                   DI'=AMCI+-JBMDI
""""""""""""""""""""
 IFFT4G: ADD MINC,LPBASE
         MOV LPBASE,READ
         ADD MDEL,READ;SETMA                  "FETCH CR
         NOP
         INCMA                                "FETCH CI
         FMUL DPX(W2R),MD                     "W2R*CR
         ADD MDEL,READ;SETMA;                 "FETCH BR
           FMUL DPX(W2I),MD                   "W2I*CR
         FMUL DPX(W2I),MD                     "W2I*CI
         INCMA;                               "FETCH BI
           FMUL DPX(W2R),MD;                  "W2R*CI
           DPY(CRR)<FM                        "CRR=W2R*CR
         FMUL DPX(W1R),MD;                    "W1R*BR
           DPY(CIR)<FM                        "CIR=W2I*CR
         ADD MDEL,READ;SETMA;                 "FETCH DR
           FMUL DPX(W1I),MD;                  "W1I*BR
           FSUBR FM,DPY(CRR)                  "W2R*CR-W2I*CI
         FMUL DPX(W1I),MD;                    "W1I*BI
           FADD FM,DPY(CIR)                   "W2R*CI+W2I*CR
         INCMA;                               "FETCH DI
           FMUL DPX(W1R),MD;                  "W1R*BI
           DPY(BRR)<FM                        "BRR=W1R*BR
         FMUL DPX(W3R),MD;                    "W3R*DR
           DPY(BIR)<FM                        "BIR=W1I*BR
         MOV LPBASE,LPBASE;SETMA;             "FETCH AR
           FMUL DPX(W3I),MD;                  "W3I*DR
           FSUBR FM,DPY(BRR);                 "W1R*BR-W1I*BI
           DPY(CRW)<FA                        "CRW=W2R*CR-W2I*CI
         FMUL DPX(W3I),MD;                    "W3I*DI
           FADD FM,DPY(BIR);                  "W1R*BI+W1I*BR
           DPY(CIW)<FA                        "CIW=W2R*CI+W2I*CR
         INCMA;                               "FETCH AI
           FMUL DPX(W3R),MD;                  "W3R*DI
           DPY(DRR)<FM                        "DRR=W3R*DR
         FADD DPY(CRW),MD;                    "AR+CRW
           FMUL;
           DPY(DIR)<FM;                       "DIR=W3I*DR
           DPX(BRW)<FA                        "BRW=W1R*BR-W1I*BI
         FSUBR DPY(CRW),MD;                   "AR-CRW
           DPX(BIW)<FA                        "BIW=W1R*BI+W1I*BR
         FADD DPY(CIW),MD;                    "AI+CIW
           DPY(APCR)<FA                       "APCR=AR+CRW
         FSUBR DPY(CIW),MD;                   "AI-CIW
           DPY(AMCR)<FA                       "AMCR=AR-CRW
         FSUBR FM,DPY(DRR);                   "W3R*DR-W3I*DI
           DPY(APCI)<FA;                      "APCI=AI+CIW
           FMUL
         FADD FM,DPY(DIR);                    "W3R*DI+W3I*DR
           DPY(AMCI)<FA                       "AMCI=AI-CIW
         FADD DPX(BRW),FA;                    "BRW+DRW
           DPY(DRW)<FA                        "DRW=W3R*DR-W3I*DI
         FSUBR DPX(BIW),FA;                   "DIW-BIW
           DPY(DIW)<FA                        "DIW=W3R*DI+W3I*DR
         FADD DPX(BIW),DPY(DIW);              "BIW+DIW
           DPX(BPDR)<FA;                      "BPDR=BRW+DRW
           DPY(BPDRW)<FA                      "BPDRW=BPDR
         FSUB DPX(BRW),DPY(DRW);              "BRW-DRW
           DPY(JBMDR)<FA                      "JBMDR=DIW-BIW
         DPX(BPDI)<FA;                        "BPDI=BIW+DIW
           DPY(BPDIW)<FA;                     "BPDIW=BPDI
           FADD DPY(APCR),DPX(BPDR)           "APCR+BPDR
         DPY(JBMDI)<FA;                       "JBMDI=BRW-DRW
           FADD DPY(APCI),DPX(BPDI)           "APCI+BPDI
         FADD;
           MOV LPBASE,WRITE;SETMA;MI<FA;      "STORE AR'=APCR+BPDR
           DPX(AMCRZ)<DPY(AMCR)
         INCMA;MI<FA;                         "STORE AI'=APCI+BPDI
           DPX(AMCIZ)<DPY(AMCI);
           BIFN INVRS1
         FSUB DPX(AMCRZ),DPY(JBMDR)           "AMCR-JBMDR
         FSUB DPX(AMCIZ),DPY(JBMDI);          "AMCI-JBMDI
           BR COMM1
 INVRS1: FADD DPX(AMCRZ),DPY(JBMDR)           "AMCR+JBMDR
         FADD DPX(AMCIZ),DPY(JBMDI)           "AMCI+JBMDI
 COMM1:  FADD;
           ADD MDEL,WRITE;SETMA;MI<FA;        "STORE BR'=AMCR-+JBMDR
           DPX(BPDR)<DPY(BPDRW)
         INCMA;MI<FA;                         "STORE BI'=AMCI-+JBMDI
           DPX(BPDI)<DPY(BPDIW)
         FSUB DPY(APCR),DPX(BPDR)             "APCR-BPDR
         FSUB DPY(APCI),DPX(BPDI)             "APCI-BPDI
         FADD;
           ADD MDEL,WRITE;SETMA;MI<FA;        "STORE CR'=APCR-BPDR
           DPX(AMCRZ)<DPY(AMCR)
         INCMA;MI<FA;                         "STORE CI'=APCI-BPDI
           DPX(AMCIZ)<DPY(AMCI);
           BIFN INVRS2
         FADD DPX(AMCRZ),DPY(JBMDR)           "AMCR+JBMDR
         FADD DPX(AMCIZ),DPY(JBMDI);          "AMCI+JBMDI
           BR COMM2
 INVRS2: FSUB DPX(AMCRZ),DPY(JBMDR)           "AMCR-JBMDR
         FSUB DPX(AMCIZ),DPY(JBMDI)           "AMCI-JBMDI
 COMM2:  FADD;
           ADD MDEL,WRITE;SETMA;MI<FA         "STORE DR'=AMCR+-JBMDR
         INCMA;MI<FA                          "STORE DI'=AMCI+-JBMDI
         RETURN
$END
"****** IREALT = RFFTI UNRAVEL /COMMON/ = REL 3.0, AUG 80 *****
$TITLE IREALT
$RADIX 8
$ENTRY IREALT
$EXT   STSTAT,CLSTAT
"""""
"FUNCTION:  PERFORMS THE FINAL (OR INITIAL, FOR INVERSE)
"           UNRAVEL AND RADIX-2 PASS, FOR THE INTERPOLATED
"           REAL FFT
"LANGUAGE:  AP-120B ASSEMBLER
"EQUIPMENT: AP-120B WITH STANDARD OR FAST MEMORY
"SIZE:      99 LOCATIONS
"SPEED:     54 CYCLE LOOP, N/8 ITERATIONS
"SCRATCH:   SP(10 TO 17), DPX(-4 TO 1), DPY(-3 TO 1), FA,FM,TM,MD
"EXTERNALS: NONE
"HISTORY:   ORIGINAL  AUG 80  T.E. SKINNER
"""""
"""""TABLE MEMORY CONSTANTS:
     HAFADR $EQU !HALF
     ONEADR $EQU !ONE
     TWOADR $EQU !TWO
"""""
"""""S-PAD NAMES:
     W      $EQU 10      "INITIAL ANGLE REF (PI FOR INVERSE, 0 FOR DIRECT)
     WD     $EQU 11      "ANGLE REF INCREMENT = 2
     MDEL   $EQU 12      "DATA MEMORY DELTA = 2
     ICTR   $EQU 13      "LOOP COUNTER = N/8 (N=TM SIZE*8)
     AREAD  $EQU 14      "INITIALLY = A BASE ADDRESS
     CREAD  $EQU 15      "INITIALLY = A+N = ADRS OF END OF INPUT DATA VECTOR
     AWRITE $EQU 16      "INITIALLY = C BASE ADDRESS
     CWRITE $EQU 17      "INITIALLY = C+N = ADRS OF END OF OUTPUT DATA VECTOR
     A      $EQU  0      "BASE ADDRESS OF INPUT DATA VECTOR
     C      $EQU  1      "BASE ADDRESS OF OUTPUT DATA VECTOR
"(NOTE: FOR RFFTI A = C)
     N      $EQU  2      "SIZE OF FFT (TM SIZE*8)
     F      $EQU  3      "+1 FOR DIRECT; -1 FOR INVERSE
"""""
"""""DATA PAD X NAMES:
     APCR   $EQU -4      "AR; AR+CR
     AMCR   $EQU -3      "AR; AR-CR
     APCI   $EQU -2      "AI; AI+CI
     AMCI   $EQU -1      "AI; AI-CI
     HALF   $EQU  0      "0.5 FROM TM FOR INTERPOLATION MULTIPLIER
     AR     $EQU  1      "AR IN SPECIAL CASE
"""""
"""""DATA PAD Y NAMES:
     WR     $EQU -3      "COSINE COEFFIFIENT
     WI     $EQU -2      "SINE COEFFICIENT
     TR     $EQU -1      "SP CASE MULT (1.0 FOR INV; 2.0 FOR DIR)
     RE     $EQU  0      "WR*APCI; WR*APCI+WI*AMCR
     IM     $EQU  1      "WR*AMCR; WI*APCI-WR*AMCR
"""""
 IREALT: LDSPI MDEL;DB=2                  "SET MDEL=2
         LDSPI WD;DB=2                    "SET WD=2
         LDTMA;DB=HAFADR                  "SET-UP 0.5 INTERP MULTIPLIER
         NOP
         DPX(HALF)<TM
         MOVRR N,ICTR                     "SET LOOP COUNTER = N/8
         MOVR ICTR,ICTR
         MOV F,F                          "SET-UP BASED ON DIR OR INV
         BGT DIRECT
 INVERS: LDTMA;DB=ONEADR                  "MULTIPLIER=1
         LDSPI W;DB=!FFTX4                "W STARTS AT PI
         BR COMMON
 DIRECT: LDTMA;DB=TWOADR                  "MULTIPLIER=2
         CLR W                            "W STARTS AT 0
 COMMON: DPY(TR)<TM                       "SPECIAL CASE MULTIPLIER
         MOV F,16
         MOVR N,17                        "PACKED N/2
         JSR STSTAT                       "SET FFT STATUS BITS
         MOV A,AREAD                      "SET-UP I/O POINTERS
         MOV A,CREAD                      "     AREAD=A
         ADD N,CREAD                      "     CREAD=A+N
         MOV C,CWRITE                     "     CWRITE=C+N
         ADD N,CWRITE                     "     AWRITE=C
         MOV C,AWRITE
"""""
 SPCASE: MOV AREAD,AREAD;SETMA            "SPECIAL CASE
         NOP                              "AR(0)=(1 OR 2)*(AR+AI)
         INCMA                            "AI(0)=(1 OR 2)*(AR-AI)
         DPX(AR)<MD
         NOP
         FADD DPX(AR),MD
         FSUB DPX(AR),MD
         FMUL DPY(TR),FA;
           FADD
         FMUL DPY(TR),FA
         FMUL
         MOV AWRITE,AWRITE;SETMA;MI<FM;   "STORE AR(0)'
           FMUL
         INCMA;MI<FM                      "STORE AI(0)'
"""""
"    APCR=AR+CR
"    AMCR=AR-CR
"    APCI=AI+CI
"    AMCI=AI-CI
"    RE=WR*APCI+WI*AMCR
"    IM=WI*APCI-WR*AMCR
"    CR'=APCR-RE
"    CI'=IM-AMCI
"    AR'=APCR+RE
"    AI'=IM+AMCI
"""""
 INTRO:  MOV W,W;SETTMA                  ""FETCH WR
         NOP                             ""
         INCTMA                          ""FETCH WI
         DPY(WR)<TM                      ""STORE WR
         DPY(WI)<TM                      ""STORE WI
""""" INTERPOLATION PASS FIRST
 LOOP:   ADD MDEL,AREAD;SETMA             "FETCH AR
         ADD WD,W;SETTMA                 ""FETCH WR(+1)
         INCMA                            "FETCH AI
         DPX(APCR)<MD;                    "APCR=AR
           INCTMA                        ""FETCH WI(+1)
         DPX(AMCR)<MD;                    "AMCR=AR
           FADD TM,DPY(WR);              ""WR(+1)+WR
           SUB MDEL,CREAD;SETMA           "FETCH CR
         DPX(APCI)<MD;                    "APCI=AI
           FADD TM,DPY(WI)               ""WI(-1)+WI
         DPX(AMCI)<MD;                    "AMCI=AI
           FMUL DPX(HALF),FA;            ""0.5*(WR(-1)+WR)
           FADD                          ""
         INCMA;                           "FETCH CI
           FMUL DPX(HALF),FA             ""0.5*(WI(-1)+WI)
         FADD DPX(APCR),MD;               "AR+CR
           FMUL
         FSUB DPX(AMCR),MD;               "AR-CR
           DPY(WR)<FM;                   ""STORE WR
           FMUL                          ""
         FADD DPX(APCI),MD;               "AI+CI
           DPY(WI)<FM;                   ""STORE WI
           DPX(APCR)<FA                   "APCR=AR+CR
         FSUB DPX(AMCI),MD;               "AI-CI
           DPX(AMCR)<FA                   "AMCR=AR-CR
         DPX(APCI)<FA;                    "APCI=AI+CI
           FADD
         DPX(AMCI)<FA;                    "AMCI=AI-CI
           FMUL DPY(WR),DPX(APCI)         "WR*APCI
         FMUL DPY(WR),DPX(AMCR)           "WR*AMCR
         FMUL DPY(WI),DPX(AMCR)           "WI*AMCR
         FMUL DPY(WI),DPX(APCI);          "WI*APCI
           DPY(RE)<FM                     "RE=WR*APCI
         DPY(IM)<FM;                      "IM=WR*AMCR
           FMUL
         FADD FM,DPY(RE);                 "WR*APCI+WI*AMCR
           FMUL
         FSUB FM,DPY(IM)                  "WI*APCI-WR*AMCR
         DPY(RE)<FA;                      "RE=WR*APCI+WI*AMCR
           FSUB DPX(APCR),FA              "APCR-RE
         DPY(IM)<FA;                      "IM=WI*APCI-WR*AMCR
           FSUBR DPX(AMCI),FA             "IM-AMCI
         FADD DPX(APCR),DPY(RE);          "APCR+RE
           SUB MDEL,CWRITE;SETMA;MI<FA    "STORE CR'=APCR-RE
         FADD DPY(IM),DPX(AMCI);          "IM+AMCI
           INCMA;MI<FA                    "STORE CI'=IM-AMCI
         ADD MDEL,AWRITE;SETMA;MI<FA;     "STORE AR'=APCR+RE
           FADD
         INCMA;MI<FA                      "STORE AI'=IM+AMCI
""""" NON-INTERPOLATION PASS
         ADD MDEL,AREAD;SETMA             "FETCH AR
         MOV W,W;SETTMA                  ""FETCH WR
         INCMA                            "FETCH AI
         DPX(APCR)<MD                     "APCR=AR
         DPX(AMCR)<MD;                    "AMCR=AR
           SUB MDEL,CREAD;SETMA           "FETCH CR
         DPX(APCI)<MD                     "APCI=AI
         DPX(AMCI)<MD                     "AMCI=AI
         INCMA;                           "FETCH CI
           DPY(WR)<TM;                   ""STORE WR
           INCTMA                        ""FETCH WI
         FADD DPX(APCR),MD                "AR+CR
         FSUB DPX(AMCR),MD                "AR-CR
         FADD DPX(APCI),MD;               "AI+CI
           DPX(APCR)<FA                   "APCR=AR+CR
         FSUB DPX(AMCI),MD;               "AI-CI
           DPX(AMCR)<FA                   "AMCR=AR-CR
         DPX(APCI)<FA;                    "APCI=AI+CI
           DPY(WI)<TM;                   ""STORE WI
           FADD
         DPX(AMCI)<FA;                    "AMCI=AI-CI
           FMUL DPY(WR),DPX(APCI)         "WR*APCI
         FMUL DPY(WR),DPX(AMCR)           "WR*AMCR
         FMUL DPY(WI),DPX(AMCR)           "WI*AMCR
         FMUL DPY(WI),DPX(APCI);          "WI*APCI
           DPY(RE)<FM                     "RE=WR*APCI
         DPY(IM)<FM;                      "IM=WR*AMCR
           FMUL
         FADD FM,DPY(RE);                 "WR*APCI+WI*AMCR
           FMUL
         FSUB FM,DPY(IM)                  "WI*APCI-WR*AMCR
         DPY(RE)<FA;                      "RE=WR*APCI+WI*AMCR
           FSUB DPX(APCR),FA              "APCR-RE
         DPY(IM)<FA;                      "IM=WI*APCI-WR*AMCR
           FSUBR DPX(AMCI),FA             "IM-AMCI
         FADD DPX(APCR),DPY(RE);          "APCR+RE
           SUB MDEL,CWRITE;SETMA;MI<FA    "STORE CR'=APCR-RE
         FADD DPY(IM),DPX(AMCI);          "IM+AMCI
           INCMA;MI<FA                    "STORE CI'=IM-AMCI
         ADD MDEL,AWRITE;SETMA;MI<FA;     "STORE AR'=APCR+RE
           FADD
         INCMA;MI<FA;                     "STORE AI'=IM+AMCI
           DEC ICTR                       "CHECK FOR DONE
         BEQ DONE
         JMP LOOP
 DONE:   JMP CLSTAT                       "CLEAR FFT STATUS BITS
         RETURN
$END
$ENDLIB
 